<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jni入门]]></title>
    <url>%2F2019%2F04%2F13%2FJni%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Jni入门参考:JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki 1、编写native方法，使用javah创建头文件123public class HelloWorld &#123; public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现&#125; 1javah -jni -classpath JniCalcINterface 参数说明：classpath：类搜索路径，这里表示从当前的 bin 目录下查找d：将生成的头文件放到当前的 jni 目录下o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h） 注意：-d和-o只能使用其中一个参数。 创建的.h文件如下123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_study_jnilearn_HelloWorld */ #ifndef _Included_com_study_jnilearn_HelloWorld #define _Included_com_study_jnilearn_HelloWorld #ifdef __cplusplus extern "C" &#123; #endif /* * Class: com_study_jnilearn_HelloWorld * Method: sayHello * Signature: (Ljava/lang/String;)Ljava/lang/String; */ JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello (JNIEnv *, jclass, jstring); #ifdef __cplusplus &#125; #endif #endif **注意 extern “C”表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern “C”后面 3、编译出so文件1gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so 参数含义: -L 表示要链接的库所在的目录。-L. 表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。 -l (L的小写) 表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test -include 包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。 -I (i 的大写) 指定头文件的所在的目录，可以使用相对路径。 -shared 指定生成动态链接库 -fPIC 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。 -o 指定编译后动态库生成的路径和文件名 4、加载动态库1234static&#123; System.loadLibrary("HelloWorld"); //方式一 System.load("/Users/yangxin/Desktop/libHelloWorld.jnilib" //方式二);&#125; 方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀方式2：指定动态库的绝对路径名，需要加上前缀和后缀 推荐使用这种方法 如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。 将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下 给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。 5、运行java程序]]></content>
  </entry>
  <entry>
    <title><![CDATA[自定义ViewGroup]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%2F</url>
    <content type="text"><![CDATA[自定义ViewGroup参考文章自定义LayoutParams关于onMeasure过程的理解Measure测量流程全解析（简洁） 下面是继承自ViewGroup的FlowLayout标签流式布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.example.test;import android.content.Context;import android.util.AttributeSet;import android.util.Log;import android.view.View;import android.view.ViewGroup;public class FlowLayout extends ViewGroup &#123; public FlowLayout(Context context) &#123; super(context); &#125; public FlowLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int specWidth = MeasureSpec.getSize(widthMeasureSpec); int specHeight = MeasureSpec.getSize(heightMeasureSpec); int specWidthMode = MeasureSpec.getMode(widthMeasureSpec); int specHeightMode = MeasureSpec.getMode(heightMeasureSpec); int count = getChildCount(); //计算child的大小 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); //measureChildWithMargins方法在计算时似乎考虑到了padding, 所以这里widthUsed参数设置为0 //这里为了支持margin，所以用measureChildWithMargins方法 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); &#125; //计算ViewGroup自身的大小 //这里只要处理height的wrap_content情况就可以了 int height = specHeight; int width = specWidth; if (specHeightMode == MeasureSpec.AT_MOST) &#123; height = getPaddingBottom() + getPaddingTop(); int used_width = 0; int line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams(); int child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //在这一行可以容纳 if (used_width + child_width &lt;= width - getPaddingStart() - getPaddingEnd()) &#123; line_max_height = Math.max(line_max_height, child_height); used_width += child_width; &#125; else &#123; //切换到下一行 height += line_max_height; used_width = child_width; line_max_height = child_height; &#125; &#125; //加上最后一行的最大height height += line_max_height; &#125; setMeasuredDimension(width, height); &#125; private final String TAG = "test_log"; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd(); //cur_l, cur_t 计算时不包含padding int used_width = 0; int used_height = 0; int count = getChildCount(); int last_line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child_view = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams(); //用于计算是否越界时需要包含margin int child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //layout时的位置，必须考虑padding int layout_l, layout_t, layout_r, layout_b; if (used_width + child_width &lt;= width) &#123; // base_l, base_t 代表该view的左上角坐标 layout_l = getPaddingStart() + used_width + mlp.leftMargin; layout_t = getPaddingTop() + used_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_width += child_width; //记录该行height的最大值 last_line_max_height = Math.max(last_line_max_height, child_height); &#125; else &#123; layout_l = getPaddingStart() + mlp.leftMargin; layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_height += last_line_max_height; used_width = child_width; last_line_max_height = child_height; &#125; child_view.layout(layout_l, layout_t, layout_r, layout_b); &#125; &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; @Override protected LayoutParams generateLayoutParams(LayoutParams p) &#123; return new MarginLayoutParams(p); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new MarginLayoutParams(super.generateDefaultLayoutParams()); &#125;&#125; 关于MeasureSpec父控件告诉子控件可获得的空间以及关于这个空间的约束条件 SpecMode EXACTLY 设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式 AT_MOST width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值 UNSPECIFIED 这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用 关于view的Measure过程我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。 这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程： ViewRootImpl.performTraversals()-&gt;performMeasure(): 这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量 DecorView.measure()-&gt;onMeasure(): DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量 ViewGroupA.measure()-&gt;onMeasure(): 这是我们自定义的一个ViewGroup(继承自ViewGroup)假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。 所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。 ViewB.measure()-&gt;onMeasure(): View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。 测量子view时MeasureSpec的生成规则 当子View的宽高设置的是具体数值时 显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。 当子View的宽高设置的是match_parent 则不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED） 当子View的宽高设置的是wrap_content, 因为这种情况父容器实在不知道子View应该多宽多高，所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。 通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。 关于LayoutParams在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。在使用中必须重写所有的generateLayoutParams()方法尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams]]></content>
      <categories>
        <category>android</category>
        <category>view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多个cpp文件编译共享同一个.h文件的全局变量]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A4%9A%E4%B8%AAcpp%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E4%B8%AA-h%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[多个cpp文件编译共享同一个.h文件的全局变量在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案: 一个cpp文件多次#include一个.h文件 使用#ifndef 12345//在.h头文件中#ifndef &lt;标示&gt; //自定义的一个标示, 习惯性用.h文件名大写#define &lt;标示&gt;//...头文件内容#endif 原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容 这种方法只能解决一个cpp源文件中的重复include问题 多个cpp文件多次#include一个.h文件使用static关键字123//.h头文件static int i;static void func(); static修饰变量变量static标记之后，多个cpp文件include不会出现问题。但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的下面是网上的一些解释: 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。 static修饰函数函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。似乎是这样的。。。我的理解。网上说static和inline经常配合使用 使用extern关键字extern表明该变量在别的地方已经定义过了，在这里要使用那个变量 12//cpp文件extern int i; 经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。 定义在.h文件的情况下，在使用extern时，不能include定义它的.h文件。否则还是会出现重定义的问题。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C语言结构体的内存对齐]]></title>
    <url>%2F2019%2F04%2F13%2FC%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[C语言结构体的内存对齐内存对齐原则 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。） 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍 pragram pack(4)设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节 例子：123456789101112131415# pragram pack(8)struct S3&#123; double d; char c; int i;&#125;;struct S4&#123; char c1; struct S3 s3; double d;&#125;;printf("%d\n", sizeof(struct S4)); 最后的输出为 32 参考：[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园 C语言联合体union的sizeof分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello-world</category>
      </categories>
  </entry>
</search>
