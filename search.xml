<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F04%2F14%2Fboostnote%2F</url>
    <content type="text"><![CDATA[{"folders":[],"version":"1.0"}]]></content>
  </entry>
  <entry>
    <title><![CDATA[fragment懒加载]]></title>
    <url>%2F2019%2F04%2F14%2Ffragment%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载，顾名思义，是希望在展示相应 Fragment 页面时再动态加载页面数据，数据通常来自于网络或本地数据库。这种做法的合理性在于用户可能不会滑到一下页面，同时还能帮助减轻当前页面数据请求的带宽压力，如果是用户使用流量的话，还能避免无用的流量消耗。 懒加载的原理其实挺简单的, 最主要的就是利用fragment中的setUserVisibleHint(boolean isVisibleToUser)方法中传进来的那个isVisibleToUser这个参数, 这个参数的字面意思是表示当前fragment是否对用户可见 注意fragment还有一个getUserVisibleHint()的方法, 这个方法在我看来其实没什么用, 因为我试过打印这个方法的返回值, 返回为true并不能保证用户切换到了当前fragment. 我切到了viewpager中的第一个fragment, 然后打印了viewpager中每一个fragment中的getUserVisibleHint()方法的返回值 重写setUserVisibleHint() 首先定义一个基类, BaseLazyFragment 重写setUserVisibleHint()这个方法1234567891011@Overridepublic void setUserVisibleHint(boolean isVisibleToUser) &#123; Log.d(TAG, "setUserVisibleHint, isVisibleToUser = " + isVisibleToUser); super.setUserVisibleHint(isVisibleToUser); // 如果还没有加载过数据 &amp;&amp; 用户切换到了这个fragment // 那就开始加载数据 if (!mHaveLoadData &amp;&amp; isVisibleToUser) &#123; loadDataStart(); mHaveLoadData = true; &#125; &#125; 用一个布尔变量mHaveLoadData来表示该fragment是否加载过数据. 如果没有加载过数据, 并且isVisibleToUser为true(表示用户切换到了这个fragment), 那就开始加载数据, 然后标记该fragment已经加载过数据 loadDataStart()加载数据这个方法是基类里的一个抽象方法, 需要子类来重写, 因为具体的加载过程是需要子类自己来实现的. 写到这里我突然想到了那个抽象类和接口有什么区别的面试题. 在这里的情景的话, 抽象类就是帮子类统一处理了一些逻辑, 比如判断什么时候需要进行加载数据, 这是由父类帮我们做好的, 子类就不需要再写重复的代码了, 而具体的请求过程是由子类自己去实现的.抽象类在这里的作用就是将重复的逻辑统一处理. 而接口的作用, 就我自己来说用的最多的就是使用一个接口类型的变量来引用一个对象, 这样就不用去关心这个对象具体是什么, 而我们只要知道这个对象中一定有接口中的方法, 到时候我们就能调用这个对象的方法, 虽然我们并不知道方法中的具体逻辑. 扯远了. 现在我们写一个子类继承这个基类fragment @Override public void loadDataStart() { Log.d(TAG, &quot;loadDataStart&quot;); // 模拟请求数据 mHandler.postDelayed(new Runnable() { @Override public void run() { mData = &quot;这是加载下来的数据&quot;; // 一旦获取到数据, 就应该立刻标记数据加载完成 mLoadDataFinished = true; if (mViewInflateFinished) { mTextView.setVisibility(View.VISIBLE); mTextView.setText(mData); mTextView.setText(&quot;这是改变后的数据&quot;); mPb.setVisibility(View.GONE); } } }, 3000); } 复制代码 在具体的fragment中模拟请求数据, 在请求完成后将mLoadDataFinished这个变量置为true, 这个字段是继承自基类fragment的. 然后再判断是否布局加载和找控件已经完成, 防止将数据设置到控件上的时候出现控件空指针的错误. 那么我们是在那里将mViewInflateFinished置为true的呢?在去看基类 onCreateView()@Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { Log.d(TAG, &quot;onCreateView&quot;); if (mRootView != null) { return mRootView; } mRootView = initRootView(inflater, container, savedInstanceState); findViewById(mRootView); mViewInflateFinished = true; return mRootView; } 我们回到基类看onCeateView()方法, 在这里将布局用一个mRootView的全局变量储存起来是因为当viewpager中的fragment比较多的时候, 切换到别的fragment会导致回调onDestroyView()方法, 再切回来的时候导致onCreateView()和onViewCreate()方法又被调用, 为了防止fragment重新从layout文件中加载布局导致之前设置到控件上的变量和状态丢失, 在布局初次加载完成之后用mRootView这个变量储存起来, 当这个变量不为null时就直接复用这个布局就好了. initRootView()是初次从layout文件加载布局的方法, 是一个抽象方法, 由子类具体去实现, 返回的View表示fragment的布局. 在初次加载布局完成之后就是找控件的findViewById()方法了, 这也是个抽象方法, 需要子类自己去实现. 在findViewById()完成之后就将mViewInflateFinished置为true, 表示加载布局和找控件完成. findViewById()我们再去看子类具体实现的findViewById()方法. @Override protected void findViewById(View view) { mTextView = view.findViewById(R.id.section_label); mPb = view.findViewById(R.id.pb); if (mLoadDataFinished) { // 一般情况下这时候数据请求都还没完成, 所以不会进这个if mTextView.setVisibility(View.VISIBLE); mTextView.setText(mData); mPb.setVisibility(View.GONE); } } 复制代码 在这个方法里, 如果找控件完成之后, 我们立刻将数据设置到控件上.但是在这之前我们还是需要判断一下是否数据已经加载完成, 如果数据已经加载完成, 那就将数据设置到控件上.这个mLoadDataFinished标志位在上面已经提过. initRootView这个方法其实没什么好说的 @Override protected View initRootView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Log.d(TAG, &quot;initRootView&quot;); return inflater.inflate(R.layout.fragment_tab, container, false); } 复制代码 完整代码再来贴一下基类和子类的完整代码 BaseLazyFragment public abstract class BaseLazyFragment extends Fragment { public final String TAG = getClass().getSimpleName(); public boolean mHaveLoadData; // 表示是否已经请求过数据 public boolean mLoadDataFinished; // 表示数据是否已经请求完毕 private View mRootView; // 表示开始加载数据, 但不表示数据加载已经完成 public abstract void loadDataStart(); // 表示找控件完成, 给控件们设置数据不会报空指针了 public boolean mViewInflateFinished; @Override public void onAttach(Context context) { Log.d(TAG, &quot;onAttach&quot;); super.onAttach(context); } @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(TAG, &quot;onCreate&quot;); } @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { Log.d(TAG, &quot;onActivityCreated&quot;); super.onActivityCreated(savedInstanceState); } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { Log.d(TAG, &quot;onCreateView&quot;); if (mRootView != null) { return mRootView; } mRootView = initRootView(inflater, container, savedInstanceState); findViewById(mRootView); mViewInflateFinished = true; return mRootView; } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState); Log.d(TAG, &quot;onViewCreated&quot;); } protected abstract void findViewById(View view); protected abstract View initRootView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState); @Override public void onDestroyView() { Log.d(TAG, &quot;onDestroyView&quot;); super.onDestroyView(); } @Override public void onDestroy() { Log.d(TAG, &quot;onDestroy&quot;); super.onDestroy(); } @Override public void onDetach() { Log.d(TAG, &quot;onDetach&quot;); super.onDetach(); } @Override public void setUserVisibleHint(boolean isVisibleToUser) { Log.d(TAG, &quot;setUserVisibleHint, isVisibleToUser = &quot; + isVisibleToUser); super.setUserVisibleHint(isVisibleToUser); // 如果还没有加载过数据 &amp;&amp; 用户切换到了这个fragment // 那就开始加载数据 if (!mHaveLoadData &amp;&amp; isVisibleToUser) { loadDataStart(); mHaveLoadData = true; } } } 复制代码 子类PlaceholderFragment0 public class PlaceholderFragment0 extends BaseLazyFragment { private TextView mTextView; private ProgressBar mPb; private Handler mHandler = new Handler(); private String mData; public PlaceholderFragment0() { } /** * Returns a new instance of this fragment for the given section * number. */ public static PlaceholderFragment0 newInstance() { PlaceholderFragment0 fragment = new PlaceholderFragment0(); return fragment; } @Override public void loadDataStart() { Log.d(TAG, &quot;loadDataStart&quot;); // 模拟请求数据 mHandler.postDelayed(new Runnable() { @Override public void run() { mData = &quot;这是加载下来的数据&quot;; // 一旦获取到数据, 就应该立刻标记数据加载完成 mLoadDataFinished = true; if (mViewInflateFinished) { // mViewInflateFinished一般都是true mTextView.setVisibility(View.VISIBLE); mTextView.setText(mData); mTextView.setText(&quot;这是改变后的数据&quot;); mPb.setVisibility(View.GONE); } } }, 3000); } @Override protected View initRootView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { Log.d(TAG, &quot;initRootView&quot;); return inflater.inflate(R.layout.fragment_tab, container, false); } @Override protected void findViewById(View view) { mTextView = view.findViewById(R.id.section_label); mPb = view.findViewById(R.id.pb); if (mLoadDataFinished) { // 一般情况下这时候数据请求都还没完成, 所以不会进这个if mTextView.setVisibility(View.VISIBLE); mTextView.setText(mData); mPb.setVisibility(View.GONE); } } } 复制代码 完结最后上一个github地址和效果图, 完结撒花LazyFragmentDemo]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity管理类的封装]]></title>
    <url>%2F2019%2F04%2F14%2FActivity%E7%AE%A1%E7%90%86%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[使用场景有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的 我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class FinishActivityManager extends BaseActivity &#123; private FinishActivityManager() &#123; &#125; private static FinishActivityManager sManager; private Stack&lt;WeakReference&lt;Activity&gt;&gt; mActivityStack; public static FinishActivityManager getManager() &#123; if (sManager == null) &#123; synchronized (FinishActivityManager.class) &#123; if (sManager == null) &#123; sManager = new FinishActivityManager(); &#125; &#125; &#125; return sManager; &#125; /** * 添加Activity到栈 * @param activity */ public void addActivity(Activity activity) &#123; if (mActivityStack == null) &#123; mActivityStack = new Stack&lt;&gt;(); &#125; mActivityStack.add(new WeakReference&lt;&gt;(activity)); &#125; /** * 检查弱引用是否释放，若释放，则从栈中清理掉该元素 */ public void checkWeakReference() &#123; if (mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity temp = activityReference.get(); if (temp == null) &#123; it.remove(); &#125; &#125; &#125; &#125; /** * 获取当前Activity（栈中最后一个压入的） * @return */ public Activity currentActivity() &#123; checkWeakReference(); if (mActivityStack != null &amp;&amp; !mActivityStack.isEmpty()) &#123; return mActivityStack.lastElement().get(); &#125; return null; &#125; /** * 关闭当前Activity（栈中最后一个压入的） */ public void finishActivity() &#123; Activity activity = currentActivity(); if (activity != null) &#123; finishActivity(activity); &#125; &#125; /** * 关闭指定的Activity * @param activity */ public void finishActivity(Activity activity) &#123; if (activity != null &amp;&amp; mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity temp = activityReference.get(); // 清理掉已经释放的activity if (temp == null) &#123; it.remove(); continue; &#125; if (temp == activity) &#123; it.remove(); &#125; &#125; activity.finish(); &#125; &#125; /** * 关闭指定类名的所有Activity * @param cls */ public void finishActivity(Class&lt;?&gt; cls) &#123; if (mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity activity = activityReference.get(); // 清理掉已经释放的activity if (activity == null) &#123; it.remove(); continue; &#125; if (activity.getClass().equals(cls)) &#123; it.remove(); activity.finish(); &#125; &#125; &#125; &#125; /** * 结束所有Activity */ public void finishAllActivity() &#123; if (mActivityStack != null) &#123; for (WeakReference&lt;Activity&gt; activityReference : mActivityStack) &#123; Activity activity = activityReference.get(); if (activity != null) &#123; activity.finish(); &#125; &#125; mActivityStack.clear(); &#125; &#125; /** * 退出应用程序 */ public void exitApp() &#123; try &#123; finishAllActivity(); // 退出JVM,释放所占内存资源,0表示正常退出 System.exit(0); // 从系统中kill掉应用程序 android.os.Process.killProcess(android.os.Process.myPid()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后是一个BaseActivity类， 重写onCreate和onDestory方法 1234567891011121314151617181920212223242526package com.example.chenlei.test;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.util.Log;public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MyActivityManager.addActivity(this); Log.i("有activity新添加", "onCreate: "); &#125; @Override protected void onDestroy() &#123; Log.i("有activity被销毁", "onDestroy: "+ MyActivityManager.getSize()); MyActivityManager.finishActivity(this); super.onDestroy(); &#125;&#125; 接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作 网上原文：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android-Studio解决依赖冲突]]></title>
    <url>%2F2019%2F04%2F14%2FAndroid-Studio%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[Android-Studio解决依赖冲突我们做android项目通常会引入很多第三方库， 有时候不同的第三方库会出现依赖冲突，导致添加依赖后就android-studio就报错。做项目是要添加glide库，直接添加最新版本 4.8，《第一行代码》中介绍使用的版本是3.7。 结果就是4.8的版本一添加依赖就报错，在build.gradle文件中报错buildtool版本冲突。我在网上找到了如下的文章，解决方法是一样的，做一个笔记。需要说明的 glide4.+ 的版本和 3.+ 的版本，提供的api接口的操作形式发生了变化，而且google上搜到说版本升级之后其实性能没有多大提升 原文：https://blog.csdn.net/victor888886/article/details/73714141 以下是网上的文章内容：最近刚接手一个项目，里面模块有三四个，引入的第三方包更多了。但是问题来了，新配置的studio一运行就报了错。 Error:Execution failed for task &apos;:app:processDebugManifest&apos;. Manifest merger failed : Attribute meta-data#android.support.VERSION@value value=(25.3.1) from [com.android.support:design:25.3.1] AndroidManifest.xml:27:9-31is also present at [com.android.support:support-v4:26.0.0-alpha1] AndroidManifest.xml:27:9-38 value=(26.0.0-alpha1).Suggestion: add ‘tools:replace=”android:value”’ to element at AndroidManifest.xml:25:5-27:34 to override. 可以看到，studio已经明确的指出了错误，在清单文件中Android support 库版本冲突了，而且，studio还很“人性”地给出了suggestion：清单文件25行——27行添加： tools:replace=&quot;android:value&quot; 坑就坑在这里，给出的建议完全误导人了。咳咳，下面看我详（如）细（何）解（装）释（逼）： 问题分析：看到com.android.support:design:25.3.1 和 com.android.support:support-v4:26.0.0-alpha1， 说明这个Android support库版本冲突了，解决的思想很简单，就是统一使用同一个版本的support库，比如修改掉26.0.0-alpha1的依赖，统一换成25.3.1的版本。 解决既然有了思路，那就动手试一试，全局搜索26.0.0-alpha1，统一替换为 25.3.1 正常情况下，这个是能解决问题的，但只能解决gradle里面自己引入的依赖版本问题。然而，今天碰到的坑还没完呢，同步代码以后，还是原来的错误信息！ 再次分析：问题就出在第三方库的依赖了，好多第三方库默认引用当前最新的support库，现在最新的就是26.0.0-alpha1这个版本。所以，要解决问题，就要从引入的三方库里面入手了！那么问题来了，挖掘机哪家......哦不，怎么知道哪个依赖包有冲突？下面出杀手锏了： 打开Android studio下面的terminal，输入命令：`gradle -q app:dependencies`,惊喜出现了：没有配置gradle环境变量的同学赶快去配一个吧！.. **（这里不需要配置gradle环境变量也可以，在terminal中输入命令：./gradlew -q app:dependencies效果是一样的）** 配过之后可以看到类似一下的输出： +— project :base-util| +— com.android.support:recyclerview-v7:25.3.1 ()| +— cn.qqtheme.framework:WheelPicker:1.5.1| | +— cn.qqtheme.framework:Common:1.5.1| | | +— com.android.support:support-v4:latest.release -&gt; 26.0.0-alpha1 ()| | | — com.android.support:support-annotations:latest.release -&gt; 26.0.0-alpha1| | +— com.android.support:support-v4:latest.release -&gt; 26.0.0-alpha1 ()| | — com.android.support:support-annotations:latest.release -&gt; 26.0.0-alpha1| +— com.github.CymChad:BaseRecyclerViewAdapterHelper:v1.9.8| +— io.reactivex:rxjava:1.1.8| +— io.reactivex:rxandroid:1.1.0| | — io.reactivex:rxjava:1.1.0 -&gt; 1.1.8| +— com.squareup.okhttp3:okhttp:3.2.0 -&gt; 3.4.1| | — com.squareup.okio:okio:1.9.0| +— com.squareup.retrofit2:retrofit:2.0.2| | — com.squareup.okhttp3:okhttp:3.2.0 -&gt; 3.4.1 ()| +— com.squareup.retrofit2:adapter-rxjava:2.0.2| | +— com.squareup.retrofit2:retrofit:2.0.2 ()| | — io.reactivex:rxjava:1.1.1 -&gt; 1.1.8| +— com.squareup.retrofit2:converter-gson:2.0.2| | +— com.squareup.retrofit2:retrofit:2.0.2 ()| | — com.google.code.gson:gson:2.6.1| +— com.squareup.okhttp3:logging-interceptor:3.4.1| | — com.squareup.okhttp3:okhttp:3.4.1 ()| +— com.github.zhaokaiqiang.klog:library:1.5.0| | — com.android.support:support-annotations:23.4.0 -&gt; 26.0.0-alpha1| +— com.squareup.retrofit2:converter-simplexml:2.0.2| | +— com.squareup.retrofit2:retrofit:2.0.2 ()| | — org.simpleframework:simple-xml:2.7.1| +— com.github.bumptech.glide:glide:3.7.0| +— project :base-res (*)| — com.jakewharton:butterknife:7.0.1 很明显cn.qqtheme.framework:WheelPicker这个包默认引用了最新的support库！ 最终解决：找到依赖的库，修改为下面的方式引入： compile (&apos;cn.qqtheme.framework:WheelPicker:1.5.1&apos;){ exclude group:&apos;com.android.support&apos; }]]></content>
      <categories>
        <category>Android</category>
        <category>AndroidStudio</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler防止内存泄露]]></title>
    <url>%2F2019%2F04%2F14%2FHandler%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[Handler防止内存泄露1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = (MainActivity) reference.get(); if(activity != null)&#123; activity.mTextView.setText(""); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); &#125; //loadData()方法是在子线程中，执行 private void loadData() &#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //如果你的Handler被delay（延时了）,可以做如下的处理 mHandler.removeCallbacksAndMessages(null); &#125;&#125; 解释创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息 使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jni入门]]></title>
    <url>%2F2019%2F04%2F13%2FJni%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Jni入门参考:JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki 1、编写native方法，使用javah创建头文件123public class HelloWorld &#123; public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现&#125; 1javah -jni -classpath JniCalcINterface 参数说明：classpath：类搜索路径，这里表示从当前的 bin 目录下查找d：将生成的头文件放到当前的 jni 目录下o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h） 注意：-d和-o只能使用其中一个参数。 创建的.h文件如下123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_study_jnilearn_HelloWorld */ #ifndef _Included_com_study_jnilearn_HelloWorld #define _Included_com_study_jnilearn_HelloWorld #ifdef __cplusplus extern "C" &#123; #endif /* * Class: com_study_jnilearn_HelloWorld * Method: sayHello * Signature: (Ljava/lang/String;)Ljava/lang/String; */ JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello (JNIEnv *, jclass, jstring); #ifdef __cplusplus &#125; #endif #endif **注意 extern “C”表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern “C”后面 3、编译出so文件1gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so 参数含义: -L 表示要链接的库所在的目录。-L. 表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。 -l (L的小写) 表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test -include 包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。 -I (i 的大写) 指定头文件的所在的目录，可以使用相对路径。 -shared 指定生成动态链接库 -fPIC 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。 -o 指定编译后动态库生成的路径和文件名 4、加载动态库1234static&#123; System.loadLibrary("HelloWorld"); //方式一 System.load("/Users/yangxin/Desktop/libHelloWorld.jnilib" //方式二);&#125; 方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀方式2：指定动态库的绝对路径名，需要加上前缀和后缀 推荐使用这种方法 如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。 将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下 给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。 5、运行java程序]]></content>
  </entry>
  <entry>
    <title><![CDATA[自定义ViewGroup]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%2F</url>
    <content type="text"><![CDATA[自定义ViewGroup参考文章自定义LayoutParams关于onMeasure过程的理解Measure测量流程全解析（简洁） 下面是继承自ViewGroup的FlowLayout标签流式布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.example.test;import android.content.Context;import android.util.AttributeSet;import android.util.Log;import android.view.View;import android.view.ViewGroup;public class FlowLayout extends ViewGroup &#123; public FlowLayout(Context context) &#123; super(context); &#125; public FlowLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int specWidth = MeasureSpec.getSize(widthMeasureSpec); int specHeight = MeasureSpec.getSize(heightMeasureSpec); int specWidthMode = MeasureSpec.getMode(widthMeasureSpec); int specHeightMode = MeasureSpec.getMode(heightMeasureSpec); int count = getChildCount(); //计算child的大小 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); //measureChildWithMargins方法在计算时似乎考虑到了padding, 所以这里widthUsed参数设置为0 //这里为了支持margin，所以用measureChildWithMargins方法 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); &#125; //计算ViewGroup自身的大小 //这里只要处理height的wrap_content情况就可以了 int height = specHeight; int width = specWidth; if (specHeightMode == MeasureSpec.AT_MOST) &#123; height = getPaddingBottom() + getPaddingTop(); int used_width = 0; int line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams(); int child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //在这一行可以容纳 if (used_width + child_width &lt;= width - getPaddingStart() - getPaddingEnd()) &#123; line_max_height = Math.max(line_max_height, child_height); used_width += child_width; &#125; else &#123; //切换到下一行 height += line_max_height; used_width = child_width; line_max_height = child_height; &#125; &#125; //加上最后一行的最大height height += line_max_height; &#125; setMeasuredDimension(width, height); &#125; private final String TAG = "test_log"; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd(); //cur_l, cur_t 计算时不包含padding int used_width = 0; int used_height = 0; int count = getChildCount(); int last_line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child_view = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams(); //用于计算是否越界时需要包含margin int child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //layout时的位置，必须考虑padding int layout_l, layout_t, layout_r, layout_b; if (used_width + child_width &lt;= width) &#123; // base_l, base_t 代表该view的左上角坐标 layout_l = getPaddingStart() + used_width + mlp.leftMargin; layout_t = getPaddingTop() + used_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_width += child_width; //记录该行height的最大值 last_line_max_height = Math.max(last_line_max_height, child_height); &#125; else &#123; layout_l = getPaddingStart() + mlp.leftMargin; layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_height += last_line_max_height; used_width = child_width; last_line_max_height = child_height; &#125; child_view.layout(layout_l, layout_t, layout_r, layout_b); &#125; &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; @Override protected LayoutParams generateLayoutParams(LayoutParams p) &#123; return new MarginLayoutParams(p); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new MarginLayoutParams(super.generateDefaultLayoutParams()); &#125;&#125; 关于MeasureSpec父控件告诉子控件可获得的空间以及关于这个空间的约束条件 SpecMode EXACTLY 设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式 AT_MOST width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值 UNSPECIFIED 这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用 关于view的Measure过程我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。 这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程： ViewRootImpl.performTraversals()-&gt;performMeasure(): 这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量 DecorView.measure()-&gt;onMeasure(): DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量 ViewGroupA.measure()-&gt;onMeasure(): 这是我们自定义的一个ViewGroup(继承自ViewGroup)假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。 所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。 ViewB.measure()-&gt;onMeasure(): View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。 测量子view时MeasureSpec的生成规则 当子View的宽高设置的是具体数值时 显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。 当子View的宽高设置的是match_parent 则不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED） 当子View的宽高设置的是wrap_content, 因为这种情况父容器实在不知道子View应该多宽多高，所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。 通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。 关于LayoutParams在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。在使用中必须重写所有的generateLayoutParams()方法尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams]]></content>
      <categories>
        <category>Android</category>
        <category>view</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多个cpp文件编译共享同一个.h文件的全局变量]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A4%9A%E4%B8%AAcpp%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E4%B8%AA-h%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[多个cpp文件编译共享同一个.h文件的全局变量在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案: 一个cpp文件多次#include一个.h文件 使用#ifndef 12345//在.h头文件中#ifndef &lt;标示&gt; //自定义的一个标示, 习惯性用.h文件名大写#define &lt;标示&gt;//...头文件内容#endif 原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容 这种方法只能解决一个cpp源文件中的重复include问题 多个cpp文件多次#include一个.h文件使用static关键字123//.h头文件static int i;static void func(); static修饰变量变量static标记之后，多个cpp文件include不会出现问题。但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的下面是网上的一些解释: 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。 static修饰函数函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。似乎是这样的。。。我的理解。网上说static和inline经常配合使用 使用extern关键字extern表明该变量在别的地方已经定义过了，在这里要使用那个变量 12//cpp文件extern int i; 经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。 定义在.h文件的情况下，在使用extern时，不能include定义它的.h文件。否则还是会出现重定义的问题。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C语言结构体的内存对齐]]></title>
    <url>%2F2019%2F04%2F13%2FC%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[C语言结构体的内存对齐内存对齐原则 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。） 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍 pragram pack(4)设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节 例子：123456789101112131415# pragram pack(8)struct S3&#123; double d; char c; int i;&#125;;struct S4&#123; char c1; struct S3 s3; double d;&#125;;printf("%d\n", sizeof(struct S4)); 最后的输出为 32 参考：[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园 C语言联合体union的sizeof分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello-world</category>
      </categories>
  </entry>
</search>
