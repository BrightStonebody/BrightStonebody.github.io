{"meta":{"title":"BrightStone","subtitle":null,"description":null,"author":"BrightStone","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2019-04-13T04:54:42.000Z","updated":"2021-10-03T01:57:41.032Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-10-03T01:57:41.038Z","updated":"2021-10-03T01:57:41.038Z","comments":true,"path":"notes/boostnote.json","permalink":"http://yoursite.com/notes/boostnote.json","excerpt":"","text":""},{"title":"tags","date":"2019-04-14T12:06:37.000Z","updated":"2021-10-03T01:57:41.038Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"探究: AGP编译时svg资源自动生成png","slug":"Android/gradle/探究-AGP编译时svg资源自动生成png","date":"2022-08-28T06:21:50.000Z","updated":"2022-08-28T06:38:57.150Z","comments":true,"path":"2022/08/28/Android/gradle/探究-AGP编译时svg资源自动生成png/","link":"","permalink":"http://yoursite.com/2022/08/28/Android/gradle/探究-AGP编译时svg资源自动生成png/","excerpt":"背景：当安卓工程的minSdk&lt;24时，项目中的svg资源如果使用到了有兼容问题的属性，同时module的 vectorDrawables.useSupportLibrary 开关为false，会自动在编译打包过程中生成png图片来解决兼容性问题。123456android &#123; defaultConfig &#123; vectorDrawables.useSupportLibrary = false vectorDrawables.generatedDensities = [\"xxhdpi\"] // 设置只在drawable-xxhdpi目录下的生成png图片，如果不设置，最终的apk会在每一个drawable目录下有一个png &#125;&#125;","text":"背景：当安卓工程的minSdk&lt;24时，项目中的svg资源如果使用到了有兼容问题的属性，同时module的 vectorDrawables.useSupportLibrary 开关为false，会自动在编译打包过程中生成png图片来解决兼容性问题。123456android &#123; defaultConfig &#123; vectorDrawables.useSupportLibrary = false vectorDrawables.generatedDensities = [\"xxhdpi\"] // 设置只在drawable-xxhdpi目录下的生成png图片，如果不设置，最终的apk会在每一个drawable目录下有一个png &#125;&#125; 这样兼容性的问题就解决了，但是，生成了很多冗余的png图片。本来我们使用svg就是为了缩小包体积，现在反而包体积增大了。需要去探究一下，冗余的png图片是在哪里生成的，什么情况下额外生成png图片 MergeResources基于AGP 4.1.0 版本 通过ide的全局文本查找 useSupportLibrary 出现的地方，可以找到一个明显有嫌疑的类 MergeResources 。这是编译打包过程中的一个task类，需要注意的是，在子module和app，这个task有所不同。它在子module的task-name是packageDebugResource ，在app的task-name是mergeDebugResource。同样，在子module和app，表现也有所不同。 先从doFullTaskAction方法看这个task的主流程：伪代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Overrideprotected void doFullTaskAction() throws IOException, JAXBException &#123; ResourcePreprocessor preprocessor = getPreprocessor(); // 关键1 File destinationDir = getOutputDir().get().getAsFile(); // 资源merge的最终目录 // build/intermediates/package_res ... //省略 // 因为是全量，删除destinationDir的所有文件 // 获取所有资源目录 List&lt;ResourceSet&gt; resourceSets = getConfiguredResourceSets(preprocessor, getAaptEnv().getOrNull()); // task 的核心类 ResourceMerger merger = new ResourceMerger(getMinSdk().get()); try ( // 创建资源编译服务类 ResourceCompilationService resourceCompiler = getResourceProcessor( getProjectName(), getPath(), getAapt2FromMaven(), workerExecutorFacade, errorFormatMode, flags, processResources, useJvmResourceCompiler, getLogger(), getAapt2DaemonBuildService().get())) &#123; for (ResourceSet resourceSet : resourceSets) &#123; resourceSet.loadFromFiles(new LoggerWrapper(getLogger())); // 关键2 merger.addDataSet(resourceSet); &#125; File publicFile = getPublicFile().isPresent() ? getPublicFile().get().getAsFile() : null; MergedResourceWriter writer = new MergedResourceWriter( workerExecutorFacade, destinationDir, publicFile, mergingLog, preprocessor, resourceCompiler, getIncrementalFolder(), dataBindingLayoutProcessor, mergedNotCompiledResourcesOutputDirectory, pseudoLocalesEnabled, getCrunchPng()); merger.mergeData(writer, false) // 关键3 &#125; catch (Exception e) &#123; ... &#125; finally &#123; cleanup(); &#125;&#125; 关键1 ResourcePreprocessorgetPreprocessor() 返回的是一个接口12345678public interface ResourcePreprocessor extends Serializable &#123; // 返回预处理需要生成的file集合 @NonNull Collection&lt;File&gt; getFilesToBeGenerated(@NonNull File original) throws IOException; // 生成 getFilesToBeGenerated 方法返回的file集合文件 void generateFile(@NonNull File toBeGenerated, @NonNull File original) throws IOException;&#125; 它的实现类是 VectorDrawableRenderer ，看名字可以判定，这就是svg-&gt;png的实现类（罪魁祸首）。。。先寻找它被调用的地方。 关键2 ResourceSet#loadFromFiles1234for (ResourceSet resourceSet : resourceSets) &#123; resourceSet.loadFromFiles(new LoggerWrapper(getLogger())); // 关键2 merger.addDataSet(resourceSet);&#125; resourceSets 是一个res目录的集合。在子module，会包含工程里module的src/main/res目录；（断点看，似乎有用的也就只有这个）在app，会包含 app 的 src/main/res ，所有子module的 build/intermediates/package_res ，以及一些安卓官方库的资源目录从 resourceSet.loadFromFiles 一直追，会到 ResourceSet#getResourceMergerItemsForGeneratedFiles 方法12345678910111213141516171819202122232425@NonNullprivate List&lt;ResourceMergerItem&gt; getResourceMergerItemsForGeneratedFiles(@NonNull File file) throws MergingException &#123; Collection&lt;File&gt; filesToBeGenerated; try &#123; filesToBeGenerated = mPreprocessor.getFilesToBeGenerated(file); // 关键 &#125; catch (IOException e) &#123; throw new MergingException(e); &#125; List&lt;ResourceMergerItem&gt; resourceItems = new ArrayList&lt;&gt;(filesToBeGenerated.size()); for (File generatedFile : filesToBeGenerated) &#123; FolderData generatedFileFolderData = getFolderData(generatedFile.getParentFile()); resourceItems.add( new GeneratedResourceMergerItem( getNameForFile(generatedFile), mNamespace, generatedFile, generatedFileFolderData.type, generatedFileFolderData.folderConfiguration.getQualifierString(), mLibraryName) ); &#125; return resourceItems;&#125; 这里的 mPreprocessor 就是 VectorDrawableRenderer ，mPreprocessor.getFilesToBeGenerated(file) 会返回 svg 资源文件和png兼容资源文件的集合。里面不详细看了，主要是根据useSupportLibrary 和generatedDensities 这两个gradle参数生成png文件的绝对路径。这里的png路径是 build/generated/res/pngs/debug 。 这和 MergeResources task 的目标路径并不相同。getResourceMergerItemsForGeneratedFiles 方法最终会将每一个资源文件抽象为ResourceMergerItem ，并返回他们的集合。 关键3 merger#mergeDataResourceMerger#mergeData 会调用到父类的 DataMerger#mergeData12345678public void mergeData(@NonNull MergeConsumer&lt;I&gt; consumer, boolean doCleanUp)&#123; consumer.start(mFactory); for(...) &#123; ... // 忽略 merge 的过程 consumer.addItem(toWrite) &#125; consumer.end();&#125; 这里的 consumer 是 MergedResourceWriter 实例。 12345678910111213141516171819202122232425262728293031@Overridepublic void addItem(@NonNull final ResourceMergerItem item) throws ConsumerException &#123; final ResourceFile.FileType type = item.getSourceType(); if (type == ResourceFile.FileType.XML_VALUES) &#123; mValuesResMap.put(item.getQualifiers(), item); &#125; else &#123; if (item.isTouched()) &#123; File file = item.getFile(); String folderName = getFolderName(item); if (type == DataFile.FileType.GENERATED_FILES) &#123; try &#123; FileGenerationParameters workItem = new FileGenerationParameters(item, mPreprocessor); if (workItem.resourceItem.getSourceFile() != null) &#123; // 这个action是生成png文件的地方 getExecutor().submit(FileGenerationWorkAction.class, workItem); &#125; &#125; catch (Exception e) &#123; throw new ConsumerException(e, item.getSourceFile().getFile()); &#125; &#125; // 添加资源编译 Request mCompileResourceRequests.add( new CompileResourceRequest( file, getRootFolder(), folderName, item.mIsFromDependency)); &#125; &#125;&#125; 这里有一个 ResourceFile.FileType 枚举值 12345public enum FileType &#123; SINGLE_FILE, // 表示项目中工程目录 src/main/res 原本就有的资源文件 GENERATED_FILES, // 需要生成的资源文件，生成的目录在 build/generated/res/pngs/debug XML_VALUES // values文件&#125; 如果是 GENERATED_FILES 会生成新文件 1234567891011121314151617181920public static class FileGenerationWorkAction implements Runnable &#123; private final FileGenerationParameters workItem; @Inject public FileGenerationWorkAction(FileGenerationParameters workItem) &#123; this.workItem = workItem; &#125; @Override public void run() &#123; try &#123; workItem.resourcePreprocessor.generateFile( workItem.resourceItem.getFile(), workItem.resourceItem.getSourceFile().getFile()); &#125; catch (Exception e) &#123; ... &#125; &#125;&#125; workItem.resourcePreprocessor 是 VectorDrawableRenderer 对象，这样生成了png文件的地方也找到了。123456789101112131415161718192021@Overridepublic void generateFile(@NonNull File toBeGenerated, @NonNull File original) throws IOException &#123; Files.createParentDirs(toBeGenerated); if (isXml(toBeGenerated)) &#123; // 目标文件如果是xml文件，直接拷贝即可 Files.copy(original, toBeGenerated); &#125; else &#123; // 在对应 density 的目录下生成png文件 FolderConfiguration folderConfiguration = getFolderConfiguration(toBeGenerated); Density density = folderConfiguration.getDensityQualifier().getValue(); float scaleFactor = density.getDpiValue() / (float) Density.MEDIUM.getDpiValue(); if (scaleFactor &lt;= 0) &#123; scaleFactor = 1.0f; &#125; VdPreview.TargetSize imageSize = VdPreview.TargetSize.createFromScale(scaleFactor); String xmlContent = Files.asCharSource(original, StandardCharsets.UTF_8).read(); BufferedImage image = VdPreview.getPreviewFromVectorXml(imageSize, xmlContent, null); ImageIO.write(image, \"png\", toBeGenerated); &#125;&#125; 生成png文件的效果工程module下有两个资源图片文件，一个是svg，一个是png。 svg图片会在 build/generated/res/pngs 下生成多个资源，工程原有的png则不会 编译资源再来看 ResourceMerger#mergeData， 12345678public void mergeData(@NonNull MergeConsumer&lt;I&gt; consumer, boolean doCleanUp)&#123; consumer.start(mFactory); for(...) &#123; ... // 忽略 merge 的过程 consumer.addItem(toWrite) &#125; consumer.end();&#125; 最后有一个consumer.end() 1234567891011121314151617public void end() throws ConsumerException &#123; while (!mCompileResourceRequests.isEmpty()) &#123; mResourceCompiler.submitCompile( new CompileResourceRequest( fileToCompile, request.getOutputDirectory(), request.getInputDirectoryName(), request.getInputFileIsFromDependency(), pseudoLocalesEnabled, crunchPng, ImmutableMap.of(), request.getInputFile())); mCompiledFileMap.put( fileToCompile.getAbsolutePath(), mResourceCompiler.compileOutputFor(request).getAbsolutePath()); &#125;&#125; mResourceCompiler.submitCompile 正式提交编译。mResourceCompiler 的实现在子module和app有所不同，在module，实例是CopyToOutputDirectoryResourceCompilationService在app，实例是 WorkerExecutorResourceCompilationService 子module的资源 “编译”123456789101112131415object CopyToOutputDirectoryResourceCompilationService : ResourceCompilationService &#123; override fun submitCompile(request: CompileResourceRequest) &#123; val out = compileOutputFor(request) FileUtils.mkdirs(out.parentFile) FileUtils.copyFile(request.inputFile, out) &#125; override fun compileOutputFor(request: CompileResourceRequest): File &#123; val parentDir = File(request.outputDirectory, request.inputDirectoryName) return File(parentDir, request.inputFile.name) &#125; override fun close() &#123; &#125;&#125; 在子module比较简单，就是把 request 里的 inputFile 拷贝到目标目录。如果是svg生成png的case，是 build/generated/res/pngs/ 文件拷贝到 build/intermediates/package_res/如果是工程中的一般资源文件，是src/main/res 文件拷贝到 build/intermediates/package_res/ app的资源编译1234567891011121314151617181920class WorkerExecutorResourceCompilationService(...) : ResourceCompilationService &#123; private val requests: MutableList&lt;CompileResourceRequest&gt; = ArrayList() override fun submitCompile(request: CompileResourceRequest) &#123; requests.add(request) &#125; ... override fun close() &#123; for (...) &#123; val bucketRequests = requests.filterIndexed &#123; i, _ -&gt; i.rem(buckets) == bucket &#125; workerExecutor.submit( Aapt2CompileRunnable::class.java, Aapt2CompileRunnable.Params(aapt2ServiceKey, bucketRequests, errorFormatMode, true) ) &#125; &#125;&#125; 在close方法遍历所有request，然后在Aapt2CompileRunnable进行资源编译。 输出路径是app/build/intermediates/res/merged/debug对于appt2编译，我不是很了解，这里不详细说了。 SVG -&gt; PNG 的条件12345678910111213141516171819202122232425262728293031public class VectorDrawableRenderer implements ResourcePreprocessor &#123; @Override @NonNull public Collection&lt;File&gt; getFilesToBeGenerated(@NonNull File inputXmlFile) throws IOException &#123; FolderConfiguration originalConfiguration = getFolderConfiguration(inputXmlFile); PreprocessingReason reason = getReasonForPreprocessing(inputXmlFile, originalConfiguration); if (reason == null) &#123; return Collections.emptyList(); &#125; Collection&lt;File&gt; filesToBeGenerated = new ArrayList&lt;&gt;(); DensityQualifier densityQualifier = originalConfiguration.getDensityQualifier(); boolean validDensityQualifier = ResourceQualifier.isValid(densityQualifier); if (mMinSdk &lt; reason.getSdkThreshold() &amp;&amp; mDensities.size() &gt; 0) &#123; for (Density density : mDensities) &#123; FolderConfiguration newConfiguration = FolderConfiguration.copyOf(originalConfiguration); newConfiguration.setDensityQualifier(new DensityQualifier(density)); filesToBeGenerated.add( new File( getDirectory(newConfiguration), inputXmlFile.getName().replace(\".xml\", \".png\")) ); &#125; &#125; return filesToBeGenerated; &#125;&#125; 上面的代码省略了诸多逻辑，我们只看关心的部分。首先去获取一个reason，如果reason为空，直接返回空集合。如果 mMinSdk &lt; reason.getSdkThreshold() ，项目的minSdk小于 reason的sdk阈值，则往filesToBeGenerated添加一个png路径。所以要去看如何得到reason的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Nullableprivate PreprocessingReason getReasonForPreprocessing( @NonNull File resourceFile, @NonNull FolderConfiguration folderConfig) throws IOException &#123; // 如果开启了 supportLibraryIsUsed 直接返回null。 和「背景」中说的一致 if (mSupportLibraryIsUsed) return null; // 如果 minSdk 大于 GRADIENT_SUPPORT 的版本号，也直接返回null // PreprocessingReason.GRADIENT_SUPPORT 版本号是24。 // 即到了24版本开始就没有兼容性问题了。 minSdk &gt; 24 即无需处理 if (mMinSdk &gt;= PreprocessingReason.GRADIENT_SUPPORT.getSdkThreshold()) return null; if (!isXml(resourceFile) || !isInDrawable(resourceFile)) return null; try (InputStream stream = new BufferedInputStream(new FileInputStream(resourceFile))) &#123; XMLInputFactory factory = XMLInputFactory.newFactory(); XMLStreamReader xmlReader = factory.createXMLStreamReader(stream); // 开始读取svg xml文件的内容，check每一个元素和属性 boolean beforeFirstTag = true; while (xmlReader.hasNext()) &#123; int event = xmlReader.next(); if (event == XMLStreamReader.START_ELEMENT) &#123; if (beforeFirstTag) &#123; if (!TAG_VECTOR.equals(xmlReader.getLocalName())) &#123; // 如果不是 vector 直接不用check了 return null; &#125; beforeFirstTag = false; &#125; else &#123; if (TAG_GRADIENT.equals(xmlReader.getLocalName())) &#123; // 找到 gradient 这个元素，返回一个reason // GRADIENT_SUPPORT 的版本阈值是24 return PreprocessingReason.GRADIENT_SUPPORT; &#125; int n = xmlReader.getAttributeCount(); for (int i = 0; i &lt; n; i++) &#123; // 找到 fillType 这个属性，返回一个reason 。 // FILLTYPE_SUPPORT 的版本阈值是 24 if (\"fillType\".equals(xmlReader.getAttributeLocalName(i)) &amp;&amp; NS_RESOURCES.equals(xmlReader.getAttributeNamespace(i))) &#123; return PreprocessingReason.FILLTYPE_SUPPORT; &#125; &#125; &#125; &#125; &#125; if (!beforeFirstTag &amp;&amp; mMinSdk &lt; PreprocessingReason.VECTOR_SUPPORT.getSdkThreshold()) &#123; // 判断是minSdk否是压根就不支持 vector ，返回一个reason // VECTOR_SUPPORT 的版本阈值是 21 return PreprocessingReason.VECTOR_SUPPORT; &#125; &#125; catch (XMLStreamException e) &#123; throw new IOException( \"Failed to parse resource file \" + resourceFile.getAbsolutePath(), e); &#125; return null;&#125; 很明显，AGP 只会判断svg文件里的 gradient 和 fillType 这两个东西。gradient是颜色渐变fillType 专业性太强，搜了一圈看不懂，不知道是做什么的。。。他们的版本号阈值都是24，svg文件中出现这两个东西，并且 minSdk &lt; 24 时就会触发 svg-&gt;png 的生成 如何处理在我们的项目里，svg自动生成png的case太多了，大概接近300个资源图片。 需要去治理一波。生成的png直接导致我们使用svg去减小包体积的初衷失去意义。但是不能一个一个改，太费事。 有一个开源的 McImage 插件，作用是把项目中的所有资源转换成webp，我们可以模仿它 AGP提供了 variant.getAllRawAndroidResources().files 这个api，在app下使用，可以获取到所有的resource目录。 打印所有的目录123456789101112131415161718// 子module的 build/intermediates/packaged_res 目录/Users/xx/PluginX/module_1/build/intermediates/packaged_res/debug// 依赖库的res目录/Users/xx/.gradle/caches/transforms-2/files-2.1/414fc23eb49f389f342a6e17218892be/appcompat-1.2.0/res/Users/xx/.gradle/caches/transforms-2/files-2.1/72202874f0ee490d85b35e8bc8155d2b/constraintlayout-1.1.3/res/Users/xx/.gradle/caches/transforms-2/files-2.1/52e4a4d01e3d8c6a6c3d516d66f6acc9/recyclerview-1.0.0/res/Users/xx/.gradle/caches/transforms-2/files-2.1/83248d60fee84d269b4d5ae691d6e421/jetified-appcompat-resources-1.2.0/res/Users/xx/.gradle/caches/transforms-2/files-2.1/5fddbd55bd0ad4a84e0959052d0c417d/coordinatorlayout-1.0.0/res/Users/xx/.gradle/caches/transforms-2/files-2.1/05736e5c1eb0ab8976aa5868fca67ffe/core-1.3.1/res// 不知道是什么目录，空的/Users/xx/PluginX/app/build/generated/res/rs/debug/Users/xx/PluginX/app/build/generated/res/resValues/debug/Users/xx/PluginX/app/build/generated/res/microapk/debug// 工程开发目录 /src/main/res/Users/xx/PluginX/app/src/main/res/Users/xx/PluginX/app/src/debug/res 结合上面 MergeResources 的分析。子module会在 packageDebugResources 任务，把module所有资源汇总拷贝到 build/intermediates/packaged_res/在app也能拿到所有子module汇总拷贝之后的这个目录。可以在app的 mergeDebugResources 任务之前，插入一个我们自己的任务。作用是收集 getAllRawAndroidResources().files 目录里的所有资源文件，查找删除同名的多余资源图片，如果存在xml后缀的svg资源和多个同名的png资源，只保留 xxhdpi 目录下的png图片资源。实践来看，可行，没有报错，打出来的apk文件安装使用也都正常。 TODO：是否可以在 mergeDebugResources 之后进行 hook ？ 参考:Android中Gradle原理以及机制深入分析gradle编译打包过程分析之ProcessAndroidResources","categories":[],"tags":[],"keywords":[]},{"title":"网络相关知识点","slug":"Base/网络相关知识点","date":"2022-08-27T09:56:47.000Z","updated":"2022-09-03T08:56:14.217Z","comments":true,"path":"2022/08/27/Base/网络相关知识点/","link":"","permalink":"http://yoursite.com/2022/08/27/Base/网络相关知识点/","excerpt":"OSI五层网络模型 物理层利用传输介质为数据提供物理连接，传输比特流。 wifi 、光纤 等 数据链路层在两个相邻结点之间传送数据，传输数据帧 网络层提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径。 IP协议 传输层向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，负责向两个主机中进程之间的通信提供服务。 TCP ， UDP 应用层 为用户提供的服务。 http，https 协议","text":"OSI五层网络模型 物理层利用传输介质为数据提供物理连接，传输比特流。 wifi 、光纤 等 数据链路层在两个相邻结点之间传送数据，传输数据帧 网络层提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径。 IP协议 传输层向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，负责向两个主机中进程之间的通信提供服务。 TCP ， UDP 应用层 为用户提供的服务。 http，https 协议 TCP面试准备 TCP 知识，看这一篇就够了 TCP 三次握手123client ---- SYN=1,seq=j ----------&gt; serverclient &lt;--- SYN=1,seq=k,ack=j+1 --- serverclient ---- ack=k+1 --------&gt; server 为什么需要三次，而不是两次？如果试了两次握手，client端第一次发送到服务端，服务端即会认为建立连接。但是网络是会延迟或丢包的，如果第一次发生了客户端的握手发生了延迟，客户端会超时重传，这样就有可能服务端收到多个建立连接的消息，导致连接建立多次。 TCP 四次挥手12345client ---- FIN=1,seq=x ----&gt; serverclient &lt;--- ack=x+1 ----- serverclient &lt;--------------------- server // 服务端传输剩余内容client &lt;--- FIN=1,seq=z ----&gt; serverclient ---- ack=z+1 ----&gt; server 客户端发送关闭连接的报文， FIN 标志位为1 服务端收到FIN后，发送确认报文 服务端继续发送剩余的报文，客户端继续接收剩余报文 服务端报文发送完毕，向客户端发送FIN报文 客户端向服务端发送确认报文，客户端等待一段时间后进入closed状态。 服务端收到确认报文即进入closed状态 为什么挥手要四次不是三次？因为客户端发起关闭连接报文时，服务端可能还有剩余的数据没有发送完毕。 要等待服务端将剩余的数据发送完毕。 客户端收到FIN后为什么要等待一段时间在进入closed状态？因为客户端发送的确认报文有可能丢失，这样，服务端会重复发送FIN报文； 如果客户端收到FIN立即关闭，就无法处理服务端重复发送的FIN报文。 和UDP相比，为什么TCP是可靠的TCP有超时重传机制。 当TCP报文发出，会启动计数器，等待接收端返回确认报文。如果长时间没有收到确认报文，会将报文重新发送 httphttp版本迭代http1.1 Connnection: Keep-Alive复用tcp连接。 允许HTTP设备在事务处理结束之后将TCP连接保持在打开的状态，以便未来的HTTP请求重用现在的连接 支持只请求数据的一部分 rangeRANGE:bytes=XXXX 表示要求服务器从文件 XXXX 字节处开始传送，断点续传 http2.0 多路复用。多个请求并行的复用一个连接。和 keep-alive 的区别： http1.1 的复用是串行的，如果有一个请求耗时较长会阻塞。http2.0 是并行复用，不会阻塞 https123456client ---- 请求https连接 ----&gt; serverclient &lt;--- 公钥 ----&gt; serverclient ---- 生成秘钥，并用公钥加密client ---- 公钥加密后的秘钥 ---&gt; server 使用私钥解密，得到秘钥 ---- serverclient &lt;--- client 和 server使用秘钥通信 ---&gt; server // 对称加密","categories":[],"tags":[],"keywords":[]},{"title":"DecorView, Window, ViewRootImpl的关系","slug":"Android/Framework/DecorView-Window-ViewRootImpl的关系","date":"2022-08-19T02:22:30.000Z","updated":"2022-08-31T16:18:29.867Z","comments":true,"path":"2022/08/19/Android/Framework/DecorView-Window-ViewRootImpl的关系/","link":"","permalink":"http://yoursite.com/2022/08/19/Android/Framework/DecorView-Window-ViewRootImpl的关系/","excerpt":"Window的创建一个 activity 对应的是 PhoneWindow 。 创建的时机是在 attach","text":"Window的创建一个 activity 对应的是 PhoneWindow 。 创建的时机是在 attach 12345678910111213141516171819202122232425final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123; attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback); ... mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); ...&#125; 实例化 PhoneWindow 的同时，会设置 WindowManager , WindowManager 是一个系统服务。 在app进程的代理类是 WindowManagerImpl， 但是 WindowManagerImpl 把实现委托给了 WindowManagerGlobal 。 DecorView 的创建DecorView的创建在 activity.setContentView(int) , 最终实现在 PhoneWindow.setContentView(int) 1234567891011121314151617181920212223242526@Overridepublic void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; ... // mContentParent 是 android.R.id.content 的 view mLayoutInflater.inflate(layoutResID, mContentParent); ...&#125;private void installDecor() &#123; mForceDecorInstall = false; if (mDecor == null) &#123; mDecor = generateDecor(-1); // 实例化 DecorView ... &#125; else &#123; mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); // 返回 content 的view &#125;&#125; ViewRootImpl 的创建ViewRootImpl 的创建在 ActivityThread#handleResumeActivity 里。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; // 调用 activity#onResume final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); ... final Activity a = r.activity; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityTaskManager.getService().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; ... if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); // 主流程下一步 &#125; else &#123; a.onWindowAttributesChanged(l); &#125; &#125; &#125; else if (!willBeVisible) &#123; r.hideForNow = true; &#125; ... // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; ViewRootImpl impl = r.window.getDecorView().getViewRootImpl(); WindowManager.LayoutParams l = impl != null ? impl.mWindowAttributes : r.window.getAttributes(); ... r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; Looper.myQueue().addIdleHandler(new Idler());&#125; 调用了 WindowManagerGlobal#addView(…) activity#makeVisible()1234void makeVisible() &#123; ... mDecor.setVisibility(View.VISIBLE);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow, int userId) &#123; ... final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; ViewRootImpl root; // 实例化 ViewRootImpl View panelParentView = null; synchronized (mLock) &#123; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; mRoots.get(index).doDie(); &#125; else &#123; throw &#125; // The previous removeView() had not completed executing. Now it has. &#125; root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); // 存储所有的 decorView 和 ViewRootImpl 。暂时不明白存储来做什么的 mViews.add(view); mRoots.add(root); mParams.add(wparams); try &#123; // 绑定 DecorView 和 ViewRootImpl root.setView(view, wparams, panelParentView, userId); &#125; catch (RuntimeException e) &#123; if (index &gt;= 0) &#123; // 异常了，移除 removeViewLocked(index, true); &#125; throw e; &#125; &#125;&#125; ViewRootImpl核心类是 ViewRootImpl 。 它负责和系统 WMS 交互 123456789101112131415161718192021222324252627282930313233343536373839public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks &#123; final ViewRootHandler mHandler = new ViewRootHandler(); public ViewRootImpl(Context context, Display display) &#123; mContext = context; // WMS端Session的代理对象 mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; mThread = Thread.currentThread(); // 继承于IWindow.Stub的W对象 mWindow = new W(this); mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this, context); // 绘制相关的对象 mChoreographer = Choreographer.getInstance(); // ... &#125; public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; mAttachInfo.mRootView = view; // ... &#125; // 开启绘制流程三步走 requestLayout(); // 由之前的解析可知Session.addToDisplay会调用到WMS.addWindow方法 // 通过session与WMS建立通信，完成window的添加 // mWindowSession app进程只会有一个 // mWindow 用于binder双向通信，ViewRootImpl 都会有一个 es = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mWinFrame, mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel); // ... &#125; &#125;&#125; Window 的移除在 ActivityThread 的 handleDestroyActivity 中 1234567891011121314151617181920212223242526272829303132@Overridepublic void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) &#123; // 调用 activity#onDestroy ActivityClientRecord r = performDestroyActivity(token, finishing, configChanges, getNonConfigInstance, reason); if (r != null) &#123; WindowManager wm = r.activity.getWindowManager(); View v = r.activity.mDecor; if (v != null) &#123; if (r.activity.mVisibleFromServer) &#123; mNumVisibleActivities--; &#125; IBinder wtoken = v.getWindowToken(); if (r.activity.mWindowAdded) &#123; if (r.mPreserveWindow) &#123; ... // window还未显示出来，pending remove &#125; else &#123; wm.removeViewImmediate(v); &#125; &#125; &#125; &#125; if (finishing) &#123; try &#123; ActivityTaskManager.getService().activityDestroyed(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; mSomeActivitiesChanged = true;&#125; wm.removeViewImmediate(v); 是下一步 12345678910111213141516171819202122232425262728// WindowManagerGlobal#removeViewpublic void removeView(View view, boolean immediate) &#123; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; &#125;&#125;private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (root != null) &#123; // 通知 InputManagerService root.getImeFocusController().onWindowDismissed(); &#125; boolean deferred = root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125;&#125; 下一步是 ViewRootImpl.die(boolean) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647boolean die(boolean immediate) &#123; if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; ... // 如果不是 immediate 加入到消息循环中 mHandler.sendEmptyMessage(MSG_DIE); return true;&#125;void doDie() &#123; checkThread(); synchronized (this) &#123; if (mRemoved) &#123; return; &#125; mRemoved = true; if (mAdded) &#123; dispatchDetachedFromWindow(); &#125; if (mAdded &amp;&amp; !mFirst) &#123; ... if (mView != null) &#123; // 销毁 Surface destroySurface(); &#125; &#125; mAdded = false; &#125; WindowManagerGlobal.getInstance().doRemoveView(this);&#125;void dispatchDetachedFromWindow() &#123; destroySurface(); .... try &#123; // binder调用移除window mWindowSession.remove(mWindow); &#125; catch (RemoteException e) &#123; &#125; ...&#125;","categories":[],"tags":[],"keywords":[]},{"title":"协程的原理","slug":"Kotlin/协程的原理","date":"2022-07-17T05:30:18.000Z","updated":"2022-07-17T13:30:10.939Z","comments":true,"path":"2022/07/17/Kotlin/协程的原理/","link":"","permalink":"http://yoursite.com/2022/07/17/Kotlin/协程的原理/","excerpt":"suspend 到底做了什么一个简单的协程调用12345678910suspend fun task() &#123; delay(100) // 延时来模拟耗时任务&#125;suspend fun runTask(): String &#123; val time = System.currentTimeMillis() val result = task() println(result) return \"getTask case $&#123;time - System.currentTimeMillis()&#125;\"&#125;","text":"suspend 到底做了什么一个简单的协程调用12345678910suspend fun task() &#123; delay(100) // 延时来模拟耗时任务&#125;suspend fun runTask(): String &#123; val time = System.currentTimeMillis() val result = task() println(result) return \"getTask case $&#123;time - System.currentTimeMillis()&#125;\"&#125; 这里runTask表示一个在协程环境调用一个耗时suspend方法并获取结果。看一下 runTask() 方法反编译之后的结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Nullablepublic final Object runTask(@NotNull Continuation var1) &#123; Object $continuation; label20: &#123; // 这边label可以理解为goto语句 if (var1 instanceof &lt;undefinedtype&gt;) &#123; $continuation = (&lt;undefinedtype&gt;)var1; if ((((&lt;undefinedtype&gt;)$continuation).label &amp; Integer.MIN_VALUE) != 0) &#123; ((&lt;undefinedtype&gt;)$continuation).label -= Integer.MIN_VALUE; break label20; &#125; &#125; $continuation = new ContinuationImpl(var1) &#123; // $FF: synthetic field Object result; int label; long J$0; @Nullable public final Object invokeSuspend(@NotNull Object $result) &#123; this.result = $result; this.label |= Integer.MIN_VALUE; return ContinueTest.this.runTask(this); &#125; &#125;; &#125; Object $result = ((&lt;undefinedtype&gt;)$continuation).result; Object var8 = IntrinsicsKt.getCOROUTINE_SUSPENDED(); Object var10000; long time; switch(((&lt;undefinedtype&gt;)$continuation).label) &#123; // 状态机的状态值 case 0: ResultKt.throwOnFailure($result); time = System.currentTimeMillis(); ((&lt;undefinedtype&gt;)$continuation).J$0 = time; ((&lt;undefinedtype&gt;)$continuation).label = 1; var10000 = this.task((Continuation)$continuation); if (var10000 == var8) &#123; // 进入挂起状态，结束 return var8; &#125; break; case 1: time = ((&lt;undefinedtype&gt;)$continuation).J$0; ResultKt.throwOnFailure($result); var10000 = $result; break; default: throw new IllegalStateException(\"call to 'resume' before 'invoke' with coroutine\"); &#125; String result = (String)var10000; boolean var5 = false; System.out.println(result); return \"getTask cost \" + (time - System.currentTimeMillis());&#125; 有几个关注点： suspend 增加了一个 @NotNull Continuation var1 参数， Continuation 意思是 继续 再开始 , 可以理解为一个状态机实现的callback switch(((&lt;undefinedtype&gt;)$continuation).label)switch语句里的 continuation.label 即是状态机的状态值。case 0 是执行suspend之前的代码，case 1 代表执行suspend之后的代码。 对应调用了几次suspend挂起方法，就会生成对应的case在case 0有一个判断 if (var10000 == var8 可以转化为 if (var10000 == COROUTINE_SUSPENDED)这个判断被调用的task()是不是挂起的，因为里面做了delay，所以肯定为true, 直接return，告诉调用自己的上层自己也是挂起状态。 现在，runTask() 和 task() 都是挂起的，该如何从挂起状态恢复呢？ 挂起的恢复在上面反编译的代码里面，有一个很明显的label20: 标记，这里我理解就是一个goto语句，里面首先有一个if判断，这个不知道是什么，不管它。。。然后后面有一个new实例化$continuation = new ContinuationImpl(var1) var1是suspend方法的Continuation入参，ContinuationImpl 继承自 BaseContinuationImpl , 我们来分析一下这个 BaseContinuationImpl 的源码 12345678910111213141516171819202122232425262728293031323334353637public interface Continuation&lt;in T&gt; &#123; public val context: kotlin.coroutines.CoroutineContext public fun resumeWith(result: kotlin.Result&lt;T&gt;): kotlin.Unit&#125;internal abstract class BaseContinuationImpl( public val completion: Continuation&lt;Any?&gt;?) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123; public final override fun resumeWith(result: Result&lt;Any?&gt;) &#123; var current = this var param = result while (true) &#123; with(current) &#123; // this -&gt; // ... 这个with语句，里面的变量有些是current的成员变量，注意区分... // ... kotlin //的垃圾语法糖啊 val completion = completion!! val outcome: Result&lt;Any?&gt; = try &#123; val outcome = invokeSuspend(param) // current.invokeCurrent(param) if (outcome === COROUTINE_SUSPENDED) return Result.success(outcome) &#125; catch (exception: Throwable) &#123; Result.failure(exception) &#125; releaseIntercepted() if (completion is BaseContinuationImpl) &#123; current = completion param = outcome &#125; else &#123; completion.resumeWith(outcome) return &#125; &#125; &#125; &#125;&#125; BaseContinuationImpl 实现了 Continuation 接口，resumeWith 在 耗时挂起执行完了之后会被调用。在前面反编译的代码中创建了匿名内部类123456789101112$continuation = new ContinuationImpl(var1) &#123; Object result; int label; long J$0; @Nullable public final Object invokeSuspend(@NotNull Object $result) &#123; this.result = $result; this.label |= Integer.MIN_VALUE; return ContinueTest.this.runTask(this); &#125; &#125;; continuation 的初始 label 值是0，在switch语句里，执行完suspend之前的代码后，label会设为1， 当调用完suspend方法后， BaseContinuationImpl#resumeWith 会调用 invokeSuspend 方法递归调用suspend方法 runTask() 。 如果 suspend 方法还是 挂起的，那么直接return。否则递归不断向上resume","categories":[],"tags":[],"keywords":[]},{"title":"mmkv原理","slug":"Android/源码解析/mmkv原理","date":"2022-07-10T09:03:32.000Z","updated":"2022-07-10T11:36:49.455Z","comments":true,"path":"2022/07/10/Android/源码解析/mmkv原理/","link":"","permalink":"http://yoursite.com/2022/07/10/Android/源码解析/mmkv原理/","excerpt":"SharedPreferences的痛点只能全量读取和写入","text":"SharedPreferences的痛点只能全量读取和写入sp保存数据的文件形式是xml。每次读取都去读xml文件，解析后加入内存缓存里。每次写入都更改内存缓存的值，然后全量写入到文件里 有anr的风险 在第一次载入时会产生anr有一个加锁配合while循环，如果第一次使用xml文件还没有加载完成，就会pending。xml文件的全量读取本身就不快，如果xml文件过大，在首次使用时就可能会anr，在app启动过程中问题会比较明显。 1234567891011121314151617181920212223@Overridepublic boolean getBoolean(String key, boolean defValue) &#123; synchronized (mLock) &#123; awaitLoadedLocked(); Boolean v = (Boolean)mMap.get(key); return v != null ? v : defValue; &#125;&#125;private void awaitLoadedLocked() &#123; if (!mLoaded) &#123; BlockGuard.getThreadPolicy().onReadFromDisk(); &#125; while (!mLoaded) &#123; try &#123; mLock.wait(); &#125; catch (InterruptedException unused) &#123; &#125; &#125; if (mThrowable != null) &#123; throw new IllegalStateException(mThrowable); &#125;&#125; commit写入导致anr没啥说的，同步写入文件 apply写入导致anrapply会异步写入，先写入到内存缓存，然后在子线程更新xml文件。但是sp会将更新文件的问题加入到QueuedWork中。android的系统会在Activity的onStop,onPause等生命周期中，调用QueuedWork.waitToFinish，等待落盘的任务队列执行完成，如果任务队列中的任务很多，或者待写入的数据量很大时(sp文件是全量读写的)，在一些io性能差的中低端机型上就会很容易出现anr. 具体可以参考这个文章：https://juejin.cn/post/6844904033820377096https://www.jianshu.com/p/9ae0f6842689 内存映射通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。 普通io文件操作的过程Linux系统内存分为 内核空间 和 用户空间 。文件操作属于 内核空间。应用需要通过系统调用才能完成文件读取。普通io操作需要先将文件拷贝到页缓存里(内核空间)，然后再从页缓存拷贝到用户空间。这需要两次拷贝。 mmap文件读写mmap创建了 用户空间 到 内核空间 的映射，返回对应的指针；读取文件时，文件还是一样拷贝到页缓存里(内核空间)。 因为创建了内存映射，用户空间能直接获取到文件数据。写文件时，直接写入到指针地址对应的内核空间，Linux系统机制会保证内核空间到文件磁盘的写入，这样即使进程crash，也不会导致数据丢失 数据存储优化 数据组织数据序列化方面我们选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。 写入优化考虑到主要使用场景是频繁地进行写入更新，我们需要有增量更新的能力。我们考虑将增量 kv 对象序列化后，append 到内存末尾。这样同一个 key 会有新旧若干份数据，最新的数据在最后。写入速度会很快读取只需要从后往前读，读到第一个key匹配即使最新的有效数据。 空间增长使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。我们需要在性能和空间上做个折中。以内存 pagesize(内存页大小) 为单位申请空间，在空间用尽之前都是 append 模式；当 append 到文件末尾时，进行文件重整(去除重复key)、key 排重，尝试序列化保存排重结果；在程序启动第一次打开 mmkv 时，也会进行文件重整。排重后空间还是不够用的话，将文件扩大一倍，直到空间足够。 多进程读写支持在mmap的时候，只会返回映射内存的指针。在append和重整时可以加文件锁，保证自己的写文件成功。但是一个进程并不知道自己文件的数据是否被其他进程修改过。 写指针的同步因为mmkv的写入是直接append在数据末尾，mmap导致数据的大小和文件的大小并不一直，所以需要一个指针指向有效数据的末尾，称之为写指针。mmkv 在每个进程内部缓存自己的写指针，然后在写入键值的同时，还要把最新的写指针位置也写到 mmap 内存中；这样每个进程只需要对比一下缓存的指针与 mmap 内存的写指针，如果不一样，就说明其他进程进行了写操作。事实上 MMKV 原本就在文件头部保存了有效内存的大小，这个数值刚好就是写指针的内存偏移量，可以重用这个数值来校对写指针。 内存重整的感知使用一个单调递增的序列号，每次发生内存重整，就将序列号递增。将这个序列号也放到 mmap 内存中，每个进程内部也缓存一份，只需要对比序列号是否一致，就能够知道其他进程是否触发了内存重整。 内存增长的感知事实上 MMKV 在内存增长之前，会先尝试通过内存重整来腾出空间，重整后还不够空间才申请新的内存。所以内存增长可以跟内存重整一样处理。至于新的内存大小，可以通过查询文件大小来获得，无需在 mmap 内存另外存放。 可以参考文档 https://cloud.tencent.com/developer/article/1354199 mmkv的不足主要是mmap的缺点，需要提前确定好文件的大小，即 映射内存的大小。但是，映射内存的大小并不是有效数据的大小。 映射内存只是提供了一个快捷操作文件的场地。 会造成存储空间的浪费，并且映射内存的大小必须是页缓存(pagesize)的整数倍","categories":[],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"glide","slug":"glide","permalink":"http://yoursite.com/tags/glide/"}],"keywords":[]},{"title":"Retrofit源码解析","slug":"Android/源码解析/Retrofit源码解析","date":"2022-06-12T10:21:16.000Z","updated":"2022-07-05T05:30:08.364Z","comments":true,"path":"2022/06/12/Android/源码解析/Retrofit源码解析/","link":"","permalink":"http://yoursite.com/2022/06/12/Android/源码解析/Retrofit源码解析/","excerpt":"123456789101112131415161718192021222324public interface RetrofitService &#123; @GET(\"query\") Observable&lt;PostInfo&gt; getPostInfoRx(@Query(\"type\") String type, @Query(\"postid\") String postid);&#125;Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://www.kuaidi100.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 支持RxJava .build(); RetrofitService service = retrofit.create(XxxInterface.class);Call&lt;PostInfo&gt; call = service.getPostInfo(\"yuantong\", \"11111111111\");call.enqueue(new Callback&lt;PostInfo&gt;() &#123; @Override public void onResponse(Call&lt;PostInfo&gt; call, Response&lt;PostInfo&gt; response) &#123; Log.i(\"http返回：\", response.body().toString() + \"\"); &#125; @Override public void onFailure(Call&lt;PostInfo&gt; call, Throwable t) &#123; &#125;&#125;);","text":"123456789101112131415161718192021222324public interface RetrofitService &#123; @GET(\"query\") Observable&lt;PostInfo&gt; getPostInfoRx(@Query(\"type\") String type, @Query(\"postid\") String postid);&#125;Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://www.kuaidi100.com/\") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 支持RxJava .build(); RetrofitService service = retrofit.create(XxxInterface.class);Call&lt;PostInfo&gt; call = service.getPostInfo(\"yuantong\", \"11111111111\");call.enqueue(new Callback&lt;PostInfo&gt;() &#123; @Override public void onResponse(Call&lt;PostInfo&gt; call, Response&lt;PostInfo&gt; response) &#123; Log.i(\"http返回：\", response.body().toString() + \"\"); &#125; @Override public void onFailure(Call&lt;PostInfo&gt; call, Throwable t) &#123; &#125;&#125;); 上面是 Retrofit 的主要用法，主要重要的东西有 ConverterFactory , CallAdapterFactory , retrofit.create(XxxInterface.class) 三个东西 Retrofit.Builder()builder就是一个常见的建造者模式，没什么好说的。 有一个点需要注意一下123456789101112131415161718192021222324252627public Retrofit build() &#123; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; // 默认callback回调是执行在主线程的 callbackExecutor = platform.defaultCallbackExecutor(); &#125; List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor)); List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;( 1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize()); // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); converterFactories.addAll(this.converterFactories); converterFactories.addAll(platform.defaultConverterFactories()); return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); &#125; 1234567891011121314151617final class BuiltInConverters extends Converter.Factory &#123; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; if (type == ResponseBody.class) &#123; return Utils.isAnnotationPresent(annotations, Streaming.class) ? StreamingResponseBodyConverter.INSTANCE : BufferingResponseBodyConverter.INSTANCE; &#125; if (type == Void.class) &#123; return VoidResponseBodyConverter.INSTANCE; &#125; return null; &#125; ...&#125; 这里首先插入了一个 BuiltInConverters 内置的转换器。 当返回类型是 ResponseBody 的时候就会使用 BuiltInConverters ，返回 ResponseBody 就和 okhttp 的返回一致了。 retrofit.create(XxxInterface.class)1234567891011121314public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; ... return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; ... return loadServiceMethod(method).invoke(args != null ? args : emptyArgs); &#125; &#125;);&#125; 这里使用了动态代理，create方法返回的接口对象是一个动态代理的实例 loadServiceMethod12345678910111213ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123; ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = ServiceMethod.parseAnnotations(this, method); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; 缓存 + 解析Method ServiceMethod.parseAnnotations123456789abstract class ServiceMethod&lt;T&gt; &#123; static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method method) &#123; RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method); ... return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); &#125; abstract @Nullable T invoke(Object[] args);&#125; 在抽象父类里先调用了 RequestFactory.parseAnnotations(retrofit, method); 去解析方法参数的注解。HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory); 里解析了返回类型，并匹配 CallAdapter 和 Converter。。。抽象父类的静态方法区调用了子类的静态方法。。。有些迷惑 HttpServiceMethod.parseAnnotationsRequestFactory.parseAnnotations 都是一些注解的处理，不说了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt; parseAnnotations( Retrofit retrofit, Method method, RequestFactory requestFactory) &#123; boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction; boolean continuationWantsResponse = false; boolean continuationBodyNullable = false; Annotation[] annotations = method.getAnnotations(); Type adapterType; if (isKotlinSuspendFunction) &#123; // 是协程suspend方法调用 // kotli的suspend方法转成java之后会在方法参数上生成一个Continuation类型的参数 Type[] parameterTypes = method.getGenericParameterTypes(); // 获取方法的所有参数类型 Type responseType = Utils.getParameterLowerBound(0, (ParameterizedType) parameterTypes[parameterTypes.length - 1]); // 获取最后一个 Continuation 类型参数的泛型 if (getRawType(responseType) == Response.class &amp;&amp; responseType instanceof ParameterizedType) &#123; // Unwrap the actual body type from Response&lt;T&gt;. // 获取 Response&lt;T&gt; 中泛型T的类型 responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType); continuationWantsResponse = true; &#125; else &#123; &#125; // 这里把suspend方法的返回类型的 AdapterType 当做 Call&lt;T&gt; 来处理了 adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType); annotations = SkipCallbackExecutorImpl.ensurePresent(annotations); &#125; else &#123; // 如果是非suspend方法，那直接取返回类型就可以了 adapterType = method.getGenericReturnType(); &#125; // 寻找合适的 CallAdapterFactory 生产 CallAdapter CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter = createCallAdapter(retrofit, method, adapterType, annotations); Type responseType = callAdapter.responseType(); ... // 寻找合适的 ConverterFactory 生产 Converter Converter&lt;ResponseBody, ResponseT&gt; responseConverter = createResponseConverter(retrofit, method, responseType); // CallFactory 实质上就是 OkHttpClient okhttp3.Call.Factory callFactory = retrofit.callFactory; // 下面是返回 HttpServiceMethod 的子类，这三个子类其实就是 CallAdapted wrap 了一层。 SuspendForResponse 和 SuspendForBody 调用了协程的 await 方法去等待协程的完成（其实就是加了个Continuation的回调） if (!isKotlinSuspendFunction) &#123; return new CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter); &#125; else if (continuationWantsResponse) &#123; //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForResponse&lt;&gt;(requestFactory, callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter); &#125; else &#123; //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) new SuspendForBody&lt;&gt;(requestFactory, callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter, continuationBodyNullable); &#125; &#125; ServiceMethod.invode123456789/**HttpServiceMethod**/ @Override final @Nullable ReturnT invoke(Object[] args) &#123; Call&lt;ResponseT&gt; call = new OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter); return adapt(call, args); &#125; protected abstract @Nullable ReturnT adapt(Call&lt;ResponseT&gt; call, Object[] args); OkHttpCall 实现了 Retrofit 的 call 到 OkHttpCall 的转换adapt 最终会调用 CallAdapter 的 adapt 123456789101112131415161718192021222324252627282930313233@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; // 懒加载 rawCall // 传入真实请求参数，构建真正发起请求的 okhttp 的 Call 对象 call = rawCall = createRawCall(); &#125; &#125; ... call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123; Response&lt;T&gt; response; // 调用 Converter 解析返回类型 response = parseResponse(rawResponse); callback.onResponse(OkHttpCall.this, response); &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; callback.onFailure(OkHttpCall.this, e); &#125; &#125;); &#125; 可以看一下默认的 DefaultCallAdapterFactory 是怎么实现的1234567891011121314151617181920212223242526272829/**DefaultCallAdapterFactory**/ @Override public @Nullable CallAdapter&lt;?, ?&gt; get( Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; ... // 获取 Call&lt;T&gt; 的具体类型 final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType); // 是否有 SkipCallbackExecutor 这个注解，一般是没有的 final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class) ? null : callbackExecutor; return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return executor == null ? call : new ExecutorCallbackCall&lt;&gt;(executor, call); &#125; &#125;; &#125; 12345678910111213141516171819202122232425262728static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; ... &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; ... &#125;); &#125; &#125;); &#125; @Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute(); &#125; enqueue 里的返回 onResponse 和 onFailure 都是在 callbackExecutorcallbackExecutor 也是在 retrofit 构建时传入的， 默认是 Android.MainThreadExecutor 也就是说默认 enqueue 的 callback 默认是执行在主线程的","categories":[],"tags":[],"keywords":[]},{"title":"RequestLayout和Invalidate","slug":"Android/Framework/RequestLayout和Invalidate","date":"2022-05-02T08:48:49.000Z","updated":"2022-08-17T08:34:43.330Z","comments":true,"path":"2022/05/02/Android/Framework/RequestLayout和Invalidate/","link":"","permalink":"http://yoursite.com/2022/05/02/Android/Framework/RequestLayout和Invalidate/","excerpt":"RequestLayout标记自身给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。并将RequestLayout向上传递。","text":"RequestLayout标记自身给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。并将RequestLayout向上传递。 1234567891011121314151617181920212223242526272829//从源码注释可以看出，如果当前View在请求布局的时候，View树正在进行布局流程的话，//该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发现的时候再执行。@CallSuperpublic void requestLayout() &#123; if (mMeasureCache != null) mMeasureCache.clear(); if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123; // 如果处于 Layout 则将该请求加入 ViewRootImpl 中的任务队列中 ViewRootImpl viewRoot = getViewRootImpl(); if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123; if (!viewRoot.requestLayoutDuringLayout(this)) &#123; return; &#125; &#125; mAttachInfo.mViewRequestingLayout = this; &#125; //为当前view设置标记位 PFLAG_FORCE_LAYOUT mPrivateFlags |= PFLAG_FORCE_LAYOUT; mPrivateFlags |= PFLAG_INVALIDATED; if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123; //向父容器请求布局 mParent.requestLayout(); &#125; if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123; mAttachInfo.mViewRequestingLayout = null; &#125;&#125; 调用 requestLayout() 的view会给自己添加标记位 PFLAG_FORCE_LAYOUT , PFLAG_INVALIDATED并一直parent向上递归，这个view所有的祖先都会设置上标记位 ViewRootImpl会顺着view树，一路向上标记，最终到达 ViewRootImpl12345678@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); // 开启measure、layout、draw三步走 &#125;&#125; scheduleTraversals() 开启绘制三步走流程。 在measure、layout、draw过程中都会判断标志位，只有需要的时候才执行 12345678910111213141516 public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) &#123; ... if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ... mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125;&#125; measure时判断了 PFLAG_FORCE_LAYOUT ，或者 measureSpec 发生了改变。 并不是所有的view都会重新measure 。在一个view调用 requestLayout 时，这个view和它的所有祖先一定会重新measure，其他view按需要判断是否重新measure。 在 mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; 中也给layout过程做了标记 123456789101112131415161718192021222324252627282930313233343536373839404142 public void layout(int l, int t, int r, int b) &#123; ... boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); //判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局 if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); //onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位 mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; &#125; //最后清除PFLAG_FORCE_LAYOUT标记位 mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125;protected boolean setFrame(int left, int top, int right, int bottom) &#123; boolean changed = false; if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123; changed = true; // Remember our drawn bit int drawn = mPrivateFlags &amp; PFLAG_DRAWN; int oldWidth = mRight - mLeft; int oldHeight = mBottom - mTop; int newWidth = right - left; int newHeight = bottom - top; boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight); invalidate(sizeChanged); ... mPrivateFlags |= PFLAG_HAS_BOUNDS; mPrivateFlags |= drawn; if (sizeChanged) &#123; sizeChange(newWidth, newHeight, oldWidth, oldHeight); &#125; &#125; return changed; &#125; layout时判断了PFLAG_LAYOUT_REQUIRED标记，需要时才做。 changed 获取有一个 setFrame(...) 方法，里面会判断view的layout是否改变，如果改变了，会调用 invalidate() 进行重新draw 总结 调用 View.requestLayout 方法后会依次调用 performMeasure, performLayout 和 performDraw 方法，调用者 View 及其父 View 会重新从上往下进行 measure, layout 流程，如果view顶点没有改变，不会执行 draw 流程 Invalidate标记自身 123456789101112131415161718192021222324252627282930 void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; ... //根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘 if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123; ... //设置PFLAG_DIRTY标记位 mPrivateFlags |= PFLAG_DIRTY; ... // Propagate the damage rectangle to the parent view. //把需要重绘的区域传递给父容器 final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); //调用父容器的方法，向上传递事件 p.invalidateChild(this, damage); &#125; ... &#125;&#125; ViewGroup处理并向上传递 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** * Don't call or override this method. It is used for the implementation of * the view hierarchy. */public final void invalidateChild(View child, final Rect dirty) &#123; //设置 parent 等于自身 ViewParent parent = this; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; ... int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY; if (child.mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; &#125; ... do &#123; // 循环向上遍历祖先view View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; ... if (view != null) &#123; if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp; view.getSolidColor() == 0) &#123; opaqueFlag = PFLAG_DIRTY; &#125; if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123; //对当前View的标记位进行设置 view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag; &#125; &#125; //调用ViewGrup的invalidateChildInParent，如果已经达到最顶层view,则调用ViewRootImpl的invalidateChildInParent。 parent = parent.invalidateChildInParent(location, dirty); ... &#125; while (parent != null); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) &#123; if ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123; if ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) &#123; //将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响 dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY); if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == 0) &#123; //求并集，结果是把子视图的dirty区域转化为父容器的dirty区域 dirty.union(0, 0, mRight - mLeft, mBottom - mTop); &#125; final int left = mLeft; final int top = mTop; if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123; if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) &#123; dirty.setEmpty(); &#125; &#125; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; //记录当前视图的mLeft和mTop值，在下一次循环中会把当前值再向父容器的坐标转化 location[CHILD_LEFT_INDEX] = left; location[CHILD_TOP_INDEX] = top; if (mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED; &#125; //返回当前视图的父容器 return mParent; &#125; ... &#125; return null;&#125; ViewRootImpl1234567891011121314@Overridepublic ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); ... invalidateRectOnScreen(dirty); return null;&#125;private void invalidateRectOnScreen(Rect dirty) &#123; ... if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123; scheduleTraversals(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940private boolean draw(boolean fullRedrawNeeded) &#123; // 1. 使用硬件加速渲染 // 2. 使用软件加速渲染&#125;/** * @return true if drawing was successful, false if an error occurred */ private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; canvas = mSurface.lockCanvas(dirty); // The dirty rectangle can be modified by Surface.lockCanvas() //noinspection ConstantConditions if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) &#123; attachInfo.mIgnoreDirtyState = true; &#125; // TODO: Do this in native canvas.setDensity(mDensity); &#125; catch &#123; ... &#125; // 伪代码 mView.mPrivateFlags |= View.PFLAG_DRAWN; mView.draw(canvas); return true; &#125; 这里只有软件绘制的代码。网上有人说invalidate只会重绘脏区域，但是这里只看到用dirty做了一个 canvas = mSurface.lockCanvas(dirty); 。还不是很懂局部重绘是怎么做到的。。。。","categories":[],"tags":[],"keywords":[]},{"title":"协程上下文和异常传播","slug":"Kotlin/协程上下文和异常传播","date":"2022-04-11T15:50:53.000Z","updated":"2022-04-11T16:56:12.838Z","comments":true,"path":"2022/04/11/Kotlin/协程上下文和异常传播/","link":"","permalink":"http://yoursite.com/2022/04/11/Kotlin/协程上下文和异常传播/","excerpt":"","text":"https://juejin.cn/post/7068901166456766472#heading-6","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/tags/Kotlin/"}],"keywords":[]},{"title":"jvm虚拟机","slug":"Java/jvm虚拟机","date":"2022-04-07T15:10:00.000Z","updated":"2022-08-28T10:33:40.789Z","comments":true,"path":"2022/04/07/Java/jvm虚拟机/","link":"","permalink":"http://yoursite.com/2022/04/07/Java/jvm虚拟机/","excerpt":"JVM架构jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈","text":"JVM架构jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈 方法区方法区被所有线程共享。存放 类信息、类的字段信息和方法信息、常量、static类变量 Java栈Java栈线程之间不共享。Java栈是由很多的栈帧(stack frame)或者说帧(frame)组成的，一个栈帧包含一个Java方法调用状态。用来存放方法的局部变量、被调用时传进来的参数、返回值 以及运算的中间结果等等。 Native栈用来存放Native方法的调用状态 堆用于存放对象。 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。 程序计数器（PC寄存器）每一个线程有一个程序计数器。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。 类加载子系统读取class文件，加载Java类到内存。 基于栈的jvm 和 基于寄存器的jvm在虚拟机栈的每一个栈帧中(即每一个方法调用中），存在一个「操作数栈」，用于存放运算的临时数据。基于栈 和 基于寄存器 的区别在于这个「操作数栈」 基于栈对于基于栈的jvm，这个「操作数栈」的区域当然是一个栈，方法体运行过程中生成的临时数据，会压入栈中，需要的时候再从栈中弹出。实现比较简单，只是单纯的压栈出栈对于每一条字节码指令，无需指定操作数地址，所以单个指令长度较短因为要频繁的压栈出栈，所以字节码指令会增加 基于寄存器对于基于寄存器的jvm，这个「操作数栈】的区域变成了多个虚拟寄存器，方法体运行过程中的临时数据会存放到这些寄存器中。避免了频繁的压栈出栈操作，所以字节码指令数量更少因为要明确指定操作数地址，所以字节码单个指令长度会翻倍 为什么 dalvik 和 art 要基于寄存器从上面的分析看，很明显，基于寄存器的jvm运行更快！ 类加载器类加载器负责动态加载Java类到Java虚拟机的内存空间中。 双亲委托机制“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类 路径中查找并装载目标类。这一点是从安全角度考虑的 GC垃圾回收机制如何判断对象是否可以被回收 引用计数法 根搜索算法： 从GC root出发查找引用链，无法触及到的对象可以被回收。 GC-root包括：虚拟机栈中引用的对象、类静态属性引用的对象、常量引用的对象 强引用、弱引用、软引用、虚引用GC算法jvm将对象分为三个区域， 新生代（Young Generation） 、 老年代（Old Generation） 和 持久代（Permanent Generation）。 持久代： 存放java类的类信息，存放静态文件，如final常量，static常量，常量池等。几乎不回收 新生代： 新生代使用拷贝算法：新生代中存在一个Eden区和两个Survivor区，其中一个Survivor始终为空。 eden区gc时，存活的对象会复制到其中一个survivor区。 Survivor区gc时，会拷贝到另一个空闲的Survivor区。 当对象多次gc存活一定次数之后，会移动到老年代 jvm中 eden区和Survivor区的大小为8：1 老年代： 使用标记整理算法。标记需要清除对象，将存活的对象往内存的一端移动，再将需要清除要回收的对象。这样的算法可以避免内存碎片的产生 大对象会一生成就会直接放到老年代。新生代容量较小，避免新生代频繁gc jar文件和dex文件的差异一个jar文件包含多个class文件，不同的class文件之间没有关联。 如果有相同的常量信息等数据，会产生冗余，增大文件大小。一个dex文件包括索引区和数据区，多个类共用一个索引区。这样相同的常量信息等可以避免重复冗余，可以大大减小文件大小。 同时，因为只有一个文件，也可以减少文件io的开销。 对象一定是在堆上的吗？不一定，取决于不同jvm的设计优化。 在虚拟机栈的调用中，jvm会对方法体力创建的对象做逃逸分析。 通过逃逸分析，可以分析出这个对象的引用是否只存在于方法体内部。如果发现某个对象并没有逃逸到方法体之外的话，就可能对其进行优化。不会将对象分配到堆上，可以减少gc的消耗。具体的方法是，把这个对象拆解成若干个其中包含的若干个局部变量来代替。这个过程就是标量替换","categories":[],"tags":[],"keywords":[]},{"title":"ConcurrentHashMap","slug":"Java/ConcurrentHashMap","date":"2022-04-04T08:36:53.000Z","updated":"2022-04-05T09:43:51.079Z","comments":true,"path":"2022/04/04/Java/ConcurrentHashMap/","link":"","permalink":"http://yoursite.com/2022/04/04/Java/ConcurrentHashMap/","excerpt":"ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。","text":"ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 1.8 之前将 table 数组划分为多个 segment ，对每一个 segment 单独加锁，不同的 segment 可以跨线程运算，提高并发效率。 每一个segment有一个单独的table数组，类似1.7版本的 hashmap，table数组遇到哈希冲突后，同hash值的元素使用的数据结构是链表。 读是不需要加锁的，因为 segment 的 table 数组加了 volatile 修饰，HashEntry 的val和next字段也用 volatile 修饰。 一个线程改变了值，另一个线程能马上发现。 put的时候需要加锁，当put时，所在的segment还没有创建，会懒加载创建segment。实例化segment之后，会通过cas插入到segment数组中，保证线程安全。 下面是 1.8之前 ConcurrentHashMap 的 Segment 的 put 流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; //尝试获取锁，获取成功，node为null，代码向下执行 //如果有其他线程占据锁对象，那么去做别的事情，而不是一直等待，提升效率 // tryLock 通过cas获取锁 //scanAndLockForPut 稍后分析 HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; //取hash的低位，计算HashEntry[]的索引 int index = (tab.length - 1) &amp; hash; //获取索引位的元素对象 HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; //获取的元素对象不为空 if (e != null) &#123; K k; //如果是重复元素，覆盖原值 if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; //如果不是重复元素，获取链表的下一个元素，继续循环遍历链表 e = e.next; &#125; else &#123; //如果获取到的元素为空 //当前添加的键值对的HashEntry对象已经创建 if (node != null) node.setNext(first); //头插法关联即可 else //创建当前添加的键值对的HashEntry对象 node = new HashEntry&lt;K,V&gt;(hash, key, value, first); //添加的元素数量递增 int c = count + 1; //判断是否需要扩容 if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) //需要扩容 rehash(node); else //不需要扩容 //将当前添加的元素对象，存入数组角标位，完成头插法添加元素 setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; //释放锁 unlock(); &#125; return oldValue;&#125;/* 四：Segment的scanAndLockForPut方法 * 该方法在线程没有获取到锁的情况下，去完成HashEntry对象的创建，提升效率*/private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123; //获取头部元素 HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; HashEntry&lt;K,V&gt; node = null； int retries = -1; // negative while locating node while (!tryLock()) &#123; //获取锁失败 HashEntry&lt;K,V&gt; f; // to recheck first below if (retries &lt; 0) &#123; //没有下一个节点，并且也不是重复元素，创建HashEntry对象，不再遍历 if (e == null) &#123; if (node == null) // speculatively create node node = new HashEntry&lt;K,V&gt;(hash, key, value, null); retries = 0; &#125; else if (key.equals(e.key)) //重复元素，不创建HashEntry对象，不再遍历 retries = 0; else //继续遍历下一个节点 e = e.next; &#125; else if (++retries &gt; MAX_SCAN_RETRIES) &#123; //如果尝试获取锁的次数过多，直接加锁 //MAX_SCAN_RETRIES会根据可用cpu核数来确定 lock(); break; &#125; else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) &#123; //如果期间有别的线程获取锁，重新遍历 e = first = f; // re-traverse if entry changed retries = -1; &#125; &#125; return node;&#125; 1.8 之后1.8之后ConcurrentHashMap改变了加锁策略，改为对哈希数组的每一个hash位置加锁；同时，将哈希冲突的链表替换为了和 HashMap 一样的红黑树。 sizeCtl 为0，默认状态，代表数组未初始化， 且数组的初始容量为16 为-1，表示数组正在进行初始化 为正数，其记录的是数组的扩容阈值 小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操 put时如何保证线程安全 在put时对table哈希数组的每一个hash位置，如果为该位置为null，cas判断，然后在改位置添加元素；如果该位置不为null，则对该hash位置进行Synchronize加锁，将新元素加载链表or红黑树上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879final V putVal(K key, V value, boolean onlyIfAbsent) &#123; //如果有空值或者空键，直接抛异常 if (key == null || value == null) throw new NullPointerException(); //基于key计算hash值，并进行一定的扰动 int hash = spread(key.hashCode()); //记录某个桶上元素的个数，如果超过8个，会转成红黑树 int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; //如果数组还未初始化，先对数组进行初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); //如果hash计算得到的桶位置没有元素，利用cas将元素添加 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; //cas+自旋（和外侧的for构成自旋循环），保证元素添加安全 //如果cas检测没过，下一次while循环就相当于在table的这个hash位置添加新元素 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; //如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; //hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加 V oldVal = null; //对当前桶进行加锁，保证线程安全，执行元素添加操作 synchronized (f) &#123; // 重复判断，方式加锁之前已经有其他线程做了修改 if (tabAt(tab, i) == f) &#123; //普通链表节点 if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; //树节点，将元素添加到红黑树中 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; //链表长度大于/等于8，将链表转成红黑树 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); //如果是重复键，直接将旧值返回 if (oldVal != null) return oldVal; break; &#125; &#125; &#125; //添加的是新元素，维护集合长度，并判断是否要进行扩容操作 addCount(1L, binCount); return null;&#125; 初始化hash数组 在初始化哈希数组的时候，会cas+自旋保证线程安全 1234567891011121314151617181920212223242526272829303132/* 初始化底层数组 */private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; //cas+自旋，保证线程安全，对数组进行初始化操作 while ((tab = table) == null || tab.length == 0) &#123; //如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin //cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋 else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; // 如果另一个线程已经初始化了数组，则不会走到这里。 会直接break //sizeCtl为0，取默认长度16，否则去sizeCtl的值 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\"unchecked\") //基于初始长度，构建数组对象 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; //计算扩容阈值，并赋值给sc sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; //将扩容阈值，赋值给sizeCtl sizeCtl = sc; &#125; break; &#125; &#125; return tab;&#125; 扩容ConcurrentHashMap 的扩容在transfer方法中；需要注意的是，ConcurrentHashMap 有一个多线程协助扩容的机制。 当一个线程在扩容的时候，在移动hash数组的元素到新数组的时候，会确定自己的开始位置 和 一个stride容量，hash数组stride内的元素自己负责扩容拷贝；然后确定一个 transferIndex 作为下次拷贝的起点。 同时在原数组的hash位置放置一个 ForwardingNode 。 当有新的线程想要在这个hash位置插入元素时，发现这里有一个 ForwardingNode ，会协助一起扩容，帮助将原数组的元素迁移到新数组。 以 transferIndex 作为起点，stride容量内的元素自己负责协助拷贝 对于线程安全，在扩容拷贝的时候，会对hash数组要拷贝的位置进行 synchronized 加锁。在计算 transferIndex 的会使用 cas+自旋 机制保证线程安全。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; //如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range //如果是扩容线程，此时新数组为null //如果是帮助扩容的线程，此时nextTab不为null if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings(\"unchecked\") //两倍扩容创建新数组 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; //记录线程开始迁移的桶位，从后往前迁移，指向最右边 transferIndex = n; &#125; //记录新数组的末尾 int nextn = nextTab.length; //已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED） ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; // advance：代表是否可以继续推进下一个槽位，只有当前槽位数据被迁移完成之后才可以设置为 true while (advance) &#123; int nextIndex, nextBound; //i记录当前正在迁移桶位的索引值 //bound记录下一次任务迁移的开始桶位 //--i &gt;= bound 成立表示当前线程分配的迁移任务还没有完成 if (--i &gt;= bound || finishing) advance = false; //没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成 else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; //计算下一次任务迁移的开始桶位，并将这个值赋值给transferIndex else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; //如果没有更多的需要迁移的桶位，就进入该if if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; //扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl if (finishing) &#123; nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; //扩容任务线程数减1 if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; //判断当前所有扩容任务线程是否都执行完成 if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; //所有扩容线程都执行完，标识结束 finishing = advance = true; i = n; // recheck before commit &#125; &#125; //当前迁移的桶位没有元素，直接在该位置添加一个fwd节点 else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); //当前节点已经被迁移 else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; //当前节点需要迁移，加锁迁移，保证多线程安全 //此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; ... // 省略代码，和 HashMap 的扩容拷贝基本一致 advance = true; &#125; &#125; &#125; &#125;&#125; 参考https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap","categories":[],"tags":[],"keywords":[]},{"title":"HashMap","slug":"Java/HashMap","date":"2022-04-04T06:23:14.000Z","updated":"2022-04-04T08:39:37.579Z","comments":true,"path":"2022/04/04/Java/HashMap/","link":"","permalink":"http://yoursite.com/2022/04/04/Java/HashMap/","excerpt":"1. 基本数据结构Node&lt;K, V&gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树","text":"1. 基本数据结构Node&lt;K, V&gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树 2. 加入的元素如何确定在数组中的 index123static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 要把新加入的元素均匀分布到数组中，我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的. 但是jdk通过h &amp; (table.length -1)来得到该对象的保存位，这样运算会加快。 3. 如何扩容将数组的容量扩大为原来的两倍，原数组长度为oldCap，下标j的元素会被分散到 数组j 和 j+oldCap 的位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];table = newTab;if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) // 数组下表位置如果是 红黑树，逻辑和下面的链表差不多 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order // 数组下表位置如果是 链表 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 因为 oldCap 始终为2的倍数。 (e.hash &amp; oldCap) 只会有0或1两个值，由此决定是位置 j 还是 j+oldCap if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; 4. 扩容的时机12if (++size &gt; threshold) resize(); 当size大于一个阈值的时候，就会开始扩容。 threshold = length * loadFactor 是数组长度*负载因子。 负载因子默认是0.75 ，注意这个length是table数组的长度而不是HashMap的整体size（为了保证获取元素的时间复杂度接近1）。 loadFactor 是时间复杂度和空间复杂度的权衡。 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 5. HashMap是线程不安全的。HashTable是线程安全的。HashTable的线程安全很粗暴，将所有的map操作加一个synchronized修饰。 参考：https://tech.meituan.com/2016/06/24/java-hashmap.html","categories":[],"tags":[],"keywords":[]},{"title":"transform和asm初探","slug":"Android/gradle/transform和asm初探","date":"2022-03-21T13:54:26.000Z","updated":"2022-05-04T08:50:41.638Z","comments":true,"path":"2022/03/21/Android/gradle/transform和asm初探/","link":"","permalink":"http://yoursite.com/2022/03/21/Android/gradle/transform和asm初探/","excerpt":"自定义RouterTransformTransform 是AGP官方提供的接口，在 class-&gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类","text":"自定义RouterTransformTransform 是AGP官方提供的接口，在 class-&gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类 添加依赖因为是安卓官方提供的能力，需要在 buildSrc 的 build.gradle 中 添加 google() 仓库和安卓构建工具的依赖 12345678910111213repositories &#123; jcenter() google() mavenCentral()&#125;dependencies &#123; implementation gradleApi() implementation localGroovy() implementation \"com.android.tools.build:gradle:3.5.3\"&#125; 编写 RouterTranform123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class RouterTransform extends Transform &#123; @Override String getName() &#123; return \"RouterMappingTransform\" &#125; /** * 需要插桩的输入类型， 这里是类文件 * @return */ @Override Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; return TransformManager.CONTENT_CLASS &#125; /** * 需要插桩的范围, 这里是整个工程 * @return */ @Override Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123; return TransformManager.SCOPE_FULL_PROJECT &#125; /** * 是否支持增量 * @return */ @Override boolean isIncremental() &#123; return false &#125; /** * 实现 * @param transformInvocation * @throws TransformException * @throws InterruptedException * @throws IOException */ @Override void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123; super.transform(transformInvocation) println(\"transform start\") def collector = new RouterMappingCollector() // 遍历所有的输入 transformInvocation.inputs.each &#123; // 把 文件夹 类型的输入，拷贝到目标目录 it.directoryInputs.each &#123; directoryInput -&gt; def destDir = transformInvocation.outputProvider .getContentLocation( directoryInput.name, directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY) collector.collect(directoryInput.file) FileUtils.copyDirectory(directoryInput.file, destDir) &#125; // 把 JAR 类型的输入，拷贝到目标目录 it.jarInputs.each &#123; jarInput -&gt; def dest = transformInvocation.outputProvider .getContentLocation( jarInput.name, jarInput.contentTypes, jarInput.scopes, Format.JAR) collector.collectFromJarFile(jarInput.file) println(\"transform jar input path $&#123;jarInput.file.absolutePath&#125;\") println(\"transform jar output path $&#123;dest.absolutePath&#125;\") FileUtils.copyFile(jarInput.file, dest) &#125; &#125; File mappingJarFile = transformInvocation.outputProvider. getContentLocation( \"router_mapping\", getOutputTypes(), getScopes(), Format.JAR) println(\"$&#123;getName()&#125; mappingJarFile = $mappingJarFile\") if (mappingJarFile.getParentFile().exists()) &#123; mappingJarFile.getParentFile().mkdirs() &#125; if (mappingJarFile.exists()) &#123; mappingJarFile.delete() &#125; // 将生成的字节码，写入本地文件 FileOutputStream fos = new FileOutputStream(mappingJarFile) JarOutputStream jarOutputStream = new JarOutputStream(fos) // CLASS_NAME = \"com/imooc/router/mapping/generated/RouterMapping\" ZipEntry zipEntry = new ZipEntry(RouterMappingByteCodeBuilder.CLASS_NAME + \".class\") jarOutputStream.putNextEntry(zipEntry) println(\"transform collect class $&#123;collector.mappingClassName&#125;\") jarOutputStream.write( // 写入字节码 RouterMappingByteCodeBuilder.get(collector.mappingClassName) ) jarOutputStream.closeEntry() jarOutputStream.close() fos.close() println(\"transform end\") &#125;&#125; transformInvocation.inputs.each {表示遍历所有输入 it.directoryInputs.each { directoryInput -&gt;表示遍历所有目录文件输入，directoryInput 是class文件的目录 it.jarInputs.each { jarInput -&gt;遍历所有jar包输入， jarInput 是jar包 transformInvocation.outputProvider.getContentLocation(获取具体的输入 collector.collect(directoryInput.file)这里是一个自定义逻辑，表示从 class文件 或 jar包 中找到生成的 RouterMapping 路由映射类。 FileUtils.copyFile(jarInput.file, dest)拷贝文件到目标目录， 最终transform执行之后会在 /…项目目录/app/build/intermediates/transforms 中生成一个RouterMappingTransform目录。 需要吧class文件和jar包都拷贝过去。有意思是，我原本以为我们工程自己的代码应该都是 class文件，都在 it.directoryInputs.each { directoryInput -&gt; 这个输入里。 但是后来发现，只有 app工程是 class 文件，子工程打包成了 jar 包，和其他第三方库放在了一起 后面的代码都是动态生成了一个集合了所有子工程路由注册的路由类，使用asm写入了字节码 即使我们没有对文件做任何处理，我们仍然需要把输入文件拷贝到目标目录下，否则下一个Task就没有TansformInput，如果我们没有将input目录复制到output指定目录，会导致最后的打包的apk缺少class 注册transform123456789101112131415class RouterPlugin2 implements Plugin&lt;Project&gt; &#123; String TAG = \"RouterPlugin2\" @Override void apply(Project project) &#123; if (project.plugins.hasPlugin(AppPlugin)) &#123; // hasPlugin(AppPlugin) 表示这是 app 主工程 // 注册进我们的 RouterTransform def extension = project.extensions.getByType(AppExtension) extension.registerTransform(new RouterTransform()) &#125; &#125;&#125; 插件也是需要注册的。。。在resource目录的方式注册。 不写了，网上搜一下吧。 使用我们的 Router使用反射实例化我们的类即可123456789101112131415161718try &#123; // GENERATED_MAPPING = \"com.imooc.router.mapping.generated.RouterMapping\" // 注意上面原来文件\"/\"的分割要变成\".\" val clazz = Class.forName(GENERATED_MAPPING) val method = clazz.getMethod(\"get\") val allMapping = method.invoke(null) as Map&lt;String, String&gt; if (allMapping?.size &gt; 0) &#123; Log.i(TAG, \"init: get all mapping:\") allMapping.onEach &#123; Log.i(TAG, \" $&#123;it.key&#125; -&gt; $&#123;it.value&#125;\") &#125; mapping.putAll(allMapping) &#125;&#125; catch (e: Throwable) &#123; Log.e(TAG, \"init: error while init router : $e\")&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://yoursite.com/tags/Gradle/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"自定义gradle插件","slug":"Android/gradle/自定义gradle插件","date":"2022-03-19T09:52:18.000Z","updated":"2022-05-04T08:53:22.297Z","comments":true,"path":"2022/03/19/Android/gradle/自定义gradle插件/","link":"","permalink":"http://yoursite.com/2022/03/19/Android/gradle/自定义gradle插件/","excerpt":"这里只记录本地插件的写法创建 buildSrc 目录","text":"这里只记录本地插件的写法创建 buildSrc 目录 在创建的 buildScr 目录中创建 build.gradle 文件 1234567891011121314151617apply plugin: \"groovy\"repositories &#123; jcenter() google() mavenCentral()&#125;dependencies &#123; implementation gradleApi() implementation localGroovy()&#125;// 设置源码兼容性targetCompatibility = JavaVersion.VERSION_1_8sourceCompatibility = JavaVersion.VERSION_1_8 上面是固定写法，这里只使用了 groovy 插件，所以我们的插件代码只支持用 groovy 编写 在 buildSrc 目录中，创建对应的 groovy 目录文件路径是src/main/groovy/…(包名)/ 创建 自定义的插件 RouterPlugin2 创建文件名 RouterPlugin2.Plugin创建插件类，并实现 Plugin 接口 12345678910class RouterPlugin2 implements Plugin&lt;Project&gt; &#123; String TAG = \"RouterPlugin2\" @Override void apply(Project project) &#123; ... &#125;&#125; 创建 res 文件暴露自己的 groovy创建文件路径：src/main/resources/META-INF.gradle-plugins/RouterPlugin.properties 内容如下1implementation-class=com.example.test.RouterPlugin2 创建的文件名 META-INF.gradle-plugins 是固定目录名，xxxx.properties 中的xxxx就是对外暴露的插件的名字。 properties文件的内容表示插件的实现类 外部使用插件 导入插件 在业务的module的 build.gradle 文件中 1apply plugin: \"RouterPlugin2\" 向插件写入参数 在 buildSrc module 中创建一个 groovy 类，代表参数的model类 123class RouterExtension2 &#123; String wiki;&#125; 插件类读取参数 12def extension = project.extensions.create(\"router\", RouterExtension2)def path = extension.wiki 在业务调用方传入参数 12345apply plugin: \"RouterPlugin2\"router &#123; wiki \"$&#123;getRootDir().absolutePath&#125;/router_wiki.md\"&#125; RouterPlugin2 的详细实现插件中要实现三个功能 在使用路由注解处理器的module，都向注解处理器插入一个参数，代表路由文件生成的路径。 在项目clean时清除掉注解中间文件 将所有module生成的注解中间文件，汇总生成一个路由wiki文档 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.example.testimport org.gradle.api.Pluginimport org.gradle.api.Projectclass RouterPlugin2 implements Plugin&lt;Project&gt; &#123; String TAG = \"RouterPlugin2\" @Override void apply(Project project) &#123; println(\"$TAG apply kotlin\") def routerFileDir = new File(project.getRootDir(), \"router_mapping\") /** * kapt &#123; * rguments &#123; * arg(\"router_mapping\", rootProject.rootProjectDir.absolutePath） * &#125; * &#125; **/ // 1. 自动帮助用户传递路径参数到注解处理器中 start // 以下代码可以替代以上的 build.gradle 配置 if (project.extensions.findByName(\"kapt\") != null) &#123; project.extensions.findByName(\"kapt\").arguments &#123; arg(\"router_file_dir\", routerFileDir) arg(\"project_name\", project.name) &#125; &#125; // 1. 自动帮助用户传递路径参数到注解处理器中 end // 2. 在clean时自动清理旧的构建产物 project.clean.doFirst &#123; def routerMappingFile = routerFileDir if (routerMappingFile.exists()) &#123; routerMappingFile.deleteDir() &#125; &#125; // 3. 集合各个子project路由信息，生成路由文档 def extension = project.extensions.create(\"router\", RouterExtension2) project.afterEvaluate &#123; // 在工程完成配置阶段之后才能获取到 外部配置的参数 def wikiPath = extension.wiki project.tasks.findAll &#123; task -&gt; // 找到编译的task，compileDebugJavaWithJavac task.name.startsWith(\"compile\") &amp;&amp; task.name.endsWith(\"JavaWithJavac\") &#125;.each &#123;task -&gt; task.doLast &#123; def wikiFile = new File(wikiPath) if (!wikiFile.exists()) &#123; wikiFile.createNewFile() &#125; def jsonFiles = routerFileDir jsonFiles.eachFile &#123;file -&gt; def content = file.readBytes() wikiFile.append(new String(content)) &#125; // write jsonFile content into wikiPath &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://yoursite.com/tags/Gradle/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"自定义注解处理器并发布为gradle组件","slug":"Android/gradle/自定义注解处理器并发布为gradle组件","date":"2022-03-13T07:27:24.000Z","updated":"2022-03-13T09:10:55.158Z","comments":true,"path":"2022/03/13/Android/gradle/自定义注解处理器并发布为gradle组件/","link":"","permalink":"http://yoursite.com/2022/03/13/Android/gradle/自定义注解处理器并发布为gradle组件/","excerpt":"自定义一个基于注解的路由框架定义注解类 新建一个模块 router_annotations 在 router_annotations 目录中创建 build.gradle","text":"自定义一个基于注解的路由框架定义注解类 新建一个模块 router_annotations 在 router_annotations 目录中创建 build.gradle 1234567apply plugin: \"kotlin\" // 使用 kotlintargetCompatibility = JavaVersion.VERSION_1_8sourceCompatibility = JavaVersion.VERSION_1_8// 应用 发布脚本，后面会写apply from : rootProject.file(\"maven-publish.gradle\") 定义注解类 123456789package com.example.test// 设置使用注解的对象是 类@Target(AnnotationTarget.CLASS)// 设置注解只在编译期存在@Retention(AnnotationRetention.BINARY)annotation class Destination( val url: String) 定义注解处理器模块 新建一个模块 router_compile 在 router_compile 目录中创建 build.gradle 1234567891011121314151617apply plugin: \"kotlin\" // 使用kotlin插件apply plugin: \"kotlin-kapt\" // 使用kotlin注解// 设置源码兼容性targetCompatibility = JavaVersion.VERSION_1_8sourceCompatibility = JavaVersion.VERSION_1_8dependencies &#123; implementation project(\":router_annotations\") implementation \"com.google.auto.service:auto-service:1.0-rc6\" kapt \"com.google.auto.service:auto-service:1.0-rc6\"&#125;// 应用 发布脚本。后面会写apply from : rootProject.file(\"maven-publish.gradle\") 在注解处理器模块，如果使用kotlin写注解处理器代码，需要引用 kotlin-kapt 这个插件implementation &quot;com.google.auto.service:auto-service:1.0-rc6&quot; 使用google的一个注解框架。同时还要加上 kapt &quot;com.google.auto.service:auto-service:1.0-rc6&quot; 。 这是kotlin的写法，如果是java，需要换成annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39; 编写注解处理器12345678910111213141516171819202122232425262728293031323334353637383940414243@AutoService(Processor::class)class DestinationProcessor : AbstractProcessor() &#123; private val TAG = \"DestinationProcessor\" override fun process( set: MutableSet&lt;out TypeElement&gt;, roundEnvironment: RoundEnvironment ): Boolean &#123; if (roundEnvironment.processingOver()) &#123; return false &#125; println(\"$TAG &gt;&gt;&gt;&gt; process start\") println(set) val destinationClasses = roundEnvironment.getElementsAnnotatedWith(Destination::class.java) println(TAG + \" \" + destinationClasses.size) if (destinationClasses.size &lt; 1) &#123; return false &#125; for (element in destinationClasses) &#123; val typeElement = element as TypeElement val destination = typeElement.getAnnotation(Destination::class.java) ?: continue val url = destination.url val className = typeElement.qualifiedName println(\"$TAG $url $className\") &#125; println(\"$TAG &gt;&gt;&gt;&gt; process finish\") return true &#125; override fun getSupportedAnnotationTypes(): MutableSet&lt;String&gt; &#123; return mutableSetOf( Destination::class.java.canonicalName ) &#125;&#125; @AutoService(Processor::class) 是固定写法 AbstractProcessor 继承这个抽象类。重写getSupportedAnnotationTypes方法，返回需要处理的注解。重写process方法，处理注解信息。 返回值为true表示已处理这个注解，相同的注解不会再被其他注解处理器处理。roundEnvironment.processingOver()表示之前已经有处理过一轮，此时roundEnvironment.elements.size==0 不是很明白gradle为什么会执行多轮。。。 在本地使用注解12implementation project(\":router_annotations\")kapt project(\":router_compile\") 将注解处理器打包成组件并发布 在最外层的 build.properties 中写通用参数 123POM_URL=../repo // 发布的仓库地址，这里是本地GROUP_ID=com.example.test // groupVERSION_NAME=1.0.0 // 版本 在 router_annotation 和 router_compile 中写 group_id 12345// 在 router_annotation build.propertiesPOM_ARTIFACT_ID=router-test-annotation// 在 router_compile build.propertiesPOM_ARTIFACT_ID=router-test-processor 编写发布脚本 maven-publish.gradle 1234567891011121314151617181920212223242526272829303132333435363738394041apply plugin: 'maven' // 引入maven插件// 从根目录的 gradle.properties 中获取通用参数 startdef rootProperties = new Properties()rootProperties.load(new FileInputStream(project.rootProject.file(\"gradle.properties\")))def versionName = rootProperties.getProperty(\"VERSION_NAME\")def pomUrl = rootProperties.getProperty(\"POM_URL\") // ../repodef groupId = rootProperties.getProperty(\"GROUP_ID\")// 获取通用参数 end// 从当前项目的 gradle.properties 中获取参数def projectProperties = new Properties()projectProperties.load(new FileInputStream(project.file(\"gradle.properties\")))def pomArtifactId = projectProperties.getProperty(\"POM_ARTIFACT_ID\")println(\"maven-publish $versionName $pomUrl $groupId $pomArtifactId\")// 编写maven的发布任务uploadArchives &#123; repositories &#123; mavenDeployer &#123; repository(url: uri(pomUrl)) &#123; pom.groupId = groupId pom.artifactId = pomArtifactId pom.version = versionName &#125; pom.whenConfigured &#123; pom -&gt; pom.dependencies.forEach &#123; dep -&gt; if (dep.getVersion() == \"unspecified\") &#123; dep.setGroupId(groupId) dep.setVersion(versionName) &#125; &#125; &#125; &#125; &#125;&#125; 注意有一个 pom.whenConfigured { pom -&gt; ... 的代码，这是因为 router_compile 应用到了 router_annotations 模块。如果不做处理，发布之后， router_comiple 模块是找不到 router_annotations 的正确位置和版本的。所以要强制制定 执行发布任务12./gradlew :router_compile:uploadArchives./gradlew :router_annotations:uploadArchives 我们设置的 POM_URL=../repo 所以最终会在项目的repo目录里生成aar包。 使用发布后的组件 首先，moven本地仓库地址加入到工程里123456789101112131415buildscript &#123; repositories &#123; maven &#123; url uri('/Users/bytedance/code/test/repo') &#125; google() mavenCentral() &#125;&#125;allprojects &#123; repositories &#123; maven &#123; url uri('/Users/bytedance/code/test/repo') &#125; google() mavenCentral() &#125;&#125; buildscript.repositories 和 allprojects.repositories 都要加，这样才会应用到所有子工程 在app模块里引用组件 12implementation \"com.example.test:router-test-annotation:1.0.0\"kapt \"com.example.test:router-test-processor:1.0.0\" gradle版本的区别 在 gradle 7.+ 版本有很多东西不兼容，上述实现只有在 gradle 6.+ 的版本有效。 gradle 的版本升级和项目创建还是要谨慎一些。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://yoursite.com/tags/Gradle/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"MultiDex原理","slug":"Android/Framework/MultiDex原理","date":"2021-12-25T10:20:52.000Z","updated":"2021-12-25T11:04:06.178Z","comments":true,"path":"2021/12/25/Android/Framework/MultiDex原理/","link":"","permalink":"http://yoursite.com/2021/12/25/Android/Framework/MultiDex原理/","excerpt":"apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.为了规避安卓项目编译65536最大方法数的限制，需要做分dex","text":"apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.为了规避安卓项目编译65536最大方法数的限制，需要做分dex 1. Dalvik 和 ART 虚拟机的区别Android5.0以上系统使用 ART 虚拟机，5.0以下使用 Dalvik 虚拟机 Dalvik 编译策略是 JIT 技术。JIT意思是Just In Time Compiler，就是即时编译技术。JIT是运行时编译，是动态编译，可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间可以加快Dalvik运行速度。每次运行都需要重新编译。 AOT是指”Ahead Of Time”，与”Just In Time”不同，从字面来看是说提前编译。AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex预编译，一次性将所有dex代码转换为机器码，每次运行程序的时候不用重新编译。 Android 7.0上，JIT 编译器被再次使用，采用AOT/JIT 混合编译的策略，特点是： 应用在安装的时候dex不会再被编译App运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息。手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译 2. 不同虚拟机在 MultiDex 的区别。 Andorid 5.0 之后，ART天然支持从apk文件中加载多个.dex文件，在应用安装期间，它会执行一个预编译操作。将所有的dex编译成一个单一的.oat文件，在应用运行是去加载这个.oat文件，而不是一个一个的加载.dex文件。所以我们只需要 在 gradle 开启 multiDexEnabled true 即可 Dalvik 使用的 JIT ，JIT每次运行都需要重新编译。 所以我们需要在应用启动时手动去一个一个加载 dex 文件 3. 在 Dalvik 加载多dex简单来说 hook PathClassLoader 。 获取到所有的dex文件 通过反射拿到DexPathList的Element数组，把dex添加到 Element数组中 通过这样的方式也可以实现热热修复，将修改后的新class打包成一个dex， 然后通过反射将 新dex插入到 PathClassLoader 中的 element数组最前面。从而实现对旧类的覆盖","categories":[],"tags":[],"keywords":[]},{"title":"技术Owner的职责","slug":"技术Owner的职责","date":"2021-11-27T07:58:24.000Z","updated":"2021-11-27T08:09:40.100Z","comments":true,"path":"2021/11/27/技术Owner的职责/","link":"","permalink":"http://yoursite.com/2021/11/27/技术Owner的职责/","excerpt":"","text":"参与需求评审，完成可行性调研，完善细节。 要督促完成UI/UE评审，埋点评审 技术评审，输出技术方案，拆分需求子任务，给出详细排期 开始开发，定期站会，同步风险 发生变更，更改排期 需求提测前，推进case评审 自测","categories":[],"tags":[],"keywords":[]},{"title":"Binder源码笔记","slug":"Android/Framework/Binder源码笔记","date":"2021-11-03T13:42:37.000Z","updated":"2022-09-04T11:07:35.331Z","comments":true,"path":"2021/11/03/Android/Framework/Binder源码笔记/","link":"","permalink":"http://yoursite.com/2021/11/03/Android/Framework/Binder源码笔记/","excerpt":"ProcessStateProcessState 是一个系统 Service 进程的单例，一个进程只有一个 ProcessState 实例。 zygote 在fork出应用进程之后会在c层完成初始化启动 binder","text":"ProcessStateProcessState 是一个系统 Service 进程的单例，一个进程只有一个 ProcessState 实例。 zygote 在fork出应用进程之后会在c层完成初始化启动 binder 内部会打开设备 “/dev/binder”（binder驱动）；调用 mmap 函数，完成自己和内核空间的内存映射，分配缓冲区；启动binder线程，不断循环和binder驱动交互 ioctl 和 Binder 设备传递参数，设置了 binder 线程池的最大线程数 Binder线程池调用 ProcessState::startThreadPool() 启动 Binder 线程池。 调用之后，实际上就已经 run 了一个 Binder 主线程, 并开始 while 死循环接收 Binder 消息。之后会根据情况，选择在 Binder 线程池中创建新的线程，但是创建出来的就不是一个死循环的线程了 通信BpBinder 和 BBinderIBinder 对象是负责binder通信的实例。 BpBinder 是客户端和服务端交互的代理类，BBinder 代表服务端在BpBinder类的内部有一个成员变量mHandle，它是一个int型变量。对于每一个经过binder driver传输的BBinder对象，binder driver都会在驱动层为它构建一个binder_node数据结构；同时为这个binder_node生成一个“引用”：binder_refBpBinder的成员变量mHandle的值就是bidner_ref中的int型描述符，这样就建立起了用户层的Bpbinder和一个驱动空间的binder_ref数据结构的对应关系。通过 “BpBinder handle→binder_ref→binder_node→BBinder”这样的匹配关系，就可以建立一个Bpbinder对应一个BBinder的关系。 BpBinder::transact发送数据的方法 IPCThreadState::self()-&gt;transact(…)真正数据通信的方法。 一个线程只会有一个实例， 使用 pthread_setspecific 实现，类似于 java 的 ThreadLocalIPCThreadState 有两个缓存 mIn 和 mOut 分别负责数据的接收和发射 12345678-&gt; transact(..) -&gt; writeTransactionData(..) -&gt; 将 cmd 和 data 写入到 mOut 中 -&gt; waitForResponse(..) -&gt; talkWithDriver(doReceive) -&gt; 将 bwr(一个和Binder驱动的结构体) bwr.write_buffer 指向 mOut.data() -&gt; 将 bwr.read_buffer 指向 mIn.data() -&gt; do-while 循环，调用 ioctl 函数 和 Binder 驱动通信，直到结束 问题：1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的应用 Service 是发布到 AMS 上的，客户端从 AMS 上去查找 Service 的 Binder 对象","categories":[],"tags":[],"keywords":[]},{"title":"InputManagerService","slug":"Android/Framework/InputManagerService","date":"2021-10-18T13:31:03.000Z","updated":"2021-10-18T14:01:44.909Z","comments":true,"path":"2021/10/18/Android/Framework/InputManagerService/","link":"","permalink":"http://yoursite.com/2021/10/18/Android/Framework/InputManagerService/","excerpt":"native层概述InputReader输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。","text":"native层概述InputReader输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。 InputReader 持有 InputMapper 对应不同的输入设备的 事件加工器。 事件加工后，InputReader 会 调用 InputDispatcher.notifyXXX 函数 唤醒 InputDispatcher 进行事件分发 InputDispatcher输入事件的分发者。 分发输入事件到目标窗口。 运行在 InputDispatcherThread 中， 这个线程平时是休眠状态，等待 InputReader 的唤醒 被唤醒后，调用 dispatchOnceInnerLocked 将输入事件分发到合适的窗口中","categories":[],"tags":[],"keywords":[]},{"title":"kotlin-flow","slug":"Kotlin/kotlin-flow","date":"2021-10-04T06:58:00.000Z","updated":"2022-04-11T06:46:20.728Z","comments":true,"path":"2021/10/04/Kotlin/kotlin-flow/","link":"","permalink":"http://yoursite.com/2021/10/04/Kotlin/kotlin-flow/","excerpt":"基础的流demo12345678910111213141516171819202122import kotlinx.coroutines.*import kotlinx.coroutines.flow.* fun simple(): Flow&lt;Int&gt; = flow &#123; // 流构建器 for (i in 1..3) &#123; delay(100) // 假装我们在这里做了一些有用的事情 emit(i) // 发送下一个值 &#125;&#125;fun main() = runBlocking&lt;Unit&gt; &#123; // 启动并发的协程以验证主线程并未阻塞 launch &#123; for (k in 1..3) &#123; println(\"I'm not blocked $k\") delay(100) &#125; &#125; // 收集这个流 simple().collect &#123; value -&gt; println(value) &#125; &#125;","text":"基础的流demo12345678910111213141516171819202122import kotlinx.coroutines.*import kotlinx.coroutines.flow.* fun simple(): Flow&lt;Int&gt; = flow &#123; // 流构建器 for (i in 1..3) &#123; delay(100) // 假装我们在这里做了一些有用的事情 emit(i) // 发送下一个值 &#125;&#125;fun main() = runBlocking&lt;Unit&gt; &#123; // 启动并发的协程以验证主线程并未阻塞 launch &#123; for (k in 1..3) &#123; println(\"I'm not blocked $k\") delay(100) &#125; &#125; // 收集这个流 simple().collect &#123; value -&gt; println(value) &#125; &#125; flow 是 ”冷流“ 冷流的定义： flow 构建器中的代码直到流被调用 collect 的时候才运行。 1234567891011public fun &lt;T&gt; flow(@BuilderInference block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit): Flow&lt;T&gt; = SafeFlow(block)private class SafeFlow&lt;T&gt;(private val block: suspend FlowCollector&lt;T&gt;.() -&gt; Unit) : AbstractFlow&lt;T&gt;() &#123; override suspend fun collectSafely(collector: FlowCollector&lt;T&gt;) &#123; collector.block() &#125;&#125;public interface FlowCollector&lt;in T&gt; &#123; public suspend fun emit(value: T)&#125; flow 的实现如上，只不过是传入了 代码块作为 FlowCollector 的拓展函数。当 流开始收集 （调用collect），会执行这个 flow 的代码块。在 collect 中传入的代码块， 实际上是一个 FlowCollector 匿名对象，当 flow 的代码块调用 emit 的时候，就直接调用了 collect 后的代码块。 用一个例子体现这一点： 1234567891011121314151617fun simple(): Flow&lt;Int&gt; = flow &#123; for (i in 1..1) &#123; log(\"Emit start $i\") delay(100) // 假装我们异步等待了 100 毫秒 emit(i) // 发射下一个值 log(\"Emit end $i\") &#125;&#125;fun main() = runBlocking&lt;Unit&gt; &#123; simple() .collect &#123; value -&gt; log(\"Collected start $value\") delay(300) log(\"Collected end $value\") &#125;&#125; 最终输出： 1234[main] Emit start 1[main] Collected start 1[main] Collected end 1[main] Emit end 1 流的上下文保存 上下文保存： flow { … } 构建器中的代码运行在相应流的收集器提供的上下文中 123456789101112131415import kotlinx.coroutines.*import kotlinx.coroutines.flow.*fun log(msg: String) = println(\"[$&#123;Thread.currentThread().name&#125;] $msg\") fun simple(): Flow&lt;Int&gt; = flow &#123; log(\"Started simple flow\") for (i in 1..3) &#123; emit(i) &#125;&#125; fun main() = runBlocking&lt;Unit&gt; &#123; simple().collect &#123; value -&gt; log(\"Collected $value\") &#125; &#125; 1234[main @coroutine#1] Started simple flow[main @coroutine#1] Collected 1[main @coroutine#1] Collected 2[main @coroutine#1] Collected 3 由于 simple().collect 是在主线程调用的，那么 simple 的流主体也是在主线程调用的。如果在 调用emit时切换协程上下文，会直接抛出异常 flowOn: 正确的切换 flow 的上下文 123456789101112131415161718import kotlinx.coroutines.*import kotlinx.coroutines.flow.*fun log(msg: String) = println(\"[$&#123;Thread.currentThread().name&#125;] $msg\") fun simple(): Flow&lt;Int&gt; = flow &#123; for (i in 1..3) &#123; Thread.sleep(100) // 假装我们以消耗 CPU 的方式进行计算 log(\"Emitting $i\") emit(i) // 发射下一个值 &#125;&#125;.flowOn(Dispatchers.Default) // 在流构建器中改变协程上下文的正确方式fun main() = runBlocking&lt;Unit&gt; &#123; simple().collect &#123; value -&gt; log(\"Collected $value\") &#125; &#125; 解决 背压问题名词解释：背压： 假设有一个快的数据生产者和一个慢的数据消费者，背压就是一种 “倒逼 “生产者而使自己不被数据淹没的机制 buffer并发运行这个 流中发射元素的代码以及收集的代码， 而不是顺序运行它们； buffer() 会给切换 flow 的协程，保证 发送端 是不阻塞的 。 可以设置 buffer 容量和策略 123456789101112131415161718fun simple(): Flow&lt;Int&gt; = flow &#123; for (i in 1..3) &#123; delay(100) // 假装我们异步等待了 100 毫秒 emit(i) // 发射下一个值 &#125;&#125;fun main() = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; simple() .buffer() // 缓冲发射项，无需等待 .collect &#123; value -&gt; delay(300) // 假装我们花费 300 毫秒来处理它 println(value) &#125; &#125; println(\"Collected in $time ms\")&#125; conflate一种特殊 buffer 策略 新数据会覆盖老数据 collectLatest它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。 12345678910111213141516171819202122import kotlinx.coroutines.*import kotlinx.coroutines.flow.*import kotlin.system.*fun simple(): Flow&lt;Int&gt; = flow &#123; for (i in 1..3) &#123; delay(100) // 假装我们异步等待了 100 毫秒 emit(i) // 发射下一个值 &#125;&#125;fun main() = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; simple() .collectLatest &#123; value -&gt; // 取消并重新发射最后一个值 println(\"Collecting $value\") delay(300) // 假装我们花费 300 毫秒来处理它 println(\"Done $value\") &#125; &#125; println(\"Collected in $time ms\")&#125; 12345Collecting 1Collecting 2Collecting 3Done 3Collected in 741 ms StateFlowdemo12345678910111213141516171819202122232425 val flow = MutableStateFlow(2) private suspend fun produce() &#123; for (i in 0..5) &#123; val success = flow.tryEmit(i) println(\"tryEmit $i $success\")// delay(200) &#125; &#125; @JvmStatic fun main(args: Array&lt;String&gt;): Unit = runBlocking &#123; launch(Dispatchers.IO) &#123; delay(1000) produce() &#125; launch(Dispatchers.IO)&#123; flow.onEach &#123; println(\"receive-1 $it\") delay(500) &#125;.launchIn(this) &#125; &#125; StateFlow 是一个 “流”不同于普通的 flow ， StateFlow 是一个热数据流。 不需要主动调动 collect{…} , 就能 emit 数据 StateFlow 的 collect 是阻塞的，需要在单独的协程中运行在demo中调用了 launchIn ，而不是直接 collect 。 看一下源码 12345678910111213141516171819202122232425// StateFlow private val _state = atomic(initialState) override suspend fun collect(collector: FlowCollector&lt;T&gt;) &#123; val slot = allocateSlot() try &#123; if (collector is SubscribedFlowCollector) collector.onSubscription() val collectorJob = currentCoroutineContext()[Job] var oldState: Any? = null while (true) &#123; val newState = _state.value collectorJob?.ensureActive() if (oldState == null || oldState != newState) &#123; collector.emit(NULL.unbox(newState)) oldState = newState &#125; if (!slot.takePending()) &#123; // try fast-path without suspending first slot.awaitPending() // only suspend for new values when needed &#125; &#125; &#125; finally &#123; freeSlot(slot) &#125; &#125; 可以看到，在 collec 中，一个 while 死循环，开始不断读取 _state.value 的值solt 可以看做是 collector 的一个封装。 这里调用了 slot.awaitPending() 来挂起当前协程，让出cpu时间. 看一下 StateFlowSlot 是如何挂起的 123456suspend fun awaitPending(): Unit = suspendCancellableCoroutine sc@ &#123; cont -&gt; // 如果 _state 是 None ，就设置为 cont // cont 的类型 CancellableContinuation ，只用调用 resume 或 fail 等，才会结束，否则挂起当前协程 if (_state.compareAndSet(NONE, cont)) return@sc cont.resume(Unit)&#125; 在 StateFlow 的 emit 被调用的时候， 会获取到 solt 中的 CancellableContinuation 对象，调用其 resume ，将协程进行唤醒 ShareFlowdemo1234567891011121314151617181920212223242526272829val flow = MutableSharedFlow&lt;Int&gt;( replay = 0, extraBufferCapacity = 100, onBufferOverflow = BufferOverflow.DROP_OLDEST)private suspend fun produce() &#123; for (i in 0..5) &#123; val success = flow.tryEmit(i) println(\"tryEmit $i $success\")// delay(200) &#125;&#125;@JvmStaticfun main(args: Array&lt;String&gt;): Unit = runBlocking &#123; launch(Dispatchers.IO) &#123; delay(1000) produce() &#125; launch(Dispatchers.IO)&#123; flow.onEach &#123; println(\"receive-1 $it\") delay(500) &#125;.launchIn(this) &#125;&#125; MutableShareFlow 的三个参数： 通过 replay ，您可以针对新订阅者重新发送多个之前已发出的值 extraBufferCapacity: 除了 replay 值以外的缓冲区容量。 extraBufferCapacity + replay 是缓冲区buffer的容量 通过 onBufferOverflow，您可以指定相关政策来处理缓冲区中已存满要发送的数据项的情况。默认值为 BufferOverflow.SUSPEND，这会使调用方挂起。其他选项包括 DROP_LATEST 或 DROP_OLDEST ShareFlow 在收集侧 和 StateFlow 基本一致。 都是 while 死循环，然后将 solt 挂起。 这里不再赘述","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/tags/Kotlin/"}],"keywords":[]},{"title":"nested2嵌套滚动机制","slug":"Android/nested2嵌套滚动机制","date":"2021-07-24T08:36:31.000Z","updated":"2021-10-03T01:57:41.028Z","comments":true,"path":"2021/07/24/Android/nested2嵌套滚动机制/","link":"","permalink":"http://yoursite.com/2021/07/24/Android/nested2嵌套滚动机制/","excerpt":"开头nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。","text":"开头nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。 NestedScrollingParent2NestedScrollingParent2 包含以下接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public interface NestedScrollingParent2 extends NestedScrollingParent &#123;/** * 即将开始嵌套滑动，此时嵌套滑动尚未开始，由子控件的 startNestedScroll 方法调用 * * @param child 嵌套滑动对应的父类的子类(因为嵌套滑动对于的父控件不一定是一级就能找到的，可能挑了两级父控件的父控件，child的辈分&gt;=target) * @param target 具体嵌套滑动的那个子类 * @param axes 嵌套滑动支持的滚动方向 * @param type 嵌套滑动的类型，有两种ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动 * @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行下面的 onNestedScrollAccepted 等操作 */ boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); /** * 当onStartNestedScroll返回为true时，也就是父控件接受嵌套滑动时，该方法才会调用 * * @param child * @param target * @param axes * @param type */ void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); /** * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件 * 在嵌套滑动的子View未滑动之前 * ，判断父view是否优先与子view处理(也就是父view可以先消耗，然后给子view消耗） * * @param target 具体嵌套滑动的那个子类 * @param dx 水平方向嵌套滑动的子View想要变化的距离 * @param dy 垂直方向嵌套滑动的子View想要变化的距离 dy&lt;0向下滑动 dy&gt;0 向上滑动 * @param consumed 这个参数要我们在实现这个函数的时候指定，回头告诉子View当前父View消耗的距离 * consumed[0] 水平消耗的距离，consumed[1] 垂直消耗的距离 好让子view做出相应的调整 * @param type 滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动 */ void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type); /** * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件， * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件 * * @param target 具体嵌套滑动的那个子类 * @param dxConsumed 水平方向嵌套滑动的子控件滑动的距离(消耗的距离) * @param dyConsumed 垂直方向嵌套滑动的子控件滑动的距离(消耗的距离) * @param dxUnconsumed 水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离) * @param dyUnconsumed 垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离) * @param type 滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动 */ void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type); /** * 停止滑动 * * @param target * @param type 滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动 */ void onStopNestedScroll(@NonNull View target, @NestedScrollType int type);&#125; NestedScrollingChild212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public interface NestedScrollingChild2 extends NestedScrollingChild &#123; /** * 开始滑动前调用，在惯性滑动和触摸滑动前都会进行调用，此方法一般在 onInterceptTouchEvent或者onTouch中，通知父类方法开始滑动 * 会调用父类方法的 onStartNestedScroll onNestedScrollAccepted 两个方法 * * @param axes 滑动方向 * @param type 开始滑动的类型 the type of input which cause this scroll event * @return 有父视图并且开始滑动，则返回true 实际上就是看parent的 onStartNestedScroll 方法 */ boolean startNestedScroll(@ScrollAxis int axes, @NestedScrollType int type); /** * 子控件停止滑动，例如手指抬起，惯性滑动结束 * * @param type 停止滑动的类型 TYPE_TOUCH，TYPE_NON_TOUCH */ void stopNestedScroll(@NestedScrollType int type); /** * 判断是否有父View 支持嵌套滑动 */ boolean hasNestedScrollingParent(@NestedScrollType int type); /** * 在dispatchNestedPreScroll 之后进行调用 * 当滑动的距离父控件消耗后，父控件将剩余的距离再次交个子控件， * 子控件再次消耗部分距离后，又继续将剩余的距离分发给父控件,由父控件判断是否消耗剩下的距离。 * 如果四个消耗的距离都是0，则表示没有神可以消耗的了，会直接返回false，否则会调用父控件的 * onNestedScroll 方法，父控件继续消耗剩余的距离 * 会调用父控件的 * * @param dxConsumed 水平方向嵌套滑动的子控件滑动的距离(消耗的距离) dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致） * @param dyConsumed 垂直方向嵌套滑动的子控件滑动的距离(消耗的距离) dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致） * @param dxUnconsumed 水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致） * @param dyUnconsumed 垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致） * @param offsetInWindow 子控件在当前window的偏移量 * @return 如果返回true, 表示父控件又继续消耗了 */ boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow, @NestedScrollType int type); /** * 子控件在开始滑动前，通知父控件开始滑动，同时由父控件先消耗滑动时间 * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离 * 最终会调用父view的 onNestedPreScroll 方法 * * @param dx 水平方向嵌套滑动的子控件想要变化的距离 dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致） * @param dy 垂直方向嵌套滑动的子控件想要变化的距离 dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致） * @param consumed 父控件消耗的距离，父控件消耗完成之后，剩余的才会给子控件，子控件需要使用consumed来进行实际滑动距离的处理 * @param offsetInWindow 子控件在当前window的偏移量 * @param type 滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动 * @return true 表示父控件进行了滑动消耗，需要处理 consumed 的值，false表示父控件不对滑动距离进行消耗，可以不考虑consumed数据的处理，此时consumed中两个数据都应该为0 */ boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow, @NestedScrollType int type);&#125; nested2机制，滚动的传递一般情况下，事件是从child的触摸事件开始的， 首先调用 child.startNestedScroll() 方法，此方法内部通过 NestedScrollingChildHelper 调用并返回 parent.onStartNestedScroll() 方法的结果，为 true，说明parent接受了嵌套滑动，同时会调用 parent.onNestedScrollAccepted() 方法，此时开始嵌套滑动； 在滑动事件中，child通过 child.dispatchNestedPreScroll() 方法分配滑动的距离，内部会先调用 parent.onNestedPreScroll() 方法，由parent先处理滑动距离。 parent消耗完成之后，再将剩余的距离传递给child，child拿到parent使用完成之后的距离之后，自己再处理剩余的距离。 如果此时子控件还有未处理的距离，则将剩余的距离再次通过 child.dispatchNestedScroll() 方法调用 parent.onNestedScroll() 方法，将剩余的距离交个parent来进行处理 滑动结束之后，调用 child.stopNestedScroll()通知parent滑动结束，至此，触摸滑动结束 触摸滑动结束之后，child会继续进行惯性滑动，惯性滑动可以通过 Scroller 实现，具体滑动可以自己来处理，在fling过程中，和触摸滑动调用流程一样，需要注意 type 参数的区分，用来通知parent两种不同的滑动流程 一个栗子预期目标自己实现一个嵌套滚动的 parent 和 child， 满足以下效果 parent 包含 top 和 content 两部分，可滚动 当 top 未完全隐藏是，滚动 content ，是外层的 parent 滚动 当 top 完全隐藏，触摸滚动 content ，content 自己滚动 当触摸 content 滚动到顶部， top 未完全漏出， 则 parent 滚动，直至 top 完全露出 xml布局123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;com.example.test2.nest2_test.CustomNestedParent android:id=\"@+id/nested_parent\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;androidx.core.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;LinearLayout android:id=\"@+id/view_top\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@color/colorAccent\" android:orientation=\"vertical\"&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"200dp\" /&gt; &lt;/LinearLayout&gt; &lt;/androidx.core.widget.NestedScrollView&gt; &lt;com.example.test2.nest2_test.CustomNestedChild android:id=\"@+id/view_list\" android:layout_width=\"match_parent\" android:layout_height=\"1500dp\" /&gt; &lt;/LinearLayout&gt; &lt;/com.example.test2.nest2_test.CustomNestedParent&gt;&lt;/LinearLayout&gt; 这里模仿 ScrollView 嵌套 ScrollView 的场景，即外部的 CustomNestedParent 嵌套 内部的 CustomNestedChild ，并解决他们的之间的滑动冲突topVie2 外面包裹了一层 NestedScrollView，是为了让它支持 nested 机制 1234567891011121314151617181920212223242526272829class NestedTestActivity : AppCompatActivity() &#123; private lateinit var nestedParent: CustomNestedParent private lateinit var listView: LinearLayout override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_nested_test) nestedParent = findViewById(R.id.nested_parent) val topView: View = findViewById(R.id.view_top) listView = findViewById(R.id.view_list) nestedParent.init(topView, listView) addListItems() &#125; private fun addListItems() &#123; // 填充 child， 这里模拟 child 是一个 recyclerview for (i in 0 until 100) &#123; val textView = TextView(this) textView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 100) textView.text = \"position $i\" listView.addView(textView) &#125; &#125;&#125; CustomNestedParent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113class CustomNestedParent @JvmOverloads constructor( context: Context?, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingParent2 &#123; val TAG = \"CustomNestedParent\" private val mNestedScrollingParentHelper = NestedScrollingParentHelper(this) private lateinit var topView: View private lateinit var nestedChild: View private var childrenHeight = 0 override fun onFinishInflate() &#123; super.onFinishInflate() &#125; fun init(topView: View, contentView: View) &#123; this.topView = topView this.nestedChild = contentView &#125; override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123; // 模仿 NestedScrollView var height = MeasureSpec.getSize(heightMeasureSpec) var width = MeasureSpec.getSize(widthMeasureSpec) childrenHeight = 0 for (i in 0 until childCount) &#123; val child = getChildAt(i) measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED) childrenHeight += child.measuredHeight &#125; setMeasuredDimension(width, height) &#125; // @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行其他操作 override fun onStartNestedScroll(child: View, target: View, axes: Int, type: Int): Boolean &#123; Log.i(TAG, \"onStartNestedScroll: \") return axes == ViewCompat.SCROLL_AXIS_VERTICAL &#125; // 当嵌套滑动被parent接收了，会回调这个方法 override fun onNestedScrollAccepted(child: View, target: View, axes: Int, type: Int) &#123; Log.i(TAG, \"onNestedScrollAccepted: \") mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes, type) &#125; /** * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件 * 不管手势滚动还是fling都会回调这个方法 */ override fun onNestedPreScroll(target: View, dx: Int, dy: Int, consumed: IntArray, type: Int) &#123; val threshold = nestedChild.top var parentScrollable = false val hideTop = dy &gt; 0 &amp;&amp; scrollY &lt; threshold val showTop = dy &lt; 0 &amp;&amp; !target.canScrollVertically(-1) Log.i(TAG, \"onNestedPreScroll-1: $dy $type\") if (hideTop || showTop) &#123; // parent 提前消费的场景 // 1. 向上滚动，parent滚动的距离 &lt; topView的高度，需要隐藏topView // 2. 向下滚动，且 child 已经滚动到顶部，需要漏出 topView parentScrollable = true consumed[1] = dy scrollBy(0, dy) Log.i(TAG, \"onNestedPreScroll-2: hideTop=$hideTop showTop=$showTop dy=$dy scrollY=$scrollY threshold=$threshold type=$type\") &#125; else &#123; // 反之，应该让 child 滚动，parent不应该消费滚动距离 parentScrollable = false &#125; &#125; /** * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件， * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件 * * 孩子吃剩下的留给爸爸了 */ override fun onNestedScroll( target: View, dxConsumed: Int, dyConsumed: Int, dxUnconsumed: Int, dyUnconsumed: Int, type: Int ) &#123; Log.i(TAG, \"onNestedScroll: $dyUnconsumed $type $scrollY\") // 剩余的parent全部消费 scrollBy(0, dyUnconsumed) &#125; override fun onStopNestedScroll(target: View, type: Int) &#123; mNestedScrollingParentHelper.onStopNestedScroll(target, type); &#125; override fun getNestedScrollAxes(): Int &#123; return mNestedScrollingParentHelper.nestedScrollAxes &#125; override fun scrollTo(x: Int, y: Int) &#123; var resY = y // 限定 parnet 的上下边界，防止滚动出屏幕外 if (resY &lt; 0) &#123; resY = 0 &#125; val max = max(childrenHeight - height, 0) if (y &gt; max) &#123; resY = max &#125; Log.i(TAG, \"scrollTo: $max $y $resY\") super.scrollTo(x, resY) &#125;&#125; CustomNestedChild123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243class CustomNestedChild @JvmOverloads constructor( context: Context?, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingChild2 &#123; val TAG = \"CustomNestedChild\" private val mScrollingChildHelper = NestedScrollingChildHelper(this) private val viewConfiguration: ViewConfiguration = ViewConfiguration.get(context) private var mVelocityTracker: VelocityTracker? = null private val mScroller: Scroller = Scroller(context) private var mLastX: Float = 0f private var mLastY: Float = 0f private var mLastFlingX: Float = 0f private var mLastFlingY: Float = 0f private val offset = IntArray(2) private val consumed = IntArray(2) private var fling = false //判断当前是否是可以进行惯性滑动 private var childrenHeight = 0 init &#123; orientation = VERTICAL // 这里必须都设置为 true ，表明这个view是支持nested2机制的 isNestedScrollingEnabled = true mScrollingChildHelper.isNestedScrollingEnabled = true &#125; override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123; var height = MeasureSpec.getSize(heightMeasureSpec) var width = MeasureSpec.getSize(widthMeasureSpec) childrenHeight = 0 for (i in 0 until childCount) &#123; val child = getChildAt(i) measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED) childrenHeight += child.measuredHeight &#125; setMeasuredDimension(width, height) &#125; override fun startNestedScroll(axes: Int, type: Int): Boolean &#123; return mScrollingChildHelper.startNestedScroll(axes, type) &#125; override fun stopNestedScroll(type: Int) &#123; mScrollingChildHelper.stopNestedScroll(type) &#125; override fun hasNestedScrollingParent(type: Int): Boolean &#123; return mScrollingChildHelper.hasNestedScrollingParent() &#125; override fun dispatchNestedPreScroll( dx: Int, dy: Int, consumed: IntArray?, offsetInWindow: IntArray?, type: Int ): Boolean &#123; return mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type) &#125; override fun dispatchNestedScroll( dxConsumed: Int, dyConsumed: Int, dxUnconsumed: Int, dyUnconsumed: Int, offsetInWindow: IntArray?, type: Int ): Boolean &#123; return mScrollingChildHelper.dispatchNestedScroll( dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, offsetInWindow, type ) &#125; override fun onTouchEvent(event: MotionEvent): Boolean &#123; // 处理触摸事件是，关闭fling cancelFling() if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain() &#125; val velocityTracker = mVelocityTracker!! velocityTracker.addMovement(event) when (event.action) &#123; MotionEvent.ACTION_DOWN -&gt; &#123; mLastX = event.x mLastY = event.y // 表明开始处理嵌套滚动， TYPE_TOUCH 表明这是一个触摸场景 startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH) &#125; MotionEvent.ACTION_MOVE -&gt; &#123; val curX = event.x val curY = event.y var dy = (mLastY - curY).toInt() var dx = (mLastX - curX).toInt() // 先交给parent处理 if (dispatchNestedPreScroll(dx, dy, consumed, offset, TYPE_TOUCH)) &#123; dy -= consumed[1] dx -= consumed[0] &#125; // child自己消费 val consumedY = childConsumeY(dy) // 将消费剩下的，传递给parent dispatchNestedScroll(0, consumedY, dx, dy - consumedY, null, TYPE_TOUCH) mLastX = curX mLastY = curY &#125; MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; &#123; // 先结束 TYPE_TOUCH 场景的嵌套滚动 stopNestedScroll(TYPE_TOUCH) // 判断是否需要惯性滑动 velocityTracker.computeCurrentVelocity( 1000, viewConfiguration.scaledMaximumFlingVelocity.toFloat() ) val yvel = velocityTracker.yVelocity fling(yvel.toInt()) velocityTracker.clear() &#125; &#125; return true &#125; private fun fling(velocityY: Int) &#123; cancelFling() //判断速度是否足够大。如果够大才执行fling var dy: Int = velocityY if (abs(velocityY) &lt; viewConfiguration.scaledMinimumFlingVelocity) &#123; dy = 0 &#125; if (dy == 0) &#123; return &#125; // 这步必须要有，表明开始 TYPE_NON_TOUCH 的嵌套滚动 // 如果不设置，后续的嵌套滚动流程都都会找不到对应的parent startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_NON_TOUCH) val maxFlingVelocity: Int = viewConfiguration.scaledMaximumFlingVelocity dy = max(-maxFlingVelocity, min(dy, maxFlingVelocity)) Log.i(TAG, \"fling: $dy \") fling = true // 开始fling mScroller.fling( 0, 0, 0, dy, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE ) postInvalidate() &#125; override fun computeScroll() &#123; if (mScroller.computeScrollOffset() &amp;&amp; fling) &#123; val y = mScroller.currY var dy = (mLastFlingY - y).toInt() mLastFlingY = y.toFloat() // 和触摸场景一样，优先让parent处理 if (dispatchNestedPreScroll(0, dy, consumed, null, TYPE_NON_TOUCH)) &#123; dy -= consumed[1] &#125; Log.i(TAG, \"computeScroll: $&#123;consumed[1]&#125; $dy\") // child 自己处理 val consumedY = childFling(dy) // 将剩下的在传递给 parent dispatchNestedScroll(0, consumedY, 0, dy - consumedY, null, TYPE_NON_TOUCH) postInvalidate() &#125; else &#123; stopNestedScroll(TYPE_NON_TOUCH) cancelFling() &#125; &#125; private fun childConsumeY(dy: Int): Int &#123; var consumed = dy if (consumed &lt; 0) &#123; // 如果滑动到顶部，只处理部分，不然可能无法触达顶部边界 consumed = max(-scrollY, consumed) &#125; else &#123; // 如果滑动到顶部，只处理部分，不然可能会无法触达底部边界 val max = max(childrenHeight - height, 0) if (dy + scrollY &gt; max) &#123; consumed = max - scrollY &#125; &#125; Log.i(TAG, \"childConsumeY: $dy $consumed $scrollY\") scrollBy(0, consumed) return consumed &#125; private fun childFling(dy: Int): Int &#123; return childConsumeY(dy) &#125; private fun cancelFling() &#123; fling = false mLastFlingY = 0f mLastFlingY = 0f &#125; override fun scrollTo(x: Int, y: Int) &#123; var resY = y if (resY &lt; 0) &#123; resY = 0 &#125; val max = max(childrenHeight - height, 0) if (y &gt; max) &#123; resY = max &#125; Log.i(TAG, \"scrollTo: $max $y $resY\") super.scrollTo(x, resY) &#125; override fun canScrollVertically(direction: Int): Boolean &#123; if (direction &lt; 0 &amp;&amp; scrollY &lt;= 0) &#123; return false &#125; else if (direction &gt; 0 &amp;&amp; scrollY &gt;= measuredHeight - height) &#123; return false &#125; else &#123; return true &#125; &#125;&#125; https://juejin.cn/post/6844903960432607246#heading-1","categories":[],"tags":[{"name":"nested2","slug":"nested2","permalink":"http://yoursite.com/tags/nested2/"}],"keywords":[]},{"title":"编译aosp","slug":"编译aosp","date":"2021-05-22T09:12:59.000Z","updated":"2021-10-03T01:57:41.032Z","comments":true,"path":"2021/05/22/编译aosp/","link":"","permalink":"http://yoursite.com/2021/05/22/编译aosp/","excerpt":"注意事项 在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘","text":"注意事项 在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘 下载源代码 下载 Repo 工具，并确保它可执行： 12curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 使用清华源12curl https://mirrors.tuna.tsinghua.edu.cn/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 初始化 Repo -b 后面可以指定要同步代码的安卓系统版本代号版本代号可以在下面的链接中查找https://source.android.com/setup/start/build-numbers 1repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1 使用清华源1repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r40 同步 Repo 需要几个小时的时间同步代码1repo sync 编译执行下面的命令，lunch 选择编译模式（ 这里我选择的是 aosp_x86_64-eng）m （m 命令系统会根据cpu性能自动选取需要使用的线程，你也可以根据cpu多少使用 make -jN, N表示cpu个数x2） 123source build/envsetup.shlunch aosp_x86_64-engm 坑点 找不到对应的MacOSX.sdkCould not find a supported mac sdk: [“10.10” “10.11” “10.12” “10.13”] 我的系统版本是10.15，你需要到 https://github.com/phracker/MacOSX-SDKs/releases 下载需要的版本 我这里下载的是MacOSX10.12.sdk，解压复制到如下目录：/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs 不知名报错、 找到文件：源文件根目录/system/sepolicy/tests/Android.bp，删除掉第14行的一行代码： 1234567891011// libsepolwrap gets loaded from the system python, which does not have the// ASAN runtime. So turn off sanitization for ourself, and use static// libraries, since the shared libraries will use ASAN.static_libs: [ &quot;libbase&quot;, &quot;libsepol&quot;,],stl: &quot;libc++_static&quot;, // 删除掉这一行sanitize: &#123; never: true,&#125;, 使用 Android Studio 阅读源码 生成 Android Studio 工程配置文件 生成 android.iml 和 android.ipr 文件。 其中 iml 文件 表示 information of modules, 用来描述 AOSP 的模块信息。ipr 文件 表示 IDEA project configuration ，用来描述 IDEA 的工程配置信息，双击此文件时系统将直接使用 Andorid Studio 打开此项目。 1234# 设置 AOSP 编译所需的环境变量source build/envsetup.sh# 使用 idegen.sh 脚本生成 IDEA 工程文件development/tools/idegen/idegen.sh","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/tags/AOSP/"}],"keywords":[]},{"title":"屏幕刷新机制","slug":"Android/Framework/屏幕刷新机制","date":"2021-03-17T16:05:08.000Z","updated":"2021-10-03T01:57:41.023Z","comments":true,"path":"2021/03/18/Android/Framework/屏幕刷新机制/","link":"","permalink":"http://yoursite.com/2021/03/18/Android/Framework/屏幕刷新机制/","excerpt":"requestLayoutview.requestLayout 最终会调用 ViewRootImpl.requestLayout","text":"requestLayoutview.requestLayout 最终会调用 ViewRootImpl.requestLayout 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); // 检查线程是否是 ViewRootImpl 实例化的线程 mLayoutRequested = true; scheduleTraversals(); &#125;&#125;void scheduleTraversals() &#123; // mTraversalScheduled 标记位，避免短时间多次调用requestLayout重复刷新 if (!mTraversalScheduled) &#123; mTraversalScheduled = true; // 添加一个同步屏障 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); // 通过 Choreographer 添加一个 Vsync 回调 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); ... &#125;&#125;final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); // 开始 measure layout draw 三步走 performTraversals(); &#125;&#125; 这个 mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); 这个操作会在 LooperQueue 中添加一个同步屏障，阻断同步 message（普通 message ）的执行。（异步 message 能正常执行）这里主要是为了保证在 Vync 到来时，这个 message 能够快速响应，保证在 Vync 到来的最初时刻就开始绘制，从而保证 UI 的绘制和 Vync 的周期是协调的。 mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); 添加一个 Vsync 回调。在 Vsync 信号到来时执行 mTraversalRunnable 。 ChoreographerChoreographer 是用来监听 Vsync 信号的一个类。 在刷新UI时主要有两步。 添加一个 vsync 信号的回调12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; // 这里 mCallbackQueues 是多个事件的队列 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; // 延时做刷新，最终也会走 scheduleFrameLocked Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125;private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; // 判断是不是在 ViewRootImpl 实例化时的线程 if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; // 如果不是，用一个 Handler 切换线程 // 发送一个异步消息，并且放置在队列最前方 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; ... &#125; &#125;&#125;private void scheduleVsyncLocked() &#123; mDisplayEventReceiver.scheduleVsync();&#125;public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; ... &#125; else &#123; // 调用 native 方法请求一个 vsync 回调 nativeScheduleVsync(mReceiverPtr); &#125;&#125; 处理 vsync 回调12345678910111213141516// 在 Choreographer 的构造方法里实例化 DisplayEventReceiver private Choreographer(Looper looper, int vsyncSource) &#123; mLooper = looper; mHandler = new FrameHandler(looper); mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper, vsyncSource) : null; mLastFrameTimeNanos = Long.MIN_VALUE; mFrameIntervalNanos = (long)(1000000000 / getRefreshRate()); mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1]; for (int i = 0; i &lt;= CALLBACK_LAST; i++) &#123; mCallbackQueues[i] = new CallbackQueue(); &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable &#123; private boolean mHavePendingVsync; private long mTimestampNanos; private int mFrame; public FrameDisplayEventReceiver(Looper looper, int vsyncSource) &#123; super(looper, vsyncSource); &#125; @Override public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; timestampNanos = now; &#125; mTimestampNanos = timestampNanos; mFrame = frame; // 发送一个异步消息，注意，这里没有放置到消息队列最前端 Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); &#125; @Override public void run() &#123; doFrame(mTimestampNanos, mFrame); &#125;&#125;void doFrame(long frameTimeNanos, int frame) &#123; final long startNanos; synchronized (mLock) &#123; if (!mFrameScheduled) &#123; return; // no work to do &#125; long intendedFrameTimeNanos = frameTimeNanos; startNanos = System.nanoTime(); // 当前时间 - vsync回调到来时间 = 主线程message耗时 final long jitterNanos = startNanos - frameTimeNanos; // 当超过了屏幕一帧刷新时间 16ms if (jitterNanos &gt;= mFrameIntervalNanos) &#123; final long skippedFrames = jitterNanos / mFrameIntervalNanos; if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123; // 当跳过的帧超过一定程度 &#125; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; frameTimeNanos = startNanos - lastFrameOffset; &#125; mFrameScheduled = false; mLastFrameTimeNanos = frameTimeNanos; &#125; try &#123; AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); // 处理屏幕刷新的回调，这里会调用 ViewRootImpl.TraversalRunnable doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125; ...&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}],"keywords":[]},{"title":"应用进程是如何启动的","slug":"Android/Framework/应用进程是如何启动的","date":"2021-03-06T16:23:23.000Z","updated":"2022-08-25T06:01:09.978Z","comments":true,"path":"2021/03/07/Android/Framework/应用进程是如何启动的/","link":"","permalink":"http://yoursite.com/2021/03/07/Android/Framework/应用进程是如何启动的/","excerpt":"zygote的启动zygote 的功能zygote 进程的主要功能有两个：","text":"zygote的启动zygote 的功能zygote 进程的主要功能有两个： 在系统启动时启动 SystemServer 进程 启动 应用进程 zygote 进程的启动过程zygote进程的创建。在 Android 系统开机之后，会创建 init 进程，这是 Linux 系统启动后创建的第一个进程。 init 进程有一个配置文件 init.rc 。 将需要启动的服务写入到 init.rc 中， init 进程在启动后就会创建这些进程， 比如 zygote ， ServiceManager 等。 zygote 进程的 native 部分。zygote 的c层代码入口在 /rameworks/base/cmds/app_process/app_main.cpp 中，最终主要的工作内容在 /frameworks/base/core/jni/AndroidRuntime.cpp 。主要内容如下。不详细分析了 启动虚拟机。 注册 JNI 函数 调用 Java 类 Zygote.main 方法，进入 Java 循环 。 zygote 进程的 Java 部分zygote 的 java 入口在 /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java public static void main(String argv[]) &#123; ZygoteServer zygoteServer = new ZygoteServer(); ... final Runnable caller; try &#123; RuntimeInit.enableDdms(); boolean startSystemServer = false; String socketName = \"zygote\"; String abiList = null; boolean enableLazyPreload = false; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (\"--enable-lazy-preload\".equals(argv[i])) &#123; enableLazyPreload = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; socketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(\"Unknown command line argument: \" + argv[i]); &#125; &#125; // 注册 socket zygoteServer.registerServerSocketFromEnv(socketName); // In some configurations, we avoid preloading resources and classes eagerly. // In such cases, we will preload things prior to our first fork. if (!enableLazyPreload) &#123; // 预加载类和资源 preload(bootTimingsTraceLog); &#125; else &#123; Zygote.resetNicePriority(); &#125; ... if (startSystemServer) &#123; // fork SystemServer 进程 Runnable r = forkSystemServer(abiList, socketName, zygoteServer); // &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the // child (system_server) process. if (r != null) &#123; // 如果 r != null ，说明是子进程 SystemServer ，r.run 应该是进入 SystemServer 的事件循环，然后直接return r.run(); return; &#125; &#125; // zygote 事件循环，不让zygote退出 caller = zygoteServer.runSelectLoop(abiList); &#125; catch (Throwable ex) &#123; throw ex; &#125; finally &#123; zygoteServer.closeServerSocket(); &#125; // We're in the child process and have exited the select loop. Proceed to execute the // command. if (caller != null) &#123; caller.run(); &#125; &#125; 注册 Socket 服务， zygote 进程通过 socket 和 AMS 通信 预加载类和资源。这样在 fork SystemServer 和 应用进程时，能够直接拷贝给子进程使用 fork 出 SystemServer 进程， SystemServer 进程随后又会启动 Binder ，并启动这种系统 Service ，比如 AMS ，WMS 等。 进入 loop 循环，等待接收 AMS 的 Socket 消息。 收到消息后会调用 runOnce 方法，fork 出应用进程，并执行应用进程的 ActivityThread.main() 小结：注意：zygote fork 进程时一定是单线程的 zygote 新 fork 出来的进程不需要再创建java虚拟机，因为 fork 出来的子进程是会继承拷贝父进程的资源的， fork 出来的进程会拥有 zygote 进程的虚拟机的拷贝 为什么要设计一个 zygote 来 fork 应用进程，而不是 SystemServer : 因为systemServer中运行了很多系统服务，不能被继承。应用程序启动时，除了必要的资源外，最好是干净的，所以需要单独用一个zygote来fork。 为什么Zygote要使用Socket不使用binder： 因为binder机制支持并发有一个线程池，如果zygote支持并发，在fork之后，会把线程池中的线程一起复制一份。 如果zygote的binder线程池处于一个等待锁的状态，fork之后的新进程依然是在等待锁的，并且不能解锁。 从而有可能造成死锁 zygote 的事件循环123456789101112131415161718192021222324252627282930313233343536373839404142// /frameworks/base/core/java/com/android/internal/os/ZygoteServer.java Runnable runSelectLoop(String abiList) &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); fds.add(mServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; //处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里 Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; // 这里没看懂。。。 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); &#125; else &#123; try &#123; // 处理接收到的消息 ZygoteConnection connection = peers.get(i); final Runnable command = connection.processOneCommand(this); ... &#125; ... &#125; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java Runnable processOneCommand(ZygoteServer zygoteServer) &#123; ... pid = Zygote.forkAndSpecialize(parsedArgs.uid, ...); try &#123; if (pid == 0) &#123; // 子进程 zygoteServer.setForkChild(); zygoteServer.closeServerSocket(); IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; return handleChildProc(parsedArgs, descriptors, childPipeFd, parsedArgs.startChildZygote); &#125; else &#123; // 父进程 IoUtils.closeQuietly(childPipeFd); childPipeFd = null; handleParentProc(pid, descriptors, serverPipeFd); return null; &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125; &#125; private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, boolean isZygote) &#123; closeSocket(); ... if (!isZygote) &#123; // 应用进程启动流程进入这个分支 // 从 socket 传来参数中取出 class ，并执行 main 方法 return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125; else &#123; // 没看懂这个分支是做什么的。。 // 看注释的意思是提供了「跳过启动binder，直接创建进程」的方式 return ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125; &#125; 应用进程的启动我们以 Activity 的启动为入口，来探讨应用进程的启动过程 AMS 发起创建进程由 Activity 的启动寻找应用进程创建的入口首先来看 Activity 的启动。安卓四大组件都是由AMS来管理的。 应用进程会调用 AMS 的binder 对象，实现在 ActivityManagerService.startActivity 里。 最终顺着调用栈，会走到 ActivityStackSupervisor.startSpecificActivityLocked(…) 12345678910111213141516171819// /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; // 进程已启动，真正开始启动 activity 了，哎，调用链太长了 realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; &#125; &#125; // 进程没启动，开始启动进程了 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true); &#125; 上面的逻辑里，会先判断要启动的 activity 所在应用的进程是否启动，如果已经成功启动，则开始启动 activity ；否则，启动引用进程。注意这里应用是否启动的判断条件： if (app != null &amp;&amp; app.thread != null)ProcessRecord 是应用进程在 AMS 的信息记录，除了判断 app 不为空，还对 app.thread 。这个 app.thread 是一个 IApplicationThread binder 对象，这个对象很重要。 AMS 发送 Socket 给 zygote1234567891011121314151617181920212223@GuardedBy(\"this\")private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; ... if (mConstants.FLAG_PROCESS_START_ASYNC) &#123; // 异步启动进程，忽略吧 ... return true; &#125; else &#123; try &#123; final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app, uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper, startSeq, false); &#125; catch (RuntimeException e) &#123; ... &#125; return app.pid &gt; 0; &#125;&#125; AMS.startProcess 会调用 Process.start(…) 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// /frameworks/base/core/java/android/os/Process.java public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) &#123; return zygoteProcess.start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs); &#125;// /frameworks/base/core/java/android/os/ZygoteProcess.java public final Process.ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, false /* startChildZygote */, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; ... &#125; &#125; private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, boolean startChildZygote, String[] extraArgs) throws ZygoteStartFailedEx &#123; ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;(); ... // 组装 socket 的参数 synchronized(mLock) &#123; // openZygoteSocketIfNeeded 会获取一个 ZygoteState ，有必要的话，会创建 socket 连接。 ZygoteState 包含了 socket 输入输出流。 // zygote fork 进程成功会返回应用进程的 pid return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125; &#125; AMS 会发送 socket 消息给 zygote ，zygote 会 fork 应用进程，并执行应用进程的 ActivityThread.main 方法 应用进程在启动之后都干了啥？thread.attach(…)12345678910111213141516171819202122232425262728// frameworks/base/core/java/android/app/ActivityThread.java public static void main(String[] args) &#123; Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); Looper.loop(); &#125; private void attach(boolean system, long startSeq) &#123; sCurrentActivityThread = this; mSystemThread = system; if (!system) &#123; // 走这个分支 RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManager.getService(); try &#123; mgr.attachApplication(mAppThread, startSeq); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; ... &#125; else &#123; ... &#125; ... &#125; 应用整个进程的入口在 ActivityThread.main() 方法中，这个方法里没啥操作： 1. 准备 Looper 2. 实例化 ActivityThread ，并 attach 3. 开启 Looper 循环 显然， main 方法里做的事情支撑不了一个 app 的启动。 重点看 thread.attach , 它 使用 binder 调用了 AMS.attachApplication ，然后又调用了 AMS.attachApplicationLocked(…) 12345678910111213141516171819202122// 伪代码。。 private final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; ProcessRecord app; if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123; synchronized (mPidsSelfLocked) &#123; app = mPidsSelfLocked.get(pid); &#125; &#125; else &#123; app = null; &#125; thread.bindApplication(...); // 处理一些因为应用进程还没有启动而暂存的组件 mStackSupervisor.attachApplicationLocked(app); ... mServices.attachApplicationLocked(app, processName); ... sendPendingBroadcastsLocked(app); &#125; thread.bindApplication(…)AMS 在 attch 进程之后又通过 binder 调用了应用进程的 bindApplication 123456789101112131415161718public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial, boolean autofillCompatibilityEnabled) &#123; ... AppBindData data = new AppBindData(); ... // 补充 AppBindData 的参数 // 发送一个 消息到 H handler sendMessage(H.BIND_APPLICATION, data);&#125; 在应用进程，发送了一个 H.BIND_APPLICATION 给 handler ，实现了线程的切换。 注意 通过 binder对象调用，是运行在 binder 线程里的，所以这个 bindApplication 也是运行在 binder 线程里的，需要切换回主线程。 handleBindApplication12345678// 伪代码private void handleBindApplication(AppBindData data) &#123; data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInstrumentation.callApplicationOnCreate(app);&#125; data.info 是一个描述应用安装包信息的类。 data.info.makeApplication 一个applicaiton 类，并调用生命周期的 onCreate 12345678// frameworks/base/core/java/android/app/LoadedApk.javapublic Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; // 创建 application 和 context 对象，并绑定 ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext);&#125; 这样，应用的启动就完成了","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Framework","slug":"Framework","permalink":"http://yoursite.com/tags/Framework/"}],"keywords":[]},{"title":"自定义LayoutManager","slug":"Android/自定义LayoutManager","date":"2021-02-26T09:06:00.000Z","updated":"2022-08-07T10:38:04.561Z","comments":true,"path":"2021/02/26/Android/自定义LayoutManager/","link":"","permalink":"http://yoursite.com/2021/02/26/Android/自定义LayoutManager/","excerpt":"LayoutManager 的常用方法generateDefaultLayoutParams","text":"LayoutManager 的常用方法generateDefaultLayoutParams生成默认RecyclerView的LayoutParams, 没啥意义，就返回 wrap_content isAutoMeasureEnabled 和 onMeasureisAutoMeasureEnabled()是自测量模式。 如果要支持 wrap_content ，那必须重写这两个方法中的一个。 大部分情况下，isAutoMeasureEnabled 返回 true 即可。 canScrollHorizontally 和 canScrollVertically无需多言 onLayoutChildren当 RecyclerView 的 layout 过程中会调用这个方法，包括第一次 layout 和 其他原因的重新 layout，比如说键盘的升降。 scrollHorizontallyBy 和 scrollVerticallyBy12345678override fun scrollHorizontallyBy( dx: Int, recycler: RecyclerView.Recycler, state: RecyclerView.State): Int &#123; ...&#125; RecyclerView 滚动的时候回回调这个方法，但是它只是告诉你用户滑动的距离，需要你自己去实现滑动的效果。同时需要去判断滑动的边界。但是返回值与 RecyclerView 的 overScorll 的动画有关，返回0会有边界的波纹动画。 getPosition(View)返回 child view 在 adapter 中的位置 getDecoratedXxxx在 LayoutManager 中与布局有关的api都需要替换成带 Decorated 的api，不然无法实现对 itemDecorated 的兼容 detachAndScrapAttachedViews()从 RecyclerView 暂时移除 child 并送入临时缓存。 之前一直很奇怪，暂时移除是个什么场景。 后来想明白了，在每次布局 child 之前，都需要调用一次这个方法，把6所有的 child 移除到临时缓存里。否则，在布局的时候 addView(child) ，如果 child 已经 add 到了 RecyclerView 里，会造成一些麻烦。 removeAndRecycleView移除 child 并将对应的 ViewHolder 移动到 cachePool ，从 cachePool 中取出的 ViewHolder 需要重新调用 Adapter.onBindViewHolder 方法 自定义 LayoutManager 的一般套路scrollHorizontallyBy 和 onLayoutChildren 可以服用同一个布局逻辑。 确定锚点 view 的 position 确定布局的左右(上下)边界 开始 addView()-&gt;measureView()-&gt;layoutView() 回收布局边界之外的 child demo代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186class CustomLinearLayoutManager : RecyclerView.LayoutManager() &#123; override fun generateDefaultLayoutParams(): RecyclerView.LayoutParams &#123; return RecyclerView.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT ) &#125; override fun isAutoMeasureEnabled(): Boolean &#123; return true &#125; override fun canScrollHorizontally(): Boolean &#123; return true &#125; override fun canScrollVertically(): Boolean &#123; return false &#125; override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) &#123; if (state.itemCount == 0) &#123; removeAndRecycleAllViews(recycler) return &#125; var left = paddingStart var curPos = 0 if (childCount &gt; 0) &#123; // 这里是兼容键盘升起然后重新 rebuild 的情况。 // 如果不做兼容，RecyclerView 会移动到列表最顶部 left = getDecoratedLeft(getChildAt(0)!!) curPos = getPosition(getChildAt(0)!!) &#125; detachAndScrapAttachedViews(recycler) fill(recycler, state, curPos, left, paddingStart + getAvailableSpace(), true) &#125; override fun scrollHorizontallyBy( dx: Int, recycler: RecyclerView.Recycler, state: RecyclerView.State ): Int &#123; val resDx = calculateOffset(recycler, state, dx) if (resDx == 0 || itemCount == 0) &#123; return resDx &#125; val d = abs(resDx) if (resDx &gt;= 0) &#123; val anchorView = getChildAt(0) val anchorPos = getPosition(anchorView!!) val anchorLeft = getDecoratedLeft(anchorView) detachAndScrapAttachedViews(recycler) fill(recycler, state, anchorPos, anchorLeft - d, getAvailableSpace() + paddingStart, true) &#125; else &#123; val anchorView = getChildAt(childCount - 1) val anchorPos = getPosition(anchorView!!) val anchorRight = getDecoratedRight(anchorView) detachAndScrapAttachedViews(recycler) fill(recycler, state, anchorPos, paddingLeft, anchorRight + d, false) &#125; recycler(recycler, state, resDx) return resDx &#125; private fun calculateOffset(recycler: RecyclerView.Recycler, state: RecyclerView.State, dx: Int): Int &#123; if (childCount == 0 || dx == 0) &#123; return 0 &#125; var fillPos = RecyclerView.NO_POSITION val d = abs(dx) if (dx &lt; 0) &#123; val firstView = getChildAt(0) val firstPos = getPosition(firstView!!) val firstLeft = getDecoratedLeft(firstView) fillPos = firstPos - 1 if (fillPos &lt; 0 &amp;&amp; firstLeft + d &gt; paddingStart) &#123; return firstLeft - paddingStart &#125; if (firstLeft + d &lt; paddingStart) &#123; return dx &#125; &#125; else &#123; val lastView = getChildAt(childCount - 1) val lastPos = getPosition(lastView!!) val lastRight = getDecoratedRight(lastView) fillPos = lastPos + 1 val endEdge = getAvailableSpace() + paddingStart if (fillPos &gt;= itemCount &amp;&amp; lastRight - d &lt; endEdge) &#123; return lastRight - endEdge &#125; if (lastRight - d &gt; endEdge) &#123; return dx &#125; &#125; return dx &#125; private fun fill(recycler: RecyclerView.Recycler, state: RecyclerView.State, anchorIndex: Int, anchorLeft: Int, anchorRight: Int, isLTR: Boolean) &#123; var availableSpace = anchorRight - anchorLeft var fillPos = anchorIndex var left = anchorLeft var right = anchorRight val top = paddingTop while (availableSpace &gt; 0 &amp;&amp; fillPos &gt;= 0 &amp;&amp; fillPos &lt; state.itemCount) &#123; val view = recycler.getViewForPosition(fillPos) if (isLTR) &#123; addView(view) measureChildWithMargins(view, 0, 0) right = left + getDecoratedMeasuredWidth(view) val bottom = top + getDecoratedMeasuredHeight(view) layoutDecoratedWithMargins(view, left, top, right, bottom) fillPos++ left = right &#125; else &#123; addView(view, 0) measureChildWithMargins(view, 0, 0) left = right - getDecoratedMeasuredWidth(view) val bottom = top + getDecoratedMeasuredHeight(view) layoutDecoratedWithMargins(view, left, top, right, bottom) fillPos-- right = left &#125; availableSpace -= getDecoratedMeasuredWidth(view) &#125; &#125; private fun recycler(recycler: RecyclerView.Recycler, state: RecyclerView.State, dx: Int) &#123; //要回收View的集合，暂存 val recycleViews = hashSetOf&lt;View&gt;() //dx&gt;0就是手指从右滑向左，所以要回收前面的children if (dx &gt; 0) &#123; for (i in 0 until childCount) &#123; val child = getChildAt(i)!! val right = getDecoratedRight(child) //itemView的right&lt;0就是要超出屏幕要回收View if (right &gt; paddingStart) break recycleViews.add(child) &#125; &#125; //dx&lt;0就是手指从左滑向右，所以要回收后面的children if (dx &lt; 0) &#123; for (i in childCount - 1 downTo 0) &#123; val child = getChildAt(i)!! val left = getDecoratedLeft(child) //itemView的left&gt;recyclerView.width就是要超出屏幕要回收View if (left &lt; getAvailableSpace() + paddingStart) break recycleViews.add(child) &#125; &#125; //真正把View移除掉 for (view in recycleViews) &#123; removeAndRecycleView(view, recycler) &#125; &#125; private fun getAvailableSpace(): Int &#123; return width - paddingStart - paddingEnd &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[]},{"title":"redux源码","slug":"Flutter/redux源码","date":"2021-01-24T13:40:51.000Z","updated":"2021-10-03T01:57:41.031Z","comments":true,"path":"2021/01/24/Flutter/redux源码/","link":"","permalink":"http://yoursite.com/2021/01/24/Flutter/redux源码/","excerpt":"Redux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux","text":"Redux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux 被观察者 Store/State被观察者 明显是 Store 和 State 。 State 是状态的 model类 。 Store 是 State 的持有者。 1234567891011121314151617181920212223242526272829303132333435363738class Store&lt;State&gt; &#123; Reducer&lt;State&gt; reducer; final StreamController&lt;State&gt; _changeController; State _state; List&lt;NextDispatcher&gt; _dispatchers; Store( this.reducer, &#123; State initialState, List&lt;Middleware&lt;State&gt;&gt; middleware = const [], bool syncStream = false, bool distinct = false, &#125;) : _changeController = StreamController.broadcast(sync: syncStream) &#123; _state = initialState; _dispatchers = _createDispatchers( middleware, _createReduceAndNotify(distinct), ); &#125; NextDispatcher _createReduceAndNotify(bool distinct) &#123; return (dynamic action) &#123; final state = reducer(_state, action); if (distinct &amp;&amp; state == _state) return; _state = state; _changeController.add(state); &#125;; &#125; dynamic dispatch(dynamic action) &#123; return _dispatchers[0](action); &#125; Stream&lt;State&gt; get onChange =&gt; _changeController.stream;&#125; 当一个 Store 创建时，会实例化一个 _changeController ，并将 middleware 和 reducer 打包合并成 _dispatchers 集合。注意看 _createReduceAndNotify 方法， 当每一个 action 发送到 Store 时，会交给 reducer 处理，并将新的 state 给 add 到 _changeController 里。这样就完成了状态的更新。。 是不是很简单。。。 观察者Redux 里观察者是 StoreConnector 。但是得先提一下 StoreProvider ， StoreProvider 是初始化和存储 Store 的 Widget 。 12345678910111213141516171819202122232425262728293031323334class StoreProvider&lt;S&gt; extends InheritedWidget &#123; final Store&lt;S&gt; _store; /// Create a [StoreProvider] by passing in the required [store] and [child] /// parameters. const StoreProvider(&#123; Key key, @required Store&lt;S&gt; store, @required Widget child, &#125;) : assert(store != null), assert(child != null), _store = store, super(key: key, child: child); static Store&lt;S&gt; of&lt;S&gt;(BuildContext context, &#123;bool listen = true&#125;) &#123; final type = _typeOf&lt;StoreProvider&lt;S&gt;&gt;(); final provider = (listen ? context.inheritFromWidgetOfExactType(type) : context .ancestorInheritedElementForWidgetOfExactType(type) ?.widget) as StoreProvider&lt;S&gt;; if (provider == null) throw StoreProviderError(type); return provider._store; &#125; // Workaround to capture generics static Type _typeOf&lt;T&gt;() =&gt; T; @override bool updateShouldNotify(StoreProvider&lt;S&gt; oldWidget) =&gt; _store != oldWidget._store;&#125; StoreProvider 也很简单，就是一个典型的 InheritedWidget 。 现在来看 StoreConnector ， 12345678910111213141516171819202122232425262728293031323334class StoreConnector&lt;S, ViewModel&gt; extends StatelessWidget &#123; const StoreConnector(&#123; Key key, @required this.builder, @required this.converter, this.distinct = false, this.onInit, this.onDispose, this.rebuildOnChange = true, this.ignoreChange, this.onWillChange, this.onDidChange, this.onInitialBuild, &#125;) : assert(builder != null), assert(converter != null), super(key: key); @override Widget build(BuildContext context) &#123; return _StoreStreamListener&lt;S, ViewModel&gt;( store: StoreProvider.of&lt;S&gt;(context), builder: builder, converter: converter, distinct: distinct, onInit: onInit, onDispose: onDispose, rebuildOnChange: rebuildOnChange, ignoreChange: ignoreChange, onWillChange: onWillChange, onDidChange: onDidChange, onInitialBuild: onInitialBuild, ); &#125;&#125; 可以看出来，StoreConnector 只是一个壳，实际的工作者是 _StoreStreamListener 。 StoreConnect 唯一做的工作就是调用 StoreProvider.of&lt;S&gt;(context) 给 _StoreStreamListener 的 store 赋值。 _StoreStreamListener 是一个 StatefulWidget 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class _StoreStreamListenerState&lt;S, ViewModel&gt; extends State&lt;_StoreStreamListener&lt;S, ViewModel&gt;&gt; &#123; @override void initState() &#123; ... latestValue = widget.converter(widget.store); _createStream(); super.initState(); &#125; @override Widget build(BuildContext context) &#123; return widget.rebuildOnChange ? StreamBuilder&lt;ViewModel&gt;( stream: stream, builder: (context, snapshot) =&gt; widget.builder( context, latestValue, ), ) : widget.builder(context, latestValue); &#125; void _createStream() &#123; stream = widget.store.onChange .where(_ignoreChange) .map(_mapConverter) .where(_whereDistinct) .transform(StreamTransformer.fromHandlers(handleData: _handleChange)); &#125; ViewModel _mapConverter(S state) &#123; return widget.converter(widget.store); &#125; bool _whereDistinct(ViewModel vm) &#123; if (widget.distinct) &#123; return vm != latestValue; &#125; return true; &#125; void _handleChange(ViewModel vm, EventSink&lt;ViewModel&gt; sink) &#123; ... latestValue = vm; ... sink.add(vm); &#125;&#125; 在 build 方法中 widget.rebuildOnChange 默认为 true 。StreamBuilder 将 stream 转化为 widget 。stream 就是对 widget.store.onChange (Store 里的 _changeController) 的监听。 需要说明的是， StoreConnector 只是在 Flutter Framework 基础上添加的额外的监听机制。之前自己一直有个误区： 当 StoreConnector 的外部 Widget 执行 rebuild 之后， StoreConnector 可以控制 child 不 rebuild ，只要 vm 没有发生改变。这显然不正确。有空可以看看 StreamBuilder 的源码。 Action 事件的执行12345class Store &#123; dynamic dispatch(dynamic action) &#123; return _dispatchers[0](action); &#125;&#125; 。。。很简单， Store.dispath 从 _dispatchers 的第一个位置开始分发事件。。","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"},{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}],"keywords":[]},{"title":"源码探究Activity的生命周期","slug":"Android/Framework/源码探究Activity的生命周期","date":"2021-01-02T07:00:33.000Z","updated":"2022-08-25T05:59:46.950Z","comments":true,"path":"2021/01/02/Android/Framework/源码探究Activity的生命周期/","link":"","permalink":"http://yoursite.com/2021/01/02/Android/Framework/源码探究Activity的生命周期/","excerpt":"startActivitystartActivity有很多重载方法，最终都会调用startActivityForResult","text":"startActivitystartActivity有很多重载方法，最终都会调用startActivityForResult 然后的调用过程12-&gt; Activit.startActivityForResult(...) -&gt; Instrumentation.execStartActivity(...) 在 Instrumentation.execStartActivity 调用了 ActivityManager.getService().startActivity(...) ，后续的流程进入到了系统进程 123456-&gt; ActivityManagerService.startActivity(...) -&gt; ...startActivityAsUser(...) -&gt; ActivityStarter.execute() -&gt; ...startActivityMayWait() -&gt; ...startActivity() -&gt; ...startActivityUnchecked(...) startActivityUnchecked 是一个很重要的方法，这个方法里会根据启动标志位和Activity启动模式来决定如何启动一个Activity以及是否要调用deliverNewIntent方法通知Activity有一个Intent试图重新启动它。因为这里只讨论住 activity 启动的主流程，所以先不看这个。 startActivityUnchecked 之后的调用过程如下 1234-&gt; ActivityStarter.startActivityUnchecked(...) -&gt; ActivityStackSupervisor.resumeFocusedStackTopActivityLocked(...) -&gt; ActivityStack.resumeTopActivityUncheckedLocked(...) -&gt; ...resumeTopActivityInnerLocked(...) 在 resumeTopActivityInnerLocked 中会先对 resume 状态的 activity 执行 pause。 123456789101112131415161718private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ... boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false); if (mResumedActivity != null) &#123; pausing |= startPausingLocked(userLeaving, false, next, false); &#125; ... // 开始进行真正最终真正的activity启动 mStackSupervisor.startSpecificActivityLocked(next, true, true); try &#123; next.completeResumeLocked(); &#125; catch (Exception e) &#123; ... &#125; ... return true;&#125; activity 的 pause 过程startPausingLocked 之后会执行 startPausingLocked 12345678910111213141516171819202122final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming, boolean pauseImmediately) &#123; ... if (prev.app != null &amp;&amp; prev.app.thread != null) &#123; try &#123; mService.updateUsageStats(prev, false); // Android 9.0在这里引入了ClientLifecycleManager和 // ClientTransactionHandler来辅助管理Activity生命周期， // 注意这里是在系统进程， prev.app.thread 是应用进程的binder对象 mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving, prev.configChangeFlags, pauseImmediately)); &#125; catch (Exception e) &#123; ... &#125; &#125; else &#123; mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; ...&#125; 123456789101112131415161718192021void scheduleTransaction(@NonNull IApplicationThread client, @NonNull IBinder activityToken, @NonNull ActivityLifecycleItem stateRequest) throws RemoteException &#123; final ClientTransaction clientTransaction = transactionWithState(client, activityToken, stateRequest); scheduleTransaction(clientTransaction);&#125;private static ClientTransaction transactionWithState(@NonNull IApplicationThread client, @NonNull IBinder activityToken, @NonNull ActivityLifecycleItem stateRequest) &#123; final ClientTransaction clientTransaction = ClientTransaction.obtain(client, activityToken); clientTransaction.setLifecycleStateRequest(stateRequest); return clientTransaction;&#125;void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; final IApplicationThread client = transaction.getClient(); transaction.schedule(); if (!(client instanceof Binder)) &#123; transaction.recycle(); &#125;&#125; Android 9.0在这里引入了ClientLifecycleManager和 ClientTransactionHandler来辅助管理Activity生命周期， startPausingLocked生成了一个 PauseActivityItem 然后，ClientLifecycleManager 会将参数打包为一个 ClientTransaction 并设置一个改变生命周期的request。 1234// ClientTransactionpublic void schedule() throws RemoteException &#123; mClient.scheduleTransaction(this);&#125; schedule() 将工作转给了 mClient ，mClient 是 transactionWithState 中传入的，是一个 IApplicationThread，这是一个APP进程的binder对象。 在 pause 流程中代表要pause的activity所在的进程。IApplicationThread 的实现是 ActivityThread 的内部类 ApplicationThread 。这里通过binder调用从 系统进程转到了应用进程。 12345678910111213141516171819202122// ApplicationThread@Overridepublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; ActivityThread.this.scheduleTransaction(transaction);&#125;// ActivityThreadvoid scheduleTransaction(ClientTransaction transaction) &#123; transaction.preExecute(this); sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);&#125;// ActivityThreadprivate void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; Message msg = Message.obtain(); ... if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125; H extends Handler在上面可以看出，最终，向 mH 发送了一个 message 1234567891011public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; mTransactionExecutor.execute(transaction); ... break; ... &#125;&#125; msg.what 是 ActivityThread.H.EXECUTE_TRANSACTION 。将activity生命周期的变换任务交给了 TransactionExecutor 123456789101112131415161718192021public void execute(ClientTransaction transaction) &#123; final IBinder token = transaction.getActivityToken(); // 如果有callback先执行callback，后面有使用到这个特性 executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear(); log(\"End resolving transaction\");&#125;private void executeLifecycleState(ClientTransaction transaction) &#123; final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest(); ... // Cycle to the state right before the final requested state. cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */); // Execute the final transition with proper parameters. lifecycleItem.execute(mTransactionHandler, token, mPendingActions); lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);&#125; 在 TransactionExecutor 中从 ClientTransaction 获取 ActivityLifecycleItem ， 并执行 execute 和 postExecute 。 由于我们传入的是 PauseActivityItem ， 所以真正执行的代码还是在系统进程的 PauseActivityItem 里。 123456789101112131415161718192021@Overridepublic void execute(ClientTransactionHandler client, IBinder token,PendingTransactionActions pendingActions) &#123; // PauseActivityItem.execute 中调用的是 ClientTransactionHandler.handlePauseActivity // ActivityThread 继承了 ClientTransactionHandler。 其实调用的还是 ActivityThread // 这里执行是在系统进程，client.xxxx 回到了应用进程，这是一个跨进程调用？？ client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions, \"PAUSE_ACTIVITY_ITEM\");&#125;@Overridepublic void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; if (mDontReport) &#123; return; &#125; try &#123; // TODO(lifecycler): Use interface callback instead of AMS. ActivityManager.getService().activityPaused(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; 12345678910111213141516171819202122232425262728// ActivityThread@Overridepublic void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, PendingTransactionActions pendingActions, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null) &#123; if (userLeaving) &#123; performUserLeavingActivity(r); &#125; r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(r, finished, reason, pendingActions); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; mSomeActivitiesChanged = true; &#125;&#125;private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) &#123; try &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); &#125; ... r.setState(ON_PAUSE);&#125; 1234// Instrumentationpublic void callActivityOnPause(Activity activity) &#123; activity.performPause();&#125; 新activity启动1234567891011121314151617181920212223// ActivityStackSupervisor void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); getLaunchTimeTracker().setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; // app.thread 不为空，表示对应的进程存在，直接启动activity ... realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; ... &#125; &#125; // 进程不存在，创建进程 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true); &#125; startSpecificActivityLocked 中会判断要跳转的 activity 所在的进程是否已经存在，如果存在，则调用 realStartActivityLocked ，如果没有存在，则调用 mService.startProcessLocked 创建进程。 先看看应用进程不存在的情况。之后的调用栈如下：1234-&gt; ActivityManagerService.startProcessLocked -&gt; ...startProcessLocked -&gt; ...startProcess -&gt; Process.start 12345-&gt; Process.start -&gt; zygoteProcess.start -&gt; ...startViaZygote -&gt; ...zygoteSendArgsAndGetResult -&gt; ...openZygoteSocketIfNeeded 123456789101112131415161718192021222324252627282930313233private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; Preconditions.checkState(Thread.holdsLock(mLock), \"ZygoteProcess lock not held\"); if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; primaryZygoteState = ZygoteState.connect(mSocket); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; maybeSetApiBlacklistExemptions(primaryZygoteState, false); maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState); &#125; if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; // The primary zygote didn't match. Try the secondary. if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; secondaryZygoteState = ZygoteState.connect(mSecondarySocket); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; maybeSetApiBlacklistExemptions(secondaryZygoteState, false); maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState); &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; 。。。这里没太看懂，但是网上的文章说 “其最终调用了Zygote并通过socket通信的方式让Zygote进程fork出一个新的进程，并根据传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法对其进行初始化。“ 。。。不知道他是怎么看出来的。。记个 TODO 吧 启动 activity1234567891011121314151617181920212223242526272829303132// ActivityStackSupervisor final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ... // Create activity launch transaction. final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread, r.appToken); // 设置 callback ，先执行 activity 的 launch 和 onCreate clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, mService.isNextTransitionForward(), profilerInfo)); // Set desired final state. final ActivityLifecycleItem lifecycleItem; // 再执行 onResume if (andResume) &#123; lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward()); &#125; else &#123; lifecycleItem = PauseActivityItem.obtain(); &#125; clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. 进入app进程 mService.getLifecycleManager().scheduleTransaction(clientTransaction); ... return true; &#125; 这里核心是创建了一个 ClientTransaction ，先添加了一个 LaunchActivityItem 作为 callback ， ClientTransaction 在调度是会先执行 callback 。然后设置 LifecycleStateRequest ，这里传入的 andResume == true ，所以设置的是 ResumeActivityItem 。 因为在之前 ClientTransaction 的调度流程已经分析过了，我们直接先来看 LaunchActivityItem.execute activity 的 onCreate12345678910111213141516171819// LaunchActivityItem@Overridepublic void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mIsForward, mProfilerInfo, client); client.handleLaunchActivity(r, pendingActions, null /* customIntent */);&#125;// ActivityThreadpublic Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; ... final Activity a = performLaunchActivity(r, customIntent); ... return a;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697 private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // 初始化ComponentName ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; // 这个 appContext 是 activity 的 baseContext 。 不清楚作用是什么 ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; // 创建 activity java.lang.ClassLoader cl = appContext.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ... &#125; try &#123; // 拿到Application // 在 ActivityThread#bindApplication 的使用已经实例化了applicaiton对象了。 // 这里实际上不会创建 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; ... // Application、Activity和ContextImpl互相关联 appContext.setOuterContext(activity); // 调用 activity 的 attach activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; // 设置Activity的Theme int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; // 调用 activity 的 onCreate 生命周期 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); &#125; r.activity = activity; &#125; r.setState(ON_CREATE); mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; return activity; &#125;// Instrumentation public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; String pkg = intent != null &amp;&amp; intent.getComponent() != null ? intent.getComponent().getPackageName() : null; // instantiateActivity 利用传入的 ClassLoader ，利用 return getFactory(pkg).instantiateActivity(cl, className, intent); &#125; 在 performLaunchActivity 中创建了 activity ，并将 context 和 application 与之绑定，执行 activity.attach 。接下来，performLaunchActivity 里通过调用 mInstrumentation.callActivityOnCreate ，开始进行 onCreate 的流程。 123456// Instrumentation public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); &#125; activity 的 onStart前面我们走完了 activity 的 onCreate 过程，执行代码是在 LaunchActivityItem 中，然后 onResume 显然是在 ResumeActivityItem 里， 那 onStart 呢？？ 再回到 ClientTransaction 的调度流程中来， 在 TransactionExecutor 里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// TransactionExecutorpublic void execute(ClientTransaction transaction) &#123; final IBinder token = transaction.getActivityToken(); executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear();&#125;private void executeLifecycleState(ClientTransaction transaction) &#123; final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest(); if (lifecycleItem == null) &#123; // No lifecycle request, return early. return; &#125; final IBinder token = transaction.getActivityToken(); final ActivityClientRecord r = mTransactionHandler.getActivityClient(token); if (r == null) &#123; // Ignore requests for non-existent client records for now. return; &#125; // Cycle to the state right before the final requested state. cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */); // Execute the final transition with proper parameters. lifecycleItem.execute(mTransactionHandler, token, mPendingActions); lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);&#125;private void cycleToPath(ActivityClientRecord r, int finish, boolean excludeLastState) &#123; final int start = r.getLifecycleState(); final IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState); performLifecycleSequence(r, path);&#125;/** Transition the client through previously initialized state sequence. */private void performLifecycleSequence(ActivityClientRecord r, IntArray path) &#123; final int size = path.size(); for (int i = 0, state; i &lt; size; i++) &#123; state = path.get(i); switch (state) &#123; ... case ON_START: mTransactionHandler.handleStartActivity(r, mPendingActions); break; ... &#125; &#125;&#125; 在 TransactionExecutor 中先执行 callback ，然后 lifecycleItem.execute 。中间有一个 cycleToPath 方法。 cycleToPath 内部逻辑很明显，执行 start 和 finish 中间状态的逻辑。 对于 ResumeActivityItem 来说就会执行 onStart 的逻辑。。。 我佛了。 activity 之后的 start 过程和 create 过程基本一致。现在再来看看 onResume 12345678910111213141516171819202122232425// ResumeActivityItem @Override public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; client.handleResumeActivity(token, true /* finalStateRequest */, mIsForward, \"RESUME_ACTIVITY\"); &#125;// ActivityThread @Override public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; ... // 执行 activity#onResume final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); ... final Activity a = r.activity; ... // 绑定 ViewRootImpl ... Looper.myQueue().addIdleHandler(new Idler()); &#125; handleResumeActivity 中操作了很多 window 相关的东西。 到这里 activity 的启动就完成了 activity 的 stop 和 destroy之前分析了 onPause 的流程， 但是没有看到 onStop ， 所以 onStop 是如何执行的呢。onStop的执行有两种case： activity a 启动 activity b ， a.onStop 应该在 a.onPause b.onResume 之后执行。 activity b 退出销毁，b.onStop 应该在 b.onPause 和 a.onResume 之后 来直接看执行puase的地方 123456789101112131415161718public class PauseActivityItem extends ActivityLifecycleItem &#123; @Override public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions, \"PAUSE_ACTIVITY_ITEM\"); &#125; @Override public int getTargetState() &#123; return ON_PAUSE; &#125; @Override public void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; ActivityManager.getService().activityPaused(token); &#125;&#125; poseExecute 的执行在 execute 之后； pause完后会通知给ams。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// ActivityManagerService@Overridepublic final void activityPaused(IBinder token) &#123; synchronized(this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) &#123; stack.activityPausedLocked(token, false); &#125; &#125;&#125;// ActivityStackfinal void activityPausedLocked(IBinder token, boolean timeout) &#123; final ActivityRecord r = isInStackLocked(token); if (r != null) &#123; // 去除anr判定 mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r); if (mPausingActivity == r) &#123; mService.mWindowManager.deferSurfaceLayout(); try &#123; // 打开新页面，进入下一步 completePauseLocked(true /* resumeNext */, null /* resumingActivity */); &#125; finally &#123; mService.mWindowManager.continueSurfaceLayout(); &#125; return; &#125; else &#123; if (r.isState(PAUSING)) &#123; r.setState(PAUSED, \"activityPausedLocked\"); if (r.finishing) &#123; // 退出当前页面，执行销毁流程 finishCurrentActivityLocked(r, FINISH_AFTER_VISIBLE, false, \"activityPausedLocked\"); &#125; &#125; &#125; &#125; mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);&#125;private void completePauseLocked(boolean resumeNext, ActivityRecord resuming) &#123; ActivityRecord prev = mPausingActivity; if (prev != null) &#123; prev.setWillCloseOrEnterPip(false); final boolean wasStopping = prev.isState(STOPPING); // 正常应该为false？ prev.setState(PAUSED, \"completePausedLocked\"); if (prev.finishing) &#123; // 退出当前页面，执行销毁流程。 FINISH_AFTER_VISIBLE 注意这个标志位 prev = finishCurrentActivityLocked(prev, FINISH_AFTER_VISIBLE, false, \"completedPausedLocked\"); &#125; else if (prev.app != null) &#123; if (mStackSupervisor.mActivitiesWaitingForVisibleActivity.remove(prev)) &#123; if (prev.deferRelaunchUntilPaused) &#123; prev.relaunchActivityLocked(false /* andResume */,prev.preserveWindowOnDeferredRelaunch); &#125; else if (wasStopping) &#123; prev.setState(STOPPING, \"completePausedLocked\"); &#125; else if (!prev.visible || shouldSleepOrShutDownActivities()) &#123; prev.setDeferHidingClient(false); // 添加到shopping等待集合中 addToStopping(prev, true /* scheduleIdle */, false /* idleDelayed */); &#125; &#125; else &#123; prev = null; &#125; ... mPausingActivity = null; &#125; &#125;&#125;final ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj, String reason) &#123; final ActivityRecord next = mStackSupervisor.topRunningActivityLocked(true /* considerKeyguardState */); if (mode == FINISH_AFTER_VISIBLE &amp;&amp; (r.visible || r.nowVisible) // FINISH_AFTER_VISIBLE 注意这个标记位 &amp;&amp; next != null &amp;&amp; !next.nowVisible) &#123; if (!mStackSupervisor.mStoppingActivities.contains(r)) &#123; addToStopping(r, false /* scheduleIdle */, false /* idleDelayed */); &#125; r.setState(STOPPING, \"finishCurrentActivityLocked\"); ... return r; &#125; ... if (mode == FINISH_IMMEDIATELY // FINISH_IMMEDIATELY 注意这个标记位 || (prevState == PAUSED &amp;&amp; (mode == FINISH_AFTER_PAUSE || inPinnedWindowingMode())) || finishingActivityInNonFocusedStack || prevState == STOPPING || prevState == STOPPED || prevState == ActivityState.INITIALIZING) &#123; r.makeFinishingLocked(); boolean activityRemoved = destroyActivityLocked(r, true, \"finish-imm:\" + reason); ... return activityRemoved ? null : r; &#125; ...&#125; 上面的代码中，activity在pause之后，无论是finish还是非finish的流程。 都不会立刻执行 stop 和 destroy开始执行 stop 和 destroy ，是在下一个 activity resume 之后来看 resume 之后做了啥 12345678910111213141516171819202122232425262728// ActivityThread@Overridepublic void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; ... final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); ... Looper.myQueue().addIdleHandler(new Idler());&#125;private class Idler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; ... if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123; try &#123; am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; ... return false; &#125;&#125; 在activity#resume 之后，会发送一个 idleHandler ， 在消息队列空闲时调用 ams#activityIdle 开始上一个activity的销毁流程。因为是一个 idleHandler ，只会在空闲时执行，所以，所以有可能一个页面退出后，很长时间都不执行 stop 和 destroy。 但是系统有一个10s的兜底，10s后一定会执行 stop 和 destroy 123456789101112131415161718// ActivityManagerServicepublic final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123; final long origId = Binder.clearCallingIdentity(); synchronized (this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) &#123; ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false /* fromTimeout */, false /* processPausingActivities */, config); if (stopProfiling) &#123; if ((mProfileProc == r.app) &amp;&amp; mProfilerInfo != null) &#123; clearProfilerLocked(); &#125; &#125; &#125; &#125; Binder.restoreCallingIdentity(origId);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// ActivityStackSupervisor.javafinal ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, boolean processPausingActivities, Configuration config) &#123; ... // 取出所有的之前 shopping 的 activity final ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r, true /* remove */, processPausingActivities); ... for (int i = 0; i &lt; NS; i++) &#123; r = stops.get(i); final ActivityStack stack = r.getStack(); if (stack != null) &#123; if (r.finishing) &#123; // 如果是销毁一个activity stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false, \"activityIdleInternalLocked\"); &#125; else &#123; // 只是 stop stack.stopActivityLocked(r); &#125; &#125; &#125; ... return r;&#125;// ActivityStackfinal ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj, String reason) &#123; ... if (mode == FINISH_IMMEDIATELY // 这里为true || (prevState == PAUSED &amp;&amp; (mode == FINISH_AFTER_PAUSE || inPinnedWindowingMode())) || finishingActivityInNonFocusedStack || prevState == STOPPING || prevState == STOPPED || prevState == ActivityState.INITIALIZING) &#123; r.makeFinishingLocked(); boolean activityRemoved = destroyActivityLocked(r, true, \"finish-imm:\" + reason); .... return activityRemoved ? null : r; &#125; ...&#125;final boolean destroyActivityLocked(ActivityRecord r, boolean removeFromApp, String reason) &#123; final boolean hadApp = r.app != null; ... if (hadApp) &#123; ... try &#123; mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken, DestroyActivityItem.obtain(r.finishing, r.configChangeFlags)); &#125; catch (Exception e) &#123; ... &#125; &#125; ... return removedFromHistory;&#125;// ActivityStackfinal void stopActivityLocked(ActivityRecord r) &#123; ... mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken, StopActivityItem.obtain(r.visible, r.configChangeFlags)); ...&#125; 先判断 r.finishing 如果为true，表示页面退出，执行destroy； 如果为false，则只执行stop。经过一番调用，最终还是一样，向 ClientLifecycleManager 发送了一个 StopActivityItem 和 DestroyActivityItem。 stop 和 destroy 系统10s兜底在 ActivityRecord.completeResumeLocked 会在activity resume 之后调用，在这个方法中会调用ActivityStackSuperVisor.scheduleIdleTimeoutLocked()123456789void scheduleIdleTimeoutLocked(ActivityRecord next) &#123; Message msg = mHandler.obtainMessage(IDLE_TIMEOUT_MSG, next); mHandler.sendMessageDelayed(msg, IDLE_TIMEOUT); // IDLE_TIMEOUT 是 10*1000&#125;// case IDLE_TIMEOUT_MSG: &#123;// activityIdleInternal((ActivityRecord) msg.obj, true /* processPausingActivities */);// &#125; break;// &#125; anr的判定参考（Android 9.0）Activity启动流程源码分析Activity启动过程全解析炼狱难度！腾讯Android高级岗：为什么 Activity.finish() 之后 10s 才 onDestroy ？","categories":[],"tags":[{"name":"Activity","slug":"Activity","permalink":"http://yoursite.com/tags/Activity/"}],"keywords":[]},{"title":"Fragment可见性总结","slug":"Android/Fragment可见性总结","date":"2020-10-04T10:28:37.000Z","updated":"2021-10-03T01:57:41.022Z","comments":true,"path":"2020/10/04/Android/Fragment可见性总结/","link":"","permalink":"http://yoursite.com/2020/10/04/Android/Fragment可见性总结/","excerpt":"onResume()/onPause()不要用这两个方法为可见性依据做操作。 触发onResume()/onPause()的场景有很多","text":"onResume()/onPause()不要用这两个方法为可见性依据做操作。 触发onResume()/onPause()的场景有很多 Activity执行onResume()/onPause()，其所有的 Fragment 都会的 onResume()/onPause() 方法，即使Fragment是状态是隐藏的 在当前Activity中添加一个Fragment时，被添加的Fragment都会调用onResume，这包括通过add和replace的方式添加；在Fragment销毁的情况下都会触发onPause，如果是add到回退栈的情况，back键就会触发onPause，如果是replace的情况，则被替换掉的Fragment会触发onPause。 ViewPager 预加载： 被预加载的Fragment也会执行 onResume()/onPause() isVisible()注释说是可以用来判断其可见性，但是如果你是在Fragment的onResume/onPause方法中调用这两个方法判断是不准确的，onResume的方法中isVisible()有可能为false, 而onPause的方法中isVisible()也有可能为true。 onHiddenChanged()就是对Fragment进行show和hide的时候会回调onHiddenChanged方法。除此之外的操作，如add/replace/remove都不会触发这个方法。 setUserVisibleHint()/getUserVisibleHint()getUserVisibleHint() 默认返回true， 只有和 ViewPager 配合使用有效，ViewPager 选中的 fragment 调用 getUserVisibleHint() 会返回true。 在ViewPager2无效 判断fragment是否可见的保险操作？？ maybe12final boolean parentVisible = parentFragment == null ? true : parentFragment.isVisible()=final boolean visible = isVisible() &amp;&amp; parentVisible &amp;&amp; getUserVisibleHint()","categories":[],"tags":[{"name":"Fragment","slug":"Fragment","permalink":"http://yoursite.com/tags/Fragment/"}],"keywords":[]},{"title":"RenderObject 原理","slug":"Flutter/RenderObject-原理","date":"2020-09-22T08:28:21.000Z","updated":"2021-10-03T01:57:41.031Z","comments":true,"path":"2020/09/22/Flutter/RenderObject-原理/","link":"","permalink":"http://yoursite.com/2020/09/22/Flutter/RenderObject-原理/","excerpt":"ParentData 和各种 Mixin123456789101112131415161718192021222324252627282930@startumlBoxParentData --|&gt; ParentDataContainerParentDataMixin --|&gt; ParentDataContainerBoxParentData --|&gt; BoxParentDataContainerBoxParentData --|&gt; ContainerParentDataMixinRenderObject *-- ParentDataRenderObjectWithChildMixin --|&gt; RenderObjectContainerRenderObjectMixin --|&gt; RenderObjectclass ContainerParentDataMixin&#123;+ previousSlibling+ nextSibling&#125;class ContainerRenderObjectMixin &#123;+ firstChild *-- ContainerParentDataMixin+ lastChild+ childCount&#125;class BoxParentData&#123;+ offset&#125;class RenderObject&#123;+ parentData&#125;@enduml","text":"ParentData 和各种 Mixin123456789101112131415161718192021222324252627282930@startumlBoxParentData --|&gt; ParentDataContainerParentDataMixin --|&gt; ParentDataContainerBoxParentData --|&gt; BoxParentDataContainerBoxParentData --|&gt; ContainerParentDataMixinRenderObject *-- ParentDataRenderObjectWithChildMixin --|&gt; RenderObjectContainerRenderObjectMixin --|&gt; RenderObjectclass ContainerParentDataMixin&#123;+ previousSlibling+ nextSibling&#125;class ContainerRenderObjectMixin &#123;+ firstChild *-- ContainerParentDataMixin+ lastChild+ childCount&#125;class BoxParentData&#123;+ offset&#125;class RenderObject&#123;+ parentData&#125;@enduml ParentData在 Flutter 的布局系统中，该类负责存储父节点所需要的子节点的布局信息 BoxParentData– offset包含有一个 offset 属性，该属性用于存储 child 的布局信息，也就是 child 应该被摆在哪个位置。与 Android 不同，Flutter并不是以父View为坐标基础进行绘制的，所以需要带上 offset 参数，得到一个累加的偏移值。至于偏移的参考点在哪里，可以看下面的绘制阶段的原理解析。 ContainerParentDataMixin– previousSibling– nextSibling该类使用频率很高，基本上所有父节点的 ParentData 都混入了该类，该类需要与ContainerRenderObjectMixin 共同使用，主要解决了对 child 的管理，previousSibling nextSibling 都是child RenderObject, 从而组成把父节点的所有 child 组成了一个双链表 ContainerBoxParentData空类，继承了 BoxParentData 并且混入了 ContainerParentDataMixin， 使其拥有二者的能力 RenderObjectFlutter 中真正实现布局和绘制的类 RenderObjectWithChildMixin实现对只有一个child的管理 ContainerRenderObjectMixin– firstChild– lastChild– childCount实现对多child的管理，firstChild、lastChild、childCount，用来获取首末 child，child的个数，配合使用 ContainerParentDataMixin 中的 previousSibling、nextSibling就可以对 child 进行遍历了。child 的insert、remove、move等操作都在这个Mixin中实现 除了以上的类，Flutter 还提供了 RenderBoxContainerDefaultsMixin，该类提供了一些 RenderBox 默认的行为方法，如上面绘制 child 的流程调用该类中的 defaultPaint(PaintingContext context, Offset offset) 就可以了，可以简化一些模板代码。 layout在 RenderBox 中，控件大小的值为 _size 成员，它只包含宽高两个属性值，我们可以通过该成员的 set 和 get 方法访问或修改它的值。在测量时( layout 方法中)，parent 会传给当前 RenderBox 一个大小的限制，为 BoxConstraints 类型，最后测量得到的 size 必须满足这个限制，在 Flutter 的 debug 模式下对 size 是否满足 constraints 做了 assert 检查，如果检查未通过就会布局失败。所以测量上我们要做的是下面两点： 如果没有 child，那么根据自身的属性计算出满足 constraints 的 size. 如果有 child，那么综合自身的属性和 child 的测量结果计算出满足 constraints 的 size. 测量和布局都在layout方法中完成 12345678910111213141516171819202122232425262728293031323334void layout(Constraints constraints, &#123; bool parentUsesSize = false &#125;) &#123; RenderObject relayoutBoundary; if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) &#123; relayoutBoundary = this; &#125; else &#123; final RenderObject parent = this.parent; relayoutBoundary = parent._relayoutBoundary; &#125; if (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123; return; &#125; _constraints = constraints; if (_relayoutBoundary != null &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123; visitChildren((RenderObject child) &#123; child._cleanRelayoutBoundary(); &#125;); &#125; _relayoutBoundary = relayoutBoundary; if (sizedByParent) &#123; try &#123; performResize(); &#125; catch (e, stack) &#123; _debugReportException('performResize', e, stack); &#125; &#125; try &#123; performLayout(); markNeedsSemanticsUpdate(); &#125; catch (e, stack) &#123; _debugReportException('performLayout', e, stack); &#125; _needsLayout = false; markNeedsPaint();&#125; parentUsesSize layout 方法中由父节点传入，表示父节点的 size 依赖当前节点的 size constraints layout 方法中从父节点传入，当前节点会从更新到自己的变量中保存 relayoutBoundary relayoutBoundary 是framework层自动设置的，如果满足 (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) 则该节点是一个 relayoutBoundary, 否则会从父节点寻找。 sizedByParent &amp; performResize() 这两个必须成对配置，performResize() 方法如果被重写，sizedByParent 也必须重写为true，并且你不应该在 perfromLayout() 方法中对 size 重新赋值。 sizedByParent 意为该控件的大小是否能仅通过 parent 赋予它的 constraints 就可以被确定下来了，即该控件的大小与它自身的属性和与它的 child 都无关，比如如果一个控件永远充满 parent 的大小，那么 sizedByParent 就应该返回 true。 这个操作不是必须的 官方文档中说这是一个优化项，如果完全不care这个，sizedByParent = false，那始终是正确的。 我的理解是，把 size 的计算单独抽出，避免每次 relayout 时对 size 重新计算。 performResize() 这个方法名字可能会造成误会，认为测量必须放在这里，其实大多是情况下，测量和布局都在 performLayout() 中 performLayout() 上面已经说得差不多了 如果是在标脏后，在一帧绘制的回调中刷新布局，不会调用layout方法，而是调用_layoutWithoutSize 12345678910void _layoutWithoutResize() &#123; try &#123; performLayout(); markNeedsSemanticsUpdate(); &#125; catch (e, stack) &#123; _debugReportException('performLayout', e, stack); &#125; _needsLayout = false; markNeedsPaint();&#125; paint父节点绘制子节点的入口 paintContext.paintChild() 123456789101112131415161718192021222324252627282930313233343536373839404142void paintChild(RenderObject child, Offset offset) &#123; if (child.isRepaintBoundary) &#123; stopRecordingIfNeeded(); _compositeChild(child, offset); &#125; else &#123; child._paintWithContext(this, offset); &#125;&#125;void _compositeChild(RenderObject child, Offset offset) &#123; // Create a layer for our child, and paint the child into it. if (child._needsPaint) &#123; // 这个方法会创建layer，然后再调用 child._paintWithContext 方法 repaintCompositedChild(child, debugAlsoPaintedParent: true); &#125; else &#123; &#125; final OffsetLayer childOffsetLayer = child._layer; childOffsetLayer.offset = offset; appendLayer(child._layer);&#125;static void _repaintCompositedChild( RenderObject child, &#123; bool debugAlsoPaintedParent = false, PaintingContext childContext,&#125;) &#123; OffsetLayer childLayer = child._layer; if (childLayer == null) &#123; child._layer = childLayer = OffsetLayer(); &#125; else &#123; childLayer.removeAllChildren(); &#125; childContext ??= PaintingContext(child._layer, child.paintBounds); child._paintWithContext(childContext, Offset.zero); childContext.stopRecordingIfNeeded();&#125;@protectedvoid appendLayer(Layer layer) &#123; layer.remove(); _containerLayer.append(layer);&#125; 在 paintChild 方法中，若 child 是一个 repaintBoundary ，会为 child 创建一个 layer ，然后再调用 child._paintWithContext(this, offset) ；如果 isRepaintBoundary 为false，则直接调用 child._paintWithContext(this, offset)。。所以这个layer又是怎样？？？ 在drawFrame()中，paint 标脏节点刷新时会直接执行 PaintContext.repaintCompositeChild() _paintWithContext(..) &amp; paint() 12345678910111213void _paintWithContext(PaintingContext context, Offset offset) &#123; if (_needsLayout) return; RenderObject debugLastActivePaint; _needsPaint = false; try &#123; paint(context, offset); &#125; catch (e, stack) &#123; _debugReportException('paint', e, stack); &#125;&#125;void paint(PaintingContext context, Offset offset) &#123; &#125; RenderObject 中的 paint 是一个空方法，交给子类来实现。 以 RenderFlex 为例： 123456789101112131415161718@overridevoid paint(PaintingContext context, Offset offset) &#123; if (!_hasOverflow) &#123; defaultPaint(context, offset); return; &#125; ...&#125;void defaultPaint(PaintingContext context, Offset offset) &#123; ChildType child = firstChild; while (child != null) &#123; final ParentDataType childParentData = child.parentData; context.paintChild(child, childParentData.offset + offset); child = childParentData.nextSibling; &#125;&#125; 因为Flex没有要绘制的内容，所以调用 RenderBoxContainerDefaultsMixin 提供的默认实现。在 defaultPaint 中遍历child，绘制child时将 childParentData.offset累加到offset中。所以，这个 offset 的基准到底是个啥？？？？ PaintingContext 和 LayerdrawFrame()PaintContext 可以类比于 BuildContext，Layer 和 Element 最终会组成一个 Layer树，最终渲染是在C++的engine层完成的。在flutter的framework层构成了一颗Layer树，传送到engine进行绘制。 回过头来看，在 drawFrame() 中对需要paint的节点是如何处理的。 12345678910void drawFrame() &#123; // BD ADD: Boost.resetIdleCallbacks(); assert(renderView != null); pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); renderView.compositeFrame(); // this sends the bits to the GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.&#125; 先直接来看 pipelineOwner.flushPaint(); 和里面调用到的 PaintContext._repaintCompositedChild 1234567891011121314151617void flushPaint() &#123; try &#123; final List&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint; _nodesNeedingPaint = &lt;RenderObject&gt;[]; // Sort the dirty nodes in reverse order (deepest first). for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123; if (node._needsPaint &amp;&amp; node.owner == this) &#123; if (node._layer.attached) &#123; PaintingContext.repaintCompositedChild(node); &#125; else &#123; node._skippedPaintingOnLayer(); &#125; &#125; &#125; &#125; finally &#123; &#125;&#125; PaintingContext._repaintCompositedChild(…) 123456789101112131415161718192021static void _repaintCompositedChild( RenderObject child, &#123; bool debugAlsoPaintedParent = false, PaintingContext childContext,&#125;) &#123; // 关注这个 assert，证明了最终需要 paint 的都是 RepaintBoundary 节点 assert(child.isRepaintBoundary); OffsetLayer childLayer = child._layer; if (childLayer == null) &#123; // 为 repaint boundaries 创建layer child._layer = childLayer = OffsetLayer(); &#125; else &#123; childLayer.removeAllChildren(); &#125; // 为 RepaintBoundary 创建 PaintContext childContext ??= PaintingContext(child._layer, child.paintBounds); // 初始化了Offset，说明offset的值是以layer为参考依据的 child._paintWithContext(childContext, Offset.zero); childContext.stopRecordingIfNeeded();&#125; 再次回顾 PaintingContext._repaintCompositedChild 方法，我们发现，它为 RepaintBoundary ，创建了PaintingContext 和 layer。 说明 RepaintBoundary 、PaintingContext 、layer 是一一对应的， 即 layer 是绘制的基本单位，只有 RepaintBoundary 极其子 RenderObject 共享一个layer， 每次绘制会创建都会为 layer 创建一个 PaintingContext。而 paint 过程中的offset的参考点，就是layer的左上角的坐标原点。 renderView.compositeFrame(); 12345678910111213void compositeFrame() &#123; Timeline.startSync('Compositing', arguments: timelineWhitelistArguments); try &#123; final ui.SceneBuilder builder = ui.SceneBuilder(); final ui.Scene scene = layer.buildScene(builder); if (automaticSystemUiAdjustment) _updateSystemChrome(); _window.render(scene); scene.dispose(); &#125; finally &#123; Timeline.finishSync(); &#125;&#125; renderView 是页面的根RenderObject，renderView.layer 是页面的根layer。 调用 layer.buildScene(builder); 生成了一个scene， 调用_window.render(scene) 发送给engine层进行渲染 Layer的标脏和局部刷新layer.buildScene 12345678910111213141516171819202122232425262728293031323334353637383940ui.Scene buildScene(ui.SceneBuilder builder) &#123; List&lt;PictureLayer&gt; temporaryLayers; updateSubtreeNeedsAddToScene(); addToScene(builder); _needsAddToScene = false; final ui.Scene scene = builder.build(); return scene;&#125;@overridevoid updateSubtreeNeedsAddToScene() &#123; super.updateSubtreeNeedsAddToScene(); Layer child = firstChild; while (child != null) &#123; child.updateSubtreeNeedsAddToScene(); _needsAddToScene = _needsAddToScene || child._needsAddToScene; // child.nextSibling 是下一个子layer， 这里显然是一个树的 层序遍历 child = child.nextSibling; &#125;&#125;/** * 这是 ContainerLayer 的实现， 没有子Layer的叶子 Layer 实现各不相同**/@overridevoid addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123; addChildrenToScene(builder, layerOffset);&#125;void addChildrenToScene(ui.SceneBuilder builder, [ Offset childOffset = Offset.zero ]) &#123; Layer child = firstChild; while (child != null) &#123; if (childOffset == Offset.zero) &#123; child._addToSceneWithRetainedRendering(builder); &#125; else &#123; child.addToScene(builder, childOffset); &#125; child = child.nextSibling; &#125;&#125; renderView 的 layer 是一个 OffsetLayer ，继承自 ContainerLayer 。Layer.buildScene(…) 这个方法在framework调用的地方很少，可以认为只有 renderView 的 layer 会调用 buildScene 方法创建创建一个 scene ， 即 scene 包含了页面的完整 layer 树。 首先会调用 updateSubtreeNeedsAddToScene ， 需要update的原因是， 如果子layer标脏， 那显然父layer 也需要标脏 _addToSceneWithRetainedRendering 1234567891011121314151617void markNeedsAddToScene() &#123; // Already marked. Short-circuit. if (_needsAddToScene) &#123; return; &#125; _needsAddToScene = true;&#125;void _addToSceneWithRetainedRendering(ui.SceneBuilder builder) &#123; if (!_needsAddToScene &amp;&amp; _engineLayer != null) &#123; builder.addRetained(_engineLayer); return; &#125; addToScene(builder); _needsAddToScene = false;&#125; markNeedAddToScene() 对 layer 节点进行标脏。在layer属性发生改变时会进行标脏；当子layer添加到父layer时也会进行标脏。 这个方法是唯一用到使用到 _needsAddToScene 标脏flag值的地方。 如果 _needsAddToScene 为false ，调用 builder.addRetained(_engineLayer); 这个 _engineLayer _eingineLayer 是 layer.addToScene(…) 返回的engine生成的图层（ContainerLayer例外，没有engineLayer） 123456789101112131415/** * 这是 OpacityLayer 的addToScene方法，生成了一个 engineLayer ， * 然后调用addChildrenToScene(builder);**/@overridevoid addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123; bool enabled = firstChild != null; // don't add this layer if there's no child if (enabled) engineLayer = builder.pushOpacity(alpha, offset: offset + layerOffset, oldLayer: _engineLayer); else engineLayer = null; addChildrenToScene(builder); if (enabled) builder.pop();&#125; SceneBuilder.addRetained() 123456void addRetained(EngineLayer retainedLayer) &#123; final _EngineLayerWrapper wrapper = retainedLayer; _addRetained(wrapper._nativeLayer);&#125;void _addRetained(EngineLayer retainedLayer) native 'SceneBuilder_addRetained'; addRetained 直接调用了engine层的代码，对layer进行复用。。。 直接使用 layer 进行UI绘制flutter最终是绘制在layer上的，那样的话，实际上，可以脱离 Widget、Element、RenderObject ，直接操作 layer 进行UI的绘制 1234567891011121314151617181920212223242526272829303132import 'dart:ui';import 'dart:math';import 'package:flutter/material.dart';import 'package:flutter/rendering.dart';void main()&#123; final OffsetLayer rootLayer = new OffsetLayer(); final PictureLayer pictureLayer = new PictureLayer(Rect.zero); rootLayer.append(pictureLayer); PictureRecorder recorder = PictureRecorder(); Canvas canvas = Canvas(recorder); Paint paint = Paint(); paint.color = Colors.primaries[Random().nextInt(Colors.primaries.length)]; canvas.drawRect(Rect.fromLTWH(0, 0, 300, 300), paint); pictureLayer.picture = recorder.endRecording(); SceneBuilder sceneBuilder = SceneBuilder(); rootLayer.addToScene(sceneBuilder); Scene scene = sceneBuilder.build(); window.onDrawFrame = ()&#123; window.render(scene); // window.scheduleFrame(); // 在onDrawFrame回调最后加上scheduleFrame，可以使UI不断刷新，进行动画操作 // 不是很懂那vsync的作用是什么。。。 &#125;; window.scheduleFrame();&#125; 参考在 main.dart 中添加 debugRepaintRainbowEnabled = true; ，或者通过 devtools 可以观察到App的layer树 Flutter Framework 源码解析（ 2 ）—— 图层详解 从源码看flutter（四）：Layer篇 Flutter画面渲染全面解析","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"},{"name":"RenderObject","slug":"RenderObject","permalink":"http://yoursite.com/tags/RenderObject/"}],"keywords":[]},{"title":"flutter ui源码 初步","slug":"Flutter/flutter-ui源码-初步","date":"2020-08-14T12:30:42.000Z","updated":"2021-10-03T01:57:41.031Z","comments":true,"path":"2020/08/14/Flutter/flutter-ui源码-初步/","link":"","permalink":"http://yoursite.com/2020/08/14/Flutter/flutter-ui源码-初步/","excerpt":"Widget, Element, RanderObject 三者之间的关系","text":"Widget, Element, RanderObject 三者之间的关系Widget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。 WidgetWidget类和Element类一一对应。Element是通过Widget生成的Widget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。 Widget.createElement() 创建Element对象 Widget.canUpdate(..)1234static bool canUpdate(Widget oldWidget, Widget newWidget) &#123; return oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key;&#125; 主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。 State一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息. createState() 用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，所以，本质上就是一个StatefulElement对应一个State实例。 widget和context widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext State如何被Widget复用只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(…)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。 Element最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。 下面从Element的 挂载、更新、卸载过程来描述Element mount根Element的mount 12345678- main() - runApp(..) - WidgetsFlutterBinding.attachRootWidget(app) - RenderObjectToWidgetAdapter&lt;RenderBox&gt;.attachToRenderTree(buildOwner, renderViewElement); - createElement() - BuildOwner.buildScope(element, () &#123; element.mount(null, null); &#125;) 以上是根Element的mount过程，其中rederViewElement是根Elemet ** Element的mount过程 首先来看一下常用的StatelessElement，StatefulElement的继承关系 12Element -&gt; ComponentElement -&gt; StatelessElement -&gt; StatefulElement 12345678- mount() - Element.updateInheritance() - ComponentElement.firstBuild() - Element.rebuild() - ComponentElement.performRebuild() - built = build() -Widget.build() - Element.updateChild(child, built, _) Element.updateChild方法非常重要 123456789101112131415161718192021222324@protectedElement updateChild(Element child, Widget newWidget, dynamic newSlot) &#123; if (newWidget == null) &#123; if (child != null) deactivateChild(child); return null; &#125; if (child != null) &#123; if (child.widget == newWidget) &#123; return child; &#125; if (Widget.canUpdate(child.widget, newWidget)) &#123; child.update(newWidget); return child; &#125; deactivateChild(child); &#125; return inflateWidget(newWidget, newSlot);&#125;static bool canUpdate(Widget oldWidget, Widget newWidget) &#123; return oldWidget.runtimeType == newWidget.runtimeType &amp;&amp; oldWidget.key == newWidget.key;&#125; 根据上面的代码，总结各种case child != null &amp;&amp; newWidget == null : newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element child == null &amp;&amp; newWidget != null : 第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot) child != null &amp;&amp; newWidget != null : 更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建 child == null &amp;&amp; newWidget == null : do nothing 在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot) 12345678@protectedElement inflateWidget(Widget newWidget, dynamic newSlot) &#123; ... final Element newChild = newWidget.createElement(); newChild.mount(this, newSlot); return newChild;&#125; 123456789101112131415161718192021abstract class StatefulWidget extends Widget &#123; const StatefulWidget(&#123; Key key &#125;) : super(key: key); @override StatefulElement createElement() =&gt; StatefulElement(this); State createState();&#125;class StatefulElement extends ComponentElement &#123; StatefulElement(StatefulWidget widget) : _state = widget.createState(), super(widget) &#123; _state._element = this; _state._widget = widget; &#125; @override Widget build() =&gt; state.build(this);&#125; StatefulWidget，State，StatefulElement的调用关系：Widget.createElement() -&gt; Element.build() -&gt; State.build() 更新Element12345Widget.setState - Element.markNeedsBuild() - Element._dirty = true - BuildOwner.scheduleBuildFor(this) - BuildOwner._dirtyElements.add(element) 当调用statState之后，会将element标脏，并加入到_dirtyElements列表中 123- WidgetsBinding.drawFrame() - BuildOwner.buildScope(renderViewElement) - BuildOwner._dirtyElements[index].rebuild() 每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的 卸载Element在Element的updateChild方法中，在 child != null &amp;&amp; newWidget == null 时，会调用deactivateChild() 123456@protectedvoid deactivateChild(Element child) &#123; child._parent = null; child.detachRenderObject(); owner._inactiveElements.add(child); // this eventually calls child.deactivate()&#125; deactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。 还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount 123456789101112131415161718192021222324252627void finalizeTree() &#123; Timeline.startSync('Finalize tree', arguments: timelineWhitelistArguments); try &#123; lockState(() &#123; _inactiveElements._unmountAll(); // this unregisters the GlobalKeys &#125;); &#125; ...&#125;void _unmountAll() &#123; _locked = true; final List&lt;Element&gt; elements = _elements.toList()..sort(Element._sort); _elements.clear(); try &#123; elements.reversed.forEach(_unmount); &#125; finally &#123; _locked = false; &#125;&#125;void _unmount(Element element) &#123; element.visitChildren((Element child) &#123; _unmount(child); &#125;); element.unmount();&#125; RenderObjectRenderObjectElementRenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。不是所有的Element都有对应的RenderObject RenderObjectElement有三个常用的子类： LeafRenderObjectElement：Leaf render objects, with no children SingleChildRenderObjectElement：A single child MultiChildRenderObjectElement：A linked list of children. RenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。 mmount、update、unmount 123456789101112131415161718192021222324@overridevoid mount(Element parent, dynamic newSlot) &#123; super.mount(parent, newSlot); _renderObject = widget.createRenderObject(this); attachRenderObject(newSlot); _dirty = false;&#125;@overridevoid attachRenderObject(dynamic newSlot) &#123; _slot = newSlot; _ancestorRenderObjectElement = _findAncestorRenderObjectElement(); _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot); final ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement(); if (parentDataElement != null) _updateParentData(parentDataElement.widget);&#125;@overridevoid update(covariant RenderObjectWidget newWidget) &#123; super.update(newWidget); widget.updateRenderObject(this, renderObject); _dirty = false;&#125; RenderObject的更新我们从render树的insert过程类分析RenderObject的更新从RenderObjectElement.insertChildRenderObject开始 12345@overridevoid insertChildRenderObject(RenderObject child, Element slot) &#123; final ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt; renderObject = this.renderObject; renderObject.insert(child, after: slot?.renderObject);&#125; 这里调用了ContainerRenderObjectMixin的insert方法， 123456789101112131415161718192021222324252627282930313233343536void insert(ChildType child, &#123; ChildType after &#125;) &#123; adoptChild(child); _insertIntoChildList(child, after: after);&#125;@overridevoid adoptChild(RenderObject child) &#123; setupParentData(child); markNeedsLayout(); markNeedsCompositingBitsUpdate(); markNeedsSemanticsUpdate(); super.adoptChild(child);&#125;void markNeedsLayout() &#123; if (_relayoutBoundary != this) &#123; markParentNeedsLayout(); &#125; else &#123; _needsLayout = true; if (owner != null) &#123; owner._nodesNeedingLayout.add(this); owner.requestVisualUpdate(); &#125; &#125;&#125;@protectedvoid markParentNeedsLayout() &#123; _needsLayout = true; final RenderObject parent = this.parent; if (!_doingThisLayoutWithCallback) &#123; parent.markNeedsLayout(); &#125; else &#123; assert(parent._debugDoingThisLayout); &#125;&#125; 和element的build流程不同，RenderObject的标脏会向上标脏。找到 _relayoutBoundary 节点，触发owner._nodesNeedingLayout.add( this )与owner.requestVisualUpdate() 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner PiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)来看一下PiplelineOwner.requestVisualUpdate 1234void requestVisualUpdate() &#123; if (onNeedVisualUpdate != null) onNeedVisualUpdate();&#125; onNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里 123456789101112131415161718192021222324void initInstances() &#123; super.initInstances(); _instance = this; _pipelineOwner = PipelineOwner( onNeedVisualUpdate: ensureVisualUpdate, onSemanticsOwnerCreated: _handleSemanticsOwnerCreated, onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed, ); window ..onMetricsChanged = handleMetricsChanged ..onTextScaleFactorChanged = handleTextScaleFactorChanged ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged ..onSemanticsAction = _handleSemanticsAction; initRenderView(); _handleSemanticsEnabledChanged(); assert(renderView != null); addPersistentFrameCallback(_handlePersistentFrameCallback); initMouseTracker();&#125;void _handlePersistentFrameCallback(Duration timeStamp) &#123; drawFrame();&#125; ensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制 layoutRendererBinding.drawFrame 123456789@protectedvoid drawFrame() &#123; ... pipelineOwner.flushLayout(); pipelineOwner.flushCompositingBits(); pipelineOwner.flushPaint(); renderView.compositeFrame(); // this sends the bits to the GPU pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.&#125; pipelineOwner.flushLayout()1234567891011121314void flushLayout() &#123; try &#123; while (_nodesNeedingLayout.isNotEmpty) &#123; final List&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout; _nodesNeedingLayout = &lt;RenderObject&gt;[]; for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123; if (node._needsLayout &amp;&amp; node.owner == this) node._layoutWithoutResize(); &#125; &#125; &#125; finally &#123; ... &#125;&#125; *RendererObject._layoutWithoutResize 12345678910void _layoutWithoutResize() &#123; try &#123; performLayout(); markNeedsSemanticsUpdate(); &#125; catch (e, stack) &#123; _debugReportException('performLayout', e, stack); &#125; _needsLayout = false; markNeedsPaint();&#125; 这里调用performLayout()进行layout，并标记需要paint paint之前说到过，layout过程中会对paint进行标脏 markNeedsPaint()123456789101112131415161718192021void markNeedsPaint() &#123; if (_needsPaint) return; _needsPaint = true; if (isRepaintBoundary) &#123; if (owner != null) &#123; owner._nodesNeedingPaint.add(this); owner.requestVisualUpdate(); &#125; &#125; else if (parent is RenderObject) &#123; final RenderObject parent = this.parent; parent.markNeedsPaint(); &#125; else &#123; // If we're the root of the render tree (probably a RenderView), // then we have to paint ourselves, since nobody else can paint // us. We don't add ourselves to _nodesNeedingPaint in this // case, because the root is always told to paint regardless. if (owner != null) owner.requestVisualUpdate(); &#125;&#125; 和layout的标脏过程类似，一直向上标脏，直到 isRepaintBoundary 为true。注意，这里只有 RepaintBoundary 才加入到了 PiplineOwner 的_nodesNeedingPaint中，即最终是以 RepaintBoundary 单位进行刷新的需要说明的是，我们可以 RepaintBoundary 是一个widget，我们可以手动添加，来终止paint的向上标脏过程，来达到局部重绘，提升性能。 LayoutBoundary 则是只是一个标记位，framework层帮我们判断的，我们不需要手动处理。 pipelineOwner.flushLayout() 123456789101112131415161718void flushPaint() &#123; try &#123; final List&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint; _nodesNeedingPaint = &lt;RenderObject&gt;[]; // Sort the dirty nodes in reverse order (deepest first). for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123; if (node._needsPaint &amp;&amp; node.owner == this) &#123; if (node._layer.attached) &#123; PaintingContext.repaintCompositedChild(node); &#125; else &#123; node._skippedPaintingOnLayer(); &#125; &#125; &#125; &#125; finally &#123; ... &#125;&#125; 与layout不同的是这里的 sort 规则是相反的，最深的节点先重绘。并且，多了判断 node._layer.attached, 如果为true，重绘，并且重绘逻辑交给了PaintContext；如果为false，则执行 node._skippedPaintingOnLayer(); node._skippedPaintingOnLayer() 1234567891011121314void _skippedPaintingOnLayer() &#123; AbstractNode ancestor = parent; while (ancestor is RenderObject) &#123; final RenderObject node = ancestor; if (node.isRepaintBoundary) &#123; if (node._layer == null) break; // looks like the subtree here has never been painted. let it handle itself. if (node._layer.attached) break; // it's the one that detached us, so it's the one that will decide to repaint us. node._needsPaint = true; &#125; ancestor = node.parent; &#125;&#125; 我的理解是，该节点的 layer 被 detached 了，需要对该节点及其父节点行重新标脏，保证该节点的 layer 被重新 attach 之后能够重绘。 PaintingContext.repaintCompositedChild(node); 1234567891011121314151617181920212223static void repaintCompositedChild(RenderObject child, &#123; bool debugAlsoPaintedParent = false &#125;) &#123; _repaintCompositedChild( child, debugAlsoPaintedParent: debugAlsoPaintedParent, );&#125;static void _repaintCompositedChild( RenderObject child, &#123; bool debugAlsoPaintedParent = false, PaintingContext childContext,&#125;) &#123; OffsetLayer childLayer = child._layer; if (childLayer == null) &#123; child._layer = childLayer = OffsetLayer(); &#125; else &#123; childLayer.removeAllChildren(); &#125; childContext ??= PaintingContext(child._layer, child.paintBounds); child._paintWithContext(childContext, Offset.zero); childContext.stopRecordingIfNeeded();&#125; 又是 PaintContext 和 layer。。。先跳过这两个，最终重绘的逻辑在 child._paintWithContext(childContext, Offset.zero);中 child._paintWithContext(childContext, Offset.zero); 1234567891011121314void _paintWithContext(PaintingContext context, Offset offset) &#123; // 一堆注释解释了为啥在paint的时候 _needsLayout 还可能为true 。。。 // 英文注释没咋看懂 if (_needsLayout) return; RenderObject debugLastActivePaint; _needsPaint = false; try &#123; // 最终的重绘交给具体的 RenderObject 子类 paint(context, offset); &#125; catch (e, stack) &#123; _debugReportException('paint', e, stack); &#125;&#125;","categories":[],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"}],"keywords":[]},{"title":"Java获取泛型类型","slug":"Java/Java获取泛型类型","date":"2020-07-23T12:05:38.000Z","updated":"2022-07-05T05:30:19.473Z","comments":true,"path":"2020/07/23/Java/Java获取泛型类型/","link":"","permalink":"http://yoursite.com/2020/07/23/Java/Java获取泛型类型/","excerpt":"获取泛型class的通用方法1Type type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[0];","text":"获取泛型class的通用方法1Type type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[0]; 因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型 无法获取到泛型类型1234567891011// 1. class SuperClass&lt;T&gt;&#123;&#125;SuperClass&lt;String&gt; object = SuperClass&lt;String&gt;()// 2.SubClass&lt;T&gt; extends SuperClass&lt;T&gt;&#123;&#125;SubClass&lt;String&gt; object = SubClass&lt;Strng&gt;() 可以获取到泛型类型123456789101112131415// 1. 子类继承父类时, 明确了泛型类型SubClass extends SuperClass&lt;String&gt;&#123;&#125;// 2. 匿名内部类, 子类继承父类的特殊情况abstract class SuperClass&lt;T&gt;&#123;&#125;SuperClass&lt;String&gt; object = new SuperClass&lt;String&gt;()&#123; ...&#125;// 3. 类成员变量的泛型类型// 4. 类方法的入参的泛型// 5. 类方法的返回类型的泛型 上面集中场景是可以获取到泛型的类型的，至于为什么可以，我觉得是因为在上面的场景中获取泛型类型时，泛型的具体类型已经是确定的了。 1和2是在编译时就能确定的，3\\4\\5是在运行时确定的","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}]},{"title":"kotlin协程","slug":"Android/kotlin协程","date":"2020-07-15T03:30:02.000Z","updated":"2021-10-03T01:57:41.027Z","comments":true,"path":"2020/07/15/Android/kotlin协程/","link":"","permalink":"http://yoursite.com/2020/07/15/Android/kotlin协程/","excerpt":"Async首先看一个例子，先后调用两个挂起函数","text":"Async首先看一个例子，先后调用两个挂起函数 12345678910111213141516171819202122232425262728import kotlinx.coroutines.*import kotlin.system.*fun main() = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; val one = doSomethingUsefulOne() val two = doSomethingUsefulTwo() println(\"The answer is $&#123;one + two&#125;\") &#125; println(\"Completed in $time ms\") &#125;suspend fun doSomethingUsefulOne(): Int &#123; delay(1000L) // 假设我们在这里做了些有用的事 return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123; delay(1000L) // 假设我们在这里也做了一些有用的事 return 29&#125;/** 输出The answer is 42Completed in 2017 ms**/ 可以发现，两个挂起函数是同步执行的，有先后顺序 使用async 1234567891011121314151617181920212223242526import kotlinx.coroutines.*import kotlin.system.*fun main() = runBlocking&lt;Unit&gt; &#123; val time = measureTimeMillis &#123; val one = async &#123; doSomethingUsefulOne() &#125; val two = async &#123; doSomethingUsefulTwo() &#125; println(\"The answer is $&#123;one.await() + two.await()&#125;\") &#125; println(\"Completed in $time ms\") &#125;suspend fun doSomethingUsefulOne(): Int &#123; delay(1000L) // 假设我们在这里做了些有用的事 return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123; delay(1000L) // 假设我们在这里也做了些有用的事 return 29&#125;/** 输出The answer is 42Completed in 1024 ms**/ 在结果耗时上，两个挂起方法达到了异步的效果。这得益于async关键字在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。 调度器与线程12345678910111213141516171819202122232425import kotlinx.coroutines.*fun main() = runBlocking&lt;Unit&gt; &#123; launch &#123; // 运行在父协程的上下文中，即 runBlocking 主协程 println(\"main runBlocking : I'm working in thread $&#123;Thread.currentThread().name&#125;\") &#125; launch(Dispatchers.Unconfined) &#123; // 不受限的——将工作在主线程中 println(\"Unconfined : I'm working in thread $&#123;Thread.currentThread().name&#125;\") &#125; launch(Dispatchers.Default) &#123; // 将会获取默认调度器 println(\"Default : I'm working in thread $&#123;Thread.currentThread().name&#125;\") &#125; launch(newSingleThreadContext(\"MyOwnThread\")) &#123; // 将使它获得一个新的线程 println(\"newSingleThreadContext: I'm working in thread $&#123;Thread.currentThread().name&#125;\") &#125; &#125;/** 输出 注意先后顺序Unconfined : I'm working in thread main @coroutine#3Default : I'm working in thread DefaultDispatcher-worker-1 @coroutine#4main runBlocking : I'm working in thread main @coroutine#2newSingleThreadContext: I'm working in thread MyOwnThread @coroutine#5**/ launch { …… } : 当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。 launch(Dispatchers.Default) { …… } : 当协程在 GlobalScope 中启动时，使用的是由Dispatchers.Default代表的默认调度器。 默认调度器使用共享的后台线程池。 所以launch(Dispatchers.Default) { …… }与GlobalScope.launch { …… }使用相同的调度器。Dispatchers.Default适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list launch(Dispatchers.IO) { …… } : 针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 launch(newSingleThreadContext(&quot;...&quot;)) { ... } : newSingleThreadContext 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。??? launch(Dispatchers.Unconfined) { ... } : 完全没搞懂这玩意儿.. 在Android中使用协程作用域1234567891011121314151617181920212223242526272829import kotlinx.coroutines.*class Activity &#123; private val mainScope = MainScope() fun destroy() &#123; mainScope.cancel() &#125; fun doSomething() &#123; // 在示例中启动了 10 个协程，且每个都工作了不同的时长 repeat(10) &#123; i -&gt; mainScope.launch &#123; delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间 println(\"Coroutine $i is done\") &#125; &#125; &#125;&#125; // Activity 类结束fun main() = runBlocking&lt;Unit&gt; &#123; val activity = Activity() activity.doSomething() // 运行测试函数 println(\"Launched coroutines\") delay(500L) // 延迟半秒钟 println(\"Destroying activity!\") activity.destroy() // 取消所有的协程 delay(1000) // 为了在视觉上确认它们没有工作 &#125; 通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 Dispatchers.Main 作为默认调度器的 UI 应用程序 创建作用域. 在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程 异步流12345678910111213141516171819202122232425262728293031import kotlinx.coroutines.*import kotlinx.coroutines.flow.*fun foo(): Flow&lt;Int&gt; = flow &#123; // 流构建器 for (i in 1..3) &#123; delay(100) // 假装我们在这里做了一些有用的事情 emit(i) // 发送下一个值 &#125;&#125;fun main() = runBlocking&lt;Unit&gt; &#123; // 启动并发的协程以验证主线程并未阻塞 launch &#123; for (k in 1..3) &#123; println(\"I'm not blocked $k\") delay(100) &#125; &#125; // 收集这个流 foo().collect &#123; value -&gt; println(value) &#125; &#125;/** 输出I'm not blocked 11I'm not blocked 22I'm not blocked 33**/ 上方的程序: 名为 flow 的 Flow 类型构建器函数。 flow { … } 构建块中的代码可以挂起。 函数 foo() 不再标有 suspend 修饰符。 流使用 emit 函数 发射 值。 流使用 collect 函数 收集 值。 kotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算 suspendCancellableCoroutine12345678910111213141516171819202122232425private suspend fun loadPageSuspend(productCategoryType: Int, page: Int): ProductListLoadResultBean = suspendCancellableCoroutine &#123; cnt -&gt; ProductManagementAPI.requestProductList( category = productCategoryType, page = page, keyword = getKeyword(), orderBy = getOrderType(), desc = isOrderDesc(), listener = object : INetRequestListener&lt;ProductListLoadResultBean&gt; &#123; override fun onSuccess(result: DataHull&lt;ProductListLoadResultBean&gt;?) &#123; result?.let &#123; cnt.resumeWith(Result.success(it.data)) &#125; ?: kotlin.run &#123; cnt.resumeWithException(Exception()) &#125; &#125; override fun onError(error: DataHull&lt;ProductListLoadResultBean&gt;?, isNetError: Boolean) &#123; cnt.resumeWithException(Exception(error?.stateBean?.message)) &#125; &#125; ) &#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/tags/Kotlin/"}],"keywords":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/categories/Kotlin/"}]},{"title":"Android自定义注解","slug":"Android/Android自定义注解","date":"2020-06-27T03:06:02.000Z","updated":"2021-10-03T01:57:41.022Z","comments":true,"path":"2020/06/27/Android/Android自定义注解/","link":"","permalink":"http://yoursite.com/2020/06/27/Android/Android自定义注解/","excerpt":"因为要自定义一个页面导航工具，需要使用自定义注解","text":"因为要自定义一个页面导航工具，需要使用自定义注解 1. 创建Java Library创建两个新的module，创建时module一定要选择Java Library 两个module分别是: libnavannotation 注解 libnavcompile 注解处理器 2. 定义注解定义两个注解ActivityDestination, FragmentDestination 1234567@Target(AnnotationTarget.CLASS)@Retention(AnnotationRetention.BINARY)annotation class ActivityDestination( val pageUrl: String, val needLogin: Boolean = false, val asStarter: Boolean = false) 1234567@Target(AnnotationTarget.CLASS)@Retention(AnnotationRetention.BINARY)annotation class FragmentDestination( val pageUrl: String, val needLogin: Boolean = false, val asStarter: Boolean = false) 3. 定义注解处理器（关键）3.1 配置build.gradle123456789101112131415161718apply plugin: 'java-library'apply plugin: 'kotlin'apply plugin: 'kotlin-kapt'dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\" implementation 'com.alibaba:fastjson:1.2.59' implementation project(':libnavannotation') implementation 'com.google.auto.service:auto-service:1.0-rc6'// annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6' kapt 'com.google.auto.service:auto-service:1.0-rc6'&#125;sourceCompatibility = \"8\"targetCompatibility = \"8\" 需要注意以下几点： 如果注解处理器是使用kotlin编写的，那么，一定要添加kotlin-kapt插件 implementation 导入annotation注解模块 导入auto-service注解处理器依赖，如果是纯Java代码，可以使用annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;， 如果是kotlin代码，必须使用kapt &#39;com.google.auto.service:auto-service:1.0-rc6&#39;。 我这里还implementation了auto-service 3.2 编写注解处理器12345678910111213141516171819202122@AutoService(Processor::class)@SupportedSourceVersion(SourceVersion.RELEASE_8)@SupportedAnnotationTypes( \"com.example.libnavannotation.ActivityDestination\", \"com.example.libnavannotation.FragmentDestination\")class NavProcessor : AbstractProcessor() &#123; override fun init(processingEnv: ProcessingEnvironment) &#123; super.init(processingEnv) ... &#125; override fun process(annotations: Set&lt;TypeElement&gt;, roundEnv: RoundEnvironment): Boolean &#123; ... &#125;&#125; 注意注解处理器类上面的几个注解 3.3 创建processor configuration file这里取决于gradle的版本，高版本必须创建processor配置文件，否则不会执行注解处理器的代码 需要在注解处理器所在module的 main 底下新建一个package，名称为 resources 在 resources 底下新建文件 META-INF/services/javax.annotation.processing.Processor 在 javax.annotation.processing.Processor 下写入 注解处理器的全名称 eg: com.example.libnavcompiler.NavProcessor 4. 使用注解在Android工程module中配置build.gradle 1234567891011121314151617apply plugin: 'com.android.application'apply plugin: 'kotlin-android'apply plugin: 'kotlin-android-extensions'apply plugin: 'kotlin-kapt'...dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\" ... implementation project(\":libnavannotation\")// annotationProcessor project(\":libnavcompiler\") kapt project(\":libnavcompiler\")&#125; 导入 注解module、注解处理器modulekotlin相关的注意事项和 注解处理器module 中的一样 123456@FragmentDestination(pageUrl = \"main/tabs/home\", asStarter = true)class HomeFragment : Fragment() &#123; ...&#125; 在build中点击make project，即可执行直接处理器中的代码。如果遇到不成功，可以rebuild再试一次 参考教你如何完全解析Kotlin中的注解 Android 开发之 自定义注解处理器","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://yoursite.com/tags/注解/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"gradle相关基础","slug":"Android/gradle/gradle相关基础","date":"2020-06-18T11:54:57.000Z","updated":"2022-09-02T14:24:15.198Z","comments":true,"path":"2020/06/18/Android/gradle/gradle相关基础/","link":"","permalink":"http://yoursite.com/2020/06/18/Android/gradle/gradle相关基础/","excerpt":"Gradle中的对象Gradle主要有三种对象这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：","text":"Gradle中的对象Gradle主要有三种对象这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象： Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。 Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。 Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。 构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。 setting.gradle1include ':app', ':progect_1', ':progect_2' 用于指示 Gradle 在构建应用时应将哪些模块包括在内 gradle.properties里面可以定义一些常量供build.gradle使用，如版本号等.然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。 123COMPILE_SDK_VERSION = 23BUILD_TOOLS_VERSION = 23.0.1VERSION_CODE = 1 build.gradlebuild文件有两种，一个是针对当前的Module，一个是针对项目中所有的module在顶层的build文件中，我们可以来添加一些子module所共有的一些配置 下面是一些常用的build.gradle的配置说明1234567891011121314151617181920212223242526272829// 应用android官方插件，module中的build.gradle很多配置都是插件提供的支持// 'com.android.application' 代表app主工程，// 如果是子工程应该使用 'com.android.library'apply plugin: 'com.android.application'// 仓库， buildscript&#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath '' // 声明插件名称和版本号 &#125;&#125;// 外部依赖，添加的依赖会在这些配置的仓库中去寻找dependencies &#123; // \"group:name:version\" implementation 'androidx.appcompat:appcompat:1.1.0'&#125;// 所有子工程的仓库地址allprojects &#123; repositories &#123; maven &#123; url uri('/Users/bytedance/code/test/repo') &#125; google() mavenCentral() &#125;&#125; 为什么buildscript和allpojectes都有repositories buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。 allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。比如用到的Glide/OkHttp等 子项目可以配置自己的repositories以获取自己独需的依赖包。 Task包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。 depandsOn: 依赖于其它任务 doFirst, doLast(&lt;&lt;): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作 apply的插件自带和很多Task，在Gradle页面的 &lt;项目名&gt;/Tasks/build 目录里面可以看到。我们也可以自己编写任务，自己的Task在Gradle页面的 &lt;项目名&gt;/Tasks/other/ 目录里可以查找到 Gradle的工作流程 Initialization: 初始化，在多模块的项目中，就是执行settings.gradle Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。 Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。 Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段 简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！ 在每一步的步骤中间可以添加hook 12345678910111213141516171819202122232425262728293031323334353637383940task a &#123; println 'this is a' doFirst &#123; println 'this is a do first' &#125; doLast &#123; println \"this is a do last\" &#125;&#125;task testBoth &#123; // 配置阶段 // 依赖 a task 先执行 dependsOn(\"a\") println 'this is b' doFirst &#123; // 执行阶段 println 'this is b first' &#125; doLast &#123; // 执行阶段 println 'this is b last' &#125;&#125;/**输出：&gt; Configure project :this is athis is b&gt; Task :athis is a do firstthis is a do last&gt; Task :testBoththis is b firstthis is b last*/ 解决依赖版本冲突大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。 以下是我们自己解决版本冲突的一般步骤 查看依赖报告运行Gradle， &lt;项目名称&gt;/app/Tasks/dependencies/ 查看依赖报告，输出如下 xxxx -&gt; xxxx 表示依赖包自动提升到了最高版本 123456789+--- androidx.lifecycle:lifecycle-extensions:2.1.0| +--- androidx.lifecycle:lifecycle-runtime:2.1.0| | +--- androidx.lifecycle:lifecycle-common:2.1.0 -&gt; 2.3.0-alpha01| | | \\--- androidx.annotation:annotation:1.1.0| | +--- androidx.arch.core:core-common:2.1.0| | | \\--- androidx.annotation:annotation:1.1.0| | \\--- androidx.annotation:annotation:1.1.0| +--- androidx.arch.core:core-common:2.1.0 (*)| +--- androidx.arch.core:core-runtime:2.1.0 排除传递性冲突123compile ('cn.qqtheme.framework:WheelPicker:1.5.1')&#123; exclude group:'com.android.support', module:\"appcompat\"&#125; 强制一个版本12345configurations.all&#123; resolutionStrategy&#123; force 'androidx.appcompat:appcompat:1.1.0' &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://yoursite.com/tags/Gradle/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Fresco源码解析","slug":"Android/源码解析/Fresco源码解析","date":"2020-03-20T07:24:32.000Z","updated":"2022-08-27T09:54:19.028Z","comments":true,"path":"2020/03/20/Android/源码解析/Fresco源码解析/","link":"","permalink":"http://yoursite.com/2020/03/20/Android/源码解析/Fresco源码解析/","excerpt":"1. 介绍：fresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。","text":"1. 介绍：fresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。 支持加载网络，本地存储和资源图片； 提供三级缓存（二级memory和一级internal storage）； 支持JPEGs，PNGs，GIFs，WEBPs等，还支持Progressive JPEG，优秀的动画支持； 图片圆角，scale，自定义背景，overlays等等； 优秀的内存管理, 在安卓低版本中会将缓存保存至特殊区域, 而不是java heap, 从而避免oom； 2. 主要组成部分 DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由ViewHolder负责。 DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。 DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。 DraweeHolder：统筹管理Hierarchy与DraweeController。 ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。 Producer/Consumer：Producer也有很多种，是完成具体工作的类. 它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。 IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。 3. 发起图片请求的主要流程3.1 流程图 3.2 源码分析3.2.1 DraweeView我们常用的类是SimpleDraweeView, 继承关系如下SimpleDraweeView -&gt; GenericDraweeView -&gt; DraweeView -&gt; ImageView注意: 虽然上述的类都是继承于ImageView的, 但是使用时最好不要调用ImageView本身的任何属性和方法, 不然的话使用不了Fresco的功能 DraweeView: 持有ViewHolder, ViewHolder管理DraweeController和DraweeHierarchy GenericDraweeView: 解析xml属性, 创建DraweeHierarchy SimpleDraweeView: 我们一般使用的类, 接受请求, 创建爱你DraweeController SimpleDraweeView.setImageURI123456789101112131415/*** Displays an image given by the uri.** @param uri uri of the image* @param callerContext caller context*/public void setImageURI(Uri uri, @Nullable Object callerContext) &#123;DraweeController controller = mControllerBuilder .setCallerContext(callerContext) .setUri(uri) .setOldController(getController()) .build();setController(controller);&#125; mControllerBuilder在setUri方法中创建了ImageRequest, 在build的过程中构建好了请求, cache, 编码, 解码等流程. 最后setController启动请求流程 3.2.2 DraweeControllerBuilder.build在DraweeControllerBuilder.build方法中创建了DataSource. 代表数据的来源，用于组装 produce 集合 1234567-&gt; AbstractDraweeControllerBuilder.build--&gt; AbstractDraweeControllerBuilder.buildController----&gt; PipelineDraweeControllerBuilder.obtainController // 创建controller并return-----&gt; AbstractDraweeControllerBuilder.obtainDataSourceSupplier------&gt; AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest // 创建了Supplier&lt;DataSource&lt;IMAGE&gt;&gt;, 调用supplier.get方法就会创建DataSource-------&gt; PipelineDraweeControllerBuilder.getDataSourceForRequest--------&gt; ImagePipeline.fetchDecodedImage(...) 3.2.3 setController123456-&gt; DraweeView.setController--&gt; DraweeHolder.setController----&gt; DraweeController.setHierarchy----&gt; DraweeHolder.attachController-----&gt; AbstractDraweeController.onAttach------&gt; AbstractDraweeController.submitRequest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647protected void submitRequest() &#123; ... final T closeableImage = getCachedImage(); // DataSource还没有start,已经开始获取缓存了 if (closeableImage != null) &#123; ... return; &#125; ... mDataSource = getDataSource(); // 获取DataSource final String id = mId; final boolean wasImmediate = mDataSource.hasResult(); // 注册并处理结果 final DataSubscriber&lt;T&gt; dataSubscriber = new BaseDataSubscriber&lt;T&gt;() &#123; @Override public void onNewResultImpl(DataSource&lt;T&gt; dataSource) &#123; boolean isFinished = dataSource.isFinished(); boolean hasMultipleResults = dataSource.hasMultipleResults(); float progress = dataSource.getProgress(); T image = dataSource.getResult(); if (image != null) &#123; onNewResultInternal( id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults); &#125; else if (isFinished) &#123; onFailureInternal(id, dataSource, new NullPointerException(), /* isFinished */ true); &#125; &#125; @Override public void onFailureImpl(DataSource&lt;T&gt; dataSource) &#123; ... &#125; @Override public void onProgressUpdate(DataSource&lt;T&gt; dataSource) &#123; ... &#125; &#125;; mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);&#125;@Overrideprotected DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDataSource() &#123; // 这里的mDataSouceSupplier是controller在创建时有构造方法传入 DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; result = mDataSourceSupplier.get(); return result;&#125; 还有一个问题, DataSource是什么时候启动的? 我们在DraweeController.build创建过程中发现创建了Supplier&lt;DataSource&lt;&gt;&gt;, controller的getDataSource实际上就是从Supplier获取的DataSource 12345-------&gt; PipelineDraweeControllerBuilder.getDataSourceForRequest--------&gt; ImagePipeline.fetchDecodedImage // 在这个方法中创建了producerSequence---------&gt; ImagePipeline.submitFetchRequest----------&gt; CloseableProducerToDataSourceAdapter&lt;T&gt;.craete-----------&gt; new CloseableProducerToDataSourceAdapter featchDecodeImage12345678910111213141516171819public DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; fetchDecodedImage( ImageRequest imageRequest, Object callerContext, ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit, @Nullable RequestListener requestListener) &#123; try &#123; // 创建Producer序列 Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence = mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest); return submitFetchRequest( producerSequence, imageRequest, lowestPermittedRequestLevelOnSubmit, callerContext, requestListener); &#125; catch (Exception exception) &#123; return DataSources.immediateFailedDataSource(exception); &#125;&#125; CloseableProducerToDataSourceAdapter的构造方法这个构造方法只是简单的调用父类的构造方法1234567891011121314151617181920protected AbstractProducerToDataSourceAdapter( Producer&lt;T&gt; producer, SettableProducerContext settableProducerContext, RequestListener requestListener) &#123; mSettableProducerContext = settableProducerContext; mRequestListener = requestListener; mRequestListener.onRequestStart( settableProducerContext.getImageRequest(), mSettableProducerContext.getCallerContext(), mSettableProducerContext.getId(), mSettableProducerContext.isPrefetch()); if (FrescoSystrace.isTracing()) &#123; FrescoSystrace.endSection(); &#125; // procuder序列启动 producer.produceResults(createConsumer(), settableProducerContext);&#125; 原来DataSource一创建就会启动produer的工作流程 3. Producer序列的工作流程3.1 Producer/Consumer的基本概念模板代码12345678910111213141516171819202122232425262728293031323334public class XXXXProducer implements Producer&#123; private final Producer mInputProducer; public BitmapMemoryCacheProducer(Producer inputProducer) &#123; mInputProducer = inputProducer; &#125; @Override public void produceResults( final Consumer consumer, final ProducerContext producerContext) &#123; ... 尝试直接得到结果 if(已经获取到结果)&#123; consumer.onNewResult(result, status); return ; &#125; Consumer newConsumer = new DelegatingConsumer(consumer)&#123; @Override public void onNewResultImpl(newResult, int status) &#123; ... 处理上一阶段返回的结果 if(isLast)&#123; // 将自己处理完成的数据交给上一层producer // 这里的getConsumer是构造方法传入的consumer, 也就是上一层producer创建的DelegatingConsumer getConsumer().onNewResult(); &#125; &#125; &#125; // 进行下一阶段 mInputProducer.produceResults(newConsumer, producerContext); &#125;&#125; Consumer的onNewResult方法onNewResult会直接调用自己的onNewResultImpl方法123456789101112@Overridepublic synchronized void onNewResult(@Nullable T newResult, @Status int status) &#123; if (mIsFinished) &#123; return; &#125; mIsFinished = isLast(status); try &#123; onNewResultImpl(newResult, status); &#125; catch (Exception e) &#123; onUnhandledException(e); &#125;&#125; 按照这样类似责任链的设计模式, 实际上, 往后加入的producer越晚执行 3.2 主要的producer内容梳理 BitmapMemoryCacheGetProducer从内存中获取已解码的图片, 因为是直接从内存中获取可以用的, 所以是即时的, 在UI线程中就可以做 BackgroundThreadHandoffProducer将任务移交给子线程, 这里仅仅是转移线程而已, 具体的工作在具体的线程中完成 BitmapMemoryCacheKeyMultiplexProducer将多个拥有相同已解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据 BitmapMemoryCacheProducer又一次获取内存缓存? 我觉得主要是将下一阶段获取的已解码图片存储到缓存中 DecodeProducer解码 ResizeAndRotateProducer旋转, 缩放 AddImageTransformMetaProducer添加MetaData EncodeCacheKeyMutiplexProducer将多个拥有相同未解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据； EncodedMemoryCacheProducer查找未解码的图片缓存, 将下一步得到的未解码图片保存到缓存中 DiskCacheReadProducer读磁盘缓存, 有分MainCache和SmallCache, SmallCache存储小图片, 避免大图片被挤出缓存. 启动task并扔进线程池 DiskCacheWriteProducer存入磁盘缓存, 同样是在线程池中操作 newNetworkFetchProducer从网络中获取图片 4. Fresco 在内存管理上的优势 在Dalvik虚拟机中，gc性能较差，会伴有stop-the-world的发生，导致卡顿，所以Fresco会将解码之后的Bitmap存放到Ashmem当中，并且每次解码完都会通过Native层的代码进行PinBitmap的操作，防止被系统回收。 Fresco使用了 CloseableReference 进行引用计数，手动回收bitmap对象。 在Art虚拟机中，gc性能得到了大幅的提升，所以没必要用各种骚操作，直接将Bitmap解码到Java堆当中即可。 4.1 CloseableReference 引用计数使用 CloseableReference 优雅的释放对象，来自 Fresco CloseableReference 是 fresco 内部建立的一个机制，核心思想是 用static的集合屏蔽java的gc的内存回收，转变为类似c/c++的手动释放内存。在Dalvik虚拟机中，gc性能较差，bitmap的频繁gc会影响性能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public final class CloseableReference&lt;T&gt; implements Cloneable, Closeable &#123;// 构造方法是private，只能使用 of(...) 方法进行实例化 private CloseableReference(T t, ResourceReleaser&lt;T&gt; resourceReleaser) &#123; mSharedReference = new SharedReference&lt;T&gt;(t, resourceReleaser); &#125; @Override public void close() &#123; synchronized (this) &#123; if (mIsClosed) &#123; return; &#125; mIsClosed = true; &#125; mSharedReference.deleteReference(); &#125;// clone 就是把引用计数+1 public synchronized CloseableReference&lt;T&gt; clone() &#123; return new CloseableReference&lt;T&gt;(mSharedReference); &#125; private CloseableReference(SharedReference&lt;T&gt; sharedReference) &#123; mSharedReference = Preconditions.checkNotNull(sharedReference); sharedReference.addReference(); &#125;&#125;public class SharedReference&lt;T&gt; &#123; public static Map&lt;Object, Integer&gt; getLiveObjects() &#123; return sLiveObjects; &#125; public SharedReference(T value, ResourceReleaser&lt;T&gt; resourceReleaser) &#123; mValue = Preconditions.checkNotNull(value); mResourceReleaser = Preconditions.checkNotNull(resourceReleaser); mRefCount = 1; // 添加进 static 的集合中，规避jvm的内存回收 addLiveReference(value); &#125; private static void addLiveReference(Object value) &#123; synchronized (sLiveObjects) &#123; Integer count = sLiveObjects.get(value); if (count == null) &#123; sLiveObjects.put(value, 1); &#125; else &#123; sLiveObjects.put(value, count + 1); &#125; &#125; &#125; // 引用计数+1 public synchronized void addReference() &#123; mRefCount++; &#125; // 引用计数-1 public void deleteReference() &#123; if (decreaseRefCount() == 0) &#123; T deleted; synchronized (this) &#123; deleted = mValue; mValue = null; &#125; mResourceReleaser.release(deleted); removeLiveReference(deleted); &#125; &#125; public synchronized int decreaseRefCount() &#123; mRefCount--; return mRefCount; &#125;&#125; 4.2 CloseableReference 在 LruCache 的使用CountingMemoryCache 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class CountingMemoryCache&lt;K, V&gt; implements MemoryCache&lt;K, V&gt;, MemoryTrimmable &#123; /** * 有两个集合， mExclusiveEntries 等待移除的entry，引用为0的entry的集合 * mCachedEntries 是缓存 **/ final CountingLruMap&lt;K, Entry&lt;K, V&gt;&gt; mExclusiveEntries; final CountingLruMap&lt;K, Entry&lt;K, V&gt;&gt; mCachedEntries; @Nullable public CloseableReference&lt;V&gt; get(final K key) &#123; Entry&lt;K, V&gt; oldExclusive; CloseableReference&lt;V&gt; clientRef = null; synchronized (this) &#123; // 从 mExclusiveEntries ，引用会增加，一定不会回收 oldExclusive = mExclusiveEntries.remove(key); Entry&lt;K, V&gt; entry = mCachedEntries.get(key); if (entry != null) &#123; // 重要 clientRef = newClientReference(entry); &#125; &#125; maybeNotifyExclusiveEntryRemoval(oldExclusive); maybeUpdateCacheParams(); // 尝试回收 mExclusiveEntries 的元素 maybeEvictEntries(); return clientRef; &#125; public CloseableReference&lt;V&gt; cache( final K key, final CloseableReference&lt;V&gt; valueRef, final EntryStateObserver&lt;K&gt; observer ) &#123; maybeUpdateCacheParams(); Entry&lt;K, V&gt; oldExclusive; CloseableReference&lt;V&gt; oldRefToClose = null; CloseableReference&lt;V&gt; clientRef = null; synchronized (this) &#123; oldExclusive = mExclusiveEntries.remove(key); // 从lrucache中找到得到旧的entry Entry&lt;K, V&gt; oldEntry = mCachedEntries.remove(key); if (oldEntry != null) &#123; makeOrphan(oldEntry); oldRefToClose = referenceToClose(oldEntry); &#125; if (canCacheNewValue(valueRef.get())) &#123; Entry&lt;K, V&gt; newEntry = Entry.of(key, valueRef, observer); // 新entry加入集合 mCachedEntries.put(key, newEntry); clientRef = newClientReference(newEntry); &#125; &#125; // 旧entry引用计数-1 CloseableReference.closeSafely(oldRefToClose); maybeNotifyExclusiveEntryRemoval(oldExclusive); // 尝试回收 maybeEvictEntries(); return clientRef; &#125; private synchronized CloseableReference&lt;V&gt; newClientReference(final Entry&lt;K, V&gt; entry) &#123; increaseClientCount(entry); return CloseableReference.of( entry.valueRef.get(), new ResourceReleaser&lt;V&gt;() &#123; @Override public void release(V unused) &#123; // 当有一次引用释放发生时，会回调这里 releaseClientReference(entry); &#125; &#125;); &#125; private void releaseClientReference(final Entry&lt;K, V&gt; entry) &#123; Preconditions.checkNotNull(entry); boolean isExclusiveAdded; CloseableReference&lt;V&gt; oldRefToClose; synchronized (this) &#123; decreaseClientCount(entry); isExclusiveAdded = maybeAddToExclusives(entry); oldRefToClose = referenceToClose(entry); &#125; // 引用计数-1 CloseableReference.closeSafely(oldRefToClose); maybeNotifyExclusiveEntryInsertion(isExclusiveAdded ? entry : null); maybeUpdateCacheParams(); // 尝试回收 maybeEvictEntries(); &#125;&#125; 这个cache就是将 LruCache 和 引用计数的思想结合 4.3 针对 Dalvik 虚拟机的缓存优化在 DecodeProducer 中，进行了图片的解码。 最终调用解码是在 ProgressiveDecoder#doDecode 方法中 12345private void doDecode(EncodedImage encodedImage, @Status int status) &#123; ... image = mImageDecoder.decode(encodedImage, length, quality, mImageDecodeOptions); ...&#125; mImageDecoder的实现类根据系统版本有所不同，在 api21 也就是 art虚拟机实现类是 DefaultDecoder 。 在 Dalvik虚拟机实现类是 DalvikPurgeableDecoder 以jpg图片的解码举例12345678910111213141516171819@Overridepublic CloseableReference&lt;Bitmap&gt; decodeJPEGFromEncodedImageWithColorSpace( final EncodedImage encodedImage, Bitmap.Config bitmapConfig, @Nullable Rect regionToDecode, int length, final boolean transformToSRGB) &#123; BitmapFactory.Options options = getBitmapFactoryOptions( encodedImage.getSampleSize(), bitmapConfig); final CloseableReference&lt;PooledByteBuffer&gt; bytesRef = encodedImage.getByteBufferRef(); Preconditions.checkNotNull(bytesRef); try &#123; Bitmap bitmap = decodeJPEGByteArrayAsPurgeable(bytesRef, length, options); return pinBitmap(bitmap); &#125; finally &#123; CloseableReference.closeSafely(bytesRef); &#125;&#125; 这里做了两个操作，先解码得到bitmap，然后对pin这个bitmap。 pin的作用是让的bitmap对象避免被系统gc 先来看一下解码12345678910111213141516171819202122232425262728293031@Overrideprotected Bitmap decodeJPEGByteArrayAsPurgeable( CloseableReference&lt;PooledByteBuffer&gt; bytesRef, int length, BitmapFactory.Options options) &#123; byte[] suffix = endsWithEOI(bytesRef, length) ? null : EOI; return decodeFileDescriptorAsPurgeable(bytesRef, length, suffix, options);&#125;private Bitmap decodeFileDescriptorAsPurgeable( CloseableReference&lt;PooledByteBuffer&gt; bytesRef, int inputLength, byte[] suffix, BitmapFactory.Options options) &#123; MemoryFile memoryFile = null; try &#123; memoryFile = copyToMemoryFile(bytesRef, inputLength, suffix); FileDescriptor fd = getMemoryFileDescriptor(memoryFile); if (mWebpBitmapFactory != null) &#123; Bitmap bitmap = mWebpBitmapFactory.decodeFileDescriptor(fd, null, options); return Preconditions.checkNotNull(bitmap, \"BitmapFactory returned null\"); &#125; else &#123; throw new IllegalStateException(\"WebpBitmapFactory is null\"); &#125; &#125; catch (IOException e) &#123; throw Throwables.propagate(e); &#125; finally &#123; if (memoryFile != null) &#123; memoryFile.close(); &#125; &#125;&#125; 这里有一个 MemoryFile ， 这是安卓系统提供的用来使用匿名共享内存的类(ashmem) , 也就是说在 Dalvik 会将bitmap保存到 ashmem 里，避免被触碰到java层的oom限制。 然后是 pin12345678910111213141516171819 public CloseableReference&lt;Bitmap&gt; pinBitmap(Bitmap bitmap) &#123; // jni调用pin nativePinBitmap(bitmap); // 使用 CloseableReference 。最终会在引用计数为0时，手动触发回收 return CloseableReference.of(bitmap, mUnpooledBitmapsCounter.getReleaser()); &#125;/** mUnpooledBitmapsReleaser = new ResourceReleaser&lt;Bitmap&gt;() &#123; @Override public void release(Bitmap value) &#123; try &#123; decrease(value); &#125; finally &#123; value.recycle(); &#125; &#125; &#125;;**/ Dalvik 和 Art 在gc上的差异揭秘 ART 细节 —- Garbage collection art 新增了 large object space ，专供大对象使用 Dalvik 在垃圾回收时，会暂停所有线程，在内存紧张时会频繁执行，容易造成卡顿丢帧。art优化了回收算法，会减少暂停线程的次数","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"Fresco","slug":"Fresco","permalink":"http://yoursite.com/tags/Fresco/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Flutter中常用布局和Android的对应关系","slug":"Flutter/Flutter中常用布局和Android的对应关系","date":"2020-02-26T07:49:51.000Z","updated":"2021-10-03T01:57:41.030Z","comments":true,"path":"2020/02/26/Flutter/Flutter中常用布局和Android的对应关系/","link":"","permalink":"http://yoursite.com/2020/02/26/Flutter/Flutter中常用布局和Android的对应关系/","excerpt":"","text":"","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"}],"keywords":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/categories/Flutter/"}]},{"title":"ViewDragHelper的使用","slug":"Android/ViewDragHelper的使用","date":"2020-02-19T02:36:30.000Z","updated":"2021-10-03T01:57:41.026Z","comments":true,"path":"2020/02/19/Android/ViewDragHelper的使用/","link":"","permalink":"http://yoursite.com/2020/02/19/Android/ViewDragHelper的使用/","excerpt":"ViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部","text":"ViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部 参考 ViewDragHelper 的基本使用 常用Api初始化 1public static ViewDragHelper create(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb) 第一个参数是父布局, 第二个参数是自定义的监听回调 拦截事件 在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断 123456789101112131415@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; //ViewDragHelper对事件进行拦截 //注意, ACTION_DOWN事件不会被拦截 //当clampViewPositionXxx方法没有修改left或top值时, 不会拦截 //是的, shouldInterceptTouchEvent中会调用callback.clampViewPositionXxx方法 return mViewDragHelper.shouldInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; //将事件传递给ViewDragHelper进行处理 mViewDragHelper.processTouchEvent(event); return true;&#125; 处理computeScroll 因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法) 1234567@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mViewDragHelper != null &amp;&amp; mViewDragHelper.continueSettling(true))&#123; invalidate(); &#125;&#125; 处理CallBack回调 1234567891011121314151617181920212223242526private ViewDragHelper.Callback mCallback = new ViewDragHelper.Callback() &#123; // tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动 @Override public boolean tryCaptureView(View child, int pointerId) &#123; &#125; // clampViewPositionHorizontal() 判断水平方向上将要移动到的位置 // left 将要移动到的left值 // dx 表示速度 @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; &#125; // 同clampViewPositionHorizontal(), 换成了垂直方向而已 @Override public int clampViewPositionVertical(View child, int top, int dy) &#123; &#125; // 手指拖拽后释放 // releasedChild 拖拽的view // xvel, yvel拖拽动速度 @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; &#125;&#125;; ViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法 还有一些常用的关于边缘滑动相关的重写方法 在这里就不写了 例子实现一个支持拖拽, 有粘性的ViewGroup 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class DragLayout extends LinearLayout &#123; private float mRaftValue = UIUtils.dip2Px(getContext(), 20); //回弹临界距离 private float mRaftYVel = 1000.0f; // 回弹临界速度 private ViewDragHelper mDragHelper; private OnDismissListener mOnDismissListener; private boolean mDragToggle = true; public DragLayout(@NonNull Context context) &#123; this(context, null); &#125; public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; public void setOnDismissListener(OnDismissListener onDismissListener) &#123; mOnDismissListener = onDismissListener; &#125; private void init() &#123; ViewDragHelper.Callback callback = new ViewDragHelper.Callback() &#123; private int mCurrentTop; @Override public boolean tryCaptureView(@NonNull View child, int pointerId) &#123; return mDragToggle; &#125; @Override public int clampViewPositionVertical(@NonNull View child, int top, int dy) &#123; // 禁止向上滑动 if (top &lt; 0) &#123; top = 0; &#125; mCurrentTop = top; return top; &#125; @Override public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) &#123; super.onViewReleased(releasedChild, xvel, yvel); // 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画 // 还需要限定一个速度，优化用户体验 if (mCurrentTop &lt;= mRaftValue &amp;&amp; yvel &lt;= mRaftYVel) &#123; mDragHelper.settleCapturedViewAt(0, 0); invalidate(); &#125; else &#123; // 从底部滑出 if (mOnDismissListener != null) &#123; mOnDismissListener.onDismiss(); &#125; &#125; &#125; // 响应垂直滑动事件 // 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件 // 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中, // 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截. // 所以需要重写并返回一个非0值 @Override public int getViewVerticalDragRange(@NonNull View child) &#123; return 1; &#125; &#125;; mDragHelper = ViewDragHelper.create(this, callback); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragHelper.shouldInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; try &#123; mDragHelper.processTouchEvent(event); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return true; &#125; @Override public void computeScroll() &#123; if (mDragHelper != null &amp;&amp; mDragHelper.continueSettling(true)) &#123; invalidate(); &#125; &#125; public interface OnDismissListener &#123; void onDismiss(); &#125;&#125; 注意 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"外部View随着RecyclerView的滚动而显示或隐藏","slug":"Android/外部View随着RecyclerView的滚动而显示或隐藏","date":"2020-01-09T15:01:39.000Z","updated":"2021-10-03T01:57:41.028Z","comments":true,"path":"2020/01/09/Android/外部View随着RecyclerView的滚动而显示或隐藏/","link":"","permalink":"http://yoursite.com/2020/01/09/Android/外部View随着RecyclerView的滚动而显示或隐藏/","excerpt":"外部的View上滑显示, 下滑隐藏1234567891011121314151617181920212223242526272829mOutsideOnScrollListener = new OnScrollListener() &#123; boolean controlsVisible = false; int scrolledDistance = 0; @Override public void onScrollStateChanged(int newState) &#123; if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; scrolledDistance = 0; &#125; &#125; @Override public void onScrolled(int dx, int dy) &#123; if ((controlsVisible &amp;&amp; dy &lt; 0) || (!controlsVisible &amp;&amp; dy &gt; 0)&#123; scrolledDistance += dy; &#125; if (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123; //UP scrolledDistance = 0; controlsVisible = false; view.onShow(); &#125; else if (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123; //DOWN scrolledDistance = 0; controlsVisible = true; view.onPause(); &#125; &#125;&#125;;","text":"外部的View上滑显示, 下滑隐藏1234567891011121314151617181920212223242526272829mOutsideOnScrollListener = new OnScrollListener() &#123; boolean controlsVisible = false; int scrolledDistance = 0; @Override public void onScrollStateChanged(int newState) &#123; if (newState == RecyclerView.SCROLL_STATE_IDLE) &#123; scrolledDistance = 0; &#125; &#125; @Override public void onScrolled(int dx, int dy) &#123; if ((controlsVisible &amp;&amp; dy &lt; 0) || (!controlsVisible &amp;&amp; dy &gt; 0)&#123; scrolledDistance += dy; &#125; if (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123; //UP scrolledDistance = 0; controlsVisible = false; view.onShow(); &#125; else if (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123; //DOWN scrolledDistance = 0; controlsVisible = true; view.onPause(); &#125; &#125;&#125;; 我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。 123if ((controlsVisible &amp;&amp; dy &lt; 0) || (!controlsVisible &amp;&amp; dy &gt; 0)) &#123; scrolledDistance += dy;&#125; 如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。 1234567891011if (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123; //UP scrolledDistance = 0; controlsVisible = false; view.onResume();&#125; else if (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123; //DOWN scrolledDistance = 0; controlsVisible = true; view.onPause();&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"自动滚播TextView","slug":"Android/自动滚播TextView","date":"2019-12-31T06:49:08.000Z","updated":"2021-10-03T01:57:41.029Z","comments":true,"path":"2019/12/31/Android/自动滚播TextView/","link":"","permalink":"http://yoursite.com/2019/12/31/Android/自动滚播TextView/","excerpt":"","text":"要实现一个自动滚播的自定义View123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class AutoSwitchView extends AppCompatTextView &#123; private final int DEFAULT_IDLE_TIME = 3000; private final int DEFAULT_SWITCH_TIME = 1000; private int mIdleTime = DEFAULT_IDLE_TIME; private int mSwitchTime = DEFAULT_SWITCH_TIME; private Paint mPaint; private String mCurStr; private String mNextStr; private List&lt;String&gt; mContentList; private int mCurIndex = 0; private float mCurValue; private boolean mIsRunning = false; private ValueAnimator mAnimator; private Paint.FontMetrics mFontMetrics; private Runnable mRunnable; private int mWidth; private int mPaddingLeft; private int mPaddingRight; private int mPaddingTop; private int mPaddingBottom; private int mHeight; private float mTextBaseY; public AutoSwitchView(Context context) &#123; super(context); init(context); &#125; public AutoSwitchView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public AutoSwitchView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; mPaint = new Paint(); mPaint.setTextAlign(Paint.Align.CENTER); mAnimator = ValueAnimator.ofFloat(0, 1); mAnimator.setStartDelay(mIdleTime); mAnimator.setDuration(mSwitchTime); mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCurValue = (float) animation.getAnimatedValue(); // 必须要加这个判断, 不然会出现问题 if (mCurValue &lt; 1.0) &#123; invalidate(); &#125; &#125; &#125;); mAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation, boolean isReverse) &#123; if (!mIsRunning) &#123; return; &#125; mCurIndex = (mCurIndex + 1) % mContentList.size(); mCurStr = mContentList.get(mCurIndex); mNextStr = mContentList.get((mCurIndex + 1) % mContentList.size()); if (mRunnable == null) &#123; mRunnable = new Runnable() &#123; @Override public void run() &#123; mAnimator.start(); &#125; &#125;; &#125; postDelayed(mRunnable, mIdleTime); &#125; @Override public void onAnimationCancel(Animator animation) &#123; mIsRunning = false; &#125; &#125;); &#125; public void start() &#123; if (mContentList == null || mContentList.size() == 0) return; if (mIsRunning) &#123; return; &#125; if (mContentList.size() &gt; 1) &#123; mCurStr = mContentList.get(0); mNextStr = mContentList.get(1); &#125; else &#123; mCurStr = mContentList.get(0); mNextStr = mContentList.get(0); &#125; mCurIndex = 0; mIsRunning = true; mAnimator.start(); mAnimator.setStartDelay(mIdleTime); &#125; public void stop() &#123; if (mRunnable != null) &#123; removeCallbacks(mRunnable); &#125; mAnimator.cancel(); mIsRunning = false; mCurIndex = 0; &#125; public void setContentList(List&lt;String&gt; contentList) &#123; if (contentList == null || contentList.size() == 0) return; mContentList = contentList; start(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); mWidth = MeasureSpec.getSize(widthMeasureSpec); mPaddingLeft = getPaddingLeft(); mPaddingRight = getPaddingRight(); mPaddingTop = getPaddingTop(); mPaddingBottom = getPaddingBottom(); mPaint.setTextSize(getTextSize()); mFontMetrics = mPaint.getFontMetrics(); mTextBaseY = -mFontMetrics.top + mPaddingTop; mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom; setMeasuredDimension(mWidth, mHeight); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); float curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / 2; float nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / 2; float baseY = 2 * mTextBaseY * (0.5f - mCurValue); if (baseY &gt; 0) &#123; canvas.drawText(mCurStr, curStartX, baseY, mPaint); &#125; else &#123; canvas.drawText(mNextStr, nextStartX, 2 * mTextBaseY + baseY, mPaint); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"ViewModel,LiveData和Lifecycle","slug":"Android/ViewModel-LiveData和LifeCricle","date":"2019-12-21T12:19:41.000Z","updated":"2021-10-03T01:57:41.027Z","comments":true,"path":"2019/12/21/Android/ViewModel-LiveData和LifeCricle/","link":"","permalink":"http://yoursite.com/2019/12/21/Android/ViewModel-LiveData和LifeCricle/","excerpt":"ViewModel、Lifecycles和LiveData","text":"ViewModel、Lifecycles和LiveData1. ViewModel:ViewModel是Google官方提供的组件，是用来处理和存放和UI相关的数据的，可以把UI和数据进行分离。但就这一点来说的话，其实没有必要一定使用Google提供的ViewModel组件，我们使用自定义的ViewModel类同样可以达到这样的效果。 还有一个很重要的特性，我们都知道，在配置改变时，Activity会出现销毁重建，比如说横竖屏切换的时候。ViewModel的生命周期和Activity是不一样的，它不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，可以将和UI相关的数据存放在ViewModel中，这样，即使Activity销毁重建，页面上显示的数据也不会丢失。12345public abstract class ViewModel &#123; // 在ViewModel销毁的时候做回收工作，主要是为了防止ViewModel的泄漏 protected void onCleared() &#123; &#125;&#125; ViewModel的创建和存储过程主要是要搞清楚上面说的：Activity销毁重建的时候，ViewModel是如何保持不重建的。注意，这里只是在Activity因为配置改变而销毁重建的情况下。还有一种情况是，App由前台进入后台，因为内存紧张，Activity被系统销毁。这种情况下，ViewModel是无法保存数据的。 以下全都以Activity举例，Fragment也是一样的在Activity中获取ViewModel：1viewModel = ViewModelProviders.of(this).get(XxxViewModel.class); ViewModelProviders#of12345678910111213@NonNull@MainThreadpublic static ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory) &#123; Application application = checkApplication(activity); if (factory == null) &#123; // 使用默认的工厂类 // 如果想要在ViewModel的构造方法里传参，需要自定义factory类 factory = ViewModelProvider.AndroidViewModelFactory .getInstance(application); &#125; return new ViewModelProvider(ViewModelStores.of(activity), factory);&#125; viewModelProvider#get123456789101112131415161718// 从ViewModelStore中获取ViewModel，没有则创建public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; return (T) viewModel; &#125; else &#123; ... &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); return (T) viewModel;&#125;public class ViewModelStore &#123; // ViewModel的集合，key是由ViewModel类名构成的字符串 private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); ...&#125; ViewModelStore中存储了一个Activity/Fragment的所有ViewModel。那现在问题就转变成了探究ViewModelStore的获取和存储的过程 ViewModelStores#of123456public static ViewModelStore of(@NonNull FragmentActivity activity) &#123; if (activity instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; return holderFragmentFor(activity).getViewModelStore();&#125; 这里先判断FragmentActivity是否实现了ViewModelStoreOwner接口。不同的依赖包，实现有可能是不一样的。高版本的support-v4和androidx中的Fragment和FragmentActivity都实现了这个接口。1234public interface ViewModelStoreOwner &#123; @NonNull ViewModelStore getViewModelStore();&#125; 实现了ViewModelStoreOwner接口FragmentActivity1234567public class FragmentActivity extends SupportActivity implements ViewModelStoreOwner, ...&#123; private ViewModelStore mViewModelStore; public ViewModelStore getViewModelStore() &#123; ... &#125;&#125; 实现了ViewModelStoreOwner接口的FragmentActivity会直接持有ViewModelStore的引用 主要关注三个方法：getViewModelStore()onCreate()onRetainNonConfigurationInstance() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public ViewModelStore getViewModelStore() &#123; if (this.getApplication() == null) &#123; ... &#125; else &#123; if (this.mViewModelStore == null) &#123; FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances) this.getLastNonConfigurationInstance(); if (nc != null) &#123; this.mViewModelStore = nc.viewModelStore; &#125; if (this.mViewModelStore == null) &#123; this.mViewModelStore = new ViewModelStore(); &#125; &#125; return this.mViewModelStore; &#125;&#125;protected void onCreate(@Nullable Bundle savedInstanceState) &#123; ... FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)this.getLastNonConfigurationInstance(); if (nc != null &amp;&amp; nc.viewModelStore != null &amp;&amp; this.mViewModelStore == null) &#123; this.mViewModelStore = nc.viewModelStore; &#125; ...&#125;// 在页面销毁时，保存ViewModelStorepublic final Object onRetainNonConfigurationInstance() &#123; Object custom = onRetainCustomNonConfigurationInstance(); ViewModelStore viewModelStore = mViewModelStore; if (viewModelStore == null) &#123; // 如果NonConfigurationInstance保存了viewModelStore，把它取出来 NonConfigurationInstances nc = getLastNonConfigurationInstance(); if (nc != null) &#123; viewModelStore = nc.viewModelStore; &#125; &#125; if (viewModelStore == null &amp;&amp; custom == null) &#123; return null; &#125; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; //把viewModelStore放到NonConfigurationInstances中并返回 nci.viewModelStore = viewModelStore; //这样当页面被重建而销毁时ViewModelStore就被保存起来了。 return nci;&#125; ViewModelStore在onCreate里会从NonConfigurationInstances里尝试取出，然后在onRetainNonConfigurationInstanc方法中保存到NonConfigurationInstances。onRetainNonConfigurationInstance何时被调用，数据又是怎样保存的呢？了解过Activity启动流程的都知道ActivityThread，它控制着Activity的生命周期，当ActivityThread执行performDestroyActivity这个方法时，会调用Activity#retainNonConfigurationInstances获取到保存的数据并保存到ActivityClientRecord中。 123456789101112ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) &#123; ... ActivityClientRecord r = mActivities.get(token); // 由于状态改变的destroy，这里会为true if (getNonConfigInstance) &#123; //保存retainNonConfigurationInstances中的数据到ActivityClientRecord中 r.lastNonConfigurationInstances = r.activity .retainNonConfigurationInstances(); &#125; ... return r;&#125; 当页面重建完成,ActivityThread执行了performLaunchActivity方法时，会调用Activity的attach方法,便会把刚刚存储的数据，传递进去。 12345private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ... activity.attach(......, r.lastNonConfigurationInstances,.....); ...&#125; 总结：Activity对应的ViewModel保存在ViewModelStore里，FragmentActivity持有ViewModelStore的引用，Activity因配置原因销毁-重建时，ViewModelStore被NonConfigurationInstances保存，重建时从保存处恢复。 未实现ViewModelStoreOwner接口低版本未实现ViewModelStoreOwner接口，采取的方法是在Activity中注入一个不可见的HolderFragment 123456public static ViewModelStore of(@NonNull FragmentActivity activity) &#123; if (activity instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; return holderFragmentFor(activity).getViewModelStore();&#125; HolderFragment: 1234567891011121314public class HolderFragment extends Fragment implements ViewModelStoreOwner &#123; private static final HolderFragmentManager sHolderFragmentManager = new HolderFragmentManager(); private ViewModelStore mViewModelStore = new ViewModelStore(); public HolderFragment() &#123; setRetainInstance(true); &#125; public static HolderFragment holderFragmentFor(FragmentActivity activity) &#123; // 在activity中插入HolderFragment return sHolderFragmentManager.holderFragmentFor(activity); &#125;&#125; HolderFragment持有mViewModelStore的引用。在HolderFragment的构造方法中，调用了setRetainInstance(true)。控制一个fragment实例是否在activity因为配置改变而销毁重建的时候被保留。如果设置为true, fragment在activity销毁重建的时候将会被保留。同时，fragment的生命周期将会发生改变，当Activity销毁重建时，fragment生命周期中的onCreate和onDestroy将不会被执行。 总结：HolderFragment实现了ViewModelStoreOwner接口，持有mViewModelStore的引用。由于Fragment和activity的生命周期是绑定的，Fragment内部可以感知到activity的生命周期。同时，通过setRetainInstance(true)，当activity被销毁重建的时候，HolderFragment并不会被销毁，导致mViewModelStore也不会被销毁ViewModel的销毁： FragmentActivity#onDestroy12345678910@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (this.mViewModelStore != null &amp;&amp; !this.isChangingConfigurations()) &#123; //当activity由于非config改变而销毁时清空mViewModelStore this.mViewModelStore.clear(); &#125; this.mFragments.dispatchDestroy();&#125; HolderFragment#onDestroy12345@Overridepublic void onDestroy() &#123; super.onDestroy(); mViewModelStore.clear();&#125; ViewModelStore#clear()123456public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.onCleared(); &#125; mMap.clear();&#125; ViewModel实现更进一步的数据持久化上面的是 activity 在因为配置改变，销毁重建的情况，在这种情况下，ViewModel 可以自动实现数据保留和现场恢复。还有一种情况是，App进入后台，然后因为内存紧张，activity 被系统销毁，然后用户再次打开，activity重建。这种情况下，ViewModel默认是不能实现现场恢复的，需要借助 SavedStateHandle。可以简单的把 SavedStateHandle 理解为 onSaveInstanceState()的逻辑从 activity 转移到了ViewModel 中。 要想使用 SavedStateHandle 需要额外导入包：1implementation &apos;androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-alpha01&apos; 然后在获取ViewModel时使用 SavedStateViewModelFactory123viewModel = ViewModelProviders.of(this, new SavedStateViewModelFactory(getApplication(), this)) .get(SaveStateTestViewModel.class); 然后在ViewModel的构造方法里传入SavedStateHandle实例，然后就可以通过SavedStateHandle保存和读取数据了。 123456789101112131415161718192021public class SaveStateTestViewModel extends ViewModel &#123; private SavedStateHandle savedStateHandle; private final MutableLiveData&lt;String&gt; notifyLiveData; public SaveStateTestViewModel(SavedStateHandle handle) &#123; this.savedStateHandle = handle; this.notifyLiveData = savedStateHandle.getLiveData(\"key\"); &#125; public void save(int data)&#123; savedStateHandle.set(\"key2\", data); &#125; public void setData(String data) &#123; this.notifyLiveData.setValue(data); &#125; public MutableLiveData&lt;String&gt; getNotifyLiveData()&#123; return notifyLiveData; &#125;&#125; 和 onSaveInstanceState() 的保存和恢复方式一样，不能保存复杂的数据，只能保存可以存入Bundle的那些类型。 也可以SavedStateHandle中使用LiveData的方式进行保存，这样的话稍微有那么一点的好处是你不需要特意的save和get数据，直接把在初始化的时候替换成SavedStateHandle#getLiveData就可以了 2. LifecyclesLifecycles组件是为了方便感知Activity和Fragment的生命周期而出现的，它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。Lifecycle包含在support library 26.1.0及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。support library在26.1.0之前，需要我们引入另外的包。 lifecycle 组件包括 Lifecycle, LifecycleOwner, LifecycleObserver 三个主要类： Lifecycle 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。 LifecycleOwner 仅有一个 getLifecycle() 方法，用于返回当前对象的 Lifecycle。 LifecycleObserver，代表观察者 1234567LifecyclerOwner和LifecycleObserverpublic interface LifecycleOwner &#123; Lifecycle getLifecycle();&#125;public interface LifecycleObserver &#123;&#125; LifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口，是被观察者。LifecycleOwner#getLifecycle()返回Lifecycle实例. 这是一种解耦实现, LifecycleOwner不包含任何有关生命周期管理的逻辑, 实际的逻辑都在Lifecycle实例中, 我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏。并不是所有的google官方的Activity和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有FragmentActivity，AppCompatActivity和v4包下的Fragment。LifecycleObserver接口代表生命周期的观察者，它的实现为空。实现LifecycleObserver的类要想感知到生命周期的变化需要借助额外的注解。或者，也可以使用一些继承了LifecycleObserver的子接口。 12345public class MyObserver implements LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public voidactivityResume() &#123; &#125; &#125; Lifecycle中的state和event1234567891011121314151617181920public enum State &#123; DESTROYED, INITIALIZED, CREATED, STARTED, RESUMED; public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125;&#125;public enum Event &#123; ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY // ON_ANY代表任意时间&#125; Lifecycle的获取生命周期的变化1234567891011121314151617public class SupportActivity extends Activity implements LifecycleOwner, Component &#123; private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this); &#125; protected void onSaveInstanceState(Bundle outState) &#123; this.mLifecycleRegistry.markState(State.CREATED); super.onSaveInstanceState(outState); &#125; public Lifecycle getLifecycle() &#123; return this.mLifecycleRegistry; &#125;&#125; LifecycleRegistry继承了Lifecycle。SupportActivity是FragmentActivity的父类。在SupportActivity中找不到state和event分发相关的代码，这些相关内容是在ReportFragment中实现的。 1234567891011121314151617181920212223242526272829public class ReportFragment extends Fragment &#123; public static void injectIfNeededIn(Activity activity) &#123; android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); manager.executePendingTransactions(); &#125; &#125; @Override public void onStart() &#123; super.onStart(); dispatchStart(mProcessListener); dispatch(Lifecycle.Event.ON_START); &#125; private void dispatch(Lifecycle.Event event) &#123; Activity activity = getActivity(); ... if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125; &#125; ...&#125; LifecycleRegistry#addObserverLifecycleRegistry继承了Lifecycle，是Activity和Fragment生命周期的真正管理类。 这个类里面的很多逻辑有点绕，我不太能理清楚。主要看一下addObserver这个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class LifecycleRegistry extends Lifecycle &#123; private FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = new FastSafeIterableMap&lt;&gt;(); private final WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner; // 当前的state private State mState; @Override public void addObserver(@NonNull LifecycleObserver observer) &#123; // observer的state初始化为DESTROYED或者INITIALIZED State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly return; &#125; boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; // 得到一个目标state State targetState = calculateTargetState(observer); mAddingObserverCounter++; // 当observer被add进来的时候，会进入循环，分发事件，直到observer的state==targetState while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; pushParentState(statefulObserver.mState); // 这里的upEvent(state)会导致statefulObserver.mState在分发的过程中不断更新 statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--; &#125; private State calculateTargetState(LifecycleObserver observer) &#123; // 这里的previous指前一个加入进来的Observer Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer); State siblingState = previous != null ? previous.getValue().mState : null; // 这个mParentStates不知道是啥。。。 State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1) : null; // 这里的min(x, y)是 返回在枚举中order最小的state return min(min(mState, siblingState), parentState); &#125; ...&#125; 在addObserver中，ObserverWithState将state和observer包装一下，ObserverWithState内初始的state是DESTROYED或者INITIALIZED。之后会计算一个targetState，在while循环中会不断的分发和更新event。 具体效果看下面的demo： 123456789101112131415@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; ... handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; TestActivity.this.getLifecycle().addObserver(new GenericLifecycleObserver() &#123; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; Log.i(\"chenlei\", \"onStateChanged: \" + event); &#125; &#125;); &#125; &#125;, 5000);&#125; 这里的GenericLifecycleObserver继承了LifecycleObserver的接口。demo中在create方法里延时5s添加一个LifecycleObserver并打印event。最后打印输出如下： 可以看到从ON_CREATE到ON_RESUME在同一时刻都打印出来了 ProcessLifecycleOwnerProcessLifecycleOwner实现了LifecycleOwner接口，可以监听当前应用前后台切换，并对此进行响应。这个类提供整个应用进程的生命周期。你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，Lifecycle.Event.ON_CREATE 事件只会分发一次，而 Lifecycle.Event.ON_DESTROY 永远不被分发。其他事件的分发遵守以下规则：ProcessLifecycleOwner 会在第一个 Activity 经历 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 事件 延迟一段时间 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。使用的时候，在Application中添加LifecycleObserver就可以了(实际上，在应用进程中的任意位置都可以） 12345678910111213141516class ApplicationObserver(val analytics: Analytics) : LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_STOP) fun onBackground() &#123; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_START) fun onForeground() &#123; &#125;&#125;public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); ProcessLifecycleOwner.get().getLifecycle().addObserver(new ApplicationObserver()); &#125;&#125; 原理： ProcessLifecycleOwnerInitializer123456789public class ProcessLifecycleOwnerInitializer extends ContentProvider &#123; @Override public boolean onCreate() &#123; LifecycleDispatcher.init(getContext()); ProcessLifecycleOwner.init(getContext()); return true; &#125; ...&#125; 这个类是ProcessLifecycleOwner初始化的地方，它继承了一个ContentProvider ，这个ContentProvider声明在了Lifecycle包的AndroidManifest.xml里。 这个AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。这里利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application 的 onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建。 LifecycleDispatcher#init123456789101112131415161718192021class LifecycleDispatcher &#123; private static AtomicBoolean sInitialized = new AtomicBoolean(false); static void init(Context context) &#123; if (sInitialized.getAndSet(true)) &#123; return; &#125; ((Application) context.getApplicationContext()) .registerActivityLifecycleCallbacks(new DispatcherActivityCallback()); &#125; static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; ReportFragment.injectIfNeededIn(activity); &#125; ... &#125;&#125; 在Application中注册一个ActivityLifecycleCallbacks，在ActivityLifecycleCallbacks中有Activity所有生命周期的回调，这样就能监听到每一个Activity的创建和销毁。在onActivityCreated回调中往Activity注入一个了ReportFragment，我没看出来这里的ReportFragment的作用是什么。。 ProcessLifecycleOwner 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ProcessLifecycleOwner implements LifecycleOwner &#123; private final LifecycleRegistry mRegistry = new LifecycleRegistry(this); private static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner(); static void init(Context context) &#123; sInstance.attach(context); &#125; private ActivityInitializationListener mInitializationListener = new ActivityInitializationListener() &#123; @Override public void onCreate() &#123; &#125; @Override public void onStart() &#123; activityStarted(); &#125; @Override public void onResume() &#123; activityResumed(); &#125; &#125;; void attach(Context context) &#123; mHandler = new Handler(); mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); Application app = (Application) context.getApplicationContext(); app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; //在ReportFragment的生命周期中会有dispatchXxxx(mProcessListener) ReportFragment.get(activity) .setProcessListener(mInitializationListener); &#125; @Override public void onActivityPaused(Activity activity) &#123; activityPaused(); &#125; @Override public void onActivityStopped(Activity activity) &#123; activityStopped(); &#125; &#125;); &#125; void activityResumed() &#123; mResumedCounter++; if (mResumedCounter == 1) &#123; if (mPauseSent) &#123; mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME); mPauseSent = false; &#125; else &#123; mHandler.removeCallbacks(mDelayedPauseRunnable); &#125; &#125; &#125; void activityPaused() &#123; mResumedCounter--; if (mResumedCounter == 0) &#123; mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS); &#125; &#125; // 在mDelayedPauseRunnable中会调用这个方法 private void dispatchPauseIfNeeded() &#123; if (mResumedCounter == 0) &#123; mPauseSent = true; mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE); &#125; &#125; ...&#125; 2. LiveDataViewModel和Lifecycles分别代表数据和UI两端，这两个组件是相对比较独立的，并没有太多直接的关系。为了防止内存泄漏，ViewModel不能直接持有activity和fragment的引用。为了让更好的结合ViewModel和Lifecycles，就需要LiveData。LiveData是一种观察者模式, 在 Value发生变化时通知之前注册的所有观察者。同时，借助于Lifecycles，LiveData具有生命周期的感知能力。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。使用LiveData有以下的优点： LiveData 只会将消息通知给活跃的观察者，非活跃观察者将不会收到消息通知。 当非活跃观察者状态变为活跃的时候，LiveData会将自动将最新的消息发送给它。 当相应的 Lifecycle 对象的状态变为 DESTROYED 时，LiveData会自动的移除此观察者，这样就不用担心Fragment和Activity的内存泄漏。 LiveData的数据发送和Observer的添加是没有顺序限制的。比如说LiveData在第1s发送消息，然后在第5s添加Observer，Observer依然能够立即接收到第1s发送出的数据，只要数据是当前最新的。这主要和LifecycleRegistry#addObserver的实现有关 2.1 LiveData的使用2.1.1 基本使用12345678910111213141516171819202122232425262728 public class NameViewModel extends ViewModel &#123; private MutableLiveData&lt;String&gt; notifyCurrentName = new MutableLiveData&lt;&gt;(); private void post()&#123; notifyCurrentName.postValue(\"value\"); &#125; public MutableLiveData&lt;String&gt; getNotifyCurrentName()&#123; return notifyCurrentName; &#125;&#125;// 在activity or fragment中// public void observe(LifecycleOwner owner, Observer&lt;T&gt; observer) getViewModel().getNotifyCurrentName().observer(this, new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable Stirng value) &#123; ... &#125;&#125;// 如果不想让LiveData感知到生命周期，可以用observeForever(Observer&lt;T&gt; observer)getViewModel().getNotifyCurrentName().observeForever(new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable Stirng value) &#123; ... &#125;&#125; 2.1.2 Transformations#mapTransformations是用来做LiveData转换的类。Transformations#map可以在消息分派给观察者之前对消息进行更改。 1234LiveData&lt;User&gt; userLiveData = ...;LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123; user.name + \" \" + user.lastName&#125;); 2.1.3 Transformations#switchMapswitchMap可以实现LiveData的转换，下面是一个demo，通过switchMap切换LiveData的数据源 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MapTestViewModel extends ViewModel &#123; private MutableLiveData&lt;String&gt; dataSourceA = new MutableLiveData&lt;&gt;(); private MutableLiveData&lt;String&gt; dataSourceB = new MutableLiveData&lt;&gt;(); private MutableLiveData&lt;Boolean&gt; changeDataSource = new MutableLiveData&lt;&gt;(); private LiveData&lt;String&gt; notifyData = Transformations.switchMap(changeDataSource, new Function&lt;Boolean, LiveData&lt;String&gt;&gt;() &#123; @Override public LiveData&lt;String&gt; apply(Boolean input) &#123; return input ? dataSourceA : dataSourceB; &#125; &#125;); public void start(Activity activity) &#123; changeDataSource.setValue(true); Handler handler = new Handler(activity.getMainLooper()); handler.postDelayed(() -&gt; &#123; dataSourceA.postValue(\"data from source A\"); dataSourceB.postValue(\"data from source B\"); &#125;, 2000); handler.postDelayed(() -&gt; &#123; changeDataSource(false); &#125;, 10000); &#125; public void changeDataSource(boolean userA) &#123; changeDataSource.setValue(userA); &#125; public LiveData&lt;String&gt; getNotifyData() &#123; return notifyData; &#125;&#125;// activityviewModel.start(this);viewModel.getNotifyData().observe(MapTestActivity.this, new Observer&lt;String&gt;() &#123; @Override public void onChanged(String s) &#123; Log.i(\"chenlei\", \"onChanged: \" + s); &#125;&#125;); 上面的demo中，延时2s同时向dataSourceA和dataSourceB发送数据，并延时10s将数据源从A指向B。在observe中打印结果，最终dataSourceA和dataSourceB在间隔一段时间之后都能打印出来。每次调用changeDataSource.setValue(Boolean)，都会调用Function#apply返回一个LiveData，并将notifyData的 Observer 添加到新的LiveData上 2.2 LiveData的原理2.2.1 LiveData1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class LiveData&lt;T&gt; &#123; // 存放Observer的集合 private SafeIterableMap&lt;Observer&lt;T&gt;, ObserverWrapper&gt; mObservers = new SafeIterableMap&lt;&gt;(); static final int START_VERSION = -1; private int mActiveCount = 0; private int mVersion = START_VERSION; ... // 当LiveData的活跃Observer数量由0变成1的时候调用 protected void onActive() &#123;&#125; // 当LiveData的活跃Observer数量由1变成0的时候调用 protected void onInactive() &#123;&#125; ... private abstract class ObserverWrapper &#123; final Observer&lt;T&gt; mObserver; boolean mActive; int mLastVersion = START_VERSION; ObserverWrapper(Observer&lt;T&gt; observer) &#123; mObserver = observer; &#125; abstract boolean shouldBeActive(); boolean isAttachedTo(LifecycleOwner owner) &#123; return false; &#125; void detachObserver() &#123; &#125; void activeStateChanged(boolean newActive) &#123; // 活跃状态没有改变则return， 防止重复发送消息 if (newActive == mActive) &#123; return; &#125; mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; onInactive(); &#125; if (mActive) &#123; // 开始分发value dispatchingValue(this); &#125; &#125; &#125; ...&#125; 2.2.2 LiveData#observer123456789101112131415161718public abstract class LiveData&lt;T&gt; &#123; ... @MainThread public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; return; &#125; LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); ... if (existing != null) &#123; return; &#125; // 将wrapper将入到lifecycleOwner的生命周期的监听中 owner.getLifecycle().addObserver(wrapper); &#125; ...&#125; LifecycleBoundObserver继承自ObserverWrapper，并且实现了 1234GenericLifecycleObserver接口。GenericLifecycleObserver接口继承自LifecycleObserver接口public interface GenericLifecycleObserver extends LifecycleObserver &#123; void onStateChanged(LifecycleOwner source, Lifecycle.Event event);&#125; 123456789101112131415161718192021222324252627282930313233343536373839class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; super(observer); mOwner = owner; &#125; @Override boolean shouldBeActive() &#123; // 通过Lifecycle判断当前Observer是否活跃 return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); &#125; // GenericLifecycleObserver#onStatechanged @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; // 当LifecycleOwner已经被销毁，remove这个Observer。 // removeObserver会调用detachObserver()和activeStateChanged(false) // 这也是为什么LiveData可以自动防止UI泄漏的原因 removeObserver(mObserver); return; &#125; activeStateChanged(shouldBeActive()); &#125; @Override boolean isAttachedTo(LifecycleOwner owner) &#123; return mOwner == owner; &#125; @Override void detachObserver() &#123; // 从LifecycleOwner中remove观察者 mOwner.getLifecycle().removeObserver(this); &#125;&#125; LiveData#observeForever 12345678910111213141516171819202122@MainThreadpublic void observeForever(@NonNull Observer&lt;T&gt; observer) &#123; AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); ... if (existing != null) &#123; return; &#125; // 因为observeForever没有LifecycleOwner，为了保持和普通observe方法的特性一致，在添加observe之后立刻检查是否有数据可以发送， wrapper.activeStateChanged(true);&#125;private class AlwaysActiveObserver extends ObserverWrapper &#123; AlwaysActiveObserver(Observer&lt;T&gt; observer) &#123; super(observer); &#125; @Override boolean shouldBeActive() &#123; return true; &#125;&#125; 2.2.3 LiveData#postValue()LiveData发送消息使用setValue或者postValue方法。其中setValue只能在主线程中使用，postValue发送消息时会自动切换到主线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class LiveData&lt;T&gt; &#123; private final Runnable mPostValueRunnable = new Runnable() &#123; @Override public void run() &#123; ... setValue((T) newValue); &#125; &#125;; ... protected void postValue(T value) &#123; ... ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable); &#125; ...&#125;LiveData#setValue@MainThreadprotected void setValue(T value) &#123; assertMainThread(\"setValue\"); mVersion++; mData = value; dispatchingValue(null);&#125;private void dispatchingValue(@Nullable ObserverWrapper initiator) &#123; if (mDispatchingValue) &#123; mDispatchInvalidated = true; return; &#125; mDispatchingValue = true; do &#123; mDispatchInvalidated = false; if (initiator != null) &#123; // 向特定的Observer发送数据 considerNotify(initiator); initiator = null; &#125; else &#123; // 向所有Observer发送消息 for (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator = mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123; considerNotify(iterator.next().getValue()); if (mDispatchInvalidated) &#123; break; &#125; &#125; &#125; &#125; while (mDispatchInvalidated); mDispatchingValue = false;&#125;private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; return; &#125; if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; if (observer.mLastVersion &gt;= mVersion) &#123; // 将要发送的是旧版本，扔掉 return; &#125; observer.mLastVersion = mVersion; observer.mObserver.onChanged((T) mData);&#125;","categories":[],"tags":[{"name":"ViewModel","slug":"ViewModel","permalink":"http://yoursite.com/tags/ViewModel/"}],"keywords":[]},{"title":"Glide源码-缓存机制","slug":"Android/源码解析/Glide源码-缓存机制","date":"2019-11-18T08:52:17.000Z","updated":"2021-10-03T01:57:41.028Z","comments":true,"path":"2019/11/18/Android/源码解析/Glide源码-缓存机制/","link":"","permalink":"http://yoursite.com/2019/11/18/Android/源码解析/Glide源码-缓存机制/","excerpt":"Glide的配置在实例化Glide的时候, 对很多重要的部分做了初始化.","text":"Glide的配置在实例化Glide的时候, 对很多重要的部分做了初始化. 1234567// 起始入口public DrawableTypeRequest&lt;String&gt; load(String string) &#123; return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);&#125;... // 省略中间步骤 一直向下追溯, 可以找到Glide类的这个方法 1234567891011121314151617181920212223242526272829303132333435363738394041Glide createGlide() &#123; if (sourceService == null) &#123; // 初始化加载网络图片的线程池 final int cores = Math.max(1, Runtime.getRuntime().availableProcessors()); sourceService = new FifoPriorityThreadPoolExecutor(cores); &#125; if (diskCacheService == null) &#123; // 初始化加载磁盘缓存的线程池 diskCacheService = new FifoPriorityThreadPoolExecutor(1); &#125; // 初始化内存缓存池, 可以看到, 是一个lrucache MemorySizeCalculator calculator = new MemorySizeCalculator(context); if (bitmapPool == null) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; int size = calculator.getBitmapPoolSize(); bitmapPool = new LruBitmapPool(size); &#125; else &#123; bitmapPool = new BitmapPoolAdapter(); &#125; &#125; if (memoryCache == null) &#123; memoryCache = new LruResourceCache(calculator.getMemoryCacheSize()); &#125; if (diskCacheFactory == null) &#123; diskCacheFactory = new InternalCacheDiskCacheFactory(context); &#125; if (engine == null) &#123; // 实例化Glide Engine engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService); &#125; if (decodeFormat == null) &#123; decodeFormat = DecodeFormat.DEFAULT; &#125; return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);&#125; 内存缓存Engine-load1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private final Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;...public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; Util.assertMainThread(); long startTime = LogTime.getLogTime(); // 组装key final String id = fetcher.getId(); EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); // 先从内存cache中获取 EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Loaded resource from cache\", startTime, key); &#125; return null; &#125; // 从ActiveResources获取 EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key); &#125; return null; &#125; // 后面的内容暂时和内存缓存无关 EngineJob current = jobs.get(key); if (current != null) &#123; // 当已经存在相同的图片加载job, 直接添加新的callback即可 current.addCallback(cb); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Added to existing load\", startTime, key); &#125; return new LoadStatus(cb, current); &#125; EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable); DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority); // 具体的图片请求工作在这个runnable中 EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); engineJob.addCallback(cb); engineJob.start(runnable); return new LoadStatus(cb, engineJob);&#125; 可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取.ActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合: 为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。 存储的正在使用的图片资源的弱引用: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用 来看看对lrucache和ActiveResources的操作 内存cache的获取1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 从cache中获取private EngineResource&lt;?&gt; loadFromCache(Key key, boolean isMemoryCacheable) &#123; // 检查内存缓存是否被禁用 if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key); if (cached != null) &#123; // cache命中, 从lrucache中取出后放入ActiveResources cached.acquire(); activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue())); &#125; return cached;&#125;// 从cache中获取资源private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123; // 注意这里是直接remove的 Resource&lt;?&gt; cached = cache.remove(key); final EngineResource result; if (cached == null) &#123; result = null; &#125; else if (cached instanceof EngineResource) &#123; // Save an object allocation if we've cached an EngineResource (the typical case). result = (EngineResource) cached; &#125; else &#123; result = new EngineResource(cached, true /*isCacheable*/); &#125; return result;&#125;private EngineResource&lt;?&gt; loadFromActiveResources(Key key, boolean isMemoryCacheable) &#123; // 检查内存cache是否被禁用 if (!isMemoryCacheable) &#123; return null; &#125; EngineResource&lt;?&gt; active = null; WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key); if (activeRef != null) &#123; active = activeRef.get(); if (active != null) &#123; // ActiveResource命中 active.acquire(); &#125; else &#123; // 弱引用的对象被释放了, 直接remove activeResources.remove(key); &#125; &#125; return active;&#125; 内存cache的释放先来看看resource中如何表示图片需要被释放1234567891011121314151617class EngineResource&lt;Z&gt; implements Resource&lt;Z&gt; &#123; private int acquired; ... void acquire() &#123; ... // 省略异常处理 ++acquired; &#125; void release() &#123; ... // 省略异常处理 if (--acquired == 0) &#123; // 当acquired为0的使用, 表示当前图片没有被引用 listener.onResourceReleased(key, this); &#125; &#125;&#125; resource中listener的回调是在EngineJob类中实现的 1234567891011// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache@Overridepublic void onResourceReleased(Key cacheKey, EngineResource resource) &#123; Util.assertMainThread(); activeResources.remove(cacheKey); if (resource.isCacheable()) &#123; cache.put(cacheKey, resource); &#125; else &#123; resourceRecycler.recycle(resource); &#125;&#125; 磁盘缓存首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理. 入口内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中 123456789101112131415161718192021222324private Resource&lt;?&gt; decode() throws Exception &#123; if (isDecodingFromCache()) &#123; return decodeFromCache(); &#125; else &#123; return decodeFromSource(); &#125;&#125;// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片private Resource&lt;?&gt; decodeFromCache() throws Exception &#123; Resource&lt;?&gt; result = null; try &#123; result = decodeJob.decodeResultFromCache(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, \"Exception decoding result from cache: \" + e); &#125; &#125; if (result == null) &#123; result = decodeJob.decodeSourceFromCache(); &#125; return result; &#125; 磁盘cache读取1234567891011121314151617181920212223242526272829303132333435public Resource&lt;Z&gt; decodeResultFromCache() throws Exception &#123; if (!diskCacheStrategy.cacheResult()) &#123; return null; &#125; long startTime = LogTime.getLogTime(); Resource&lt;T&gt; transformed = loadFromCache(resultKey); startTime = LogTime.getLogTime(); Resource&lt;Z&gt; result = transcode(transformed); return result;&#125;public Resource&lt;Z&gt; decodeSourceFromCache() throws Exception &#123; if (!diskCacheStrategy.cacheSource()) &#123; return null; &#125; long startTime = LogTime.getLogTime(); Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey()); return transformEncodeAndTranscode(decoded);&#125;private Resource&lt;T&gt; loadFromCache(Key key) throws IOException &#123; File cacheFile = diskCacheProvider.getDiskCache().get(key); if (cacheFile == null) &#123; return null; &#125; Resource&lt;T&gt; result = null; try &#123; result = loadProvider.getCacheDecoder().decode(cacheFile, width, height); &#125; finally &#123; if (result == null) &#123; diskCacheProvider.getDiskCache().delete(key); &#125; &#125; return result;&#125; 磁盘缓存读取这里挺好懂的 磁盘cache写入缓存原始图片直接贴调用过程吧 EngineRunnable.decodeFromSource()-&gt; EngineRunnable.decodeFromSource()-&gt; DecodeJob.decodeFromSource()-&gt; DecodeJob.decodeSource()-&gt; DecodeJob.decodeFromSourceData()-&gt; DecodeJob.cacheAndDecodeSourceData 1234567891011121314151617181920212223242526private Resource&lt;T&gt; decodeSource() throws Exception &#123; Resource&lt;T&gt; decoded = null; try &#123; long startTime = LogTime.getLogTime(); // 从网络获取图片 final A data = fetcher.loadData(priority); if (isCancelled) &#123; return null; &#125; decoded = decodeFromSourceData(data); &#125; finally &#123; fetcher.cleanup(); &#125; return decoded;&#125;private Resource&lt;T&gt; cacheAndDecodeSourceData(A data) throws IOException &#123; long startTime = LogTime.getLogTime(); SourceWriter&lt;A&gt; writer = new SourceWriter&lt;A&gt;(loadProvider.getSourceEncoder(), data); diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer); startTime = LogTime.getLogTime(); // ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个? Resource&lt;T&gt; result = loadFromCache(resultKey.getOriginalKey()); return result;&#125; 缓存处理过后的图片EngineRunnable.decodeFromSource()-&gt; EngineRunnable.decodeFromSource()-&gt; DecodeJob.decodeFromSource()-&gt; DecodeJob.transformEncodeAndTranscode-&gt; DecodeJob.writeTransformedToCache 12345678910111213141516171819202122private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) &#123; long startTime = LogTime.getLogTime(); // 先转换图片 Resource&lt;T&gt; transformed = transform(decoded); // 写入磁盘 writeTransformedToCache(transformed); startTime = LogTime.getLogTime(); // 转码 Resource&lt;Z&gt; result = transcode(transformed); return result;&#125;private void writeTransformedToCache(Resource&lt;T&gt; transformed) &#123; if (transformed == null || !diskCacheStrategy.cacheResult()) &#123; return; &#125; long startTime = LogTime.getLogTime(); SourceWriter&lt;Resource&lt;T&gt;&gt; writer = new SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed); diskCacheProvider.getDiskCache().put(resultKey, writer);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"glide","slug":"glide","permalink":"http://yoursite.com/tags/glide/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Glide源码-主要流程","slug":"Android/源码解析/Glide源码-主要流程","date":"2019-11-17T18:00:05.000Z","updated":"2021-10-03T01:57:41.028Z","comments":true,"path":"2019/11/18/Android/源码解析/Glide源码-主要流程/","link":"","permalink":"http://yoursite.com/2019/11/18/Android/源码解析/Glide源码-主要流程/","excerpt":"API调用123Glide.with(fragment) .load(myUrl) .into(imageView);","text":"API调用123Glide.with(fragment) .load(myUrl) .into(imageView); with过程主要工作将图片加载和对应的生命周期绑定(如activity, fragment等)绑定生命周期的优点: 在activity, fragment等销毁的时候, 停止对应的图片加载. 避免消耗资源 防止空指针问题的出现 Glide123456789101112131415161718192021222324public static RequestManager with(Context context) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(context);&#125;public static RequestManager with(Activity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity);&#125;public static RequestManager with(FragmentActivity activity) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity);&#125;public static RequestManager with(android.app.Fragment fragment) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(fragment);&#125;public static RequestManager with(Fragment fragment) &#123; RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(fragment);&#125; RequestManagerRetriever前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public RequestManager get(Context context) &#123; if (context == null) &#123; throw new IllegalArgumentException(\"You cannot start a load on a null Context\"); &#125; else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) &#123; if (context instanceof FragmentActivity) &#123; return get((FragmentActivity) context); &#125; else if (context instanceof Activity) &#123; return get((Activity) context); &#125; else if (context instanceof ContextWrapper) &#123; return get(((ContextWrapper) context).getBaseContext()); &#125; &#125; return getApplicationManager(context);&#125;// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定private RequestManager getApplicationManager(Context context) &#123; // Either an application context or we're on a background thread. if (applicationManager == null) &#123; synchronized (this) &#123; if (applicationManager == null) &#123; // Normally pause/resume is taken care of by the fragment we add to the fragment or activity. // However, in this case since the manager attached to the application will not receive lifecycle // events, we must force the manager to start resumed using ApplicationLifecycle. // 双校验锁 懒汉单例 // 将资源加载与整个APP的生命周期绑定 applicationManager = new RequestManager(context.getApplicationContext(), new ApplicationLifecycle(), new EmptyRequestManagerTreeNode()); &#125; &#125; &#125; return applicationManager;&#125;// 获取RequestManagerpublic RequestManager get(Activity activity) &#123; if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); android.app.FragmentManager fm = activity.getFragmentManager(); return fragmentGet(activity, fm); &#125;&#125;.... // 省略其他的重载方法// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定RequestManager fragmentGet(Context context, android.app.FragmentManager fm) &#123; RequestManagerFragment current = getRequestManagerFragment(fm); RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager;&#125;// 创建并添加RequestManagerFragmentRequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) &#123; RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) &#123; // pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的 current = pendingRequestManagerFragments.get(fm); if (current == null) &#123; // 使用FragmentManager添加fragment current = new RequestManagerFragment(); pendingRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current;&#125; load过程RequestManager-load123public DrawableTypeRequest&lt;String&gt; load(String string) &#123; return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);&#125; GenericRequestBuilderRequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法.跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了 123456// ModelType是一个泛型通配符, model是加载的参数public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; load(ModelType model) &#123; this.model = model; isModelSet = true; return this;&#125; into过程GenericRequestBuilder-into123456789101112131415161718192021222324252627282930313233public Target&lt;TranscodeType&gt; into(ImageView view) &#123; Util.assertMainThread(); if (view == null) &#123; throw new IllegalArgumentException(\"You must pass in a non null View\"); &#125; // ...省略代码 return into(glide.buildImageViewTarget(view, transcodeClass));&#125;public &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(Y target) &#123; Util.assertMainThread(); ... // 省略代码 Request previous = target.getRequest(); // 清楚target上旧的图片请求 if (previous != null) &#123; previous.clear(); requestTracker.removeRequest(previous); previous.recycle(); &#125; Request request = buildRequest(target); target.setRequest(request); lifecycle.addListener(target); // 开始请求图片 requestTracker.runRequest(request); return target;&#125; 为什么要清楚target上旧的图片请求: 由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。 在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象 GenericRequestBuilder-runRequest12345678910public void runRequest(Request request) &#123; requests.add(request); if (!isPaused) &#123; // 请求加载没有暂停, 则开始请求 request.begin(); &#125; else &#123; // 请求加载暂停了, 则放入到等待队列中去 pendingRequests.add(request); &#125;&#125; 1234567891011121314151617181920212223242526@Overridepublic void begin() &#123; startTime = LogTime.getLogTime(); if (model == null) &#123; onException(null); return; &#125; status = Status.WAITING_FOR_SIZE; if (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123; // 如果用户在调用API时配置了图片的大小, 直接下一步 // onSizeReady这个方法很重要 onSizeReady(overrideWidth, overrideHeight); &#125; else &#123; // 如果没有, 则获取ImageView的大小 // 这个方法最终也会走到onSizeReady方法 target.getSize(this); &#125; if (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123; target.onLoadStarted(getPlaceholderDrawable()); &#125; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime)); &#125;&#125; 123456789101112131415161718192021222324252627282930313233@Overridepublic void onSizeReady(int width, int height) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(\"Got onSizeReady in \" + LogTime.getElapsedMillis(startTime)); &#125; if (status != Status.WAITING_FOR_SIZE) &#123; return; &#125; status = Status.RUNNING; width = Math.round(sizeMultiplier * width); height = Math.round(sizeMultiplier * height); ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader(); final DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height); if (dataFetcher == null) &#123; onException(new Exception(\"Failed to load model: \\'\" + model + \"\\'\")); return; &#125; ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder(); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(\"finished setup for calling load in \" + LogTime.getElapsedMillis(startTime)); &#125; loadedFromMemoryCache = true; // 前面的代码都不知道在讲啥, 反正这个engine.load是重点 loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder, priority, isMemoryCacheable, diskCacheStrategy, this); loadedFromMemoryCache = resource != null; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logV(\"finished onSizeReady in \" + LogTime.getElapsedMillis(startTime)); &#125;&#125; Engine-load获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public &lt;T, Z, R&gt; LoadStatus load(Key signature, int width, int height, DataFetcher&lt;T&gt; fetcher, DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder, Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) &#123; Util.assertMainThread(); long startTime = LogTime.getLogTime(); final String id = fetcher.getId(); EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable); if (cached != null) &#123; cb.onResourceReady(cached); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Loaded resource from cache\", startTime, key); &#125; return null; &#125; EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable); if (active != null) &#123; cb.onResourceReady(active); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key); &#125; return null; &#125; EngineJob current = jobs.get(key); if (current != null) &#123; current.addCallback(cb); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Added to existing load\", startTime, key); &#125; return new LoadStatus(cb, current); &#125; // 前面的缓存策略, 只有再说 EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable); DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority); EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority); jobs.put(key, engineJob); engineJob.addCallback(cb); engineJob.start(runnable); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey(\"Started new load\", startTime, key); &#125; return new LoadStatus(cb, engineJob);&#125; EngineRunnable获取网络图片, 并编解码 12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic void run() &#123; if (isCancelled) &#123; return; &#125; Exception exception = null; Resource&lt;?&gt; resource = null; try &#123; // decode()方法是重点 // decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等 // 这里就不分析了, 太麻烦 resource = decode(); &#125; catch (OutOfMemoryError e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, \"Out Of Memory Error decoding\", e); &#125; exception = new ErrorWrappingGlideException(e); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, \"Exception decoding\", e); &#125; exception = e; &#125; if (isCancelled) &#123; if (resource != null) &#123; resource.recycle(); &#125; return; &#125; if (resource == null) &#123; onLoadFailed(exception); &#125; else &#123; onLoadComplete(resource); &#125;&#125;private void onLoadComplete(Resource resource) &#123; // manager是一个EngineJob对象 manager.onResourceReady(resource);&#125; EngineJob12345678910111213141516171819202122232425262728293031@Overridepublic void onResourceReady(final Resource&lt;?&gt; resource) &#123; this.resource = resource; // 这个handler最终会执行到handleResultOnMainThread方法 MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();&#125;private void handleResultOnMainThread() &#123; if (isCancelled) &#123; resource.recycle(); return; &#125; else if (cbs.isEmpty()) &#123; throw new IllegalStateException(\"Received a resource without any callbacks to notify\"); &#125; engineResource = engineResourceFactory.build(resource, isCacheable); hasResource = true; // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it // synchronously released by one of the callbacks. engineResource.acquire(); listener.onEngineJobComplete(key, engineResource); for (ResourceCallback cb : cbs) &#123; if (!isInIgnoredCallbacks(cb)) &#123; engineResource.acquire(); cb.onResourceReady(engineResource); &#125; &#125; // Our request is complete, so we can release the resource. engineResource.release();&#125; 就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"glide","slug":"glide","permalink":"http://yoursite.com/tags/glide/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-CallServerInterceptor","slug":"Android/源码解析/OkHttp3源码-CallServerInterceptor","date":"2019-11-16T17:10:03.000Z","updated":"2021-10-03T01:57:41.029Z","comments":true,"path":"2019/11/17/Android/源码解析/OkHttp3源码-CallServerInterceptor/","link":"","permalink":"http://yoursite.com/2019/11/17/Android/源码解析/OkHttp3源码-CallServerInterceptor/","excerpt":"CallServerInterceptor主要负责具体的访问服务端","text":"CallServerInterceptor主要负责具体的访问服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** This is the last interceptor in the chain. It makes a network call to the server. */ @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); realChain.eventListener().requestHeadersStart(realChain.call()); // HttpCodec相当于流, 将请求header写入流 httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100 // Continue\" response before transmitting the request body. If we don't get that, return // what we did get (such as a 4xx response) without ever transmitting the request body. // 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流. // \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体 if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) &#123; // 发送请求头 httpCodec.flushRequest(); realChain.eventListener().responseHeadersStart(realChain.call()); // 读取response responseBuilder = httpCodec.readResponseHeaders(true); &#125; // 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, // 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体 if (responseBuilder == null) &#123; // Write the request body if the \"Expect: 100-continue\" expectation was met. // 将请求体写入流 realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); &#125; else if (!connection.isMultiplexed()) &#123; // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection // from being reused. Otherwise we're still obligated to transmit the request body to // leave the connection in a consistent state. // 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接) streamAllocation.noNewStreams(); &#125; &#125; // 结束发送请求 httpCodec.finishRequest(); if (responseBuilder == null) &#123; realChain.eventListener().responseHeadersStart(realChain.call()); // 读取response的头 responseBuilder = httpCodec.readResponseHeaders(false); &#125; // 构建带响应头的响应体 Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (code == 100) &#123; // server sent a 100-continue even though we did not request one. // try again to read the actual response responseBuilder = httpCodec.readResponseHeaders(false); response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); code = response.code(); &#125; realChain.eventListener() .responseHeadersEnd(realChain.call(), response); if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; // 构建响应体 response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength()); &#125; return response; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-ConnectInterceptor","slug":"Android/源码解析/OkHttp3源码-ConnectInterceptor","date":"2019-11-15T15:45:15.000Z","updated":"2022-09-07T13:24:00.374Z","comments":true,"path":"2019/11/15/Android/源码解析/OkHttp3源码-ConnectInterceptor/","link":"","permalink":"http://yoursite.com/2019/11/15/Android/源码解析/OkHttp3源码-ConnectInterceptor/","excerpt":"ConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.","text":"ConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用. 参考链接:okhttp源码分析（四）-ConnectInterceptor过滤器OkHttp3源码解析(三)——连接池复用 intercept123456789101112@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection);&#125; ConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单. StreamAllocation流, 连接, 请求HTTP通信执行网络”请求”需要在”连接”上建立一个新的”流”. StreamAllocation称之流的桥梁，它负责为一次”请求”寻找”连接”并建立”流”来看看StreamAllocation源代码上的官方注释:1234567891011121314/** * &lt;ul&gt; * &lt;li&gt;&lt;strong&gt;Connections:&lt;/strong&gt; physical socket connections to remote servers. These are * potentially slow to establish so it is necessary to be able to cancel a connection * currently being connected. * &lt;li&gt;&lt;strong&gt;Streams:&lt;/strong&gt; logical HTTP request/response pairs that are layered on * connections. Each connection has its own allocation limit, which defines how many * concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream * at a time, HTTP/2 typically carry multiple. * &lt;li&gt;&lt;strong&gt;Calls:&lt;/strong&gt; a logical sequence of streams, typically an initial request and * its follow up requests. We prefer to keep all streams of a single call on the same * connection for better behavior and locality. * &lt;/ul&gt; */ 翻译: Connection: 到远端服务器的物理连接. Socket连接的具体工作者 Stream: 在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个. 在okhttp3的流是HttpCodec表示 Call: 对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中 newStream, findHealthyConnectionnewStream获取合适的连接, 从连接中获取流123456789101112131415161718192021public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123; int connectTimeout = client.connectTimeoutMillis(); int readTimeout = client.readTimeoutMillis(); int writeTimeout = client.writeTimeoutMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try &#123; //获取一个连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks); //实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec HttpCodec resultCodec = resultConnection.newCodec(client, this); synchronized (connectionPool) &#123; codec = resultCodec; return resultCodec; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125;&#125; findHealthyConnecton不断循环, 直到获取一个healthy?的连接健康的连接, 大概意思是socket能正常使用的意思吧 123456789101112131415161718192021222324252627282930/** * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated * until a healthy connection is found. */private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; while (true) &#123; RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); // If this is a brand new connection, we can skip the extensive health checks. synchronized (connectionPool) &#123; if (candidate.successCount == 0) &#123; return candidate; &#125; &#125; // Do a (potentially slow) check to confirm that the pooled connection is still good. If it // isn't, take it out of the pool and start again. if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123; // 如果这个连接不健康, // 禁用这条连接, 重复寻找可用的连接 noNewStreams(); continue; &#125; return candidate; &#125;&#125; findConnection-重点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139 /** * Returns a connection to host a new stream. This prefers the existing connection if it exists, * then the pool, finally building a new connection. */ /** * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接 */private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) throws IOException &#123; boolean foundPooledConnection = false; RealConnection result = null; Route selectedRoute = null; Connection releasedConnection; Socket toClose; synchronized (connectionPool) &#123; ... // 省略代码 // Attempt to use an already-allocated connection. We need to be careful here because our // already-allocated connection may have been restricted from creating new streams. releasedConnection = this.connection; toClose = releaseIfNoNewStreams(); if (this.connection != null) &#123; //如果当前connection不为空可以直接使用 // We had an already-allocated connection and it's good. result = this.connection; releasedConnection = null; &#125; if (!reportedAcquired) &#123; // If the connection was never reported acquired, don't report it as released! releasedConnection = null; &#125; //当前这个connection不能使用，尝试从连接池里面获取一个请求 if (result == null) &#123; // Attempt to get a connection from the pool. // Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法 Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; foundPooledConnection = true; result = connection; &#125; else &#123; selectedRoute = route; &#125; &#125; &#125; closeQuietly(toClose); ... // 省略代码 if (result != null) &#123; // 找到一条可复用的连接 // If we found an already-allocated or pooled connection, we're done. return result; &#125; // 到达这里表示没有找到 // 切换路由再在连接池里面找下，如果有则返回 // If we need a route selection, make one. This is a blocking operation. boolean newRouteSelection = false; // 检查是否有其他路由 if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123; newRouteSelection = true; routeSelection = routeSelector.next(); &#125; synchronized (connectionPool) &#123; if (canceled) throw new IOException(\"Canceled\"); if (newRouteSelection) &#123; // Now that we have a set of IP addresses, make another attempt at getting a connection from // the pool. This could match due to connection coalescing. // 有其他路由, 遍历RooteSelector List&lt;Route&gt; routes = routeSelection.getAll(); for (int i = 0, size = routes.size(); i &lt; size; i++) &#123; Route route = routes.get(i); Internal.instance.get(connectionPool, address, this, route); if (connection != null) &#123; foundPooledConnection = true; result = connection; this.route = route; break; &#125; &#125; &#125; if (!foundPooledConnection) &#123; //没找到则创建一条 if (selectedRoute == null) &#123; selectedRoute = routeSelection.next(); &#125; // Create a connection and assign it to this allocation immediately. This makes it possible // for an asynchronous cancel() to interrupt the handshake we're about to do. route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); //往连接中增加流 acquire(result, false); &#125; &#125; // If we found a pooled connection on the 2nd time around, we're done. //如果第二次找到了可以复用的，则返回 if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result); return result; &#125; // Do TCP + TLS handshakes. This is a blocking operation. // 建立连接,开始握手 result.connect( connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener); // 将这条路由从错误缓存中清除 routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; reportedAcquired = true; // Pool the connection. //将这个请求加入连接池 Internal.instance.put(connectionPool, result); // If another multiplexed connection to the same address was created concurrently, then // release this connection and acquire that one. // 如果是多路复用，则合并 if (result.isMultiplexed()) &#123; // 返回的是一个重复的socket socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; &#125; &#125; // 关闭重复的socket closeQuietly(socket); eventListener.connectionAcquired(call, result); return result; &#125; ConnectionPool主要成员变量123456789101112131415161718192021222324252627282930313233343536373839404142/*** Background threads are used to cleanup expired connections. There will be at most a single* thread running per connection pool. The thread pool executor permits the pool itself to be* garbage collected.*//**被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). */private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(\"OkHttp ConnectionPool\", true));/** The maximum number of idle connections for each address. */// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5private final int maxIdleConnections;// 允许的线程空闲的最大时间, 默认为5分钟private final long keepAliveDurationNs;// 清理的taskprivate final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; while (true) &#123; long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) &#123; try &#123; ConnectionPool.this.wait(waitMillis, (int) waitNanos); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125; &#125;&#125;;// 连接池中的连接集合private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;();// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...final RouteDatabase routeDatabase = new RouteDatabase();// 标记清理线程是否在运行boolean cleanupRunning; ConnectionPool创建的位置:ConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs) cleanUpRunnable会被放入线程池的清理任务 1234567891011121314151617181920private final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; while (true) &#123; // cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间 long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (ConnectionPool.this) &#123; try &#123; // 挂起清理线程 ConnectionPool.this.wait(waitMillis, (int) waitNanos); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125; &#125;&#125;; cleanUp找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*** Performs maintenance on this pool, evicting the connection that has been idle the longest if* either it has exceeded the keep alive limit or the idle connections limit.** &lt;p&gt;Returns the duration in nanos to sleep until the next scheduled call to this method. Returns* -1 if no further cleanups are required.*/long cleanup(long now) &#123; int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; // Find either a connection to evict, or the time that the next eviction is due. // 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection synchronized (this) &#123; for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123; RealConnection connection = i.next(); // If the connection is in use, keep searching. // pruneAndGetAllocationCount方法判断当前connection是否正在使用中 if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123; inUseConnectionCount++; continue; &#125; idleConnectionCount++; // If the connection is ready to be evicted, we're done. long idleDurationNs = now - connection.idleAtNanos; // 记录空闲最长的那个connection, 并且记录空闲的最长时间 if (idleDurationNs &gt; longestIdleDurationNs) &#123; longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; &#125; &#125; if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) &#123; // We've found a connection to evict. Remove it from the list, then close it below (outside // of the synchronized block). // 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制 // 从connections集合中remove掉该connection connections.remove(longestIdleConnection); &#125; else if (idleConnectionCount &gt; 0) &#123; // A connection will be ready to evict soon. // 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间 return keepAliveDurationNs - longestIdleDurationNs; &#125; else if (inUseConnectionCount &gt; 0) &#123; // All connections are in use. It'll be at least the keep alive duration 'til we run again. // 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理 return keepAliveDurationNs; &#125; else &#123; // No connections, idle or in use. // 根本没有connection, 返回-1, 直接终止清理任务 cleanupRunning = false; return -1; &#125; &#125; closeQuietly(longestIdleConnection.socket()); // Cleanup again immediately. return 0;&#125; 当连接空闲时间超出限制 或者 空闲连接的数量超出限制时，会remove掉最长空闲时间的connection pruneAndGetAllocationCount判断该连接是否是空闲的 1234567891011121314151617181920212223242526private int pruneAndGetAllocationCount(RealConnection connection, long now) &#123; List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations; for (int i = 0; i &lt; references.size(); ) &#123; Reference&lt;StreamAllocation&gt; reference = references.get(i); //如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation if (reference.get() != null) &#123; i++; continue; &#125; ... // 省略代码 //如果没有引用，就移除 references.remove(i); connection.noNewStreams = true; //如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接 if (references.isEmpty()) &#123; connection.idleAtNanos = now - keepAliveDurationNs; return 0; &#125; &#125; //遍历结束后，返回引用的数量，说明当前连接是活跃连接 return references.size();&#125; 判断连接是否空闲过程:RealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用…), 若集合为空, 则该连接时空闲的. get和putget:123456789101112RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; //判断这个连接是否符合address和route, 判断过程很麻烦 if (connection.isEligible(address, route)) &#123; // 将streamAllocation和这个connection绑定 streamAllocation.acquire(connection, true); return connection; &#125; &#125; return null;&#125; put:1234567891011void put(RealConnection connection) &#123; assert (Thread.holdsLock(this)); if (!cleanupRunning) &#123; // 当清理任务没有工作的时候, 将任务放入线程池中运行 // 因为当connections集合为空时, 清理任务会终止 // ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ??? cleanupRunning = true; executor.execute(cleanupRunnable); &#125; connections.add(connection);&#125; 插入和获取connection的key是adress， 它是 host ，cdn ，port 等的抽象","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-CacheInterceptor","slug":"Android/源码解析/OkHttp3源码-CacheInterceptor","date":"2019-11-14T12:17:52.000Z","updated":"2022-08-16T08:50:14.208Z","comments":true,"path":"2019/11/14/Android/源码解析/OkHttp3源码-CacheInterceptor/","link":"","permalink":"http://yoursite.com/2019/11/14/Android/源码解析/OkHttp3源码-CacheInterceptor/","excerpt":"OkHttp3源码-CacheInterceptor","text":"OkHttp3源码-CacheInterceptorinterceptor的详细过程看过伪代码, 现在来看详细过程, 就好多了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106@Override public Response intercept(Chain chain) throws IOException &#123; //默认cache为null, client可以配置cache,不为空尝试获取缓存中的response Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //根据response, time, request 创建一个缓存策略，用于判断怎样使用缓存 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); // 如果不需要使用网络请求 networkRequest 会为空 Request networkRequest = strategy.networkRequest; // 如果不能使用缓存， cacheResponse 会为空 Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; //如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // 不使用网络，但是有缓存，直接返回缓存 if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; //直接走后续拦截器 networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // 当缓存响应和网络响应同时存在的时候，选择用哪个 if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; // 如果返回码是304，客户端有缓存，并发出了一个条件性的请求 // (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档). // 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应 Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; //使用网络响应 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); //所以默认创建的OkHttpClient是没有缓存的 if (cache != null) &#123; // 缓存response if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // 缓存Resposne里的request信息 CacheRequest cacheRequest = cache.put(response); // 缓存Response里的body。 缓存到disk return cacheWritingResponse(cacheRequest, response); &#125; // 只能okhttp3只能缓存GET请求....不然从cache中移除request // 很奇怪, 为什么要在这里加一个判断 if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response;&#125; CacheOkHttpClient创建时添加cache:12345OkHttpClient.Builder builder = new OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .writeTimeout(20, TimeUnit.SECONDS) .readTimeout(20, TimeUnit.SECONDS) .cache(new Cache(context.getExternalCacheDir(), 10*1024*1024)); InternalCache和Cache: InternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量 实现原理: 封装了对DiskLruCach的操作 注意点:Cache类只能缓存get请求. 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低.首先，okhttp缓存的key是url。 而post请求包含了body。而且对于标准的RESTful请求，GET就是用来获取数据，最适合使用缓存，而对于数据的其他操作缓存意义不大或者根本不需要缓存。 CacheStrategy构造方法1CacheStrategy(Request networkRequest, Response cacheResponse) 生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。 CacheStrategy.Factory1public Factory(long nowMillis, Request request, Response cacheResponse) 这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy request参数中附带有用户对缓存策略的配置: ( .cacheControl) 类如:1234Request request = new Request.Builder() .cacheControl(new CacheControl.Builder().noCache().build()) .url(\"http://publicobject.com/helloworld.txt\") .build();","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-RetryAndInterceptor和BridgeInterceptor","slug":"Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor","date":"2019-11-14T08:54:17.000Z","updated":"2021-10-03T01:57:41.029Z","comments":true,"path":"2019/11/14/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor/","link":"","permalink":"http://yoursite.com/2019/11/14/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor/","excerpt":"OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor","text":"OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptorRetryAndInterceptor主要功能:失败重连, 重定向 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); EventListener eventListener = realChain.eventListener(); StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(request.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; int followUpCount = 0; // priorResponse表示在重定向时, 上一次request的response Response priorResponse = null; // while死循环, 在请求失败或者重定向之后重新发起请求 while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException(\"Canceled\"); &#125; Response response; boolean releaseConnection = true; try &#123; // 进入责任链的下一个结点 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. // recover方法判断这个request是否可以失败重连 // 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false if (!recover(e.getLastConnectException(), streamAllocation, false, request)) &#123; throw e.getFirstConnectException(); &#125; releaseConnection = false; // 进入下一个while迭代, 开始失败重连 continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, streamAllocation, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. // 如果priorResponse不为null, 将其加入到当前response中 if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); &#125; // followUp意思是重定向 Request followUp; try &#123; // followUpRequest方法: 重定向时根据response构建新的request followUp = followUpRequest(response, streamAllocation.route()); &#125; catch (IOException e) &#123; streamAllocation.release(); throw e; &#125; // followUp为空, 表示没有重定向了, 当前response为最终结果, return if (followUp == null) &#123; streamAllocation.release(); return response; &#125; // 有重定向, 关闭响应流 closeQuietly(response.body()); // 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); &#125; // 判断是否是不可重定向的类型 if (followUp.body() instanceof UnrepeatableRequestBody) &#123; streamAllocation.release(); throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code()); &#125; if (!sameConnection(response, followUp.url())) &#123; streamAllocation.release(); streamAllocation = new StreamAllocation(client.connectionPool(), createAddress(followUp.url()), call, eventListener, callStackTrace); this.streamAllocation = streamAllocation; &#125; else if (streamAllocation.codec() != null) &#123; throw new IllegalStateException(\"Closing the body of \" + response + \" didn't close its backing stream. Bad interceptor?\"); &#125; // 更新request 和 priorResponse request = followUp; priorResponse = response; &#125;&#125; RetryAndInterceptor伪代码1234567891011121314151617181920212223242526272829303132333435@Override public Response intercept(Chain chain) throws IOException &#123; Response response; Request request = chain.request; StreamAllocation streamAllocation = new StreamAllocation(); int followUpCount = 0; while(true)&#123; try&#123; response = realChain.proceed(request, streamAllocation, null, null); &#125;catch(OkhttpException e)&#123; if (!recover()) throw e; continue; &#125;catch(OtherException e)&#123; throw e; &#125; Request followUp; try &#123; followUp = followUpRequest(response, streamAllocation.route()); &#125; catch (IOException e) &#123; throw e; &#125; if(followUp == null) return response; if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; throw new Exception(\"Too many follow-up requests: \" + followUpCount); &#125; request = followUp; &#125;&#125; BridgeInterceptor这个拦截器比较简单, 提一下源代码上的注释吧 12345678910/*** Bridges from application code to network code. First it builds a network request from a user* request. Then it proceeds to call the network. Finally it builds a user response from the network* response.*//*** 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。*/","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-责任链的分析","slug":"Android/源码解析/OkHttp3源码-责任链的分析","date":"2019-11-14T07:52:46.000Z","updated":"2021-10-03T01:57:41.029Z","comments":true,"path":"2019/11/14/Android/源码解析/OkHttp3源码-责任链的分析/","link":"","permalink":"http://yoursite.com/2019/11/14/Android/源码解析/OkHttp3源码-责任链的分析/","excerpt":"okhttp3源码-责任链的分析okhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程","text":"okhttp3源码-责任链的分析okhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程 getResponseWithInterceptorChain()12345678910111213141516171819202122232425Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); Response response = chain.proceed(originalRequest); if (retryAndFollowUpInterceptor.isCanceled()) &#123; closeQuietly(response); throw new IOException(\"Canceled\"); &#125; return response; &#125;&#125; 每个拦截器的简单说明: 用户拦截器：通过Builder的addInterceptor方法添加的拦截器。 RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。 BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。 CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程 ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。 CallServerInterceptor：和服务器通信，完成Http请求。所以我们可以总结出网络请求的调用流程： Chain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类 RealInterceptorChian12345678910111213141516171819202122232425262728293031323334353637@Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection);&#125;public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; ... // 省略一些异常处理的代码 // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index + 1, request, call, eventListener, connectTimeout, readTimeout, writeTimeout); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptor + \" must call proceed() exactly once\"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\"); &#125; if (response.body() == null) &#123; throw new IllegalStateException( \"interceptor \" + interceptor + \" returned a response with no body\"); &#125; return response;&#125; interceptor.intercept(chain)伪代码123456789101112131415161718@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Call call = realChain.call(); ... // 处理request Response response; try &#123; // 继续责任链的下一个结点 response = realChain.proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (Exception e) &#123; ... // &#125; ... // 处理response&#125; 梳理一下这个责任链模式的流程: (‘ -&gt; ‘表示调用关系)-&gt; getResponseWithInterceptorChain()-&gt; chain.process(request)-&gt; interceptor.intercept(nextChain)-&gt; chain.process(request)-&gt; interceptor.intercept(nextChain)-&gt; … // 循环直至责任链最后一个结点","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"okhttp3","slug":"okhttp3","permalink":"http://yoursite.com/tags/okhttp3/"},{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/源码分析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"OkHttp3源码-发起请求的主要流程","slug":"Android/源码解析/OkHttp3源码-发起请求的主要流程","date":"2019-11-13T13:21:04.000Z","updated":"2022-06-12T06:54:54.364Z","comments":true,"path":"2019/11/13/Android/源码解析/OkHttp3源码-发起请求的主要流程/","link":"","permalink":"http://yoursite.com/2019/11/13/Android/源码解析/OkHttp3源码-发起请求的主要流程/","excerpt":"OkHttp3源码解析-发起请求的主要流程","text":"OkHttp3源码解析-发起请求的主要流程结合网上的博客和自己看的源码, 写的简单理解. 主要的类: OkHttpClient: 用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等 Request: 用户对单次请求的数据进行配置, uur, 数据参数等. Call: 在框架内部表示对请求的封装 Dispatcher: 在框架内部对请求进行分发 OkHttpClient:主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用. 123456/*** Prepares the &#123;@code request&#125; to be executed at some point in the future.*/@Override public Call newCall(Request request) &#123; return RealCall.newRealCall(this, request, false /* for web socket */);&#125; Call:构造方法12345678910111213141516171819private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; this.client = client; this.originalRequest = originalRequest; this.forWebSocket = forWebSocket; this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket); this.timeout = new AsyncTimeout() &#123; @Override protected void timedOut() &#123; cancel(); &#125; &#125;; this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);&#125;static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; // Safely publish the Call instance to the EventListener. RealCall call = new RealCall(client, originalRequest, forWebSocket); call.eventListener = client.eventListenerFactory().create(call); return call;&#125; 同步执行一个call在RealCall中有一个execute方法, 这里发起一个同步请求12345678910111213141516171819202122@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; captureCallStackTrace(); timeout.enter(); eventListener.callStart(this); try &#123; client.dispatcher().executed(this); // getResponseWithInterceptorChain()是具体的请求的操作过程 Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result; &#125; catch (IOException e) &#123; e = timeoutExit(e); eventListener.callFailed(this, e); throw e; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; getResponseWithInterceptorChain()方法是请求发出的最终执行方法. 也就是说RealCall中调用execute()就已经直接同步开始了请求操作. 但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? 详细的内容可以看Dispatcher的源码解析. 异步执行一个callRealCall中的enqueue方法, 发起一个异步请求123456789@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; captureCallStackTrace(); eventListener.callStart(this); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类 AsyncCall中的executeOn, execute123456789101112131415161718192021222324252627282930313233343536373839404142/*** Attempt to enqueue this async call on &#123;@code executorService&#125;. This will attempt to clean up* if the executor has been shut down by reporting the call as failed.*/void executeOn(ExecutorService executorService) &#123; assert (!Thread.holdsLock(client.dispatcher())); boolean success = false; try &#123; executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; InterruptedIOException ioException = new InterruptedIOException(\"executor rejected\"); ioException.initCause(e); eventListener.callFailed(RealCall.this, ioException); responseCallback.onFailure(RealCall.this, ioException); &#125; finally &#123; if (!success) &#123; client.dispatcher().finished(this); // This call is no longer running! &#125; &#125; &#125;@Override protected void execute() &#123; boolean signalledCallback = false; timeout.enter(); try &#123; Response response = getResponseWithInterceptorChain(); signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; catch (IOException e) &#123; e = timeoutExit(e); if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; eventListener.callFailed(RealCall.this, e); responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行. Dispatcher重要的成员变量12345678910111213141516private int maxRequests = 64;private int maxRequestsPerHost = 5;private @Nullable Runnable idleCallback;/** Executes calls. Created lazily. */// 这是一个线程池, 并且实现了懒加载private @Nullable ExecutorService executorService;/** Ready async calls in the order they'll be run. */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** Running synchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); 为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列. ExcutorService1234567public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(\"OkHttp Dispatcher\", false)); &#125; return executorService;&#125; 这个线程池其实是一个CacheThreadPool. 他的特点是: 底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列) 通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定时间，则该线程会被销毁。 适用：执行很多短期异步的小程序或者负载较轻的服务器 检查调用executorService()方法的地方, 是一个promoteAndExecute()方法 enqueue(AsyncCall call)123456void enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); &#125; promoteAndExecute();&#125; 上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步 promoteAndExecute()12345678910111213141516171819202122232425262728293031323334353637383940/** * Promotes eligible calls from &#123;@link #readyAsyncCalls&#125; to &#123;@link #runningAsyncCalls&#125; and runs * them on the executor service. Must not be called with synchronization because executing calls * can call into user code. * * @return true if the dispatcher is currently running calls. */// 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call// 如果成功执行上面的操作, 返回trueprivate boolean promoteAndExecute() &#123; assert (!Thread.holdsLock(this)); List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; // 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去 for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall asyncCall = i.next(); // 到达了max限制, break if (runningAsyncCalls.size() &gt;= maxRequests) break; // Max capacity. if (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) continue; // Host max capacity. i.remove(); executableCalls.add(asyncCall); runningAsyncCalls.add(asyncCall); &#125; isRunning = runningCallsCount() &gt; 0; &#125; for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); // 在线程池中执行这个call asyncCall.executeOn(executorService()); &#125; return isRunning;&#125; promoteAndExecute()方法的解析直接看上面源码的注释. 结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行.想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢?想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法 finished(Deque calls, T call)12345678910111213private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\"); idleCallback = this.idleCallback; &#125; boolean isRunning = promoteAndExecute(); if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 在RealCall和AsyncCall代码中, 能看到在调用了责任链完成一次请求之后，调用了despatcher.finished方法从readyAsyncCalls集合里获取下一个call来执行 executed(RealCall call)123synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; 可以看到只是做了一个把 call 加入到 runningSyncCalls 里 同步的call1234/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; 同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已.","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"},{"name":"Okhttp3","slug":"Okhttp3","permalink":"http://yoursite.com/tags/Okhttp3/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"docker的使用","slug":"Linux/docker的使用","date":"2019-11-12T08:09:50.000Z","updated":"2021-10-03T01:57:41.032Z","comments":true,"path":"2019/11/12/Linux/docker的使用/","link":"","permalink":"http://yoursite.com/2019/11/12/Linux/docker的使用/","excerpt":"docker 的使用Docker 和 虚拟机的区别:","text":"docker 的使用Docker 和 虚拟机的区别: 实现资源隔离的方式不同: 虚拟机:利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行 Docker:应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值 隔离性:虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker 性能:docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化 Docker Toolbox因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版. Docker Toolbox 添加镜像加速可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题. 可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好 具体的配置修改, 参考:http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox image, containerimage:镜像. 是一个包含有文件系统的面向 Docker 引擎的只读模板. 可以是从远端拉取的, 也可以是自己制作的 container:容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. 注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。 常用操作https://www.runoob.com/docker/docker-container-usage.html很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方 docker container run1docker run -it --name string ubuntu:latest /bin/bash 参数说明: -i: 交互式操作。 -t: 终端。 ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。 /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。 –name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字 注意image 每一次 docker run 之后, 都会启动一个不同的 container, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令 将容器转化为一个镜像1docker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2 -m: 提交的描述信息 -a: 指定镜像作者 e218edb10161：容器 ID runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag 注意 如果要制作的 image 打包上传到自己 docker hub, ‘ / ‘ 前面的用户名需要和自己 docker hub 的用户名保持一致 使用 Dockerfile 创建镜像没试过… 以后有机会再写上","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"handler机制源码解析","slug":"Android/Framework/handler机制源码解析","date":"2019-11-09T05:59:20.000Z","updated":"2021-10-03T01:57:41.022Z","comments":true,"path":"2019/11/09/Android/Framework/handler机制源码解析/","link":"","permalink":"http://yoursite.com/2019/11/09/Android/Framework/handler机制源码解析/","excerpt":"Handler机制源码解析因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。","text":"Handler机制源码解析因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。 1. Looper主要是loop()方法123456789101112131415161718192021222324public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. // 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中. // 只有调用quit方法时,next()方法再能真正的返回null return; &#125; try &#123; // msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方 msg.target.dispatchMessage(msg); &#125; finally &#123; ... // 省略代码 &#125; msg.recycleUnchecked(); &#125;&#125; 2. MessageQueue关键成员变量12345678910111213141516171819// mPtr是native的MessageQueue的指针private long mPtr; // used by native code// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个messageMessage mMessages;// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;();private IdleHandler[] mPendingIdleHandlers;private SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;private boolean mQuitting;// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.private boolean mBlocked;// The next barrier token.// Barriers are indicated by messages with a null target whose arg1 field carries the token.private int mNextBarrierToken; 构造方法1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; next()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 调用native层的方法,使用epoll机制,挂起当前线程. // nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; // 获取链表的头结点,即第一个message Message msg = mMessages; // 判断msg是否为同步栅栏 // 表示同步栅栏的msg, 其msg.target为null if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. // 寻找队列中第一个异步message do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; // 处理 msg if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到 // Process the quit message now that all pending messages have been handled. // 判断是否需要结束循环 if (mQuitting) &#123; // dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0 // 只有在这里next()方法才会返回null dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. // 当获取到的message为空, 或者message的执行时间没有到 // 当前没有msg可以处理的，开始处理 idleHandler if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. // 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. // 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 1. nativePollOnce(ptr, nextPollTimeoutMillis);这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间.特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.nextPollTimeoutMillis = -1 出现的时机两种情况: 消息队列为空 遇到了同步barrier, 并且之后没有遇到异步的msg 2. IdleHandler:1234567891011public static interface IdleHandler &#123; /** * Called when the message queue has run out of messages and will now * wait for more. Return true to keep your idle handler active, false * to have it removed. This may be called if there are still messages * pending in the queue, but they are all scheduled to be dispatched * after the current time. */ // queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次 boolean queueIdle();&#125; MessageQueue中有两个IdleHandler的集合, IdleHandler是一个接口, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到) 3. 同步栅栏 Barrier 定义: target为null的msg为同步栅栏 作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg 意义: 相当于为msg添加了一个优先级 quit()123456789101112131415161718192021void quit(boolean safe) &#123; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; if (safe) &#123; // 这个方法会去除所有的msg.when &gt; now 的msg removeAllFutureMessagesLocked(); &#125; else &#123; // 没有任何判断, 直接去除所有的msg removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. // 因为在next()方法中才会调用dispose()方法销毁消息队 // 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法 nativeWake(mPtr); &#125;&#125; enqueueMessage1234567891011121314151617181920212223242526272829303132333435363738394041424344454647boolean enqueueMessage(Message msg, long when) &#123; ... // 省略代码 synchronized (this) &#123; if (mQuitting) &#123; msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. // 添加到队列头部, 有可能是需要wake的 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. // 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 1. 插入顺序:之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序 2. needWake判断是否需要唤醒线程.在以下情况下, needWake会为true: 消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1 消息队列不为空, 并且当前线程是blocked的, 新插入msg.when &lt; 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg 消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://yoursite.com/tags/Handler/"},{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"RemoteView刷新view","slug":"Android/RemoteView刷新View","date":"2019-09-15T08:09:50.000Z","updated":"2021-10-03T01:57:41.025Z","comments":true,"path":"2019/09/15/Android/RemoteView刷新View/","link":"","permalink":"http://yoursite.com/2019/09/15/Android/RemoteView刷新View/","excerpt":"RemoteView刷新View通知栏在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。","text":"RemoteView刷新View通知栏在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。 在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了 关于Intent由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。 在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。 也就是说，Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"通知铃声的自定义遇到的问题-根据uri读取文件","slug":"Android/通知铃声的自定义遇到的问题-根据uri读取文件","date":"2019-08-28T15:07:53.000Z","updated":"2021-10-03T02:27:00.346Z","comments":true,"path":"2019/08/28/Android/通知铃声的自定义遇到的问题-根据uri读取文件/","link":"","permalink":"http://yoursite.com/2019/08/28/Android/通知铃声的自定义遇到的问题-根据uri读取文件/","excerpt":"通知铃声自定义遇到的问题: 根据uri读取文件","text":"通知铃声自定义遇到的问题: 根据uri读取文件问题：在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音 问题根源：1.从系统文件管理器中获取文件，从得到的uri中获取原始路径所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的 网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。 正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。 1InputStream fis = getContentResolver().openInputStream(uri); 2. 将拷贝的文件转化为uri失败的尝试：使用Uri.fromFile():首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。 在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法. 3. grantUriPermission()在某些机型中，使用file自定义notification的声音，仍然不能正常工作。设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning为什么要选择No Filter选项才会看到这个warning。是因为，弹出notification是系统服务，和我们的APP项目不是一个包名在file转uri之后添加一个授权的语句就可以了：12getApplicationContext().grantUriPermission(&quot;com.android.systemui&quot;, Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION); 包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作 到这里问题就解决了","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Notification","slug":"Notification","permalink":"http://yoursite.com/tags/Notification/"},{"name":"Uri","slug":"Uri","permalink":"http://yoursite.com/tags/Uri/"}],"keywords":[]},{"title":"RecyclerView缓存机制总结","slug":"Android/RecyclerView缓存机制总结","date":"2019-08-14T16:31:17.000Z","updated":"2022-09-06T15:54:46.453Z","comments":true,"path":"2019/08/15/Android/RecyclerView缓存机制总结/","link":"","permalink":"http://yoursite.com/2019/08/15/Android/RecyclerView缓存机制总结/","excerpt":"RecyclerView缓存机制总结基本概念","text":"RecyclerView缓存机制总结基本概念scrapped:即 dettach 和 attach 。对一个view做dettach操作，会把这个view从 ViewGroup 的 children 数组里移除，但是不会重绘UI。在 LayoutManager 布局时，会 dettach 掉所有的子view，再从 Recycler 中获取view（缓存或新创建）后再 addView。 因为做过 dettach ，已经从 children 数组里移除了。所以再addView不会造成问题。 RecyclerView中涉及到缓存的集合 mAttachedScrap 显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 LayoutManager 布局时的临时缓存，布局完成后为空 mChangedScrap 显示在屏幕中，和 mAttachedScrap 类似，在预布局的时候会用到 mCachedViews 在屏幕外的Holder。缓存，默认大小为2。 mRecyclerPool 在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法 mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。 mAttachedScrap 和 mChangedScrap 的插入1234567891011121314151617void scrapView(View view) &#123; final ViewHolder holder = getChildViewHolderInt(view); if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID) || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) &#123; if (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) &#123; throw .. &#125; holder.setScrapContainer(this, false); mAttachedScrap.add(holder); &#125; else &#123; if (mChangedScrap == null) &#123; mChangedScrap = new ArrayList&lt;ViewHolder&gt;(); &#125; holder.setScrapContainer(this, true); mChangedScrap.add(holder); &#125;&#125; LayoutManager 在布局之前会scrap所有的view。 会根据不同的情况放入到 mAttachedScrap 或者 mChangedScrap试了下，一般都是放在 mAttachedScrap 里，即使 holder.isUpdated() 为true。 所以 mAttachedScrap 里的ViewHolder也是有可能调用 onBind 的。mChangedScrap 试了下只在有一些动画需要 preLayout 的时候有用到 ViewHolder 只有在满足下面情况才会被添加到 mChangedScrap：当它关联的 item 发生了变化（notifyItemChanged 或者 notifyItemRangeChanged 被调用），并且 ItemAnimator 调用 ViewHolder#canReuseUpdatedViewHolder 方法时，返回了 false。否则，ViewHolder 会被添加到AttachedScrap 中。 canReuseUpdatedViewHolder 返回 “false” 表示我们要执行用一个 view 替换另一个 view 的动画，例如淡入淡出动画。 “true”表示动画在 view 内部发生。 mAttachedScrap 在 整个布局过程中都能使用，但是 changed scrap — 只能在预布局阶段使用。 mCachedViews 和 mRecyclerPool 的插入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void recycleViewHolderInternal(ViewHolder holder) &#123; final boolean transientStatePreventsRecycling = holder .doesTransientStatePreventRecycling(); @SuppressWarnings(\"unchecked\") final boolean forceRecycle = mAdapter != null &amp;&amp; transientStatePreventsRecycling &amp;&amp; mAdapter.onFailedToRecycleView(holder); boolean cached = false; boolean recycled = false; if (forceRecycle || holder.isRecyclable()) &#123; if (mViewCacheMax &gt; 0 &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) &#123; // Retire oldest cached view int cachedViewSize = mCachedViews.size(); if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) &#123; recycleCachedViewAt(0); cachedViewSize--; &#125; int targetCacheIndex = cachedViewSize; if (ALLOW_THREAD_GAP_WORK &amp;&amp; cachedViewSize &gt; 0 &amp;&amp; !mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) &#123; int cacheIndex = cachedViewSize - 1; while (cacheIndex &gt;= 0) &#123; int cachedPos = mCachedViews.get(cacheIndex).mPosition; if (!mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) &#123; break; &#125; cacheIndex--; &#125; targetCacheIndex = cacheIndex + 1; &#125; mCachedViews.add(targetCacheIndex, holder); cached = true; &#125; if (!cached) &#123; addViewHolderToRecycledViewPool(holder, true); recycled = true; &#125; &#125; ...&#125;void addViewHolderToRecycledViewPool(@NonNull ViewHolder holder, boolean dispatchRecycled) &#123; ... holder.mBindingAdapter = null; holder.mOwnerRecyclerView = null; getRecycledViewPool().putRecycledView(holder);&#125; 先尝试加入到 mCachedViews 集合，如果满了，就删除第一个为加入到 mCachedViews 的会加入到 recyclerPool 里mCacheViews 缓存是区分 viewType 的， recyclerPool 会区分存储，单个 viewType 容量是5判定 !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID | ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN 为true，才会加入到 mCachedViews 。 所以从 mCachedViews 获取是不需要重新 onBind 的加入到 recyclerPool 时会设置 holder.mBindingAdapter = null 下面会说到这个 RecyclerView获取Holder的顺序(sdk 28)LayoutManager 在布局的时候会调用 getViewForPosition(int position) 方法获取 VH 和 View后续会调用到tryGetViewHolderForPositionByDeadline 中获取viewholder缓存，如果不存在会创建。 getChangedScrapViewForPosition getScrapOrHiddenOrCachedHolderForPosition getScrapOrCachedViewForId getChildViewHolder mViewCacheExtension.getViewForPositionAndType getRecycledViewPool().getRecycledView mAdapter.createViewHolder 从各种缓存集合中获取 ViewHolder 。 获取的 ViewHolder 是否需要重新 bind1234567891011121314151617181920212223242526272829303132333435boolean bound = false;if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; // do not update unless we absolutely have to. holder.mPreLayoutPosition = position;&#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);&#125;private boolean tryBindViewHolderByDeadline(@NonNull ViewHolder holder, int offsetPosition, int position, long deadlineNs) &#123; holder.mBindingAdapter = null; holder.mOwnerRecyclerView = RecyclerView.this; final int viewType = holder.getItemViewType(); mAdapter.bindViewHolder(holder, offsetPosition); return true;&#125;public final void bindViewHolder(@NonNull VH holder, int position) &#123; boolean rootBind = holder.mBindingAdapter == null; if (rootBind) &#123; holder.mPosition = position; if (hasStableIds()) &#123; holder.mItemId = getItemId(position); &#125; holder.setFlags(ViewHolder.FLAG_BOUND, ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN); TraceCompat.beginSection(TRACE_BIND_VIEW_TAG); &#125; holder.mBindingAdapter = this; onBindViewHolder(holder, position, holder.getUnmodifiedPayloads()); ...&#125; !holder.isBound() ViewHolder 是否调用过 onBind 。在bind时，如果 holder.mBindingAdapter == null ，会设置这个 bound 标记位。holder.needsUpdate() 调用 notifyXxxxx 方法时vh会为trueholder.isInvalid() vh非法 是否调用 vh.onBind 只和标记位有关系，和从哪个缓存集合中获取到的无关。 加入到 mCacheView 时会判断一定没有 needUpdate 和 Invalide 的标记位，所以mCacheView一定不需要重新bind recyclerPool 加入元素时设置了 holder.mBindingAdapter = null ，所以一定需要重新 bind mAttachedScrap 是否需要重新bind是不一定的 ListView的缓存机制缓存的集合 mActiveViews 屏幕内的view，可直接重用 mScrapViews 屏幕外的view，需要调用bind 与RecyclerView的不同 缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。 RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView） RecyclerView可以实现局部刷新， ListView不行 参考：RecyclerView源码分析缓存机制 RecyclerView的缓存机制 Android ListView 与 RecyclerView 对比浅析–缓存机制 深入理解 RecyclerView 的缓存机制","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"事件分发机制","slug":"Android/Framework/事件分发机制","date":"2019-08-13T13:12:59.000Z","updated":"2022-09-06T09:03:22.112Z","comments":true,"path":"2019/08/13/Android/Framework/事件分发机制/","link":"","permalink":"http://yoursite.com/2019/08/13/Android/Framework/事件分发机制/","excerpt":"事件分发机制dispatchTouchEvent","text":"事件分发机制dispatchTouchEventViewGroup 的 dispatchTouchEvent 方法伪代码1234567891011public boolean dispatchTouchEvent()&#123; boolean consume = false; if (onInterceptTouchEvent(ev))&#123; consume = super.dispatchTouchEvent(); &#125;else&#123; consume = child.dispatchTouchEvent(ev); if (!consume) consume = super.dispatchTouchEvent(ev) &#125; return consume;&#125; 解释：在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理。上面的只是一个概述，还有很多细节要去深究 源代码dispatchTouchEvent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null cancelAndClearTouchTargets(ev); resetTouchState();&#125;final boolean intercepted;// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget 会被赋值病指向子元素// mFirstTouchTarget赋值在addTouchTarget方法中if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // mFirstTouchTarget == null, 并且这不是一个down事件, 说明 // down事件没有被ViewGroup拦击, down事件也没有被子view消费, // 后续的事件也没有被子View消费, 所以后续的事件交给ViewGroup intercepted = true;&#125;.... //省略代码// Check for cancelation.final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;// Update list of touch targets for pointer down, if needed.final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;TouchTarget newTouchTarget = null;boolean alreadyDispatchedToNewTouchTarget = false;if (!canceled &amp;&amp; !intercepted) &#123; ... //省略部分代码 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; ... for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; ... //省略部分代码 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; ... // 省略部分代码 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. // 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环 .... // 省略部分代码 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; ... //省略代码 &#125; &#125; ... // 省略部分代码&#125;... // 省略部分代码// Dispatch to touch targets.if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; else &#123; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; ... target = next; &#125; &#125; ... // 省略代码&#125;return handled; dispatchTransformedTouchEvent123456789101112131415private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; ... // 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理 if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; ... handled = child.dispatchTouchEvent(transformedEvent); &#125; ... // 省略代码&#125; mFirstTargetmFirstTouchTarget 是一个 TouchTarget 对象，通过注释的说明：”触摸目标的链接列表中的第一个触摸目标”，可以得出：mFirstTouchTarget 是”触摸目标”链表的头部。 123456789101112131415161718192021222324252627282930313233343536if (!canceled &amp;&amp; !intercepted) &#123; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; ... newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; &#125; &#125; ... &#125;&#125;if (mFirstTouchTarget == null) &#123; handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; else &#123; .... if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125;&#125; addTouchTarget(..) 方法是 mFirstTouchTarget 赋值的地方。 我们看 dispatchTouchEvent 中 mFirstTouchTarget 的使用。发现它只在 MotionEvent.ACTION_DOWN 事件的时候赋值。 然后所有的事件都会判断 mFirstTouchTarget 是否为 null ，为 null 则有 ViewGroup 处理， 不为 null 则由 mFirstTouchTarget 对应的 子view 处理。由此也就可以得出结论： 如果 子view 消费了 TOUCH_DOWN 事件，后续的事件，如果 ViewGroup 不拦截，则都交给这个 子View 消费。因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, dispatchTouchEvent 直接返回 false addTouchTargetmFirstTarget 赋值的地方 123456private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;&#125; 需要注意的点ActionDown ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理 ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位 ActionMove、ActionUp 等其他事件 若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截 若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理。 ( 因为mFirstTouchTarget==null) (以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到) requestDisallowInterceptTouchEvent(true) 子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。 但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位 mFirstTouchTarget因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, ViewGroup 的 dispatchTouchEvent 直接返回 false View 的 dispatchTouchEvent 方法如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法 123456789101112131415161718public boolean dispatchTouchEvent(MotionEvent event) &#123; ... // 省略代码 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; ... // 省略代码 return result;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"源码解析","slug":"源码解析","permalink":"http://yoursite.com/tags/源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"LayoutInflater解析","slug":"Android/LayoutInflater解析","date":"2019-08-13T12:31:21.000Z","updated":"2021-10-03T01:57:41.024Z","comments":true,"path":"2019/08/13/Android/LayoutInflater解析/","link":"","permalink":"http://yoursite.com/2019/08/13/Android/LayoutInflater解析/","excerpt":"LayoutInflater解析源码1View result = root;","text":"LayoutInflater解析源码1View result = root; 12345678910111213// Temp is the root view that was found in the xmlfinal View temp = createViewFromTag(root, name, inflaterContext, attrs);ViewGroup.LayoutParams params = null;if (root != null) &#123; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125;&#125; 123456789101112131415// Inflate all children under temp against its context.rInflateChildren(parser, temp, attrs, true);// We are supposed to attach all the views we found (int temp)// to root. Do that now.if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params);&#125;// Decide whether to return the root that was passed in or the// top view found in xml.if (root == null || !attachToRoot) &#123; result = temp;&#125; 1return result; 使用方法1LayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ; 第一个参数是layout资源文件id 第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam 第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中 需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[]},{"title":"Scale动画组合使用的坑","slug":"Android/Scale动画组合使用的坑","date":"2019-08-02T01:43:37.000Z","updated":"2021-10-03T01:57:41.025Z","comments":true,"path":"2019/08/02/Android/Scale动画组合使用的坑/","link":"","permalink":"http://yoursite.com/2019/08/02/Android/Scale动画组合使用的坑/","excerpt":"Scale动画组合使用的坑API1Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);","text":"Scale动画组合使用的坑API1Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0); 参数1: X的初始值参数2: X的最终值参数3: Y的初始值参数4: Y的最终值参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放参数6: X轴缩放轴点，1f表示以View的最右端为轴点参数7: Y轴，同参数5参数8: Y轴，同参数6 问题一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小1234567891011121314// start animation AnimationSet animationSet = new AnimationSet(false); Animation alpha = new AlphaAnimation(0, 100); alpha.setDuration(80); Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0); scale.setDuration(160); scale.setInterpolator(PathInterpolatorCompat.create(0.32f, 0.66f, 0.6f, 1f)); Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0); scale2.setDuration(70); scale2.setStartOffset(160); animationSet.addAnimation(scale); animationSet.addAnimation(scale2); animationSet.addAnimation(alpha); tv.startAnimation(animationSet); 但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小 原因scale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子123Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);scale2.setDuration(70);scale2.setStartOffset(160);","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"Animation","slug":"Animation","permalink":"http://yoursite.com/tags/Animation/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"ThreadLocal","slug":"Java/ThreadLocal","date":"2019-07-22T05:57:12.000Z","updated":"2021-10-03T01:57:41.031Z","comments":true,"path":"2019/07/22/Java/ThreadLocal/","link":"","permalink":"http://yoursite.com/2019/07/22/Java/ThreadLocal/","excerpt":"ThreadLocal作用当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量","text":"ThreadLocal作用当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量 源码分析set()12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; createMap()方法：123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 查看Thread类的代码：123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value get()方法12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; 其中的ThreadLocalMap.Entry123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己 总结Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://yoursite.com/categories/java/多线程/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://yoursite.com/categories/java/多线程/"}]},{"title":"Text相关计算","slug":"Android/Text相关计算","date":"2019-07-19T03:09:42.000Z","updated":"2021-10-03T01:57:41.025Z","comments":true,"path":"2019/07/19/Android/Text相关计算/","link":"","permalink":"http://yoursite.com/2019/07/19/Android/Text相关计算/","excerpt":"Text相关计算Text的相关属性Baseline上方的值为正，下方的值为负","text":"Text相关计算Text的相关属性Baseline上方的值为正，下方的值为负 TextSize和TextView大小的转换相关参数包括： 基准点是baseline Ascent是baseline之上至字符最高处的距离 Descent是baseline之下至字符最低处的距离 其实是上一行字符的descent到下一行的ascent之间的距离 Top指的是指的是最高字符到baseline的值，即ascent的最大值 同上，bottom指的是最下字符到baseline的值，即descent的最大值 参考Paint 绘制文字属性TextView文字实际高度分析","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"RecyclerView设置item的间距","slug":"Android/RecyclerView设置item的间距","date":"2019-07-09T09:29:55.000Z","updated":"2021-10-03T01:57:41.025Z","comments":true,"path":"2019/07/09/Android/RecyclerView设置item的间距/","link":"","permalink":"http://yoursite.com/2019/07/09/Android/RecyclerView设置item的间距/","excerpt":"RecyclerView设置item的间距","text":"RecyclerView设置item的间距关于GridLayoutManager当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，实际上就是将屏幕均分为四份，每一份都是180px宽（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。 自定义ItemDecorationgetItemOffsets方法设置ItemView的内嵌偏移长度 ItemView 外面会包裹着一个矩形（outRect）内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔相当于为item添加了padding 常用的getItemOffsets的计算 123456789101112131415161718192021222324252627282930313233343536373839// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等public class EmojiItemDecoration extends RecyclerView.ItemDecoration &#123; private int mNumColumn; private int mVerticalSpacing; private int mItemWidth; private int mItemHorizontalSpacing; private boolean mInitSpacing = false; public EmojiItemDecoration(int column, int itemWidth, int verticalSpacing) &#123; mNumColumn = column; mItemWidth = itemWidth; mVerticalSpacing = verticalSpacing; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; if (!mInitSpacing) &#123; mInitSpacing = true; int parentWidth = parent.getWidth(); mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + 1); &#125; int position = parent.getChildAdapterPosition(view); int column = position % mNumColumn; outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn; outRect.right = (column + 1) * mItemHorizontalSpacing / mNumColumn; if (position &lt; mNumColumn) &#123; outRect.top = Dimensions.pxFromDp(12); &#125; if (position &gt;= mNumColumn) &#123; outRect.top = mVerticalSpacing; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"startService()和bindService()","slug":"Android/Framework/startService-和bindService","date":"2019-07-04T12:37:58.000Z","updated":"2021-10-03T01:57:41.023Z","comments":true,"path":"2019/07/04/Android/Framework/startService-和bindService/","link":"","permalink":"http://yoursite.com/2019/07/04/Android/Framework/startService-和bindService/","excerpt":"startService()和bindService()的区别","text":"startService()和bindService()的区别 生命周期上的差别startService()执行startService时，Service经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。 多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。但是每次调用startService，onStartCommand方法都会被调用。无论startService调用多少次，stopService只需要调用一次就能够终止Service BindService()bindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。 onBind返回值是null调用bindService开启服务，生命周期执行的方法依次是：onCreate() ==&gt; onBind();调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。 onBind返回值不为null这时候调用bindService开启服务，生命周期执行的方法依次是：onCreate() ==&gt; onBind() ==&gt; onServiceConnected();可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。总结第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。 既使用startService又使用bindService的情况如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。 参考链接:https://my.oschina.net/tingzi/blog/376545https://www.jianshu.com/p/d870f99b675c startService 启动过程源码分析ContextImpl.startService(…) 最终会调用到 AMS 的对应方法，最终会调用到 ActivityService.startServiceLocked(…) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId) throws TransactionTooLargeException &#123; ServiceLookupResult res = retrieveServiceLocked(service, resolvedType, callingPackage, callingPid, callingUid, userId, true, callerFg, false, false); ServiceRecord r = res.record; ... // ServiceRecord.StartItem 用于在 service 启动之后调用 startCommond r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), service, neededGrants, callingUid)); ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting); return cmp; &#125; ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123; String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false); ... return r.name; &#125; private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123; if (r.app != null &amp;&amp; r.app.thread != null) &#123; // service 的进程已经启动，sendServiceArgsLocked 用于调用 startCommond() 方法 sendServiceArgsLocked(r, execInFg, false); return null; &#125; final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0; final String procName = r.processName; String hostingType = \"service\"; ProcessRecord app; if (!isolated) &#123; app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (app != null &amp;&amp; app.thread != null) &#123; // service 不是单独的进程且，service 所在进程已经启动，则直接启动进程 try &#123; realStartServiceLocked(r, app, execInFg); return null; &#125; ... &#125; &#125; else &#123; app = r.isolatedProc; ... &#125; if (app == null &amp;&amp; !permissionsReviewRequired) &#123; // servie 所在的进程还没有启动，启动相应的进程 if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags, hostingType, r.name, false, isolated, false)) == null) &#123; String msg = ... return msg; &#125; if (isolated) &#123; r.isolatedProc = app; &#125; &#125; // 暂存进程未启动的 service , 当 service 进程启动完，Application 进行 AMS.attach() 的时候，会 mPendingServices 取出 ServiceRecord 并执行 realStartServiceLocked if (!mPendingServices.contains(r)) &#123; mPendingServices.add(r); &#125; return null; &#125; private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; if (app.thread == null) &#123; // service 进程未启动，抛出异常 throw new RemoteException(); &#125; r.app = app; r.restartTime = r.lastActivity = SystemClock.uptimeMillis(); final boolean newService = app.services.add(r); boolean created = false; try &#123; ... // 调用 Service 的 onCreate 方法 app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo), app.repProcState); r.postNotification(); created = true; &#125; catch (DeadObjectException e) &#123; ... &#125; finally &#123; ... &#125; // 向 service 请求 binder 对象 requestServiceBindingsLocked(r, execInFg); if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123; // 如果 r.pendingStarts 为空，就添加一个，pendingStarts 在调用 service.startCommond() 有用 // 只有在 startService 的时候，r.startRequested才会为true r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), null, null, 0)); &#125; // 执行 startCommond() sendServiceArgsLocked(r, execInFg, true); ... &#125; startService 暂时就到这，后面的就很简单了。 bindService 启动流程源码分析bindService 启动流程概述 应用端调用 AMS.bindService AMS 查找是否存在这个 service 的 binder 对象，如果不存在，则启动 service 并请求 binder 对象 service 将 binder 对象发布到 AMS AMS 返回 service 的 binder 对象给 应用 应用端1234567891011121314151617181920// frameworks/base/core/java/android/app/ContextImpl.java private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler handler, UserHandle user) &#123; IServiceConnection sd; if (mPackageInfo != null) &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags); &#125; else &#123; throw new ... &#125; try &#123; ... int res = ActivityManager.getService().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); return res != 0; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; IServiceConnection 是一个 IBinder 对象，但是 ServiceConnection 是一个只是一样普通对象。 ServiceDispatcher 可以理解为 IServiceConnection 和 ServiceConnection 的衔接者。 ServiceDispatcher 和 IServiceConnection 是一对一的，但是 IServiceConnection 和 ServiceConnection 不是。可以理解为 IServiceConnection 和 ServiceConnection + Context 是一对一的 我们来看 ServiceDispatcher.connected(…) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// frameworks/base/core/java/android/app/LoadedApk.java// ServiceDispatcher public void connected(ComponentName name, IBinder service, boolean dead) &#123; if (mActivityThread != null) &#123; // 从 Binder 线程池切换到主线程 mActivityThread.post(new RunConnection(name, service, 0, dead)); &#125; else &#123; doConnected(name, service, dead); &#125; &#125; public void doConnected(ComponentName name, IBinder service, boolean dead) &#123; ServiceDispatcher.ConnectionInfo old; ServiceDispatcher.ConnectionInfo info; synchronized (this) &#123; old = mActiveConnections.get(name); if (old != null &amp;&amp; old.binder == service) &#123; // Huh, already have this one. Oh well! // 如果应用端已经存在 service 的 binder 对象，则不做处理。 // 所以，onServiceConnected 只会执行一次 return; &#125; if (service != null) &#123; // A new service is being connected... set it all up. info = new ConnectionInfo(); info.binder = service; info.deathMonitor = new DeathMonitor(name, service); try &#123; // linkToDeath 监控 binder 死亡， 会调用 service.onServiceDisconnected service.linkToDeath(info.deathMonitor, 0); mActiveConnections.put(name, info); &#125; catch (RemoteException e) &#123; // This service was dead before we got it... just // don't do anything with it. mActiveConnections.remove(name); return; &#125; &#125; else &#123; // The named service is being disconnected... clean up. mActiveConnections.remove(name); &#125; if (old != null) &#123; old.binder.unlinkToDeath(old.deathMonitor, 0); &#125; &#125; // If there was an old service, it is now disconnected. if (old != null) &#123; // old 不为空，还走到了这里，说明是断开连接 mConnection.onServiceDisconnected(name); &#125; if (dead) &#123; mConnection.onBindingDied(name); &#125; // If there is a new viable service, it is now connected. if (service != null) &#123; mConnection.onServiceConnected(name, service); &#125; else &#123; // The binding machinery worked, but the remote returned null from onBind(). mConnection.onNullBinding(name); &#125; &#125; AMS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, final IServiceConnection connection, int flags, String callingPackage, final int userId) throws TransactionTooLargeException &#123; ServiceLookupResult res = retrieveServiceLocked(service, ...); ServiceRecord s = res.record; if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; // 启动 service ，和 bindService 一样，可以翻翻上面 if (bringUpServiceLocked(s, service.getFlags(), callerFg, false, permissionsReviewRequired) != null) &#123; return 0; &#125; &#125; if (s.app != null &amp;&amp; b.intent.received) &#123; // service 的进程已经启动，并且，已经将 binder 对象发布给 AMS // 直接调用应用端连接 try &#123; c.conn.connected(s.name, b.intent.binder, false); &#125; catch (Exception e) &#123; ... &#125; // If this is the first app connected back to this binding, // and the service had previously asked to be told when // rebound, then do so. if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123; requestServiceBindingLocked(s, b.intent, callerFg, true); &#125; &#125; else if (!b.intent.requested) &#123; // !b.intent.requested 表明还未向 service 请求 binder 对象 requestServiceBindingLocked(s, b.intent, callerFg, false); &#125;&#125;private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123; if (r.app == null || r.app.thread == null) &#123; // If service is not currently running, can't yet bind. return false; &#125; if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123; // 没有请求过 binder 对象， 或者 rebind try &#123; // 调用 service 所在对象的 onBind 并将发挥的 binder 对象发布给 AMS r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); if (!rebind) &#123; i.requested = true; &#125; i.hasBound = true; i.doRebind = false; &#125; catch (TransactionTooLargeException e) &#123; ... &#125; catch (RemoteException e) &#123; ... return false; &#125; &#125; return true;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Service","slug":"Android/Service","permalink":"http://yoursite.com/categories/Android/Service/"},{"name":"Framework","slug":"Android/Service/Framework","permalink":"http://yoursite.com/categories/Android/Service/Framework/"}],"tags":[{"name":"Service","slug":"Service","permalink":"http://yoursite.com/tags/Service/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Service","slug":"Android/Service","permalink":"http://yoursite.com/categories/Android/Service/"},{"name":"Framework","slug":"Android/Service/Framework","permalink":"http://yoursite.com/categories/Android/Service/Framework/"}]},{"title":"scrollBy(),scrollTo()和Scroller","slug":"Android/scrollBy-scrollTo-和Scroller","date":"2019-06-16T12:26:14.000Z","updated":"2021-10-03T01:57:41.028Z","comments":true,"path":"2019/06/16/Android/scrollBy-scrollTo-和Scroller/","link":"","permalink":"http://yoursite.com/2019/06/16/Android/scrollBy-scrollTo-和Scroller/","excerpt":"scrollBy(),scrollTo()和Scroller","text":"scrollBy(),scrollTo()和Scroller作用用于对View进行滚动注意： 滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）比如：TextView滚动的是内部的text而不是整个view 滚动的方向与坐标轴正方向相反比如：scrollBy(20,0)最后显示，view会向左移动因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码) scrollBy() 和 scrollTo()的区别scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。 Scroller利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移 使用步骤Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤： 创建Scroller的实例 调用startScroll()方法来初始化滚动数据并刷新界面 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 代码：实现自定义的简单ViewPager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.example.work3;import android.content.Context;import android.support.v4.view.ViewConfigurationCompat;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.ViewConfiguration;import android.view.ViewGroup;import android.widget.Scroller;public class ScrollLayout extends ViewGroup &#123; private final String TAG = \"test_scroll\"; private Scroller mScroller; // 可以判定为拖动的最小滑动距离 private int mTouchSlop; // 落下的屏幕坐标 private float mXDown; // 当前的屏幕坐标 private float mXMove; // 上一次Action_MMOVE的屏幕坐标 private float mLastMove; // 界面可滑动的左边界 private int mLeftBorder; // 界面可滑动的右边界 private int mRightBorder; public ScrollLayout(Context context) &#123; super(context); init(context); &#125; public ScrollLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public ScrollLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; mScroller = new Scroller(context); // 获取系统定义的mTouchSlop值 mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context)); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec); &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (!changed) return; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); childView.layout(i * childView.getMeasuredWidth(), 0, (i + 1) * childView.getMeasuredWidth(), childView.getMeasuredHeight()); &#125; // 初始化左右边界 mLeftBorder = getChildAt(0).getLeft(); mRightBorder = getChildAt(childCount - 1).getRight(); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: mXDown = ev.getRawX(); mLastMove = mXDown; break; case MotionEvent.ACTION_MOVE: mXMove = ev.getRawX(); float diff = Math.abs(mXMove - mXDown); mLastMove = mXMove; // 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件 if (diff &gt; mTouchSlop) &#123; return true; &#125; break; case MotionEvent.ACTION_UP: break; default: break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: &#123; mXMove = event.getRawX(); int scrolledX = (int) (mLastMove - mXMove); if (getScrollX() + scrolledX &lt; mLeftBorder) &#123; scrollTo(mLeftBorder, 0); return true; &#125; else if (getScrollX() + scrolledX + getWidth() &gt; mRightBorder) &#123; scrollTo(mRightBorder - getWidth(), 0); return true; &#125; // view随着手指的拖动进行滚动 scrollBy(scrolledX, 0); Log.i(TAG, \"onTouchEvent: \" + getChildAt(1).getLeft()); mLastMove = mXMove; break; &#125; case MotionEvent.ACTION_UP: &#123; // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面 int targetIndex = (getScrollX() + getWidth() / 2) / getWidth(); int dx = targetIndex * getWidth() - getScrollX(); // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面 mScroller.startScroll(getScrollX(), 0, dx, 0); // 对view重绘 invalidate(); break; &#125; &#125; return super.onTouchEvent(event); &#125; @Override public void computeScroll() &#123; // computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法 if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); // 对view重绘 invalidate(); &#125; &#125;&#125; getScrollX()方法返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。原点（0，0）是初始化时内容显示的位置。 参考Android getScrollX()详解 Android Scroller完全解析，关于Scroller你所需知道的一切","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"mysql配置相关","slug":"Linux/mysql配置相关","date":"2019-05-04T03:04:44.000Z","updated":"2021-10-03T01:57:41.032Z","comments":true,"path":"2019/05/04/Linux/mysql配置相关/","link":"","permalink":"http://yoursite.com/2019/05/04/Linux/mysql配置相关/","excerpt":"1. 尽量使用MariaDB而不是mysql","text":"1. 尽量使用MariaDB而不是mysql之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了 而且，mysql的命令行终端很明显有bug，没有MariaDB好用 2. MariaDB更新密码mariadb的安装可以查看官网，上面有yum安装的教程。安装之后默认是没有密码的。需要更新密码。另外，发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的 中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ‘‘@’localhost’之类的报错。没有找到原因和解决办法，最后是直接重置了vps 1. mysql_secure_installation 命令安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码 2. 登陆mysql更改密码12345678# 2.1 更新 mysql 库中 user 表的字段：use mysql; UPDATE user SET password=password('newpassword') WHERE user='root'; flush privileges; exit; # 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法SET password for 'root'@'localhost'=password('newpassword'); 3. mysql配置远程登录1. 给用户远程登录权限：12345use mysqlupdate user set host='%' where user ='root';FLUSH PRIVILEGES;grant all privileges on *.* to root@'%' identified by \"password\";FLUSH PRIVILEGES; root可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码 使用以下命令可以查看用户的登录权限 1select host,user,password,plugin from user; 注意root密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。可以使用如下命令更改加密方式： 1update user set plugin='mysql_native_password' where user='root'; 2. lnmp环境配置iptableslnmp一键安装环境默认是禁用iptables远程登录的， 查看iptables规则：1iptables -L -n --line-numbers 输入样例如下：可以看到3306端口的target为drop 删除对应的drop规则 1iptables -D INPUT 5 iptables的使用参考：https://www.vpser.net/security/linux-iptables.html 3.非集成centos环境开放3306端口centos-7以上firewalld 防火墙（centos-7）运行命令,并重启： 12firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload centos-7以前iptables 防火墙（centos6.5及其以前）运行命令 1vim /etc/sysconfig/iptables 在文件内添加下面命令行，然后重启 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT 1service iptables restart","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"apt常用命令","slug":"Linux/apt常用命令","date":"2019-05-02T11:49:35.000Z","updated":"2021-10-03T01:57:41.031Z","comments":true,"path":"2019/05/02/Linux/apt常用命令/","link":"","permalink":"http://yoursite.com/2019/05/02/Linux/apt常用命令/","excerpt":"apt常用命令参考：apt命令安装指定版本","text":"apt常用命令参考：apt命令安装指定版本 更新 sudo apt-get update //更新源sudo apt-get upgrade //更新已安装的包sudo apt-get dist-upgrade //升级系统sudo apt-get dselect-upgrade //使用 dselect 升级 查询 apt-cache search package//搜索包 apt-cache show package//获取包的相关信息，如说明、大小、版本等 apt-cache depends package//了解使用依赖apt-cache rdepends package//是查看该包被哪些包依赖 12345apt-cache madison &lt;package name&gt; //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。apt-cache policy &lt;&lt;package name&gt;&gt; /*将列出所有来源的版本。信息会比上面详细一点*/apt-show-versions -a &lt;&lt;package name&gt;&gt; //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u &lt;&gt;来查询是否有升级版本。 安装 sudo apt-get install package//安装包 sudo apt-get install package - - reinstall//重新安装包 sudo apt-get -f install//修复安装 (“-f = ——fix-missing”) 删除sudo apt-get remove package删除包 sudo apt-get remove package - - purge删除包，包括删除配置文件等sudo apt-get clean &amp;&amp; sudo apt-get autoclean清理无用的包sudo apt-get check检查是否有损坏的依赖 其他 sudo apt-get build-dep package安装相关的编译环境apt-get source package下载该包的源代码","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"keywords":[]},{"title":"Activity class {} does not exist","slug":"Android/Activity-class-does-not-exist","date":"2019-04-16T11:23:35.000Z","updated":"2021-10-03T01:57:41.022Z","comments":true,"path":"2019/04/16/Android/Activity-class-does-not-exist/","link":"","permalink":"http://yoursite.com/2019/04/16/Android/Activity-class-does-not-exist/","excerpt":"Activity class {} does not exist","text":"Activity class {} does not exist有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。 解决办法：使用adb命令1adb uninstall [包名] 估计可能是调试的APP没有彻底卸载造成的。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AndroidStudio","slug":"Android/AndroidStudio","permalink":"http://yoursite.com/categories/Android/AndroidStudio/"}],"tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://yoursite.com/tags/AndroidStudio/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AndroidStudio","slug":"Android/AndroidStudio","permalink":"http://yoursite.com/categories/Android/AndroidStudio/"}]},{"title":"Activity管理类的封装","slug":"Android/Activity管理类的封装","date":"2019-04-14T11:41:50.000Z","updated":"2021-10-03T01:57:41.022Z","comments":true,"path":"2019/04/14/Android/Activity管理类的封装/","link":"","permalink":"http://yoursite.com/2019/04/14/Android/Activity管理类的封装/","excerpt":"使用场景有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的","text":"使用场景有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的 我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class FinishActivityManager extends BaseActivity &#123; private FinishActivityManager() &#123; &#125; private static FinishActivityManager sManager; private Stack&lt;WeakReference&lt;Activity&gt;&gt; mActivityStack; public static FinishActivityManager getManager() &#123; if (sManager == null) &#123; synchronized (FinishActivityManager.class) &#123; if (sManager == null) &#123; sManager = new FinishActivityManager(); &#125; &#125; &#125; return sManager; &#125; /** * 添加Activity到栈 * @param activity */ public void addActivity(Activity activity) &#123; if (mActivityStack == null) &#123; mActivityStack = new Stack&lt;&gt;(); &#125; mActivityStack.add(new WeakReference&lt;&gt;(activity)); &#125; /** * 检查弱引用是否释放，若释放，则从栈中清理掉该元素 */ public void checkWeakReference() &#123; if (mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity temp = activityReference.get(); if (temp == null) &#123; it.remove(); &#125; &#125; &#125; &#125; /** * 获取当前Activity（栈中最后一个压入的） * @return */ public Activity currentActivity() &#123; checkWeakReference(); if (mActivityStack != null &amp;&amp; !mActivityStack.isEmpty()) &#123; return mActivityStack.lastElement().get(); &#125; return null; &#125; /** * 关闭当前Activity（栈中最后一个压入的） */ public void finishActivity() &#123; Activity activity = currentActivity(); if (activity != null) &#123; finishActivity(activity); &#125; &#125; /** * 关闭指定的Activity * @param activity */ public void finishActivity(Activity activity) &#123; if (activity != null &amp;&amp; mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity temp = activityReference.get(); // 清理掉已经释放的activity if (temp == null) &#123; it.remove(); continue; &#125; if (temp == activity) &#123; it.remove(); &#125; &#125; activity.finish(); &#125; &#125; /** * 关闭指定类名的所有Activity * @param cls */ public void finishActivity(Class&lt;?&gt; cls) &#123; if (mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity activity = activityReference.get(); // 清理掉已经释放的activity if (activity == null) &#123; it.remove(); continue; &#125; if (activity.getClass().equals(cls)) &#123; it.remove(); activity.finish(); &#125; &#125; &#125; &#125; /** * 结束所有Activity */ public void finishAllActivity() &#123; if (mActivityStack != null) &#123; for (WeakReference&lt;Activity&gt; activityReference : mActivityStack) &#123; Activity activity = activityReference.get(); if (activity != null) &#123; activity.finish(); &#125; &#125; mActivityStack.clear(); &#125; &#125; /** * 退出应用程序 */ public void exitApp() &#123; try &#123; finishAllActivity(); // 退出JVM,释放所占内存资源,0表示正常退出 System.exit(0); // 从系统中kill掉应用程序 android.os.Process.killProcess(android.os.Process.myPid()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后是一个BaseActivity类， 重写onCreate和onDestory方法 1234567891011121314151617181920212223242526package com.example.chenlei.test;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.util.Log;public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MyActivityManager.addActivity(this); Log.i(\"有activity新添加\", \"onCreate: \"); &#125; @Override protected void onDestroy() &#123; Log.i(\"有activity被销毁\", \"onDestroy: \"+ MyActivityManager.getSize()); MyActivityManager.finishActivity(this); super.onDestroy(); &#125;&#125; 接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作 网上原文：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"http://yoursite.com/tags/Activity/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Handler防止内存泄露","slug":"Android/Handler防止内存泄露","date":"2019-04-14T10:59:55.000Z","updated":"2021-10-03T01:57:41.024Z","comments":true,"path":"2019/04/14/Android/Handler防止内存泄露/","link":"","permalink":"http://yoursite.com/2019/04/14/Android/Handler防止内存泄露/","excerpt":"Handler防止内存泄露1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = (MainActivity) reference.get(); if(activity != null)&#123; activity.mTextView.setText(\"\"); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); &#125; //loadData()方法是在子线程中，执行 private void loadData() &#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //如果你的Handler被delay（延时了）,可以做如下的处理 mHandler.removeCallbacksAndMessages(null); &#125;&#125;","text":"Handler防止内存泄露1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = (MainActivity) reference.get(); if(activity != null)&#123; activity.mTextView.setText(\"\"); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); &#125; //loadData()方法是在子线程中，执行 private void loadData() &#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //如果你的Handler被delay（延时了）,可以做如下的处理 mHandler.removeCallbacksAndMessages(null); &#125;&#125; 解释创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息 使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Handler","slug":"Handler","permalink":"http://yoursite.com/tags/Handler/"},{"name":"内存泄露","slug":"内存泄露","permalink":"http://yoursite.com/tags/内存泄露/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Jni入门","slug":"Java/Jni入门","date":"2019-04-13T05:12:47.000Z","updated":"2021-10-03T01:57:41.031Z","comments":true,"path":"2019/04/13/Java/Jni入门/","link":"","permalink":"http://yoursite.com/2019/04/13/Java/Jni入门/","excerpt":"Jni入门参考:JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki","text":"Jni入门参考:JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki 1、编写native方法，使用javah创建头文件123public class HelloWorld &#123; public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现&#125; 1javah -jni -classpath JniCalcINterface 参数说明：classpath：类搜索路径，这里表示从当前的 bin 目录下查找d：将生成的头文件放到当前的 jni 目录下o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h） 注意：-d和-o只能使用其中一个参数。 创建的.h文件如下123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_study_jnilearn_HelloWorld */ #ifndef _Included_com_study_jnilearn_HelloWorld #define _Included_com_study_jnilearn_HelloWorld #ifdef __cplusplus extern \"C\" &#123; #endif /* * Class: com_study_jnilearn_HelloWorld * Method: sayHello * Signature: (Ljava/lang/String;)Ljava/lang/String; */ JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello (JNIEnv *, jclass, jstring); #ifdef __cplusplus &#125; #endif #endif **注意 extern “C”表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern “C”后面 3、编译出so文件1gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so 参数含义: -L 表示要链接的库所在的目录。-L. 表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。 -l (L的小写) 表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test -include 包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。 -I (i 的大写) 指定头文件的所在的目录，可以使用相对路径。 -shared 指定生成动态链接库 -fPIC 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。 -o 指定编译后动态库生成的路径和文件名 4、加载动态库1234static&#123; System.loadLibrary(\"HelloWorld\"); //方式一 System.load(\"/Users/yangxin/Desktop/libHelloWorld.jnilib\" //方式二);&#125; 方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀方式2：指定动态库的绝对路径名，需要加上前缀和后缀 推荐使用这种方法 如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。 将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下 给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。 5、运行java程序","categories":[],"tags":[{"name":"jni","slug":"jni","permalink":"http://yoursite.com/tags/jni/"}],"keywords":[]},{"title":"自定义ViewGroup","slug":"Android/自定义ViewGroup","date":"2019-04-13T05:12:35.000Z","updated":"2021-10-03T01:57:41.030Z","comments":true,"path":"2019/04/13/Android/自定义ViewGroup/","link":"","permalink":"http://yoursite.com/2019/04/13/Android/自定义ViewGroup/","excerpt":"自定义ViewGroup参考文章自定义LayoutParams关于onMeasure过程的理解Measure测量流程全解析（简洁）","text":"自定义ViewGroup参考文章自定义LayoutParams关于onMeasure过程的理解Measure测量流程全解析（简洁） 下面是继承自ViewGroup的FlowLayout标签流式布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.example.test;import android.content.Context;import android.util.AttributeSet;import android.util.Log;import android.view.View;import android.view.ViewGroup;public class FlowLayout extends ViewGroup &#123; public FlowLayout(Context context) &#123; super(context); &#125; public FlowLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int specWidth = MeasureSpec.getSize(widthMeasureSpec); int specHeight = MeasureSpec.getSize(heightMeasureSpec); int specWidthMode = MeasureSpec.getMode(widthMeasureSpec); int specHeightMode = MeasureSpec.getMode(heightMeasureSpec); int count = getChildCount(); //计算child的大小 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); //measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0 //这里为了支持margin，所以用measureChildWithMargins方法 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); &#125; //计算ViewGroup自身的大小 //这里只要处理height的wrap_content情况就可以了 int height = specHeight; int width = specWidth; if (specHeightMode == MeasureSpec.AT_MOST) &#123; height = getPaddingBottom() + getPaddingTop(); int used_width = 0; int line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams(); int child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //在这一行可以容纳 if (used_width + child_width &lt;= width - getPaddingStart() - getPaddingEnd()) &#123; line_max_height = Math.max(line_max_height, child_height); used_width += child_width; &#125; else &#123; //切换到下一行 height += line_max_height; used_width = child_width; line_max_height = child_height; &#125; &#125; //加上最后一行的最大height height += line_max_height; &#125; setMeasuredDimension(width, height); &#125; private final String TAG = \"test_log\"; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd(); int used_width = 0; int used_height = 0; int count = getChildCount(); int last_line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child_view = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams(); //用于计算是否越界时需要包含margin int child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //layout时的位置，必须考虑padding int layout_l, layout_t, layout_r, layout_b; if (used_width + child_width &lt;= width) &#123; layout_l = getPaddingStart() + used_width + mlp.leftMargin; layout_t = getPaddingTop() + used_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_width += child_width; //记录该行height的最大值 last_line_max_height = Math.max(last_line_max_height, child_height); &#125; else &#123; layout_l = getPaddingStart() + mlp.leftMargin; layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_height += last_line_max_height; used_width = child_width; last_line_max_height = child_height; &#125; child_view.layout(layout_l, layout_t, layout_r, layout_b); &#125; &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; @Override protected LayoutParams generateLayoutParams(LayoutParams p) &#123; return new MarginLayoutParams(p); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new MarginLayoutParams(super.generateDefaultLayoutParams()); &#125;&#125; 关于MeasureSpec父控件告诉子控件可获得的空间以及关于这个空间的约束条件 SpecMode EXACTLY 设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式 AT_MOST width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值 UNSPECIFIED 这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用 关于view的Measure过程我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。 这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程： ViewRootImpl.performTraversals()-&gt;performMeasure(): 这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量 DecorView.measure()-&gt;onMeasure(): DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量 ViewGroupA.measure()-&gt;onMeasure(): 这是我们自定义的一个ViewGroup(继承自ViewGroup)假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。 所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。 ViewB.measure()-&gt;onMeasure(): View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。 测量子view时MeasureSpec的生成规则 当子View的宽高设置的是具体数值时 显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。 当子View的宽高设置的是match_parent 则不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED） 当子View的宽高设置的是wrap_content, 因为这种情况父容器实在不知道子View应该多宽多高，所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。 通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。 关于LayoutParams在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。在使用中必须重写所有的generateLayoutParams()方法尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}]},{"title":"多个cpp文件编译共享同一个.h文件的全局变量","slug":"C/多个cpp文件编译共享同一个-h文件的全局变量","date":"2019-04-13T05:12:22.000Z","updated":"2021-10-03T01:57:41.030Z","comments":true,"path":"2019/04/13/C/多个cpp文件编译共享同一个-h文件的全局变量/","link":"","permalink":"http://yoursite.com/2019/04/13/C/多个cpp文件编译共享同一个-h文件的全局变量/","excerpt":"多个cpp文件编译共享同一个.h文件的全局变量","text":"多个cpp文件编译共享同一个.h文件的全局变量在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案: 一个cpp文件多次#include一个.h文件 使用#ifndef 12345//在.h头文件中#ifndef &lt;标示&gt; //自定义的一个标示, 习惯性用.h文件名大写#define &lt;标示&gt;//...头文件内容#endif 原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容 这种方法只能解决一个cpp源文件中的重复include问题 多个cpp文件多次#include一个.h文件使用static关键字123//.h头文件static int i;static void func(); static修饰变量变量static标记之后，多个cpp文件include不会出现问题。但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的下面是网上的一些解释: 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。 static修饰函数函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。似乎是这样的。。。我的理解。网上说static和inline经常配合使用 使用extern关键字extern表明该变量在别的地方已经定义过了，在这里要使用那个变量 12//cpp文件extern int i; 经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。 定义在.h文件的情况下，在使用extern时，不能include定义它的.h文件。否则还是会出现重定义的问题。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}],"tags":[],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}]},{"title":"C语言结构体的内存对齐","slug":"C/C语言结构体的内存对齐","date":"2019-04-13T05:11:14.000Z","updated":"2021-10-03T01:57:41.030Z","comments":true,"path":"2019/04/13/C/C语言结构体的内存对齐/","link":"","permalink":"http://yoursite.com/2019/04/13/C/C语言结构体的内存对齐/","excerpt":"C语言结构体的内存对齐内存对齐原则 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。） 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍","text":"C语言结构体的内存对齐内存对齐原则 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。） 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍 pragram pack(4)设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节 例子：123456789101112131415# pragram pack(8)struct S3&#123; double d; char c; int i;&#125;;struct S4&#123; char c1; struct S3 s3; double d;&#125;;printf(\"%d\\n\", sizeof(struct S4)); 最后的输出为 32 参考：[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园 C语言联合体union的sizeof分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}],"tags":[],"keywords":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/categories/C-C/"}]}]}