<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BrightStone</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-06-14T16:27:13.144Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BrightStone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Retrofit源码解析</title>
    <link href="http://yoursite.com/2022/06/12/Android/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Retrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2022/06/12/Android/源码解析/Retrofit源码解析/</id>
    <published>2022-06-12T10:21:16.000Z</published>
    <updated>2022-06-14T16:27:13.144Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetrofitService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"query"</span>)</span><br><span class="line">    <span class="function">Observable&lt;PostInfo&gt; <span class="title">getPostInfoRx</span><span class="params">(@Query(<span class="string">"type"</span>)</span> String type, @<span class="title">Query</span><span class="params">(<span class="string">"postid"</span>)</span> String postid)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"http://www.kuaidi100.com/"</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class="comment">// 支持RxJava</span></span><br><span class="line">        .build();</span><br><span class="line">        </span><br><span class="line">RetrofitService service = retrofit.create(XxxInterface.class);</span><br><span class="line">Call&lt;PostInfo&gt; call = service.getPostInfo(<span class="string">"yuantong"</span>, <span class="string">"11111111111"</span>);</span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;PostInfo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;PostInfo&gt; call, Response&lt;PostInfo&gt; response)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"http返回："</span>, response.body().toString() + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;PostInfo&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面是 Retrofit 的主要用法，主要重要的东西有 ConverterFactory , CallAdapterFactory , retrofit.create(XxxInterface.class) 三个东西</p><h2 id="Retrofit-Builder"><a href="#Retrofit-Builder" class="headerlink" title="Retrofit.Builder()"></a>Retrofit.Builder()</h2><p>builder就是一个常见的建造者模式，没什么好说的。 有一个点需要注意一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">   <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">     callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">   <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 默认callback回调是执行在主线程的</span></span><br><span class="line">     callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">   callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">   List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">       <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">   <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">   converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">   converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">   converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">       unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == ResponseBody.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class="line">            ? StreamingResponseBodyConverter.INSTANCE</span><br><span class="line">            : BufferingResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == Void.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先插入了一个 BuiltInConverters 内置的转换器。 当返回类型是 ResponseBody 的时候就会使用 BuiltInConverters ，返回 ResponseBody 就和 okhttp 的返回一致了。</p><h2 id="retrofit-create-XxxInterface-class"><a href="#retrofit-create-XxxInterface-class" class="headerlink" title="retrofit.create(XxxInterface.class)"></a>retrofit.create(XxxInterface.class)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了动态代理，create方法返回的接口对象是一个动态代理的实例</p><h2 id="loadServiceMethod"><a href="#loadServiceMethod" class="headerlink" title="loadServiceMethod"></a>loadServiceMethod</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存 + 解析Method</p><h2 id="ServiceMethod-parseAnnotations"><a href="#ServiceMethod-parseAnnotations" class="headerlink" title="ServiceMethod.parseAnnotations"></a>ServiceMethod.parseAnnotations</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在抽象父类里先调用了 <code>RequestFactory.parseAnnotations(retrofit, method);</code> 去解析方法参数的注解。<br><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</code> 里解析了返回类型，并匹配 CallAdapter 和 Converter<br>。。。抽象父类的静态方法区调用了子类的静态方法。。。有些迷惑</p><h2 id="HttpServiceMethod-parseAnnotations"><a href="#HttpServiceMethod-parseAnnotations" class="headerlink" title="HttpServiceMethod.parseAnnotations"></a>HttpServiceMethod.parseAnnotations</h2><p>RequestFactory.parseAnnotations 都是一些注解的处理，不说了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    Type adapterType;</span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">    <span class="comment">// 是协程suspend方法调用</span></span><br><span class="line">    <span class="comment">// kotli的suspend方法转成java之后会在方法参数上生成一个Continuation类型的参数</span></span><br><span class="line">      Type[] parameterTypes = method.getGenericParameterTypes(); <span class="comment">// 获取方法的所有参数类型</span></span><br><span class="line">      Type responseType = Utils.getParameterLowerBound(<span class="number">0</span>,</span><br><span class="line">          (ParameterizedType) parameterTypes[parameterTypes.length - <span class="number">1</span>]); <span class="comment">// 获取最后一个 Continuation 类型参数的泛型</span></span><br><span class="line">      <span class="keyword">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="comment">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class="line">        <span class="comment">// 获取 Response&lt;T&gt; 中泛型T的类型</span></span><br><span class="line">        responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) responseType);</span><br><span class="line">        continuationWantsResponse = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里把suspend方法的返回类型的 AdapterType 当做 Call&lt;T&gt; 来处理了</span></span><br><span class="line">      adapterType = <span class="keyword">new</span> Utils.ParameterizedTypeImpl(<span class="keyword">null</span>, Call.class, responseType);</span><br><span class="line">      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是非suspend方法，那直接取返回类型就可以了</span></span><br><span class="line">      adapterType = method.getGenericReturnType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找合适的 CallAdapterFactory 生产 CallAdapter</span></span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找合适的 ConverterFactory 生产 Converter</span></span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CallFactory 实质上就是 OkHttpClient</span></span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是返回 HttpServiceMethod 的子类，这三个子类其实就是 CallAdapted wrap 了一层。 SuspendForResponse 和 SuspendForBody 调用了协程的 await 方法去等待协程的完成（其实就是加了个Continuation的回调）</span></span><br><span class="line">    <span class="keyword">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">      <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForResponse&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">      <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">          continuationBodyNullable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="ServiceMethod-invode"><a href="#ServiceMethod-invode" class="headerlink" title="ServiceMethod.invode"></a>ServiceMethod.invode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">HttpServiceMethod</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br></pre></td></tr></table></figure><p>OkHttpCall 实现了 Retrofit 的 call 到 OkHttpCall 的转换<br>adapt 最终会调用 CallAdapter 的 adapt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">   okhttp3.Call call;</span><br><span class="line">   Throwable failure;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">     executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     call = rawCall;</span><br><span class="line">     failure = creationFailure;</span><br><span class="line">     <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 懒加载 rawCall</span></span><br><span class="line">         <span class="comment">// 传入真实请求参数，构建真正发起请求的 okhttp 的 Call 对象</span></span><br><span class="line">         call = rawCall = createRawCall();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">     <span class="meta">@Override</span> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">       Response&lt;T&gt; response;</span><br><span class="line">       <span class="comment">// 调用 Converter 解析返回类型</span></span><br><span class="line">       response = parseResponse(rawResponse);</span><br><span class="line">       callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">       callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看一下默认的 DefaultCallAdapterFactory 是怎么实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">DefaultCallAdapterFactory</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取 Call&lt;T&gt; 的具体类型</span></span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有 SkipCallbackExecutor 这个注解，一般是没有的</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class="line">        ? <span class="keyword">null</span></span><br><span class="line">        : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span></span><br><span class="line">            ? call</span><br><span class="line">            : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">  <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.execute();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>enqueue 里的返回 onResponse 和 onFailure 都是在 callbackExecutor<br>callbackExecutor 也是在 retrofit 构建时传入的， 默认是 <code>Android.MainThreadExecutor</code> 也就是说默认 enqueue 的 callback 默认是执行在主线程的</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RetrofitService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GET&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;query&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Observable&amp;lt;PostInfo&amp;gt; &lt;span class=&quot;title&quot;&gt;getPostInfoRx&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(@Query(&lt;span class=&quot;string&quot;&gt;&quot;type&quot;&lt;/span&gt;)&lt;/span&gt; String type, @&lt;span class=&quot;title&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;postid&quot;&lt;/span&gt;)&lt;/span&gt; String postid)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Retrofit retrofit = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Retrofit.Builder()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .baseUrl(&lt;span class=&quot;string&quot;&gt;&quot;http://www.kuaidi100.com/&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .addConverterFactory(GsonConverterFactory.create())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) &lt;span class=&quot;comment&quot;&gt;// 支持RxJava&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RetrofitService service = retrofit.create(XxxInterface.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Call&amp;lt;PostInfo&amp;gt; call = service.getPostInfo(&lt;span class=&quot;string&quot;&gt;&quot;yuantong&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;11111111111&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;call.enqueue(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Callback&amp;lt;PostInfo&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onResponse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Call&amp;lt;PostInfo&amp;gt; call, Response&amp;lt;PostInfo&amp;gt; response)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Log.i(&lt;span class=&quot;string&quot;&gt;&quot;http返回：&quot;&lt;/span&gt;, response.body().toString() + &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onFailure&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Call&amp;lt;PostInfo&amp;gt; call, Throwable t)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RequestLayout和Invalidate</title>
    <link href="http://yoursite.com/2022/05/02/Android/Framework/RequestLayout%E5%92%8CInvalidate/"/>
    <id>http://yoursite.com/2022/05/02/Android/Framework/RequestLayout和Invalidate/</id>
    <published>2022-05-02T08:48:49.000Z</published>
    <updated>2022-05-02T10:53:02.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RequestLayout"><a href="#RequestLayout" class="headerlink" title="RequestLayout"></a>RequestLayout</h1><h2 id="标记自身"><a href="#标记自身" class="headerlink" title="标记自身"></a>标记自身</h2><p>给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。<br>并将RequestLayout向上传递。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从源码注释可以看出，如果当前View在请求布局的时候，View树正在进行布局流程的话，</span></span><br><span class="line"><span class="comment">//该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发现的时候再执行。</span></span><br><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Only trigger request-during-layout logic if this is the view requesting it,</span></span><br><span class="line">        <span class="comment">// not the views in its parent hierarchy</span></span><br><span class="line">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">        <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为当前view设置标记位 PFLAG_FORCE_LAYOUT</span></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        <span class="comment">//向父容器请求布局</span></span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><p>会顺着view树，一路向上标记，最终到达 ViewRootImpl<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals(); <span class="comment">// 开启measure、layout、draw三步走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> scheduleTraversals() 开启绘制三步走流程。 在measure、layout、draw过程中都会判断标志位，只有需要的时候才执行</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">            widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">            <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> measure时判断了PFLAG_FORCE_LAYOUT标记，需要时才做。<br>  在 <code>mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</code> 中给layout过程做了标记</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        <span class="comment">//onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后清除PFLAG_FORCE_LAYOUT标记位</span></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> layout时判断了PFLAG_LAYOUT_REQUIRED标记，需要时才做。</p><h1 id="Invalidate"><a href="#Invalidate" class="headerlink" title="Invalidate"></a>Invalidate</h1><h2 id="标记自身-1"><a href="#标记自身-1" class="headerlink" title="标记自身"></a>标记自身</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">            || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">            || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">            || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置PFLAG_DIRTY标记位</span></span><br><span class="line">        mPrivateFlags |= PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate the damage rectangle to the parent view.</span></span><br><span class="line">        <span class="comment">//把需要重绘的区域传递给父容器</span></span><br><span class="line">        <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">        <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">            <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">            damage.set(l, t, r, b);</span><br><span class="line">            <span class="comment">//调用父容器的方法，向上传递事件</span></span><br><span class="line">            p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewGroup处理并向上传递"><a href="#ViewGroup处理并向上传递" class="headerlink" title="ViewGroup处理并向上传递"></a>ViewGroup处理并向上传递</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Don't call or override this method. It is used for the implementation of</span></span><br><span class="line"><span class="comment"> * the view hierarchy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 parent 等于自身</span></span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">            mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            View view = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                view = (View) parent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        view.getSolidColor() == <span class="number">0</span>) &#123;</span><br><span class="line">                    opaqueFlag = PFLAG_DIRTY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</span><br><span class="line">                    <span class="comment">//对当前View的标记位进行设置</span></span><br><span class="line">                    view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用ViewGrup的invalidateChildInParent，如果已经达到最顶层view,则调用ViewRootImpl的invalidateChildInParent。</span></span><br><span class="line">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[] location, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN ||</span><br><span class="line">            (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) !=</span><br><span class="line">                    FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响</span></span><br><span class="line">            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,</span><br><span class="line">                    location[CHILD_TOP_INDEX] - mScrollY);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//求并集，结果是把子视图的dirty区域转化为父容器的dirty区域</span></span><br><span class="line">                dirty.union(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = mTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dirty.intersect(<span class="number">0</span>, <span class="number">0</span>, mRight - left, mBottom - top)) &#123;</span><br><span class="line">                    dirty.setEmpty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录当前视图的mLeft和mTop值，在下一次循环中会把当前值再向父容器的坐标转化</span></span><br><span class="line">            location[CHILD_LEFT_INDEX] = left;</span><br><span class="line">            location[CHILD_TOP_INDEX] = top;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回当前视图的父容器</span></span><br><span class="line">            <span class="keyword">return</span> mParent;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewRootImpl-1"><a href="#ViewRootImpl-1" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    ...</span><br><span class="line">    invalidateRectOnScreen(dirty);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidateRectOnScreen</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用硬件加速渲染</span></span><br><span class="line">    <span class="comment">// 2. 使用软件加速渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if drawing was successful, false if an error occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw with software renderer.</span></span><br><span class="line">        <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">            canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">            <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">            <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                    || bottom != dirty.bottom) &#123;</span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Do this in native</span></span><br><span class="line">            canvas.setDensity(mDensity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪代码</span></span><br><span class="line">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里只有软件绘制的代码。<br>网上有人说invalidate只会重绘脏区域，但是这里只看到用dirty做了一个 <code>canvas = mSurface.lockCanvas(dirty);</code> 。还不是很懂局部重绘是怎么做到的。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RequestLayout&quot;&gt;&lt;a href=&quot;#RequestLayout&quot; class=&quot;headerlink&quot; title=&quot;RequestLayout&quot;&gt;&lt;/a&gt;RequestLayout&lt;/h1&gt;&lt;h2 id=&quot;标记自身&quot;&gt;&lt;a href=&quot;#标记自身&quot; class=&quot;headerlink&quot; title=&quot;标记自身&quot;&gt;&lt;/a&gt;标记自身&lt;/h2&gt;&lt;p&gt;给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。&lt;br&gt;并将RequestLayout向上传递。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程上下文和异常传播</title>
    <link href="http://yoursite.com/2022/04/11/Kotlin/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD/"/>
    <id>http://yoursite.com/2022/04/11/Kotlin/协程上下文和异常传播/</id>
    <published>2022-04-11T15:50:53.000Z</published>
    <updated>2022-04-11T16:56:12.838Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7068901166456766472#heading-6" target="_blank" rel="noopener">https://juejin.cn/post/7068901166456766472#heading-6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7068901166456766472#heading-6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.cn/post/7068901166456766472#
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>jvm虚拟机</title>
    <link href="http://yoursite.com/2022/04/07/Java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2022/04/07/Java/jvm虚拟机/</id>
    <published>2022-04-07T15:10:00.000Z</published>
    <updated>2022-04-07T16:57:54.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM架构"><a href="#JVM架构" class="headerlink" title="JVM架构"></a>JVM架构</h2><p>jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈</p><a id="more"></a><ol><li><p>方法区<br>方法区被所有线程共享。存放 类信息、类的字段信息和方法信息、常量、static类变量</p></li><li><p>Java栈<br>Java栈线程之间不共享。<br>Java栈是由很多的栈帧(stack frame)或者说帧(frame)组成的，一个栈帧包含一个Java方法调用状态。用来存放方法的局部变量、被调用时传进来的参数、返回值 以及运算的中间结果等等。</p></li><li><p>Native栈<br>用来存放Native方法的调用状态</p></li><li><p>堆<br>用于存放对象。 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。</p></li><li><p>程序计数器（PC寄存器）<br>每一个线程有一个程序计数器。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。</p></li><li><p>类加载子系统<br>读取class文件，加载Java类到内存。</p></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器负责动态加载Java类到Java虚拟机的内存空间中。</p><ul><li>双亲委托机制<br>“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类 路径中查找并装载目标类。这一点是从安全角度考虑的</li></ul><h2 id="GC垃圾回收机制"><a href="#GC垃圾回收机制" class="headerlink" title="GC垃圾回收机制"></a>GC垃圾回收机制</h2><h3 id="如何判断对象是否可以被回收"><a href="#如何判断对象是否可以被回收" class="headerlink" title="如何判断对象是否可以被回收"></a>如何判断对象是否可以被回收</h3><ul><li>引用计数法</li><li>根搜索算法：<ul><li>从GC root出发查找引用链，无法触及到的对象可以被回收。 </li><li>GC-root包括：虚拟机栈中引用的对象、类静态属性引用的对象、常量引用的对象</li></ul></li></ul><h3 id="强引用、弱引用、软引用、虚引用"><a href="#强引用、弱引用、软引用、虚引用" class="headerlink" title="强引用、弱引用、软引用、虚引用"></a>强引用、弱引用、软引用、虚引用</h3><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>jvm将对象分为三个区域， 新生代（Young Generation） 、 老年代（Old Generation） 和 持久代（Permanent Generation）。</p><ul><li>持久代：<ul><li>存放java类的类信息，存放静态文件，如final常量，static常量，常量池等。几乎不回收</li></ul></li><li>新生代：<ul><li>新生代使用拷贝算法：新生代中存在一个Eden区和两个Survivor区，其中一个Survivor始终为空。 eden区gc时，存活的对象会复制到其中一个survivor区。 Survivor区gc时，会拷贝到另一个空闲的Survivor区。 当对象多次gc存活一定次数之后，会移动到老年代</li><li>jvm中 eden区和Survivor区的大小为8：1</li></ul></li><li>老年代：<ul><li>使用标记整理算法。标记需要清除对象，将存活的对象往内存的一端移动，再将需要清除要回收的对象。这样的算法可以避免内存碎片的产生</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM架构&quot;&gt;&lt;a href=&quot;#JVM架构&quot; class=&quot;headerlink&quot; title=&quot;JVM架构&quot;&gt;&lt;/a&gt;JVM架构&lt;/h2&gt;&lt;p&gt;jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="http://yoursite.com/2022/04/04/Java/ConcurrentHashMap/"/>
    <id>http://yoursite.com/2022/04/04/Java/ConcurrentHashMap/</id>
    <published>2022-04-04T08:36:53.000Z</published>
    <updated>2022-04-05T09:43:51.079Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 </p><a id="more"></a><h2 id="1-8-之前"><a href="#1-8-之前" class="headerlink" title="1.8 之前"></a>1.8 之前</h2><p>将 table 数组划分为多个 segment ，对每一个 segment 单独加锁，不同的 segment 可以跨线程运算，提高并发效率。 </p><p>每一个segment有一个单独的table数组，类似1.7版本的 hashmap，table数组遇到哈希冲突后，同hash值的元素使用的数据结构是链表。</p><p>读是不需要加锁的，因为 segment 的 table 数组加了 volatile 修饰，HashEntry 的val和next字段也用 volatile 修饰。 一个线程改变了值，另一个线程能马上发现。</p><p>put的时候需要加锁，当put时，所在的segment还没有创建，会懒加载创建segment。实例化segment之后，会通过cas插入到segment数组中，保证线程安全。</p><p>下面是 1.8之前 ConcurrentHashMap 的 Segment 的 put 流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取锁，获取成功，node为null，代码向下执行</span></span><br><span class="line">    <span class="comment">//如果有其他线程占据锁对象，那么去做别的事情，而不是一直等待，提升效率</span></span><br><span class="line">    <span class="comment">// tryLock 通过cas获取锁</span></span><br><span class="line">    <span class="comment">//scanAndLockForPut 稍后分析</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//取hash的低位，计算HashEntry[]的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//获取索引位的元素对象</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">//获取的元素对象不为空</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">//如果是重复元素，覆盖原值</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果不是重复元素，获取链表的下一个元素，继续循环遍历链表</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//如果获取到的元素为空</span></span><br><span class="line">                <span class="comment">//当前添加的键值对的HashEntry对象已经创建</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first); <span class="comment">//头插法关联即可</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//创建当前添加的键值对的HashEntry对象</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">//添加的元素数量递增</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//判断是否需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">//需要扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//不需要扩容</span></span><br><span class="line">                    <span class="comment">//将当前添加的元素对象，存入数组角标位，完成头插法添加元素</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 四：Segment的scanAndLockForPut方法</span></span><br><span class="line"><span class="comment"> * 该方法在线程没有获取到锁的情况下，去完成HashEntry对象的创建，提升效率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取头部元素</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>；</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        <span class="comment">//获取锁失败</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//没有下一个节点，并且也不是重复元素，创建HashEntry对象，不再遍历</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                <span class="comment">//重复元素，不创建HashEntry对象，不再遍历</span></span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//继续遍历下一个节点</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">//如果尝试获取锁的次数过多，直接加锁</span></span><br><span class="line">            <span class="comment">//MAX_SCAN_RETRIES会根据可用cpu核数来确定</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            <span class="comment">//如果期间有别的线程获取锁，重新遍历</span></span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8-之后"><a href="#1-8-之后" class="headerlink" title="1.8 之后"></a>1.8 之后</h2><p>1.8之后ConcurrentHashMap改变了加锁策略，改为对哈希数组的每一个hash位置加锁；同时，将哈希冲突的链表替换为了和 HashMap 一样的红黑树。</p><h3 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h3><ul><li>为0，默认状态，代表数组未初始化， 且数组的初始容量为16</li><li>为-1，表示数组正在进行初始化</li><li>为正数，其记录的是数组的扩容阈值</li><li>小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操</li></ul><h3 id="put时如何保证线程安全"><a href="#put时如何保证线程安全" class="headerlink" title="put时如何保证线程安全"></a>put时如何保证线程安全</h3><ul><li>在put时对table哈希数组的每一个hash位置，如果为该位置为null，cas判断，然后在改位置添加元素；如果该位置不为null，则对该hash位置进行Synchronize加锁，将新元素加载链表or红黑树上。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果有空值或者空键，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//基于key计算hash值，并进行一定的扰动</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果数组还未初始化，先对数组进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">    <span class="comment">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span></span><br><span class="line">            <span class="comment">//如果cas检测没过，下一次while循环就相当于在table的这个hash位置添加新元素</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 重复判断，方式加锁之前已经有其他线程做了修改</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//普通链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//树节点，将元素添加到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//链表长度大于/等于8，将链表转成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//如果是重复键，直接将旧值返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化hash数组"><a href="#初始化hash数组" class="headerlink" title="初始化hash数组"></a>初始化hash数组</h3><ul><li>在初始化哈希数组的时候，会cas+自旋保证线程安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化底层数组 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//cas+自旋，保证线程安全，对数组进行初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果另一个线程已经初始化了数组，则不会走到这里。 会直接break</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sizeCtl为0，取默认长度16，否则去sizeCtl的值</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">//基于初始长度，构建数组对象</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算扩容阈值，并赋值给sc</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将扩容阈值，赋值给sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>ConcurrentHashMap 的扩容在transfer方法中；<br>需要注意的是，ConcurrentHashMap 有一个多线程协助扩容的机制。</p><ul><li>当一个线程在扩容的时候，在移动hash数组的元素到新数组的时候，会确定自己的开始位置 和 一个stride容量，hash数组stride内的元素自己负责扩容拷贝；然后确定一个 transferIndex 作为下次拷贝的起点。 同时在原数组的hash位置放置一个 ForwardingNode 。 </li><li>当有新的线程想要在这个hash位置插入元素时，发现这里有一个 ForwardingNode ，会协助一起扩容，帮助将原数组的元素迁移到新数组。 以 transferIndex 作为起点，stride容量内的元素自己负责协助拷贝</li><li>对于线程安全，在扩容拷贝的时候，会对hash数组要拷贝的位置进行 synchronized 加锁。在计算 transferIndex 的会使用 cas+自旋 机制保证线程安全。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果是扩容线程，此时新数组为null</span></span><br><span class="line">    <span class="comment">//如果是帮助扩容的线程，此时nextTab不为null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">//两倍扩容创建新数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录线程开始迁移的桶位，从后往前迁移，指向最右边</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录新数组的末尾</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED）</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// advance：代表是否可以继续推进下一个槽位，只有当前槽位数据被迁移完成之后才可以设置为 true</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//i记录当前正在迁移桶位的索引值</span></span><br><span class="line">            <span class="comment">//bound记录下一次任务迁移的开始桶位</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//--i &gt;= bound 成立表示当前线程分配的迁移任务还没有完成</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算下一次任务迁移的开始桶位，并将这个值赋值给transferIndex</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有更多的需要迁移的桶位，就进入该if</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//扩容任务线程数减1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//判断当前所有扩容任务线程是否都执行完成</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//所有扩容线程都执行完，标识结束</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前迁移的桶位没有元素，直接在该位置添加一个fwd节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//当前节点已经被迁移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前节点需要迁移，加锁迁移，保证多线程安全</span></span><br><span class="line">            <span class="comment">//此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    ... <span class="comment">// 省略代码，和 HashMap 的扩容拷贝基本一致</span></span><br><span class="line">                    advance = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap" target="_blank" rel="noopener">https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://yoursite.com/2022/04/04/Java/HashMap/"/>
    <id>http://yoursite.com/2022/04/04/Java/HashMap/</id>
    <published>2022-04-04T06:23:14.000Z</published>
    <updated>2022-04-04T08:39:37.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1. 基本数据结构"></a>1. 基本数据结构</h2><p>Node&lt;K, V&gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。<br>如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小<br>如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树</p><a id="more"></a><h2 id="2-加入的元素如何确定在数组中的-index"><a href="#2-加入的元素如何确定在数组中的-index" class="headerlink" title="2. 加入的元素如何确定在数组中的 index"></a>2. 加入的元素如何确定在数组中的 index</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把新加入的元素均匀分布到数组中，我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的. 但是jdk通过h &amp; (table.length -1)来得到该对象的保存位，这样运算会加快。</p><h2 id="3-如何扩容"><a href="#3-如何扩容" class="headerlink" title="3. 如何扩容"></a>3. 如何扩容</h2><p>将数组的容量扩大为原来的两倍，原数组长度为oldCap，下标j的元素会被分散到 数组j 和 j+oldCap 的位置。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab;</span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 数组下表位置如果是 红黑树，逻辑和下面的链表差不多</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">            <span class="comment">// 数组下表位置如果是 链表</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="comment">// 因为 oldCap 始终为2的倍数。 (e.hash &amp; oldCap) 只会有0或1两个值，由此决定是位置 j 还是 j+oldCap</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-扩容的时机"><a href="#4-扩容的时机" class="headerlink" title="4. 扩容的时机"></a>4. 扩容的时机</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><p>当size大于一个阈值的时候，就会开始扩容。 <code>threshold = length * loadFactor</code> 是数组长度*负载因子。 负载因子默认是0.75 ，注意这个length是table数组的长度而不是HashMap的整体size（为了保证获取元素的时间复杂度接近1）。</p><p>loadFactor 是时间复杂度和空间复杂度的权衡。 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><h2 id="5-HashMap是线程不安全的。HashTable是线程安全的。"><a href="#5-HashMap是线程不安全的。HashTable是线程安全的。" class="headerlink" title="5. HashMap是线程不安全的。HashTable是线程安全的。"></a>5. HashMap是线程不安全的。HashTable是线程安全的。</h2><p>HashTable的线程安全很粗暴，将所有的map操作加一个synchronized修饰。</p><p>参考：<br><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本数据结构&quot;&gt;&lt;a href=&quot;#1-基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. 基本数据结构&quot;&gt;&lt;/a&gt;1. 基本数据结构&lt;/h2&gt;&lt;p&gt;Node&amp;lt;K, V&amp;gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。&lt;br&gt;如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小&lt;br&gt;如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>transform和asm初探</title>
    <link href="http://yoursite.com/2022/03/21/Android/gradle/transform%E5%92%8Casm%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2022/03/21/Android/gradle/transform和asm初探/</id>
    <published>2022-03-21T13:54:26.000Z</published>
    <updated>2022-05-04T08:50:41.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义RouterTransform"><a href="#自定义RouterTransform" class="headerlink" title="自定义RouterTransform"></a>自定义RouterTransform</h2><p>Transform 是AGP官方提供的接口，在 class-&gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类</p><a id="more"></a><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>因为是安卓官方提供的能力，需要在 buildSrc 的 build.gradle 中 添加 google() 仓库和安卓构建工具的依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">    implementation <span class="string">"com.android.tools.build:gradle:3.5.3"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-RouterTranform"><a href="#编写-RouterTranform" class="headerlink" title="编写 RouterTranform"></a>编写 RouterTranform</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RouterMappingTransform"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要插桩的输入类型， 这里是类文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要插桩的范围, 这里是整个工程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否支持增量</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现</span><br><span class="line">     * @param transformInvocation</span><br><span class="line">     * @throws TransformException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation)</span><br><span class="line">        throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        super.transform(transformInvocation)</span><br><span class="line"></span><br><span class="line">        println("transform start")</span><br><span class="line"></span><br><span class="line">        def collector = new RouterMappingCollector()</span><br><span class="line"></span><br><span class="line">        // 遍历所有的输入</span><br><span class="line">        transformInvocation.inputs.each &#123;</span><br><span class="line">            // 把 文件夹 类型的输入，拷贝到目标目录</span><br><span class="line">            it.directoryInputs.each &#123; directoryInput -&gt;</span><br><span class="line">                def destDir = transformInvocation.outputProvider</span><br><span class="line">                    .getContentLocation(</span><br><span class="line">                        directoryInput.name,</span><br><span class="line">                        directoryInput.contentTypes,</span><br><span class="line">                        directoryInput.scopes,</span><br><span class="line">                        Format.DIRECTORY)</span><br><span class="line"></span><br><span class="line">                collector.collect(directoryInput.file)</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.file, destDir)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 把 JAR 类型的输入，拷贝到目标目录</span><br><span class="line">            it.jarInputs.each &#123; jarInput -&gt;</span><br><span class="line">                def dest = transformInvocation.outputProvider</span><br><span class="line">                    .getContentLocation(</span><br><span class="line">                        jarInput.name,</span><br><span class="line">                        jarInput.contentTypes,</span><br><span class="line">                        jarInput.scopes, Format.JAR)</span><br><span class="line">                collector.collectFromJarFile(jarInput.file)</span><br><span class="line">                println("transform jar input path $&#123;jarInput.file.absolutePath&#125;")</span><br><span class="line">                println("transform jar output path $&#123;dest.absolutePath&#125;")</span><br><span class="line">                FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        File mappingJarFile = transformInvocation.outputProvider.</span><br><span class="line">            getContentLocation(</span><br><span class="line">                "router_mapping",</span><br><span class="line">                getOutputTypes(),</span><br><span class="line">                getScopes(),</span><br><span class="line">                Format.JAR)</span><br><span class="line"></span><br><span class="line">        println("$&#123;getName()&#125;  mappingJarFile = $mappingJarFile")</span><br><span class="line"></span><br><span class="line">        if (mappingJarFile.getParentFile().exists()) &#123;</span><br><span class="line">            mappingJarFile.getParentFile().mkdirs()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mappingJarFile.exists()) &#123;</span><br><span class="line">            mappingJarFile.delete()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将生成的字节码，写入本地文件</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(mappingJarFile)</span><br><span class="line">        JarOutputStream jarOutputStream = new JarOutputStream(fos)</span><br><span class="line">        // CLASS_NAME = "com/imooc/router/mapping/generated/RouterMapping"</span><br><span class="line">        ZipEntry zipEntry =</span><br><span class="line">            new ZipEntry(RouterMappingByteCodeBuilder.CLASS_NAME + ".class")</span><br><span class="line">        jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">        println("transform collect class $&#123;collector.mappingClassName&#125;")</span><br><span class="line">        jarOutputStream.write(</span><br><span class="line">            // 写入字节码</span><br><span class="line">            RouterMappingByteCodeBuilder.get(collector.mappingClassName)</span><br><span class="line">        )</span><br><span class="line">        jarOutputStream.closeEntry()</span><br><span class="line">        jarOutputStream.close()</span><br><span class="line">        fos.close()</span><br><span class="line"></span><br><span class="line">        println("transform end")</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>transformInvocation.inputs.each {</code><br>表示遍历所有输入</li><li><code>it.directoryInputs.each { directoryInput -&gt;</code><br>表示遍历所有目录文件输入，directoryInput 是class文件的目录</li><li><code>it.jarInputs.each { jarInput -&gt;</code><br>遍历所有jar包输入， jarInput 是jar包</li><li><code>transformInvocation.outputProvider.getContentLocation(</code><br>获取具体的输入</li><li><code>collector.collect(directoryInput.file)</code><br>这里是一个自定义逻辑，表示从 class文件 或 jar包 中找到生成的 RouterMapping 路由映射类。 </li><li><p><code>FileUtils.copyFile(jarInput.file, dest)</code><br>拷贝文件到目标目录， 最终transform执行之后会在 /…项目目录/app/build/intermediates/transforms 中生成一个RouterMappingTransform目录。 需要吧class文件和jar包都拷贝过去。有意思是，我原本以为我们工程自己的代码应该都是 class文件，都在 <code>it.directoryInputs.each { directoryInput -&gt;</code> 这个输入里。 但是后来发现，只有 app工程是 class 文件，子工程打包成了 jar 包，和其他第三方库放在了一起</p></li><li><p>后面的代码都是动态生成了一个集合了所有子工程路由注册的路由类，使用asm写入了字节码</p></li></ul><p><strong>即使我们没有对文件做任何处理，我们仍然需要把输入文件拷贝到目标目录下，否则下一个Task就没有TansformInput，如果我们没有将input目录复制到output指定目录，会导致最后的打包的apk缺少class</strong></p><h2 id="注册transform"><a href="#注册transform" class="headerlink" title="注册transform"></a>注册transform</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterPlugin2</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (project.plugins.hasPlugin(AppPlugin)) &#123;</span><br><span class="line">            <span class="comment">// hasPlugin(AppPlugin) 表示这是 app 主工程</span></span><br><span class="line">            <span class="comment">// 注册进我们的 RouterTransform</span></span><br><span class="line">            <span class="keyword">def</span> extension = project.extensions.getByType(AppExtension)</span><br><span class="line">            extension.registerTransform(<span class="keyword">new</span> RouterTransform())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件也是需要注册的。。。在resource目录的方式注册。 不写了，网上搜一下吧。</p><h2 id="使用我们的-Router"><a href="#使用我们的-Router" class="headerlink" title="使用我们的 Router"></a>使用我们的 Router</h2><p>使用反射实例化我们的类即可<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// GENERATED_MAPPING = "com.imooc.router.mapping.generated.RouterMapping"</span></span><br><span class="line">    <span class="comment">// 注意上面原来文件"/"的分割要变成"."</span></span><br><span class="line">    <span class="keyword">val</span> clazz = Class.forName(GENERATED_MAPPING)</span><br><span class="line">    <span class="keyword">val</span> method = clazz.getMethod(<span class="string">"get"</span>)</span><br><span class="line">    <span class="keyword">val</span> allMapping = method.invoke(<span class="literal">null</span>) <span class="keyword">as</span> Map&lt;String, String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allMapping?.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"init: get all mapping:"</span>)</span><br><span class="line">        allMapping.onEach &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"    <span class="subst">$&#123;it.key&#125;</span> -&gt; <span class="subst">$&#123;it.value&#125;</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mapping.putAll(allMapping)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"init: error while init router : <span class="variable">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自定义RouterTransform&quot;&gt;&lt;a href=&quot;#自定义RouterTransform&quot; class=&quot;headerlink&quot; title=&quot;自定义RouterTransform&quot;&gt;&lt;/a&gt;自定义RouterTransform&lt;/h2&gt;&lt;p&gt;Transform 是AGP官方提供的接口，在 class-&amp;gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>自定义gradle插件</title>
    <link href="http://yoursite.com/2022/03/19/Android/gradle/%E8%87%AA%E5%AE%9A%E4%B9%89gradle%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/19/Android/gradle/自定义gradle插件/</id>
    <published>2022-03-19T09:52:18.000Z</published>
    <updated>2022-05-04T08:53:22.297Z</updated>
    
    <content type="html"><![CDATA[<p>这里只记录本地插件的写法</p><h2 id="创建-buildSrc-目录"><a href="#创建-buildSrc-目录" class="headerlink" title="创建 buildSrc 目录"></a>创建 buildSrc 目录</h2><a id="more"></a><ol><li>在创建的 buildScr 目录中创建 build.gradle 文件</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"groovy"</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置源码兼容性</span></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br></pre></td></tr></table></figure><p>上面是固定写法，这里只使用了 groovy 插件，所以我们的插件代码只支持用 groovy 编写</p><ol start="2"><li><p>在 buildSrc 目录中，创建对应的 groovy 目录<br>文件路径是<br>src/main/groovy/…(包名)/</p></li><li><p>创建 自定义的插件 RouterPlugin2</p></li></ol><p>创建文件名 RouterPlugin2.Plugin<br>创建插件类，并实现 Plugin 接口</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterPlugin2</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建 res 文件暴露自己的 groovy<br>创建文件路径：<br>src/main/resources/META-INF.gradle-plugins/RouterPlugin.properties</li></ol><p>内容如下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span>=<span class="title">com</span>.<span class="title">example</span>.<span class="title">test</span>.<span class="title">RouterPlugin2</span></span></span><br></pre></td></tr></table></figure></p><p>创建的文件名 META-INF.gradle-plugins 是固定目录名，xxxx.properties 中的xxxx就是对外暴露的插件的名字。 properties文件的内容表示插件的实现类</p><h2 id="外部使用插件"><a href="#外部使用插件" class="headerlink" title="外部使用插件"></a>外部使用插件</h2><ol><li>导入插件</li></ol><p>在业务的module的 build.gradle 文件中</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"RouterPlugin2"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>向插件写入参数</li></ol><p>在 buildSrc module 中创建一个 groovy 类，代表参数的model类</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterExtension2</span> &#123;</span></span><br><span class="line">    String wiki;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>插件类读取参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> extension = project.extensions.create(<span class="string">"router"</span>, RouterExtension2)</span><br><span class="line"><span class="keyword">def</span> path = extension.wiki</span><br></pre></td></tr></table></figure></li><li><p>在业务调用方传入参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">router &#123;</span><br><span class="line">    wiki <span class="string">"$&#123;getRootDir().absolutePath&#125;/router_wiki.md"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="RouterPlugin2-的详细实现"><a href="#RouterPlugin2-的详细实现" class="headerlink" title="RouterPlugin2 的详细实现"></a>RouterPlugin2 的详细实现</h2><p>插件中要实现三个功能</p><ol><li>在使用路由注解处理器的module，都向注解处理器插入一个参数，代表路由文件生成的路径。 </li><li>在项目clean时清除掉注解中间文件</li><li>将所有module生成的注解中间文件，汇总生成一个路由wiki文档</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterPlugin2</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"$TAG apply kotlin"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> routerFileDir = <span class="keyword">new</span> File(project.getRootDir(), <span class="string">"router_mapping"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * kapt &#123;</span></span><br><span class="line"><span class="comment">         *      rguments &#123;</span></span><br><span class="line"><span class="comment">         *          arg("router_mapping", rootProject.rootProjectDir.absolutePath）</span></span><br><span class="line"><span class="comment">         *      &#125;</span></span><br><span class="line"><span class="comment">         *  &#125;</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="comment">// 1. 自动帮助用户传递路径参数到注解处理器中 start</span></span><br><span class="line">        <span class="comment">// 以下代码可以替代以上的 build.gradle 配置</span></span><br><span class="line">        <span class="keyword">if</span> (project.extensions.findByName(<span class="string">"kapt"</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            project.extensions.findByName(<span class="string">"kapt"</span>).arguments &#123;</span><br><span class="line">                arg(<span class="string">"router_file_dir"</span>, routerFileDir)</span><br><span class="line">                arg(<span class="string">"project_name"</span>, project.name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 自动帮助用户传递路径参数到注解处理器中 end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 在clean时自动清理旧的构建产物</span></span><br><span class="line">        project.clean.doFirst &#123;</span><br><span class="line">            <span class="keyword">def</span> routerMappingFile = routerFileDir</span><br><span class="line">            <span class="keyword">if</span> (routerMappingFile.exists()) &#123;</span><br><span class="line">                routerMappingFile.deleteDir()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 集合各个子project路由信息，生成路由文档</span></span><br><span class="line">        <span class="keyword">def</span> extension = project.extensions.create(<span class="string">"router"</span>, RouterExtension2)</span><br><span class="line">        project.afterEvaluate &#123;</span><br><span class="line">            <span class="comment">// 在工程完成配置阶段之后才能获取到 外部配置的参数</span></span><br><span class="line">            <span class="keyword">def</span> wikiPath = extension.wiki</span><br><span class="line">            project.tasks.findAll &#123; task -&gt;</span><br><span class="line">                <span class="comment">// 找到编译的task，compileDebugJavaWithJavac</span></span><br><span class="line">                task.name.startsWith(<span class="string">"compile"</span>) &amp;&amp; task.name.endsWith(<span class="string">"JavaWithJavac"</span>)</span><br><span class="line">            &#125;.each &#123;task -&gt;</span><br><span class="line">                task.doLast &#123;</span><br><span class="line">                    <span class="keyword">def</span> wikiFile = <span class="keyword">new</span> File(wikiPath)</span><br><span class="line">                    <span class="keyword">if</span> (!wikiFile.exists()) &#123;</span><br><span class="line">                        wikiFile.createNewFile()</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">def</span> jsonFiles = routerFileDir</span><br><span class="line">                    jsonFiles.eachFile &#123;file -&gt;</span><br><span class="line">                        <span class="keyword">def</span> content = file.readBytes()</span><br><span class="line">                        wikiFile.append(<span class="keyword">new</span> String(content))</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// write jsonFile content into wikiPath</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里只记录本地插件的写法&lt;/p&gt;&lt;h2 id=&quot;创建-buildSrc-目录&quot;&gt;&lt;a href=&quot;#创建-buildSrc-目录&quot; class=&quot;headerlink&quot; title=&quot;创建 buildSrc 目录&quot;&gt;&lt;/a&gt;创建 buildSrc 目录&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>自定义注解处理器并发布为gradle组件</title>
    <link href="http://yoursite.com/2022/03/13/Android/gradle/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E5%B9%B6%E5%8F%91%E5%B8%83%E4%B8%BAgradle%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/13/Android/gradle/自定义注解处理器并发布为gradle组件/</id>
    <published>2022-03-13T07:27:24.000Z</published>
    <updated>2022-03-13T09:10:55.158Z</updated>
    
    <content type="html"><![CDATA[<p>自定义一个基于注解的路由框架</p><h2 id="定义注解类"><a href="#定义注解类" class="headerlink" title="定义注解类"></a>定义注解类</h2><ol><li>新建一个模块 router_annotations </li><li>在 router_annotations 目录中创建 build.gradle </li></ol><a id="more"></a><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin"</span> <span class="comment">// 使用 kotlin</span></span><br><span class="line"></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 发布脚本，后面会写</span></span><br><span class="line">apply <span class="string">from :</span> rootProject.file(<span class="string">"maven-publish.gradle"</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>定义注解类</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置使用注解的对象是 类</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.CLASS)</span></span><br><span class="line"><span class="comment">// 设置注解只在编译期存在</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.BINARY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>(</span><br><span class="line">    <span class="keyword">val</span> url: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="定义注解处理器模块"><a href="#定义注解处理器模块" class="headerlink" title="定义注解处理器模块"></a>定义注解处理器模块</h2><ol><li>新建一个模块 router_compile</li><li>在 router_compile 目录中创建 build.gradle</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin"</span> <span class="comment">// 使用kotlin插件</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin-kapt"</span> <span class="comment">// 使用kotlin注解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置源码兼容性</span></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(<span class="string">":router_annotations"</span>)</span><br><span class="line">    implementation <span class="string">"com.google.auto.service:auto-service:1.0-rc6"</span></span><br><span class="line">    kapt <span class="string">"com.google.auto.service:auto-service:1.0-rc6"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 发布脚本。后面会写</span></span><br><span class="line">apply <span class="string">from :</span> rootProject.file(<span class="string">"maven-publish.gradle"</span>)</span><br></pre></td></tr></table></figure><p>在注解处理器模块，如果使用kotlin写注解处理器代码，需要引用 <code>kotlin-kapt</code> 这个插件<br><code>implementation &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 使用google的一个注解框架。<br>同时还要加上 <code>kapt &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 。 这是kotlin的写法，如果是java，需要换成<br><code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code></p><ol start="3"><li>编写注解处理器<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService(Processor::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestinationProcessor</span> : <span class="type">AbstractProcessor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">"DestinationProcessor"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">set</span>: <span class="type">MutableSet</span>&lt;<span class="type">out</span> <span class="type">TypeElement</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        roundEnvironment: <span class="type">RoundEnvironment</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (roundEnvironment.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"<span class="variable">$TAG</span> &gt;&gt;&gt;&gt; process start"</span>)</span><br><span class="line"></span><br><span class="line">        println(<span class="keyword">set</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> destinationClasses = roundEnvironment.getElementsAnnotatedWith(Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">        println(TAG + <span class="string">" "</span> + destinationClasses.size)</span><br><span class="line">        <span class="keyword">if</span> (destinationClasses.size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> destinationClasses) &#123;</span><br><span class="line">            <span class="keyword">val</span> typeElement = element <span class="keyword">as</span> TypeElement</span><br><span class="line">            <span class="keyword">val</span> destination = typeElement.getAnnotation(Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">                ?: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">val</span> url = destination.url</span><br><span class="line">            <span class="keyword">val</span> className = typeElement.qualifiedName</span><br><span class="line">            println(<span class="string">"<span class="variable">$TAG</span> <span class="variable">$url</span> <span class="variable">$className</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"<span class="variable">$TAG</span> &gt;&gt;&gt;&gt; process finish"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> mutableSetOf(</span><br><span class="line">            Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">canonicalName</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@AutoService(Processor::class)</code> 是固定写法</p><p><code>AbstractProcessor</code> 继承这个抽象类。<br>重写<code>getSupportedAnnotationTypes</code>方法，返回需要处理的注解。<br>重写<code>process</code>方法，处理注解信息。 返回值为true表示已处理这个注解，相同的注解不会再被其他注解处理器处理。<br><code>roundEnvironment.processingOver()</code>表示之前已经有处理过一轮，此时<code>roundEnvironment.elements.size==0</code> 不是很明白gradle为什么会执行多轮。。。</p><h2 id="在本地使用注解"><a href="#在本地使用注解" class="headerlink" title="在本地使用注解"></a>在本地使用注解</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation project(<span class="string">":router_annotations"</span>)</span><br><span class="line">kapt project(<span class="string">":router_compile"</span>)</span><br></pre></td></tr></table></figure><h2 id="将注解处理器打包成组件并发布"><a href="#将注解处理器打包成组件并发布" class="headerlink" title="将注解处理器打包成组件并发布"></a>将注解处理器打包成组件并发布</h2><ol><li><p>在最外层的 build.properties 中写通用参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POM_URL=..<span class="regexp">/repo  /</span>/ 发布的仓库地址，这里是本地</span><br><span class="line">GROUP_ID=com.example.test <span class="comment">// group</span></span><br><span class="line">VERSION_NAME=<span class="number">1.0</span><span class="number">.0</span> <span class="comment">// 版本</span></span><br></pre></td></tr></table></figure></li><li><p>在 router_annotation 和 router_compile 中写 group_id</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 router_annotation build.properties</span></span><br><span class="line">POM_ARTIFACT_ID=router-test-annotation</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 router_compile build.properties</span></span><br><span class="line">POM_ARTIFACT_ID=router-test-processor</span><br></pre></td></tr></table></figure></li><li><p>编写发布脚本 maven-publish.gradle</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span> <span class="comment">// 引入maven插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根目录的 gradle.properties 中获取通用参数 start</span></span><br><span class="line"><span class="keyword">def</span> rootProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">rootProperties.load(<span class="keyword">new</span> FileInputStream(project.rootProject.file(<span class="string">"gradle.properties"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> versionName = rootProperties.getProperty(<span class="string">"VERSION_NAME"</span>)</span><br><span class="line"><span class="keyword">def</span> pomUrl = rootProperties.getProperty(<span class="string">"POM_URL"</span>) <span class="comment">// ../repo</span></span><br><span class="line"><span class="keyword">def</span> groupId = rootProperties.getProperty(<span class="string">"GROUP_ID"</span>)</span><br><span class="line"><span class="comment">// 获取通用参数 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前项目的 gradle.properties 中获取参数</span></span><br><span class="line"><span class="keyword">def</span> projectProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">projectProperties.load(<span class="keyword">new</span> FileInputStream(project.file(<span class="string">"gradle.properties"</span>)))</span><br><span class="line"><span class="keyword">def</span> pomArtifactId = projectProperties.getProperty(<span class="string">"POM_ARTIFACT_ID"</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"maven-publish $versionName $pomUrl $groupId $pomArtifactId"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写maven的发布任务</span></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(<span class="string">url:</span> uri(pomUrl)) &#123;</span><br><span class="line">                pom.groupId = groupId</span><br><span class="line">                pom.artifactId = pomArtifactId</span><br><span class="line">                pom.version = versionName</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pom.whenConfigured &#123; pom -&gt;</span><br><span class="line">                pom.dependencies.forEach &#123; dep -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (dep.getVersion() == <span class="string">"unspecified"</span>) &#123;</span><br><span class="line">                        dep.setGroupId(groupId)</span><br><span class="line">                        dep.setVersion(versionName)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意有一个 <code>pom.whenConfigured { pom -&gt; ...</code> 的代码，这是因为 router_compile 应用到了 router_annotations 模块。如果不做处理，发布之后， router_comiple 模块是找不到 router_annotations 的正确位置和版本的。所以要强制制定</p><h2 id="执行发布任务"><a href="#执行发布任务" class="headerlink" title="执行发布任务"></a>执行发布任务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :router_compile:uploadArchives</span><br><span class="line">./gradlew :router_annotations:uploadArchives</span><br></pre></td></tr></table></figure><p>我们设置的 <code>POM_URL=../repo</code> 所以最终会在项目的repo目录里生成aar包。 </p><h2 id="使用发布后的组件"><a href="#使用发布后的组件" class="headerlink" title="使用发布后的组件"></a>使用发布后的组件</h2><ol><li>首先，moven本地仓库地址加入到工程里<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>buildscript.repositories 和 allprojects.repositories 都要加，这样才会应用到所有子工程</p><ol start="2"><li><p>在app模块里引用组件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"com.example.test:router-test-annotation:1.0.0"</span></span><br><span class="line">kapt <span class="string">"com.example.test:router-test-processor:1.0.0"</span></span><br></pre></td></tr></table></figure></li><li><p>gradle版本的区别</p></li></ol><p>在 gradle 7.+ 版本有很多东西不兼容，上述实现只有在 gradle 6.+ 的版本有效。 gradle 的版本升级和项目创建还是要谨慎一些。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自定义一个基于注解的路由框架&lt;/p&gt;&lt;h2 id=&quot;定义注解类&quot;&gt;&lt;a href=&quot;#定义注解类&quot; class=&quot;headerlink&quot; title=&quot;定义注解类&quot;&gt;&lt;/a&gt;定义注解类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;新建一个模块 router_annotations &lt;/li&gt;
&lt;li&gt;在 router_annotations 目录中创建 build.gradle &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>MultiDex原理</title>
    <link href="http://yoursite.com/2021/12/25/Android/Framework/MultiDex%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2021/12/25/Android/Framework/MultiDex原理/</id>
    <published>2021-12-25T10:20:52.000Z</published>
    <updated>2021-12-25T11:04:06.178Z</updated>
    
    <content type="html"><![CDATA[<p>apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.<br>为了规避安卓项目编译65536最大方法数的限制，需要做分dex</p><a id="more"></a><h2 id="1-Dalvik-和-ART-虚拟机的区别"><a href="#1-Dalvik-和-ART-虚拟机的区别" class="headerlink" title="1. Dalvik 和 ART 虚拟机的区别"></a>1. Dalvik 和 ART 虚拟机的区别</h2><p>Android5.0以上系统使用 ART 虚拟机，5.0以下使用 Dalvik 虚拟机</p><p>Dalvik 编译策略是 JIT 技术。JIT意思是Just In Time Compiler，就是即时编译技术。<br>JIT是运行时编译，是动态编译，可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间可以加快Dalvik运行速度。每次运行都需要重新编译。</p><p>AOT是指”Ahead Of Time”，与”Just In Time”不同，从字面来看是说提前编译。<br>AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex预编译，一次性将所有dex代码转换为机器码，每次运行程序的时候不用重新编译。 </p><p>Android 7.0上，JIT 编译器被再次使用，采用AOT/JIT 混合编译的策略，特点是：</p><p>应用在安装的时候dex不会再被编译<br>App运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息。<br>手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译</p><h2 id="2-不同虚拟机在-MultiDex-的区别。"><a href="#2-不同虚拟机在-MultiDex-的区别。" class="headerlink" title="2. 不同虚拟机在 MultiDex 的区别。"></a>2. 不同虚拟机在 MultiDex 的区别。</h2><ul><li>Andorid 5.0 之后，ART天然支持从apk文件中加载多个.dex文件，在应用安装期间，它会执行一个预编译操作。将所有的dex编译成一个单一的.oat文件，在应用运行是去加载这个.oat文件，而不是一个一个的加载.dex文件。<br>所以我们只需要 在 gradle 开启 multiDexEnabled true 即可</li><li>Dalvik 使用的 JIT ，JIT每次运行都需要重新编译。 所以我们需要在应用启动时手动去一个一个加载 dex 文件</li></ul><h2 id="3-在-Dalvik-加载多dex"><a href="#3-在-Dalvik-加载多dex" class="headerlink" title="3. 在 Dalvik 加载多dex"></a>3. 在 Dalvik 加载多dex</h2><p>简单来说 hook PathClassLoader 。</p><ol><li>获取到所有的dex文件</li><li>通过反射拿到DexPathList的Element数组，把dex添加到 Element数组中</li></ol><p>通过这样的方式也可以实现热热修复，将修改后的新class打包成一个dex， 然后通过反射将 新dex插入到 PathClassLoader 中的 element数组最前面。从而实现对旧类的覆盖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.&lt;br&gt;为了规避安卓项目编译65536最大方法数的限制，需要做分dex&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>技术Owner的职责</title>
    <link href="http://yoursite.com/2021/11/27/%E6%8A%80%E6%9C%AFOwner%E7%9A%84%E8%81%8C%E8%B4%A3/"/>
    <id>http://yoursite.com/2021/11/27/技术Owner的职责/</id>
    <published>2021-11-27T07:58:24.000Z</published>
    <updated>2021-11-27T08:09:40.100Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参与需求评审，完成可行性调研，完善细节。<ul><li>要督促完成UI/UE评审，埋点评审</li></ul></li><li>技术评审，输出技术方案，拆分需求子任务，给出详细排期</li><li>开始开发，定期站会，同步风险<ul><li>发生变更，更改排期</li><li>需求提测前，推进case评审</li><li>自测</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;参与需求评审，完成可行性调研，完善细节。&lt;ul&gt;
&lt;li&gt;要督促完成UI/UE评审，埋点评审&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术评审，输出技术方案，拆分需求子任务，给出详细排期&lt;/li&gt;
&lt;li&gt;开始开发，定期站会，同步风险&lt;ul&gt;
&lt;li&gt;发生变更
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Binder源码笔记</title>
    <link href="http://yoursite.com/2021/11/03/Android/Framework/Binder%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/11/03/Android/Framework/Binder源码笔记/</id>
    <published>2021-11-03T13:42:37.000Z</published>
    <updated>2021-11-09T14:29:00.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Service-的启动-独立进程的-Service"><a href="#Service-的启动-独立进程的-Service" class="headerlink" title="Service 的启动 (独立进程的 Service )"></a>Service 的启动 (独立进程的 Service )</h1><a id="more"></a><h2 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a>ProcessState</h2><p>ProcessState 是一个系统 Service 进程的单例，一个进程只有一个 ProcessState 实例。 </p><p>内部会打开设备 “/dev/binder” ，调用 mmap 函数，完成自己和内核空间的内存映射。</p><p>ioctl 和 Binder 设备传递参数，设置了 binder 线程池的最大线程数</p><h2 id="Binder线程池"><a href="#Binder线程池" class="headerlink" title="Binder线程池"></a>Binder线程池</h2><p>调用 ProcessState::startThreadPool() 启动 Binder 线程池。 调用之后，实际上就已经 run 了一个 Binder 主线程, 并开始 while 死循环接收 Binder 消息。<br>之后会根据情况，选择在 Binder 线程池中创建新的线程，但是创建出来的就不是一个死循环的线程了</p><h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="BpBinder-和-BBinder"><a href="#BpBinder-和-BBinder" class="headerlink" title="BpBinder 和 BBinder"></a>BpBinder 和 BBinder</h2><p>IBinder 对象是负责binder通信的实例。 BpBinder 是客户端和服务端交互的代理类，BBinder 代表服务端</p><h2 id="BpBinder-transact"><a href="#BpBinder-transact" class="headerlink" title="BpBinder::transact"></a>BpBinder::transact</h2><p>发送数据的方法</p><h2 id="IPCThreadState-self-gt-transact-…"><a href="#IPCThreadState-self-gt-transact-…" class="headerlink" title="IPCThreadState::self()-&gt;transact(…)"></a>IPCThreadState::self()-&gt;transact(…)</h2><p>真正数据通信的方法。 一个线程只会有一个实例， 使用 pthread_setspecific 实现，类似于 java 的 ThreadLocal<br>IPCThreadState 有两个缓存 mIn 和 mOut 分别负责数据的接收和发射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> transact(..)</span><br><span class="line">    -&gt; writeTransactionData(..)</span><br><span class="line">        -&gt; 将 cmd 和 data 写入到 mOut 中</span><br><span class="line">    -&gt; waitForResponse(..)</span><br><span class="line">        -&gt; talkWithDriver(doReceive)</span><br><span class="line">            -&gt; 将 bwr(一个和Binder驱动的结构体) bwr.write_buffer 指向 mOut.data()</span><br><span class="line">            -&gt; 将 bwr.read_buffer 指向 mIn.data()</span><br><span class="line">            -&gt; do-while 循环，调用 ioctl 函数 和 Binder 驱动通信，直到结束</span><br></pre></td></tr></table></figure><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的"><a href="#1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的" class="headerlink" title="1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的"></a>1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的</h2><p>应用 Service 是发布到 AMS 上的，客户端从 AMS 上去查找 Service 的 Binder 对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Service-的启动-独立进程的-Service&quot;&gt;&lt;a href=&quot;#Service-的启动-独立进程的-Service&quot; class=&quot;headerlink&quot; title=&quot;Service 的启动 (独立进程的 Service )&quot;&gt;&lt;/a&gt;Service 的启动 (独立进程的 Service )&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>InputManagerService</title>
    <link href="http://yoursite.com/2021/10/18/Android/Framework/InputManagerService/"/>
    <id>http://yoursite.com/2021/10/18/Android/Framework/InputManagerService/</id>
    <published>2021-10-18T13:31:03.000Z</published>
    <updated>2021-10-18T14:01:44.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="native层概述"><a href="#native层概述" class="headerlink" title="native层概述"></a>native层概述</h2><h3 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h3><p>输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。</p><a id="more"></a><p>InputReader 持有 InputMapper 对应不同的输入设备的 事件加工器。 </p><p>事件加工后，InputReader 会 调用 InputDispatcher.notifyXXX 函数 唤醒 InputDispatcher 进行事件分发</p><h3 id="InputDispatcher"><a href="#InputDispatcher" class="headerlink" title="InputDispatcher"></a>InputDispatcher</h3><p>输入事件的分发者。 分发输入事件到目标窗口。 运行在 InputDispatcherThread 中， 这个线程平时是休眠状态，等待 InputReader 的唤醒</p><p>被唤醒后，调用 dispatchOnceInnerLocked 将输入事件分发到合适的窗口中</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;native层概述&quot;&gt;&lt;a href=&quot;#native层概述&quot; class=&quot;headerlink&quot; title=&quot;native层概述&quot;&gt;&lt;/a&gt;native层概述&lt;/h2&gt;&lt;h3 id=&quot;InputReader&quot;&gt;&lt;a href=&quot;#InputReader&quot; class=&quot;headerlink&quot; title=&quot;InputReader&quot;&gt;&lt;/a&gt;InputReader&lt;/h3&gt;&lt;p&gt;输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin-flow</title>
    <link href="http://yoursite.com/2021/10/04/Kotlin/kotlin-flow/"/>
    <id>http://yoursite.com/2021/10/04/Kotlin/kotlin-flow/</id>
    <published>2021-10-04T06:58:00.000Z</published>
    <updated>2022-04-11T06:46:20.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础的流"><a href="#基础的流" class="headerlink" title="基础的流"></a>基础的流</h1><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// 流构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们在这里做了一些有用的事情</span></span><br><span class="line">        emit(i) <span class="comment">// 发送下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">"I'm not blocked <span class="variable">$k</span>"</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集这个流</span></span><br><span class="line">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="flow-是-”冷流“"><a href="#flow-是-”冷流“" class="headerlink" title="flow 是 ”冷流“"></a>flow 是 ”冷流“</h2><ul><li>冷流的定义：  flow 构建器中的代码直到流被调用 collect 的时候才运行。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">flow</span><span class="params">(<span class="meta">@BuilderInference</span> block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.()</span></span> -&gt; <span class="built_in">Unit</span>): Flow&lt;T&gt; = SafeFlow(block)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeFlow</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> FlowCollector&lt;T&gt;.() -&gt; <span class="built_in">Unit</span>) : AbstractFlow&lt;T&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collectSafely</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        collector.block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlowCollector</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flow 的实现如上，只不过是传入了 代码块作为 FlowCollector 的拓展函数。<br>当 流开始收集 （调用collect），会执行这个 flow 的代码块。<br>在 collect 中传入的代码块， 实际上是一个 FlowCollector 匿名对象，当 flow 的代码块调用 emit 的时候，就直接调用了 collect 后的代码块。</p><p>用一个例子体现这一点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">1</span>) &#123;</span><br><span class="line">        log(<span class="string">"Emit start <span class="variable">$i</span>"</span>)</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">        log(<span class="string">"Emit end <span class="variable">$i</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .collect &#123; value -&gt;</span><br><span class="line">            log(<span class="string">"Collected start <span class="variable">$value</span>"</span>)</span><br><span class="line">            delay(<span class="number">300</span>)</span><br><span class="line">            log(<span class="string">"Collected end <span class="variable">$value</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] Emit start 1</span><br><span class="line">[main] Collected start 1</span><br><span class="line">[main] Collected end 1</span><br><span class="line">[main] Emit end 1</span><br></pre></td></tr></table></figure><h2 id="流的上下文保存"><a href="#流的上下文保存" class="headerlink" title="流的上下文保存"></a>流的上下文保存</h2><ul><li>上下文保存： <strong>flow { … } 构建器中的代码运行在相应流的收集器提供的上下文中</strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line">           </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    log(<span class="string">"Started simple flow"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt; log(<span class="string">"Collected <span class="variable">$value</span>"</span>) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#1] Started simple flow</span><br><span class="line">[main @coroutine#1] Collected 1</span><br><span class="line">[main @coroutine#1] Collected 2</span><br><span class="line">[main @coroutine#1] Collected 3</span><br></pre></td></tr></table></figure><p>由于 simple().collect 是在主线程调用的，那么 simple 的流主体也是在主线程调用的。<br><strong>如果在 调用<code>emit</code>时切换协程上下文，会直接抛出异常</strong></p><ul><li>flowOn: 正确的切换 flow 的上下文</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line">           </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们以消耗 CPU 的方式进行计算</span></span><br><span class="line">        log(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// 在流构建器中改变协程上下文的正确方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt;</span><br><span class="line">        log(<span class="string">"Collected <span class="variable">$value</span>"</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决-背压问题"><a href="#解决-背压问题" class="headerlink" title="解决 背压问题"></a>解决 背压问题</h2><p>名词解释：<strong>背压： 假设有一个快的数据生产者和一个慢的数据消费者，背压就是一种 “倒逼 “生产者而使自己不被数据淹没的机制</strong></p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>并发运行这个 流中发射元素的代码以及收集的代码， 而不是顺序运行它们； buffer() 会给切换 flow 的协程，保证 发送端 是不阻塞的 。 可以设置 buffer 容量和策略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .buffer() <span class="comment">// 缓冲发射项，无需等待</span></span><br><span class="line">            .collect &#123; value -&gt; </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(value) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conflate"><a href="#conflate" class="headerlink" title="conflate"></a>conflate</h3><p>一种特殊 buffer 策略 新数据会覆盖老数据</p><h3 id="collectLatest"><a href="#collectLatest" class="headerlink" title="collectLatest"></a>collectLatest</h3><p>它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .collectLatest &#123; value -&gt; <span class="comment">// 取消并重新发射最后一个值</span></span><br><span class="line">                println(<span class="string">"Collecting <span class="variable">$value</span>"</span>) </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(<span class="string">"Done <span class="variable">$value</span>"</span>) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collecting 1</span><br><span class="line">Collecting 2</span><br><span class="line">Collecting 3</span><br><span class="line">Done 3</span><br><span class="line">Collected in 741 ms</span><br></pre></td></tr></table></figure><h1 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h1><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">val</span> flow = MutableStateFlow(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> success = flow.tryEmit(i)</span><br><span class="line">            println(<span class="string">"tryEmit <span class="variable">$i</span> <span class="variable">$success</span>"</span>)</span><br><span class="line"><span class="comment">//            delay(200)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            produce()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch(Dispatchers.IO)&#123;</span><br><span class="line"></span><br><span class="line">            flow.onEach &#123;</span><br><span class="line">                println(<span class="string">"receive-1 <span class="variable">$it</span>"</span>)</span><br><span class="line">                delay(<span class="number">500</span>)</span><br><span class="line">            &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="StateFlow-是一个-“流”"><a href="#StateFlow-是一个-“流”" class="headerlink" title="StateFlow 是一个 “流”"></a>StateFlow 是一个 “流”</h2><p>不同于普通的 flow ， StateFlow 是一个热数据流。 不需要主动调动 collect{…} , 就能 emit 数据</p><h2 id="StateFlow-的-collect-是阻塞的，需要在单独的协程中运行"><a href="#StateFlow-的-collect-是阻塞的，需要在单独的协程中运行" class="headerlink" title="StateFlow 的 collect 是阻塞的，需要在单独的协程中运行"></a>StateFlow 的 collect 是阻塞的，需要在单独的协程中运行</h2><p>在demo中调用了 launchIn ，而不是直接 collect 。 看一下源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StateFlow </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _state = atomic(initialState)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> slot = allocateSlot()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (collector <span class="keyword">is</span> SubscribedFlowCollector) collector.onSubscription()</span><br><span class="line">            <span class="keyword">val</span> collectorJob = currentCoroutineContext()[Job]</span><br><span class="line">            <span class="keyword">var</span> oldState: Any? = <span class="literal">null</span> </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newState = _state.value</span><br><span class="line">                collectorJob?.ensureActive()</span><br><span class="line">                <span class="keyword">if</span> (oldState == <span class="literal">null</span> || oldState != newState) &#123;</span><br><span class="line">                    collector.emit(NULL.unbox(newState))</span><br><span class="line">                    oldState = newState</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!slot.takePending()) &#123; <span class="comment">// try fast-path without suspending first</span></span><br><span class="line">                    slot.awaitPending() <span class="comment">// only suspend for new values when needed</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            freeSlot(slot)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 collec 中，一个 while 死循环，开始不断读取 _state.value 的值<br>solt 可以看做是 collector 的一个封装。 这里调用了 slot.awaitPending() 来挂起当前协程，让出cpu时间. 看一下 StateFlowSlot 是如何挂起的 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">awaitPending</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = suspendCancellableCoroutine <span class="symbol">sc@</span> &#123; cont -&gt;</span><br><span class="line">    <span class="comment">// 如果 _state 是 None ，就设置为 cont </span></span><br><span class="line">    <span class="comment">// cont 的类型 CancellableContinuation ，只用调用 resume 或 fail 等，才会结束，否则挂起当前协程</span></span><br><span class="line">    <span class="keyword">if</span> (_state.compareAndSet(NONE, cont)) <span class="keyword">return</span><span class="symbol">@sc</span></span><br><span class="line">    cont.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 StateFlow 的 emit 被调用的时候， 会获取到 solt 中的 CancellableContinuation 对象，调用其 resume ，将协程进行唤醒</p><h1 id="ShareFlow"><a href="#ShareFlow" class="headerlink" title="ShareFlow"></a>ShareFlow</h1><h2 id="demo-2"><a href="#demo-2" class="headerlink" title="demo"></a>demo</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> flow = MutableSharedFlow&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">    replay = <span class="number">0</span>, </span><br><span class="line">    extraBufferCapacity = <span class="number">100</span>, </span><br><span class="line">    onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> success = flow.tryEmit(i)</span><br><span class="line">        println(<span class="string">"tryEmit <span class="variable">$i</span> <span class="variable">$success</span>"</span>)</span><br><span class="line"><span class="comment">//            delay(200)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    launch(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        produce()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch(Dispatchers.IO)&#123;</span><br><span class="line"></span><br><span class="line">        flow.onEach &#123;</span><br><span class="line">            println(<span class="string">"receive-1 <span class="variable">$it</span>"</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">        &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MutableShareFlow 的三个参数：</p><ul><li>通过 replay ，您可以针对新订阅者重新发送多个之前已发出的值</li><li>extraBufferCapacity: 除了 replay 值以外的缓冲区容量。 extraBufferCapacity + replay 是缓冲区buffer的容量</li><li>通过 onBufferOverflow，您可以指定相关政策来处理缓冲区中已存满要发送的数据项的情况。默认值为 BufferOverflow.SUSPEND，这会使调用方挂起。其他选项包括 DROP_LATEST 或 DROP_OLDEST</li></ul><p>ShareFlow 在收集侧 和 StateFlow 基本一致。 都是 while 死循环，然后将 solt 挂起。 这里不再赘述</p><!-- ## BufferOverflow.SUSPEND, tryEmit 和 Emit当  -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础的流&quot;&gt;&lt;a href=&quot;#基础的流&quot; class=&quot;headerlink&quot; title=&quot;基础的流&quot;&gt;&lt;/a&gt;基础的流&lt;/h1&gt;&lt;h2 id=&quot;demo&quot;&gt;&lt;a href=&quot;#demo&quot; class=&quot;headerlink&quot; title=&quot;demo&quot;&gt;&lt;/a&gt;demo&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; kotlinx.coroutines.*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; kotlinx.coroutines.flow.*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;simple&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: Flow&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt; = flow &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 流构建器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delay(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 假装我们在这里做了一些有用的事情&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        emit(i) &lt;span class=&quot;comment&quot;&gt;// 发送下一个值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = runBlocking&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Unit&lt;/span&gt;&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 启动并发的协程以验证主线程并未阻塞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    launch &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            println(&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m not blocked &lt;span class=&quot;variable&quot;&gt;$k&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            delay(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 收集这个流&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    simple().collect &amp;#123; value -&amp;gt; println(value) &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>nested2嵌套滚动机制</title>
    <link href="http://yoursite.com/2021/07/24/Android/nested2%E5%B5%8C%E5%A5%97%E6%BB%9A%E5%8A%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/07/24/Android/nested2嵌套滚动机制/</id>
    <published>2021-07-24T08:36:31.000Z</published>
    <updated>2021-10-03T01:57:41.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。</p><a id="more"></a><h2 id="NestedScrollingParent2"><a href="#NestedScrollingParent2" class="headerlink" title="NestedScrollingParent2"></a>NestedScrollingParent2</h2><p>NestedScrollingParent2 包含以下接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 即将开始嵌套滑动，此时嵌套滑动尚未开始，由子控件的 startNestedScroll 方法调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> child  嵌套滑动对应的父类的子类(因为嵌套滑动对于的父控件不一定是一级就能找到的，可能挑了两级父控件的父控件，child的辈分&gt;=target)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target 具体嵌套滑动的那个子类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> axes   嵌套滑动支持的滚动方向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type   嵌套滑动的类型，有两种ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true 表示此父类开始接受嵌套滑动，只有true时候，才会执行下面的 onNestedScrollAccepted 等操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当onStartNestedScroll返回为true时，也就是父控件接受嵌套滑动时，该方法才会调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> child</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> axes</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class="line"><span class="comment">    * 在嵌套滑动的子View未滑动之前</span></span><br><span class="line"><span class="comment">    * ，判断父view是否优先与子view处理(也就是父view可以先消耗，然后给子view消耗）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target   具体嵌套滑动的那个子类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dx       水平方向嵌套滑动的子View想要变化的距离</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dy       垂直方向嵌套滑动的子View想要变化的距离 dy&lt;0向下滑动 dy&gt;0 向上滑动</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> consumed 这个参数要我们在实现这个函数的时候指定，回头告诉子View当前父View消耗的距离</span></span><br><span class="line"><span class="comment">    *                 consumed[0] 水平消耗的距离，consumed[1] 垂直消耗的距离 好让子view做出相应的调整</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @NonNull <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">           </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class="line"><span class="comment">    * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target       具体嵌套滑动的那个子类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxConsumed   水平方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyConsumed   垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxUnconsumed 水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyUnconsumed 垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 停止滑动</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(@NonNull View target, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NestedScrollingChild2"><a href="#NestedScrollingChild2" class="headerlink" title="NestedScrollingChild2"></a>NestedScrollingChild2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingChild2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 开始滑动前调用，在惯性滑动和触摸滑动前都会进行调用，此方法一般在 onInterceptTouchEvent或者onTouch中，通知父类方法开始滑动</span></span><br><span class="line"><span class="comment">    * 会调用父类方法的 onStartNestedScroll onNestedScrollAccepted 两个方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> axes 滑动方向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type 开始滑动的类型 the type of input which cause this scroll event</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 有父视图并且开始滑动，则返回true 实际上就是看parent的 onStartNestedScroll 方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(@ScrollAxis <span class="keyword">int</span> axes, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 子控件停止滑动，例如手指抬起，惯性滑动结束</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type 停止滑动的类型 TYPE_TOUCH，TYPE_NON_TOUCH</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">(@NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断是否有父View 支持嵌套滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">(@NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在dispatchNestedPreScroll 之后进行调用</span></span><br><span class="line"><span class="comment">    * 当滑动的距离父控件消耗后，父控件将剩余的距离再次交个子控件，</span></span><br><span class="line"><span class="comment">    * 子控件再次消耗部分距离后，又继续将剩余的距离分发给父控件,由父控件判断是否消耗剩下的距离。</span></span><br><span class="line"><span class="comment">    * 如果四个消耗的距离都是0，则表示没有神可以消耗的了，会直接返回false，否则会调用父控件的</span></span><br><span class="line"><span class="comment">    * onNestedScroll 方法，父控件继续消耗剩余的距离</span></span><br><span class="line"><span class="comment">    * 会调用父控件的</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxConsumed     水平方向嵌套滑动的子控件滑动的距离(消耗的距离)    dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyConsumed     垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)    dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxUnconsumed   水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyUnconsumed   垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 如果返回true, 表示父控件又继续消耗了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, @Nullable <span class="keyword">int</span>[] offsetInWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 子控件在开始滑动前，通知父控件开始滑动，同时由父控件先消耗滑动时间</span></span><br><span class="line"><span class="comment">    * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离</span></span><br><span class="line"><span class="comment">    * 最终会调用父view的 onNestedPreScroll 方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dx             水平方向嵌套滑动的子控件想要变化的距离 dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dy             垂直方向嵌套滑动的子控件想要变化的距离 dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> consumed       父控件消耗的距离，父控件消耗完成之后，剩余的才会给子控件，子控件需要使用consumed来进行实际滑动距离的处理</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type           滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true    表示父控件进行了滑动消耗，需要处理 consumed 的值，false表示父控件不对滑动距离进行消耗，可以不考虑consumed数据的处理，此时consumed中两个数据都应该为0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @Nullable <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           @Nullable <span class="keyword">int</span>[] offsetInWindow, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nested2机制，滚动的传递"><a href="#nested2机制，滚动的传递" class="headerlink" title="nested2机制，滚动的传递"></a>nested2机制，滚动的传递</h2><p>一般情况下，事件是从child的触摸事件开始的，</p><ol><li><p>首先调用 <code>child.startNestedScroll()</code> 方法，此方法内部通过 <code>NestedScrollingChildHelper</code> 调用并返回 <code>parent.onStartNestedScroll()</code> 方法的结果，为 true，说明parent接受了嵌套滑动，同时会调用 <code>parent.onNestedScrollAccepted()</code> 方法，此时开始嵌套滑动；</p></li><li><p>在滑动事件中，child通过 <code>child.dispatchNestedPreScroll()</code> 方法分配滑动的距离，内部会先调用 <code>parent.onNestedPreScroll()</code> 方法，由parent先处理滑动距离。</p></li><li><p>parent消耗完成之后，再将剩余的距离传递给child，child拿到parent使用完成之后的距离之后，自己再处理剩余的距离。</p></li><li><p>如果此时子控件还有未处理的距离，则将剩余的距离再次通过 <code>child.dispatchNestedScroll()</code> 方法调用 <code>parent.onNestedScroll()</code> 方法，将剩余的距离交个parent来进行处理</p></li><li><p>滑动结束之后，调用 child.stopNestedScroll()通知parent滑动结束，至此，触摸滑动结束</p></li></ol><p>触摸滑动结束之后，child会继续进行惯性滑动，惯性滑动可以通过 Scroller 实现，具体滑动可以自己来处理，在fling过程中，和触摸滑动调用流程一样，需要注意 type 参数的区分，用来通知parent两种不同的滑动流程</p><h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><h3 id="预期目标"><a href="#预期目标" class="headerlink" title="预期目标"></a>预期目标</h3><p>自己实现一个嵌套滚动的 parent 和 child， 满足以下效果</p><ol><li>parent 包含 top 和 content 两部分，可滚动</li><li>当 top 未完全隐藏是，滚动 content ，是外层的 parent 滚动</li><li>当 top 完全隐藏，触摸滚动 content ，content 自己滚动</li><li>当触摸 content 滚动到顶部， top 未完全漏出， 则 parent 滚动，直至 top 完全露出</li></ol><h3 id="xml布局"><a href="#xml布局" class="headerlink" title="xml布局"></a>xml布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.test2.nest2_test.CustomNestedParent</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nested_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.core.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/view_top"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">androidx.core.widget.NestedScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">com.example.test2.nest2_test.CustomNestedChild</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/view_list"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"1500dp"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.example.test2.nest2_test.CustomNestedParent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里模仿 ScrollView 嵌套 ScrollView 的场景，即外部的 CustomNestedParent 嵌套 内部的 CustomNestedChild ，并解决他们的之间的滑动冲突<br>topVie2 外面包裹了一层 NestedScrollView，是为了让它支持 nested 机制</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedTestActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> nestedParent: CustomNestedParent</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> listView: LinearLayout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_nested_test)</span><br><span class="line"></span><br><span class="line">        nestedParent = findViewById(R.id.nested_parent)</span><br><span class="line">        <span class="keyword">val</span> topView: View = findViewById(R.id.view_top)</span><br><span class="line">        listView = findViewById(R.id.view_list)</span><br><span class="line"></span><br><span class="line">        nestedParent.<span class="keyword">init</span>(topView, listView)</span><br><span class="line"></span><br><span class="line">        addListItems()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">addListItems</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 填充 child， 这里模拟 child 是一个 recyclerview</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> textView = TextView(<span class="keyword">this</span>)</span><br><span class="line">            textView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, <span class="number">100</span>)</span><br><span class="line">            textView.text = <span class="string">"position <span class="variable">$i</span>"</span></span><br><span class="line">            listView.addView(textView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CustomNestedParent"><a href="#CustomNestedParent" class="headerlink" title="CustomNestedParent"></a>CustomNestedParent</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNestedParent</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context?,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingParent2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> TAG = <span class="string">"CustomNestedParent"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mNestedScrollingParentHelper = NestedScrollingParentHelper(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> topView: View</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> nestedChild: View</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> childrenHeight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinishInflate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onFinishInflate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(topView: <span class="type">View</span>, contentView: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.topView = topView</span><br><span class="line">        <span class="keyword">this</span>.nestedChild = contentView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 模仿 NestedScrollView</span></span><br><span class="line">        <span class="keyword">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">        <span class="keyword">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        childrenHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getChildAt(i)</span><br><span class="line">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class="line">            childrenHeight += child.measuredHeight</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(width, height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行其他操作</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartNestedScroll</span><span class="params">(child: <span class="type">View</span>, target: <span class="type">View</span>, axes: <span class="type">Int</span>, type: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onStartNestedScroll: "</span>)</span><br><span class="line">        <span class="keyword">return</span> axes == ViewCompat.SCROLL_AXIS_VERTICAL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当嵌套滑动被parent接收了，会回调这个方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedScrollAccepted</span><span class="params">(child: <span class="type">View</span>, target: <span class="type">View</span>, axes: <span class="type">Int</span>, type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onNestedScrollAccepted: "</span>)</span><br><span class="line">        mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes, type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class="line"><span class="comment">     * 不管手势滚动还是fling都会回调这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedPreScroll</span><span class="params">(target: <span class="type">View</span>, dx: <span class="type">Int</span>, dy: <span class="type">Int</span>, consumed: <span class="type">IntArray</span>, type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> threshold = nestedChild.top</span><br><span class="line">        <span class="keyword">var</span> parentScrollable = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> hideTop = dy &gt; <span class="number">0</span> &amp;&amp; scrollY &lt; threshold</span><br><span class="line">        <span class="keyword">val</span> showTop = dy &lt; <span class="number">0</span> &amp;&amp; !target.canScrollVertically(-<span class="number">1</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">"onNestedPreScroll-1: <span class="variable">$dy</span> <span class="variable">$type</span>"</span>)</span><br><span class="line">        <span class="keyword">if</span> (hideTop || showTop) &#123;</span><br><span class="line">          <span class="comment">// parent 提前消费的场景 </span></span><br><span class="line">          <span class="comment">// 1. 向上滚动，parent滚动的距离 &lt; topView的高度，需要隐藏topView </span></span><br><span class="line">          <span class="comment">// 2. 向下滚动，且 child 已经滚动到顶部，需要漏出 topView</span></span><br><span class="line">            parentScrollable = <span class="literal">true</span></span><br><span class="line">            consumed[<span class="number">1</span>] = dy</span><br><span class="line">            scrollBy(<span class="number">0</span>, dy)</span><br><span class="line">            Log.i(TAG, <span class="string">"onNestedPreScroll-2: hideTop=<span class="variable">$hideTop</span> showTop=<span class="variable">$showTop</span> dy=<span class="variable">$dy</span> scrollY=<span class="variable">$scrollY</span> threshold=<span class="variable">$threshold</span> type=<span class="variable">$type</span>"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 反之，应该让 child 滚动，parent不应该消费滚动距离</span></span><br><span class="line">            parentScrollable = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class="line"><span class="comment">     * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 孩子吃剩下的留给爸爸了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        target: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dxConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dxUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onNestedScroll: <span class="variable">$dyUnconsumed</span> <span class="variable">$type</span> <span class="variable">$scrollY</span>"</span>)</span><br><span class="line">        <span class="comment">// 剩余的parent全部消费</span></span><br><span class="line">        scrollBy(<span class="number">0</span>, dyUnconsumed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStopNestedScroll</span><span class="params">(target: <span class="type">View</span>, type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mNestedScrollingParentHelper.onStopNestedScroll(target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNestedScrollAxes</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mNestedScrollingParentHelper.nestedScrollAxes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollTo</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> resY = y</span><br><span class="line">        <span class="comment">// 限定 parnet 的上下边界，防止滚动出屏幕外</span></span><br><span class="line">        <span class="keyword">if</span> (resY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            resY = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> max = max(childrenHeight - height, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &gt; max) &#123;</span><br><span class="line">            resY = max</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"scrollTo: <span class="variable">$max</span> <span class="variable">$y</span> <span class="variable">$resY</span>"</span>)</span><br><span class="line">        <span class="keyword">super</span>.scrollTo(x, resY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CustomNestedChild"><a href="#CustomNestedChild" class="headerlink" title="CustomNestedChild"></a>CustomNestedChild</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNestedChild</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context?,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingChild2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> TAG = <span class="string">"CustomNestedChild"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mScrollingChildHelper = NestedScrollingChildHelper(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewConfiguration: ViewConfiguration = ViewConfiguration.<span class="keyword">get</span>(context)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mVelocityTracker: VelocityTracker? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mScroller: Scroller = Scroller(context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastX: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastY: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastFlingX: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastFlingY: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> offset = IntArray(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> consumed = IntArray(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fling = <span class="literal">false</span> <span class="comment">//判断当前是否是可以进行惯性滑动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> childrenHeight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        orientation = VERTICAL</span><br><span class="line">        <span class="comment">// 这里必须都设置为 true ，表明这个view是支持nested2机制的</span></span><br><span class="line">        isNestedScrollingEnabled = <span class="literal">true</span></span><br><span class="line">        mScrollingChildHelper.isNestedScrollingEnabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">        <span class="keyword">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        childrenHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getChildAt(i)</span><br><span class="line">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class="line">            childrenHeight += child.measuredHeight</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(width, height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startNestedScroll</span><span class="params">(axes: <span class="type">Int</span>, type: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.startNestedScroll(axes, type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">stopNestedScroll</span><span class="params">(type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mScrollingChildHelper.stopNestedScroll(type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNestedScrollingParent</span><span class="params">(type: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.hasNestedScrollingParent()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        dx: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dy: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        consumed: <span class="type">IntArray</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        offsetInWindow: <span class="type">IntArray</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchNestedScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        dxConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dxUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        offsetInWindow: <span class="type">IntArray</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedScroll(</span><br><span class="line">            dxConsumed,</span><br><span class="line">            dyConsumed,</span><br><span class="line">            dxUnconsumed,</span><br><span class="line">            dyUnconsumed,</span><br><span class="line">            offsetInWindow,</span><br><span class="line">            type</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">// 处理触摸事件是，关闭fling</span></span><br><span class="line">        cancelFling()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker == <span class="literal">null</span>) &#123;</span><br><span class="line">            mVelocityTracker = VelocityTracker.obtain()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> velocityTracker = mVelocityTracker!!</span><br><span class="line">        velocityTracker.addMovement(event)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                mLastX = event.x</span><br><span class="line">                mLastY = event.y</span><br><span class="line">                <span class="comment">// 表明开始处理嵌套滚动， TYPE_TOUCH 表明这是一个触摸场景</span></span><br><span class="line">                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> curX = event.x</span><br><span class="line">                <span class="keyword">val</span> curY = event.y</span><br><span class="line">                <span class="keyword">var</span> dy = (mLastY - curY).toInt()</span><br><span class="line">                <span class="keyword">var</span> dx = (mLastX - curX).toInt()</span><br><span class="line">                <span class="comment">// 先交给parent处理</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchNestedPreScroll(dx, dy, consumed, offset, TYPE_TOUCH)) &#123;</span><br><span class="line">                    dy -= consumed[<span class="number">1</span>]</span><br><span class="line">                    dx -= consumed[<span class="number">0</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// child自己消费</span></span><br><span class="line">                <span class="keyword">val</span> consumedY = childConsumeY(dy)</span><br><span class="line">                <span class="comment">// 将消费剩下的，传递给parent</span></span><br><span class="line">                dispatchNestedScroll(<span class="number">0</span>, consumedY, dx, dy - consumedY, <span class="literal">null</span>, TYPE_TOUCH)</span><br><span class="line">                mLastX = curX</span><br><span class="line">                mLastY = curY</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP,</span><br><span class="line">            MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">              <span class="comment">// 先结束 TYPE_TOUCH 场景的嵌套滚动</span></span><br><span class="line">                stopNestedScroll(TYPE_TOUCH)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否需要惯性滑动</span></span><br><span class="line">                velocityTracker.computeCurrentVelocity(</span><br><span class="line">                    <span class="number">1000</span>,</span><br><span class="line">                    viewConfiguration.scaledMaximumFlingVelocity.toFloat()</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">val</span> yvel = velocityTracker.yVelocity</span><br><span class="line">                fling(yvel.toInt())</span><br><span class="line">                velocityTracker.clear()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fling</span><span class="params">(velocityY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        cancelFling()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断速度是否足够大。如果够大才执行fling</span></span><br><span class="line">        <span class="keyword">var</span> dy: <span class="built_in">Int</span> = velocityY</span><br><span class="line">        <span class="keyword">if</span> (abs(velocityY) &lt; viewConfiguration.scaledMinimumFlingVelocity) &#123;</span><br><span class="line">            dy = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dy == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这步必须要有，表明开始 TYPE_NON_TOUCH 的嵌套滚动</span></span><br><span class="line">        <span class="comment">// 如果不设置，后续的嵌套滚动流程都都会找不到对应的parent</span></span><br><span class="line">        startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_NON_TOUCH)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> maxFlingVelocity: <span class="built_in">Int</span> = viewConfiguration.scaledMaximumFlingVelocity</span><br><span class="line">        dy = max(-maxFlingVelocity, min(dy, maxFlingVelocity))</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"fling: <span class="variable">$dy</span> "</span>)</span><br><span class="line">        fling = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 开始fling</span></span><br><span class="line">        mScroller.fling(</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            dy,</span><br><span class="line">            Integer.MIN_VALUE,</span><br><span class="line">            Integer.MAX_VALUE,</span><br><span class="line">            Integer.MIN_VALUE,</span><br><span class="line">            Integer.MAX_VALUE</span><br><span class="line">        )</span><br><span class="line">        postInvalidate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeScroll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset() &amp;&amp; fling) &#123;</span><br><span class="line">            <span class="keyword">val</span> y = mScroller.currY</span><br><span class="line">            <span class="keyword">var</span> dy = (mLastFlingY - y).toInt()</span><br><span class="line">            mLastFlingY = y.toFloat()</span><br><span class="line">            <span class="comment">// 和触摸场景一样，优先让parent处理</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchNestedPreScroll(<span class="number">0</span>, dy, consumed, <span class="literal">null</span>, TYPE_NON_TOUCH)) &#123;</span><br><span class="line">                dy -= consumed[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">"computeScroll: <span class="subst">$&#123;consumed[<span class="number">1</span>]&#125;</span> <span class="variable">$dy</span>"</span>)</span><br><span class="line">            <span class="comment">// child 自己处理</span></span><br><span class="line">            <span class="keyword">val</span> consumedY = childFling(dy)</span><br><span class="line">            <span class="comment">// 将剩下的在传递给 parent</span></span><br><span class="line">            dispatchNestedScroll(<span class="number">0</span>, consumedY, <span class="number">0</span>, dy - consumedY, <span class="literal">null</span>, TYPE_NON_TOUCH)</span><br><span class="line">            postInvalidate()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stopNestedScroll(TYPE_NON_TOUCH)</span><br><span class="line">            cancelFling()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">childConsumeY</span><span class="params">(dy: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> consumed = dy</span><br><span class="line">        <span class="keyword">if</span> (consumed &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果滑动到顶部，只处理部分，不然可能无法触达顶部边界</span></span><br><span class="line">            consumed = max(-scrollY, consumed)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果滑动到顶部，只处理部分，不然可能会无法触达底部边界</span></span><br><span class="line">            <span class="keyword">val</span> max = max(childrenHeight - height, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (dy + scrollY &gt; max) &#123;</span><br><span class="line">                consumed = max - scrollY</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"childConsumeY: <span class="variable">$dy</span> <span class="variable">$consumed</span> <span class="variable">$scrollY</span>"</span>)</span><br><span class="line">        scrollBy(<span class="number">0</span>, consumed)</span><br><span class="line">        <span class="keyword">return</span> consumed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">childFling</span><span class="params">(dy: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> childConsumeY(dy)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelFling</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fling = <span class="literal">false</span></span><br><span class="line">        mLastFlingY = <span class="number">0f</span></span><br><span class="line">        mLastFlingY = <span class="number">0f</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollTo</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> resY = y</span><br><span class="line">        <span class="keyword">if</span> (resY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            resY = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> max = max(childrenHeight - height, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &gt; max) &#123;</span><br><span class="line">            resY = max</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"scrollTo: <span class="variable">$max</span> <span class="variable">$y</span> <span class="variable">$resY</span>"</span>)</span><br><span class="line">        <span class="keyword">super</span>.scrollTo(x, resY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">canScrollVertically</span><span class="params">(direction: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction &lt; <span class="number">0</span> &amp;&amp; scrollY &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction &gt; <span class="number">0</span> &amp;&amp; scrollY &gt;= measuredHeight - height) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844903960432607246#heading-1" target="_blank" rel="noopener">https://juejin.cn/post/6844903960432607246#heading-1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h2&gt;&lt;p&gt;nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nested2" scheme="http://yoursite.com/tags/nested2/"/>
    
  </entry>
  
  <entry>
    <title>编译aosp</title>
    <link href="http://yoursite.com/2021/05/22/%E7%BC%96%E8%AF%91aosp/"/>
    <id>http://yoursite.com/2021/05/22/编译aosp/</id>
    <published>2021-05-22T09:12:59.000Z</published>
    <updated>2021-10-03T01:57:41.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘</li></ol><a id="more"></a><h1 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h1><ol><li>下载 Repo 工具，并确保它可执行：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure><p>使用清华源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git-repo-downloads/repo  &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure></p><ol start="2"><li>初始化 Repo</li></ol><p>-b 后面可以指定要同步代码的安卓系统版本代号<br>版本代号可以在下面的链接中查找<br><a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">https://source.android.com/setup/start/build-numbers</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1</span><br></pre></td></tr></table></figure><p>使用清华源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r40</span><br></pre></td></tr></table></figure></p><ol start="3"><li>同步 Repo</li></ol><p>需要几个小时的时间同步代码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>执行下面的命令，<br>lunch 选择编译模式（ 这里我选择的是  aosp_x86_64-eng）<br>m （m 命令系统会根据cpu性能自动选取需要使用的线程，你也可以根据cpu多少使用 make -jN, N表示cpu个数x2）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">lunch  aosp_x86_64-eng</span><br><span class="line">m</span><br></pre></td></tr></table></figure><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><ul><li>找不到对应的MacOSX.sdk<br>Could not find a supported mac sdk: [“10.10” “10.11” “10.12” “10.13”]</li></ul><p>我的系统版本是10.15，你需要到 <a href="https://github.com/phracker/MacOSX-SDKs/releases" target="_blank" rel="noopener">https://github.com/phracker/MacOSX-SDKs/releases</a> 下载需要的版本</p><p>我这里下载的是MacOSX10.12.sdk，解压复制到如下目录：<br>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</p><ul><li>不知名报错、</li></ul><p>找到文件：源文件根目录/system/sepolicy/tests/Android.bp，删除掉第14行的一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// libsepolwrap gets loaded from the system python, which does not have the</span><br><span class="line">// ASAN runtime. So turn off sanitization for ourself, and  use static</span><br><span class="line">// libraries, since the shared libraries will use ASAN.</span><br><span class="line">static_libs: [</span><br><span class="line">    &quot;libbase&quot;,</span><br><span class="line">    &quot;libsepol&quot;,</span><br><span class="line">],</span><br><span class="line">stl: &quot;libc++_static&quot;, // 删除掉这一行</span><br><span class="line">sanitize: &#123;</span><br><span class="line">    never: true,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="使用-Android-Studio-阅读源码"><a href="#使用-Android-Studio-阅读源码" class="headerlink" title="使用 Android Studio 阅读源码"></a>使用 Android Studio 阅读源码</h1><ol><li>生成 Android Studio 工程配置文件</li></ol><p>生成 android.iml 和 android.ipr 文件。</p><p>其中 iml 文件 表示 information of modules, 用来描述 AOSP 的模块信息。<br>ipr 文件 表示 IDEA project configuration ，用来描述 IDEA 的工程配置信息，双击此文件时系统将直接使用 Andorid Studio 打开此项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 设置 AOSP 编译所需的环境变量</span><br><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="meta">#</span> 使用 idegen.sh 脚本生成 IDEA 工程文件</span><br><span class="line">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="AOSP" scheme="http://yoursite.com/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>屏幕刷新机制</title>
    <link href="http://yoursite.com/2021/03/18/Android/Framework/%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/03/18/Android/Framework/屏幕刷新机制/</id>
    <published>2021-03-17T16:05:08.000Z</published>
    <updated>2021-10-03T01:57:41.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h1><p>view.requestLayout 最终会调用 ViewRootImpl.requestLayout</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();  <span class="comment">// 检查线程是否是 ViewRootImpl 实例化的线程</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mTraversalScheduled 标记位，避免短时间多次调用requestLayout重复刷新</span></span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 添加一个同步屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// 通过 Choreographer 添加一个 Vsync 回调</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 measure layout draw 三步走</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</code> 这个操作会在 LooperQueue 中添加一个同步屏障，阻断同步 message（普通 message ）的执行。<br>（异步 message 能正常执行）<br>这里主要是为了保证在 Vync 到来时，这个 message 能够快速响应，保证在 Vync 到来的最初时刻就开始绘制，从而保证 UI 的绘制和 Vync 的周期是协调的。</p><p><code>mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</code> 添加一个 Vsync 回调。在 Vsync 信号到来时执行 mTraversalRunnable 。</p><h1 id="Choreographer"><a href="#Choreographer" class="headerlink" title="Choreographer"></a>Choreographer</h1><p>Choreographer 是用来监听 Vsync 信号的一个类。 在刷新UI时主要有两步。</p><h2 id="添加一个-vsync-信号的回调"><a href="#添加一个-vsync-信号的回调" class="headerlink" title="添加一个 vsync 信号的回调"></a>添加一个 vsync 信号的回调</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">// 这里 mCallbackQueues 是多个事件的队列</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 延时做刷新，最终也会走 scheduleFrameLocked</span></span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="comment">// 判断是不是在 ViewRootImpl 实例化时的线程</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是，用一个 Handler 切换线程</span></span><br><span class="line">                <span class="comment">// 发送一个异步消息，并且放置在队列最前方</span></span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 native 方法请求一个 vsync 回调</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理-vsync-回调"><a href="#处理-vsync-回调" class="headerlink" title="处理 vsync 回调"></a>处理 vsync 回调</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Choreographer 的构造方法里实例化 DisplayEventReceiver</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">        mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">                ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">        mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">            mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHavePendingVsync;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mTimestampNanos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFrame;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, vsyncSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">            timestampNanos = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        <span class="comment">// 发送一个异步消息，注意，这里没有放置到消息队列最前端</span></span><br><span class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">// 当前时间 - vsync回调到来时间 = 主线程message耗时</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="comment">// 当超过了屏幕一帧刷新时间 16ms</span></span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                <span class="comment">// 当跳过的帧超过一定程度</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理屏幕刷新的回调，这里会调用 ViewRootImpl.TraversalRunnable</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;requestLayout&quot;&gt;&lt;a href=&quot;#requestLayout&quot; class=&quot;headerlink&quot; title=&quot;requestLayout&quot;&gt;&lt;/a&gt;requestLayout&lt;/h1&gt;&lt;p&gt;view.requestLayout 最终会调用 ViewRootImpl.requestLayout&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://yoursite.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>应用进程是如何启动的</title>
    <link href="http://yoursite.com/2021/03/07/Android/Framework/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84/"/>
    <id>http://yoursite.com/2021/03/07/Android/Framework/应用进程是如何启动的/</id>
    <published>2021-03-06T16:23:23.000Z</published>
    <updated>2022-05-02T07:54:51.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zygote的启动"><a href="#zygote的启动" class="headerlink" title="zygote的启动"></a>zygote的启动</h1><h2 id="zygote-的功能"><a href="#zygote-的功能" class="headerlink" title="zygote 的功能"></a>zygote 的功能</h2><p>zygote 进程的主要功能有两个：</p><a id="more"></a><ol><li>在系统启动时启动 SystemServer 进程</li><li>启动 应用进程</li></ol><h2 id="zygote-进程的启动过程"><a href="#zygote-进程的启动过程" class="headerlink" title="zygote 进程的启动过程"></a>zygote 进程的启动过程</h2><h3 id="zygote进程的创建。"><a href="#zygote进程的创建。" class="headerlink" title="zygote进程的创建。"></a>zygote进程的创建。</h3><p>在 Android 系统开机之后，会创建 init 进程，这是 Linux 系统启动后创建的第一个进程。 init 进程有一个配置文件 init.rc 。 将需要启动的服务写入到 init.rc 中， init 进程在启动后就会创建这些进程， 比如 zygote ， ServiceManager 等。</p><h3 id="zygote-进程的-native-部分。"><a href="#zygote-进程的-native-部分。" class="headerlink" title="zygote 进程的 native 部分。"></a>zygote 进程的 native 部分。</h3><p>zygote 的c层代码入口在 /rameworks/base/cmds/app_process/app_main.cpp 中，最终主要的工作内容在 /frameworks/base/core/jni/AndroidRuntime.cpp 。主要内容如下。不详细分析了</p><ul><li>启动虚拟机。</li><li>注册 JNI 函数</li><li>调用 Java 类 Zygote.main 方法，进入 Java 循环 。</li></ul><h3 id="zygote-进程的-Java-部分"><a href="#zygote-进程的-Java-部分" class="headerlink" title="zygote 进程的 Java 部分"></a>zygote 进程的 Java 部分</h3><p>zygote 的 java 入口在 /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">        ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> Runnable caller;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            RuntimeInit.enableDdms();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">            String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">            String abiList = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                    startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                    enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                    abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 socket</span></span><br><span class="line">            zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class="line">            <span class="comment">// In such cases, we will preload things prior to our first fork.</span></span><br><span class="line">            <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">                <span class="comment">// 预加载类和资源</span></span><br><span class="line">                preload(bootTimingsTraceLog);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Zygote.resetNicePriority();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ... </span><br><span class="line">            <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">                <span class="comment">// fork SystemServer 进程</span></span><br><span class="line">                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">                <span class="comment">// child (system_server) process.</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果 r != null ，说明是子进程 SystemServer ，r.run 应该是进入 SystemServer 的事件循环，然后直接return</span></span><br><span class="line">                    r.run();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// zygote 事件循环，不让zygote退出</span></span><br><span class="line">            caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">        <span class="comment">// command.</span></span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>注册 Socket 服务， zygote 进程通过 socket 和 AMS 通信</li><li>预加载类和资源。这样在 fork SystemServer 和 应用进程时，能够直接拷贝给子进程使用</li><li>fork 出 SystemServer 进程， SystemServer 进程随后又会启动 Binder ，并启动这种系统 Service ，比如 AMS ，WMS 等。</li><li>进入 loop 循环，等待接收 AMS 的 Socket 消息。 收到消息后会调用 runOnce 方法，fork 出应用进程，并执行应用进程的 ActivityThread.main() </li></ul><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p><strong>注意：zygote fork 进程时一定是单线程的</strong></p><ul><li><strong>zygote 新 fork 出来的进程不需要再创建java虚拟机，因为 fork 出来的子进程是会继承拷贝父进程的资源的， fork 出来的进程会拥有 zygote 进程的虚拟机的拷贝</strong></li><li><strong>为什么要设计一个 zygote 来 fork 应用进程，而不是 SystemServer :</strong><ul><li>因为systemServer中运行了很多系统服务，不能被继承。应用程序启动时，除了必要的资源外，最好是干净的，所以需要单独用一个zygote来fork。</li></ul></li><li><strong>为什么Zygote要使用Socket不使用binder：</strong><ul><li>因为binder机制支持并发有一个线程池，如果zygote支持并发，在fork之后，会把线程池中的线程一起复制一份。 如果zygote的binder线程池处于一个等待锁的状态，fork之后的新进程依然是在等待锁的，并且不能解锁。 从而有可能造成死锁</li></ul></li></ul><h3 id="zygote-的事件循环"><a href="#zygote-的事件循环" class="headerlink" title="zygote 的事件循环"></a>zygote 的事件循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/com/android/internal/os/ZygoteServer.java</span></span><br><span class="line">    <span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">        ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">        fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">        peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">                pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">                pollFds[i].fd = fds.get(i);</span><br><span class="line">                pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span></span><br><span class="line">                Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 这里没看懂。。。</span></span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    fds.add(newPeer.getFileDesciptor());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 处理接收到的消息</span></span><br><span class="line">                        ZygoteConnection connection = peers.get(i);</span><br><span class="line">                        <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</span></span><br><span class="line">    <span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, ...);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 子进程</span></span><br><span class="line">                zygoteServer.setForkChild();</span><br><span class="line"></span><br><span class="line">                zygoteServer.closeServerSocket();</span><br><span class="line">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">                serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class="line">                        parsedArgs.startChildZygote);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 父进程</span></span><br><span class="line">                IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">                childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">                handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs, FileDescriptor[] descriptors,</span></span></span><br><span class="line"><span class="function"><span class="params">            FileDescriptor pipeFd, <span class="keyword">boolean</span> isZygote)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        closeSocket();</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">                <span class="comment">// 应用进程启动流程进入这个分支</span></span><br><span class="line">                <span class="comment">// 从 socket 传来参数中取出 class ，并执行 main 方法</span></span><br><span class="line">                <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没看懂这个分支是做什么的。。</span></span><br><span class="line">                <span class="comment">// 看注释的意思是提供了「跳过启动binder，直接创建进程」的方式</span></span><br><span class="line">                <span class="keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                        parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="应用进程的启动"><a href="#应用进程的启动" class="headerlink" title="应用进程的启动"></a>应用进程的启动</h1><p>我们以 Activity 的启动为入口，来探讨应用进程的启动过程</p><h2 id="AMS-发起创建进程"><a href="#AMS-发起创建进程" class="headerlink" title="AMS 发起创建进程"></a>AMS 发起创建进程</h2><h3 id="由-Activity-的启动寻找应用进程创建的入口"><a href="#由-Activity-的启动寻找应用进程创建的入口" class="headerlink" title="由 Activity 的启动寻找应用进程创建的入口"></a>由 Activity 的启动寻找应用进程创建的入口</h3><p>首先来看 Activity 的启动。安卓四大组件都是由AMS来管理的。 应用进程会调用 AMS 的binder 对象，实现在 ActivityManagerService.startActivity 里。</p><p>最终顺着调用栈，会走到 ActivityStackSupervisor.startSpecificActivityLocked(…)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 进程已启动，真正开始启动 activity 了，哎，调用链太长了</span></span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进程没启动，开始启动进程了</span></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的逻辑里，会先判断要启动的 activity 所在应用的进程是否启动，如果已经成功启动，则开始启动 activity ；否则，启动引用进程。<br>注意这里应用是否启动的判断条件： <code>if (app != null &amp;&amp; app.thread != null)</code><br> ProcessRecord 是应用进程在 AMS 的信息记录，除了判断 app 不为空，还对 app.thread 。这个 app.thread 是一个 IApplicationThread binder 对象，这个对象很重要。</p><h3 id="AMS-发送-Socket-给-zygote"><a href="#AMS-发送-Socket-给-zygote" class="headerlink" title="AMS 发送 Socket 给 zygote"></a>AMS 发送 Socket 给 zygote</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(String hostingType, String hostingNameStr, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class="line">        <span class="comment">// 异步启动进程，忽略吧</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,</span><br><span class="line">                    uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    invokeWith, startTime);</span><br><span class="line">            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                    startSeq, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app.pid &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS.startProcess 会调用 Process.start(…) 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/os/Process.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /frameworks/base/core/java/android/os/ZygoteProcess.java</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, <span class="keyword">false</span> <span class="comment">/* startChildZygote */</span>,</span><br><span class="line">                    zygoteArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ... <span class="comment">// 组装 socket 的参数</span></span><br><span class="line">        <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="comment">// openZygoteSocketIfNeeded 会获取一个 ZygoteState ，有必要的话，会创建 socket 连接。 ZygoteState 包含了 socket 输入输出流。</span></span><br><span class="line">            <span class="comment">// zygote fork 进程成功会返回应用进程的 pid</span></span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AMS 会发送 socket 消息给 zygote ，zygote 会 fork 应用进程，并执行应用进程的 ActivityThread.main 方法</p><h1 id="应用进程在启动之后都干了啥？"><a href="#应用进程在启动之后都干了啥？" class="headerlink" title="应用进程在启动之后都干了啥？"></a>应用进程在启动之后都干了啥？</h1><h2 id="thread-attach-…"><a href="#thread-attach-…" class="headerlink" title="thread.attach(…)"></a>thread.attach(…)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">            <span class="comment">// 走这个分支</span></span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>应用整个进程的入口在 ActivityThread.main() 方法中，这个方法里没啥操作： 1. 准备 Looper 2. 实例化 ActivityThread ，并 attach 3. 开启 Looper 循环</p><p>显然， main 方法里做的事情支撑不了一个 app 的启动。 重点看 thread.attach , 它 使用 binder 调用了 AMS.attachApplication ，然后又调用了 AMS.attachApplicationLocked(…)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码。。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        ProcessRecord app;</span><br><span class="line">        <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                app = mPidsSelfLocked.get(pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread.bindApplication(...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理一些因为应用进程还没有启动而暂存的组件</span></span><br><span class="line">        mStackSupervisor.attachApplicationLocked(app);</span><br><span class="line">        ...</span><br><span class="line">        mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        ...</span><br><span class="line">        sendPendingBroadcastsLocked(app);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="thread-bindApplication-…"><a href="#thread-bindApplication-…" class="headerlink" title="thread.bindApplication(…)"></a>thread.bindApplication(…)</h2><p>AMS 在 attch 进程之后又通过 binder 调用了应用进程的 bindApplication </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span></span><br><span class="line"><span class="function"><span class="params">        String buildSerial, <span class="keyword">boolean</span> autofillCompatibilityEnabled)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">    ... <span class="comment">// 补充 AppBindData 的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送一个 消息到 H handler </span></span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用进程，发送了一个 H.BIND_APPLICATION 给 handler ，实现了线程的切换。 注意 <strong>通过 binder对象调用，是运行在 binder 线程里的</strong>，所以这个 bindApplication 也是运行在 binder 线程里的，需要切换回主线程。 </p><h2 id="handleBindApplication"><a href="#handleBindApplication" class="headerlink" title="handleBindApplication"></a>handleBindApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data.info 是一个描述应用安装包信息的类。 <code>data.info.makeApplication</code> 一个applicaiton 类，并调用生命周期的 onCreate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></span><br><span class="line"><span class="function"><span class="params">            Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 application 和 context 对象，并绑定</span></span><br><span class="line">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，应用的启动就完成了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;zygote的启动&quot;&gt;&lt;a href=&quot;#zygote的启动&quot; class=&quot;headerlink&quot; title=&quot;zygote的启动&quot;&gt;&lt;/a&gt;zygote的启动&lt;/h1&gt;&lt;h2 id=&quot;zygote-的功能&quot;&gt;&lt;a href=&quot;#zygote-的功能&quot; class=&quot;headerlink&quot; title=&quot;zygote 的功能&quot;&gt;&lt;/a&gt;zygote 的功能&lt;/h2&gt;&lt;p&gt;zygote 进程的主要功能有两个：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://yoursite.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>自定义LayoutManager</title>
    <link href="http://yoursite.com/2021/02/26/Android/%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager/"/>
    <id>http://yoursite.com/2021/02/26/Android/自定义LayoutManager/</id>
    <published>2021-02-26T09:06:00.000Z</published>
    <updated>2021-10-03T01:57:41.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LayoutManager-的常用方法"><a href="#LayoutManager-的常用方法" class="headerlink" title="LayoutManager 的常用方法"></a>LayoutManager 的常用方法</h1><h3 id="generateDefaultLayoutParams"><a href="#generateDefaultLayoutParams" class="headerlink" title="generateDefaultLayoutParams"></a>generateDefaultLayoutParams</h3><a id="more"></a><p>生成默认RecyclerView的LayoutParams, 没啥意义，就返回 wrap_content</p><h3 id="isAutoMeasureEnabled-和-onMeasure"><a href="#isAutoMeasureEnabled-和-onMeasure" class="headerlink" title="isAutoMeasureEnabled 和 onMeasure"></a>isAutoMeasureEnabled 和 onMeasure</h3><p>isAutoMeasureEnabled()是自测量模式。 如果要支持 wrap_content ，那必须重写这两个方法中的一个。 大部分情况下，isAutoMeasureEnabled 返回 true 即可。重写onMeasure()的情况也极少，除非像我那个PickerLayoutManger一样。</p><h3 id="canScrollHorizontally-和-canScrollVertically"><a href="#canScrollHorizontally-和-canScrollVertically" class="headerlink" title="canScrollHorizontally 和 canScrollVertically"></a>canScrollHorizontally 和 canScrollVertically</h3><p>无需多言</p><h3 id="onLayoutChildren"><a href="#onLayoutChildren" class="headerlink" title="onLayoutChildren"></a>onLayoutChildren</h3><p>当 RecyclerView 的 layout 过程中会调用这个方法，<strong>包括第一次 layout 和 其他原因的重新 layout</strong>，比如说键盘的升降。</p><h3 id="scrollHorizontallyBy-和-scrollVerticallyBy"><a href="#scrollHorizontallyBy-和-scrollVerticallyBy" class="headerlink" title="scrollHorizontallyBy 和 scrollVerticallyBy"></a>scrollHorizontallyBy 和 scrollVerticallyBy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun scrollHorizontallyBy(</span><br><span class="line"></span><br><span class="line">    dx: Int,</span><br><span class="line">    recycler: RecyclerView.Recycler,</span><br><span class="line">    state: RecyclerView.State</span><br><span class="line">): Int &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecyclerView 滚动的时候回回调这个方法，但是它只是告诉你用户滑动的距离，需要你自己去实现滑动的效果。同时需要去判断滑动的边界。<br>但是返回值与 RecyclerView 的 overScorll 的动画有关，返回0会有边界的波纹动画。</p><h3 id="getPosition-View"><a href="#getPosition-View" class="headerlink" title="getPosition(View)"></a>getPosition(View)</h3><p>返回 child view 在 adapter 中的位置</p><h3 id="getDecoratedXxxx"><a href="#getDecoratedXxxx" class="headerlink" title="getDecoratedXxxx"></a>getDecoratedXxxx</h3><p>在 LayoutManager 中与布局有关的api都需要替换成带 Decorated 的api，不然无法实现对 itemDecorated 的兼容</p><h3 id="detachAndScrapAttachedViews"><a href="#detachAndScrapAttachedViews" class="headerlink" title="detachAndScrapAttachedViews()"></a>detachAndScrapAttachedViews()</h3><p>从 RecyclerView 暂时移除 child 并送入临时缓存。 之前一直很奇怪，暂时移除是个什么场景。 后来想明白了，在每次布局 child 之前，都需要吧调用一次这个方法，吧所有的 child 移除到临时缓存里。否则，在布局的时候 addView(child) ，如果 child 已经 add 到了 RecyclerView 里，会造成一些麻烦。</p><h3 id="removeAndRecycleView"><a href="#removeAndRecycleView" class="headerlink" title="removeAndRecycleView"></a>removeAndRecycleView</h3><p>移除 child 并将对应的 ViewHolder 移动到 cachePool ，从 cachePool 中取出的 ViewHolder 需要重新调用 Adapter.onBindViewHolder 方法</p><h1 id="自定义-LayoutManager-的一般套路"><a href="#自定义-LayoutManager-的一般套路" class="headerlink" title="自定义 LayoutManager 的一般套路"></a>自定义 LayoutManager 的一般套路</h1><p>scrollHorizontallyBy 和 onLayoutChildren 可以服用同一个布局逻辑。</p><ol><li>确定锚点 view 的 position</li><li>确定布局的左右(上下)边界</li><li>开始 addView()-&gt;measureView()-&gt;layoutView() </li><li>回收布局边界之外的 child</li></ol><h1 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomLinearLayoutManager</span> : <span class="type">RecyclerView.LayoutManager</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">generateDefaultLayoutParams</span><span class="params">()</span></span>: RecyclerView.LayoutParams &#123;</span><br><span class="line">        <span class="keyword">return</span> RecyclerView.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class="line">            ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isAutoMeasureEnabled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">canScrollHorizontally</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">canScrollVertically</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayoutChildren</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.itemCount == <span class="number">0</span>) &#123;</span><br><span class="line">            removeAndRecycleAllViews(recycler)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = paddingStart</span><br><span class="line">        <span class="keyword">var</span> curPos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (childCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是兼容键盘升起然后重新 rebuild 的情况。</span></span><br><span class="line">            <span class="comment">// 如果不做兼容，RecyclerView 会移动到列表最顶部</span></span><br><span class="line">            left = getDecoratedLeft(getChildAt(<span class="number">0</span>)!!)</span><br><span class="line">            curPos = getPosition(getChildAt(<span class="number">0</span>)!!)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        detachAndScrapAttachedViews(recycler)</span><br><span class="line"></span><br><span class="line">        fill(recycler, state, curPos, left, paddingStart + getAvailableSpace(), <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollHorizontallyBy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        dx: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        state: <span class="type">RecyclerView</span>.<span class="type">State</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> resDx = calculateOffset(recycler, state, dx)</span><br><span class="line">        <span class="keyword">if</span> (resDx == <span class="number">0</span> || itemCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resDx</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> d = abs(resDx)</span><br><span class="line">        <span class="keyword">if</span> (resDx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> anchorView = getChildAt(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">val</span> anchorPos = getPosition(anchorView!!)</span><br><span class="line">            <span class="keyword">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class="line"></span><br><span class="line">            detachAndScrapAttachedViews(recycler)</span><br><span class="line"></span><br><span class="line">            fill(recycler, state, anchorPos, anchorLeft - d, getAvailableSpace() + paddingStart, <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> anchorView = getChildAt(childCount - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> anchorPos = getPosition(anchorView!!)</span><br><span class="line">            <span class="keyword">val</span> anchorRight = getDecoratedRight(anchorView)</span><br><span class="line"></span><br><span class="line">            detachAndScrapAttachedViews(recycler)</span><br><span class="line"></span><br><span class="line">            fill(recycler, state, anchorPos, paddingLeft, anchorRight + d, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recycler(recycler, state, resDx)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resDx</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateOffset</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>, dx: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (childCount == <span class="number">0</span> || dx == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> fillPos = RecyclerView.NO_POSITION</span><br><span class="line">        <span class="keyword">val</span> d = abs(dx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> firstView = getChildAt(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">val</span> firstPos = getPosition(firstView!!)</span><br><span class="line">            <span class="keyword">val</span> firstLeft = getDecoratedLeft(firstView)</span><br><span class="line"></span><br><span class="line">            fillPos = firstPos - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fillPos &lt; <span class="number">0</span> &amp;&amp; firstLeft + d &gt; paddingStart) &#123;</span><br><span class="line">                <span class="keyword">return</span> firstLeft - paddingStart</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (firstLeft + d &lt; paddingStart) &#123;</span><br><span class="line">                <span class="keyword">return</span> dx</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> lastView = getChildAt(childCount - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> lastPos = getPosition(lastView!!)</span><br><span class="line">            <span class="keyword">val</span> lastRight = getDecoratedRight(lastView)</span><br><span class="line"></span><br><span class="line">            fillPos = lastPos + <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> endEdge = getAvailableSpace() + paddingStart</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fillPos &gt;= itemCount &amp;&amp; lastRight - d &lt; endEdge) &#123;</span><br><span class="line">                <span class="keyword">return</span> lastRight - endEdge</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lastRight - d &gt; endEdge) &#123;</span><br><span class="line">                <span class="keyword">return</span> dx</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fill</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     anchorIndex: <span class="type">Int</span>, anchorLeft: <span class="type">Int</span>, anchorRight: <span class="type">Int</span>, isLTR: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> availableSpace = anchorRight - anchorLeft</span><br><span class="line">        <span class="keyword">var</span> fillPos = anchorIndex</span><br><span class="line">        <span class="keyword">var</span> left = anchorLeft</span><br><span class="line">        <span class="keyword">var</span> right = anchorRight</span><br><span class="line">        <span class="keyword">val</span> top = paddingTop</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (availableSpace &gt; <span class="number">0</span> &amp;&amp; fillPos &gt;= <span class="number">0</span> &amp;&amp; fillPos &lt; state.itemCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> view = recycler.getViewForPosition(fillPos)</span><br><span class="line">            <span class="keyword">if</span> (isLTR) &#123;</span><br><span class="line">                addView(view)</span><br><span class="line">                measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                right = left + getDecoratedMeasuredWidth(view)</span><br><span class="line">                <span class="keyword">val</span> bottom = top + getDecoratedMeasuredHeight(view)</span><br><span class="line">                layoutDecoratedWithMargins(view, left, top, right, bottom)</span><br><span class="line">                fillPos++</span><br><span class="line">                left = right</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addView(view, <span class="number">0</span>)</span><br><span class="line">                measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                left = right - getDecoratedMeasuredWidth(view)</span><br><span class="line">                <span class="keyword">val</span> bottom = top + getDecoratedMeasuredHeight(view)</span><br><span class="line">                layoutDecoratedWithMargins(view, left, top, right, bottom)</span><br><span class="line">                fillPos--</span><br><span class="line">                right = left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            availableSpace -= getDecoratedMeasuredWidth(view)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recycler</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>, dx: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//要回收View的集合，暂存</span></span><br><span class="line">        <span class="keyword">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dx&gt;0就是手指从右滑向左，所以要回收前面的children</span></span><br><span class="line">        <span class="keyword">if</span> (dx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">                <span class="keyword">val</span> child = getChildAt(i)!!</span><br><span class="line">                <span class="keyword">val</span> right = getDecoratedRight(child)</span><br><span class="line">                <span class="comment">//itemView的right&lt;0就是要超出屏幕要回收View</span></span><br><span class="line">                <span class="keyword">if</span> (right &gt; paddingStart) <span class="keyword">break</span></span><br><span class="line">                recycleViews.add(child)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//dx&lt;0就是手指从左滑向右，所以要回收后面的children</span></span><br><span class="line">        <span class="keyword">if</span> (dx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> childCount - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> child = getChildAt(i)!!</span><br><span class="line">                <span class="keyword">val</span> left = getDecoratedLeft(child)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//itemView的left&gt;recyclerView.width就是要超出屏幕要回收View</span></span><br><span class="line">                <span class="keyword">if</span> (left &lt; getAvailableSpace() + paddingStart) <span class="keyword">break</span></span><br><span class="line">                recycleViews.add(child)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//真正把View移除掉</span></span><br><span class="line">        <span class="keyword">for</span> (view <span class="keyword">in</span> recycleViews) &#123;</span><br><span class="line">            removeAndRecycleView(view, recycler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAvailableSpace</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width - paddingStart - paddingEnd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LayoutManager-的常用方法&quot;&gt;&lt;a href=&quot;#LayoutManager-的常用方法&quot; class=&quot;headerlink&quot; title=&quot;LayoutManager 的常用方法&quot;&gt;&lt;/a&gt;LayoutManager 的常用方法&lt;/h1&gt;&lt;h3 id=&quot;generateDefaultLayoutParams&quot;&gt;&lt;a href=&quot;#generateDefaultLayoutParams&quot; class=&quot;headerlink&quot; title=&quot;generateDefaultLayoutParams&quot;&gt;&lt;/a&gt;generateDefaultLayoutParams&lt;/h3&gt;
    
    </summary>
    
    
      <category term="RecyclerView" scheme="http://yoursite.com/tags/RecyclerView/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>redux源码</title>
    <link href="http://yoursite.com/2021/01/24/Flutter/redux%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2021/01/24/Flutter/redux源码/</id>
    <published>2021-01-24T13:40:51.000Z</published>
    <updated>2021-10-03T01:57:41.031Z</updated>
    
    <content type="html"><![CDATA[<p>Redux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux</p><a id="more"></a><h1 id="被观察者-Store-State"><a href="#被观察者-Store-State" class="headerlink" title="被观察者 Store/State"></a>被观察者 Store/State</h1><p>被观察者 明显是 Store 和 State 。 State 是状态的 model类 。 Store 是 State 的持有者。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span>&lt;<span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  Reducer&lt;State&gt; reducer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;State&gt; _changeController;</span><br><span class="line">  State _state;</span><br><span class="line">  <span class="built_in">List</span>&lt;NextDispatcher&gt; _dispatchers;</span><br><span class="line"></span><br><span class="line">  Store(</span><br><span class="line">    <span class="keyword">this</span>.reducer, &#123;</span><br><span class="line">    State initialState,</span><br><span class="line">    <span class="built_in">List</span>&lt;Middleware&lt;State&gt;&gt; middleware = <span class="keyword">const</span> [],</span><br><span class="line">    <span class="built_in">bool</span> syncStream = <span class="keyword">false</span>,</span><br><span class="line">    <span class="built_in">bool</span> distinct = <span class="keyword">false</span>,</span><br><span class="line">  &#125;) : _changeController = StreamController.broadcast(<span class="keyword">sync</span>: syncStream) &#123;</span><br><span class="line">    _state = initialState;</span><br><span class="line">    _dispatchers = _createDispatchers(</span><br><span class="line">      middleware,</span><br><span class="line">      _createReduceAndNotify(distinct),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NextDispatcher _createReduceAndNotify(<span class="built_in">bool</span> distinct) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">dynamic</span> action) &#123;</span><br><span class="line">      <span class="keyword">final</span> state = reducer(_state, action);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (distinct &amp;&amp; state == _state) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      _state = state;</span><br><span class="line">      _changeController.add(state);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dynamic</span> dispatch(<span class="keyword">dynamic</span> action) &#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatchers[<span class="number">0</span>](action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Stream&lt;State&gt; <span class="keyword">get</span> onChange =&gt; _changeController.stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个 Store 创建时，会实例化一个 _changeController ，并将 middleware 和 reducer 打包合并成 _dispatchers 集合。<br>注意看 _createReduceAndNotify 方法， 当每一个 action 发送到 Store 时，会交给 reducer 处理，并将新的 state 给 add 到 _changeController 里。这样就完成了状态的更新。。</p><p>是不是很简单。。。</p><h1 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h1><p>Redux 里观察者是 StoreConnector 。<br>但是得先提一下 StoreProvider ， StoreProvider 是初始化和存储 Store 的 Widget 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoreProvider</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Store&lt;S&gt; _store;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Create a [StoreProvider] by passing in the required [store] and [child]</span></span><br><span class="line">  <span class="comment">/// parameters.</span></span><br><span class="line">  <span class="keyword">const</span> StoreProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Store&lt;S&gt; store,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(store != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">assert</span>(child != <span class="keyword">null</span>),</span><br><span class="line">        _store = store,</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Store&lt;S&gt; of&lt;S&gt;(BuildContext context, &#123;<span class="built_in">bool</span> listen = <span class="keyword">true</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;StoreProvider&lt;S&gt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> provider = (listen</span><br><span class="line">        ? context.inheritFromWidgetOfExactType(type)</span><br><span class="line">        : context</span><br><span class="line">            .ancestorInheritedElementForWidgetOfExactType(type)</span><br><span class="line">            ?.widget) <span class="keyword">as</span> StoreProvider&lt;S&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (provider == <span class="keyword">null</span>) <span class="keyword">throw</span> StoreProviderError(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> provider._store;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Workaround to capture generics</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(StoreProvider&lt;S&gt; oldWidget) =&gt;</span><br><span class="line">      _store != oldWidget._store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StoreProvider 也很简单，就是一个典型的 InheritedWidget 。</p><p>现在来看 StoreConnector ，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoreConnector</span>&lt;<span class="title">S</span>, <span class="title">ViewModel</span>&gt; <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StoreConnector(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.converter,</span><br><span class="line">    <span class="keyword">this</span>.distinct = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.onInit,</span><br><span class="line">    <span class="keyword">this</span>.onDispose,</span><br><span class="line">    <span class="keyword">this</span>.rebuildOnChange = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.ignoreChange,</span><br><span class="line">    <span class="keyword">this</span>.onWillChange,</span><br><span class="line">    <span class="keyword">this</span>.onDidChange,</span><br><span class="line">    <span class="keyword">this</span>.onInitialBuild,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">assert</span>(converter != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> _StoreStreamListener&lt;S, ViewModel&gt;(</span><br><span class="line">      store: StoreProvider.of&lt;S&gt;(context),</span><br><span class="line">      builder: builder,</span><br><span class="line">      converter: converter,</span><br><span class="line">      distinct: distinct,</span><br><span class="line">      onInit: onInit,</span><br><span class="line">      onDispose: onDispose,</span><br><span class="line">      rebuildOnChange: rebuildOnChange,</span><br><span class="line">      ignoreChange: ignoreChange,</span><br><span class="line">      onWillChange: onWillChange,</span><br><span class="line">      onDidChange: onDidChange,</span><br><span class="line">      onInitialBuild: onInitialBuild,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，StoreConnector 只是一个壳，实际的工作者是 _StoreStreamListener 。 StoreConnect 唯一做的工作就是调用 <code>StoreProvider.of&lt;S&gt;(context)</code> 给 _StoreStreamListener 的 store 赋值。</p><p>_StoreStreamListener 是一个 StatefulWidget</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StoreStreamListenerState</span>&lt;<span class="title">S</span>, <span class="title">ViewModel</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_StoreStreamListener</span>&lt;<span class="title">S</span>, <span class="title">ViewModel</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    latestValue = widget.converter(widget.store);</span><br><span class="line">    _createStream();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> widget.rebuildOnChange</span><br><span class="line">        ? StreamBuilder&lt;ViewModel&gt;(</span><br><span class="line">            stream: stream,</span><br><span class="line">            builder: (context, snapshot) =&gt; widget.builder(</span><br><span class="line">              context,</span><br><span class="line">              latestValue,</span><br><span class="line">            ),</span><br><span class="line">          )</span><br><span class="line">        : widget.builder(context, latestValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _createStream() &#123;</span><br><span class="line">    stream = widget.store.onChange</span><br><span class="line">        .where(_ignoreChange)</span><br><span class="line">        .map(_mapConverter)</span><br><span class="line">        .where(_whereDistinct)</span><br><span class="line">        .transform(StreamTransformer.fromHandlers(handleData: _handleChange));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ViewModel _mapConverter(S state) &#123;</span><br><span class="line">    <span class="keyword">return</span> widget.converter(widget.store);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _whereDistinct(ViewModel vm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (widget.distinct) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm != latestValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleChange(ViewModel vm, EventSink&lt;ViewModel&gt; sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">    latestValue = vm;</span><br><span class="line">    ...</span><br><span class="line">    sink.add(vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 build 方法中 widget.rebuildOnChange 默认为 true 。<br>StreamBuilder 将 stream 转化为 widget 。<br>stream 就是对 widget.store.onChange (Store 里的 _changeController) 的监听。</p><p>需要说明的是， StoreConnector 只是在 Flutter Framework 基础上添加的额外的监听机制。<br>之前自己一直有个误区： 当 StoreConnector 的外部 Widget 执行 rebuild 之后， StoreConnector 可以控制 child 不 rebuild ，只要 vm 没有发生改变。<br>这显然不正确。有空可以看看 StreamBuilder 的源码。</p><h1 id="Action-事件的执行"><a href="#Action-事件的执行" class="headerlink" title="Action 事件的执行"></a>Action 事件的执行</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">dynamic</span> dispatch(<span class="keyword">dynamic</span> action) &#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatchers[<span class="number">0</span>](action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。很简单， Store.dispath 从 _dispatchers 的第一个位置开始分发事件。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
</feed>
