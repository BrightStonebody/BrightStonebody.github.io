<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BrightStone</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-10-16T16:24:45.528Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BrightStone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bitmap相关</title>
    <link href="http://yoursite.com/2022/10/16/Bitmap%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2022/10/16/Bitmap相关/</id>
    <published>2022-10-16T15:40:15.000Z</published>
    <updated>2022-10-16T16:24:45.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-实现圆角"><a href="#1-实现圆角" class="headerlink" title="1. 实现圆角"></a>1. 实现圆角</h2><ol><li><p>使用ClipPath先绘制圆角的path，然后再裁剪</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    clipPath.reset();</span><br><span class="line">    rectF.set(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">    clipPath.addRoundRect(rectF, radius, radius, Path.Direction.CW);</span><br><span class="line">    <span class="comment">// int save = canvas.save();</span></span><br><span class="line">    canvas.clipPath(clipPath);</span><br><span class="line">    canvas.drawRect(rectF, paint);</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">    <span class="comment">// canvas.restoreToCount(save);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));<br>paint设置Xfermode取交集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">paint.setAntiAlias(<span class="keyword">true</span>);</span><br><span class="line">Bitmap target = Bitmap.createBitmap(width, height, Config.ARGB_8888);</span><br><span class="line">Canvas canvas = <span class="keyword">new</span> Canvas(target);</span><br><span class="line">RectF rect = <span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"><span class="comment">// 设置圆形</span></span><br><span class="line"><span class="comment">// canvas.drawCircle(width / 2, height / 2, Math.min(width, height) / 2, paint);</span></span><br><span class="line"><span class="comment">// 设置圆角</span></span><br><span class="line">canvas.drawRoundRect(rect, mRadius, mRadius, paint);</span><br><span class="line"><span class="comment">// 核心代码取两个图片的交集部分</span></span><br><span class="line">paint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</span><br><span class="line">canvas.drawBitmap(source, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line"><span class="keyword">return</span> target;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><h2 id="2-bitmap加载避免oom"><a href="#2-bitmap加载避免oom" class="headerlink" title="2. bitmap加载避免oom"></a>2. bitmap加载避免oom</h2><ol><li>inJustDecodeBounds<br>BitmapFactory.Options#inJustDecodeBounds 可以不将图片加载到内存，获取图片的宽高</li><li>inSampleSize 采样率压缩</li><li>options.inPreferredConfig = Bitmap.Config.RGB_565<br>使用565减少单个像素的内存占用</li><li>BitmapRegionDecoder 读取图片文件的一个区域<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BitmapRegionDecoder bitmapRegionDecoder = BitmapRegionDecoder</span><br><span class="line">        .newInstance(inputStream, <span class="keyword">false</span>);</span><br><span class="line">Bitmap bitmap = bitmapRegionDecoder.decodeRegion(</span><br><span class="line">        <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">938</span>, <span class="number">938</span>),   <span class="comment">//解码区域</span></span><br><span class="line">        <span class="keyword">null</span>);  <span class="comment">//解码选项 BitmapFactory.Options 类型</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-实现圆角&quot;&gt;&lt;a href=&quot;#1-实现圆角&quot; class=&quot;headerlink&quot; title=&quot;1. 实现圆角&quot;&gt;&lt;/a&gt;1. 实现圆角&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用ClipPath先绘制圆角的path，然后再裁剪&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDraw&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Canvas canvas)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    clipPath.reset();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rectF.set(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, getWidth(), getHeight());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    clipPath.addRoundRect(rectF, radius, radius, Path.Direction.CW);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// int save = canvas.save();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    canvas.clipPath(clipPath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    canvas.drawRect(rectF, paint);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onDraw(canvas);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// canvas.restoreToCount(save);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));&lt;br&gt;paint设置Xfermode取交集。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Paint paint = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Paint();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;paint.setAntiAlias(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bitmap target = Bitmap.createBitmap(width, height, Config.ARGB_8888);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Canvas canvas = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Canvas(target);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RectF rect = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RectF(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, width, height);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 设置圆形&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// canvas.drawCircle(width / 2, height / 2, Math.min(width, height) / 2, paint);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 设置圆角&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;canvas.drawRoundRect(rect, mRadius, mRadius, paint);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 核心代码取两个图片的交集部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;paint.setXfermode(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PorterDuffXfermode(PorterDuff.Mode.SRC_IN));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;canvas.drawBitmap(source, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, paint);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; target;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>包大小优化-概述</title>
    <link href="http://yoursite.com/2022/10/16/Android/%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96-%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2022/10/16/Android/包大小优化-概述/</id>
    <published>2022-10-16T15:21:06.000Z</published>
    <updated>2022-10-16T15:29:50.957Z</updated>
    
    <content type="html"><![CDATA[<ol><li>代码混淆</li><li>资源压缩、资源混淆<br>图片资源本身变小，resources.arsc 文件变小</li><li>图片资源使用svg或者webp格式</li><li>语言包优化，去除无用的语言包</li><li>Dex分包优化<br>跨Dex的调用会增加很多冗余标记信息，使用工具，尽量将有调用关系的类和方法分配到同一个 Dex 中，可以减小Dex文件的体积。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;代码混淆&lt;/li&gt;
&lt;li&gt;资源压缩、资源混淆&lt;br&gt;图片资源本身变小，resources.arsc 文件变小&lt;/li&gt;
&lt;li&gt;图片资源使用svg或者webp格式&lt;/li&gt;
&lt;li&gt;语言包优化，去除无用的语言包&lt;/li&gt;
&lt;li&gt;Dex分包优化&lt;br&gt;跨Dex
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Coordinatorlayout.Behavior使用</title>
    <link href="http://yoursite.com/2022/10/08/Android/Coordinatorlayout-Behavior%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2022/10/08/Android/Coordinatorlayout-Behavior使用/</id>
    <published>2022-10-08T10:17:53.000Z</published>
    <updated>2022-10-08T10:30:27.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Behavior-的测量和布局"><a href="#Behavior-的测量和布局" class="headerlink" title="Behavior 的测量和布局"></a>Behavior 的测量和布局</h2><p>Behavior有 onMeasureChild , onLayoutChild 。 Coordinatorlayout 在执行 onMeasureChild 和 onLayoutChild 之前会先判断 behavior 是否有重写对应的方法并返回true。<br>如果返回true，则表示 behavior 接管了这个child的测量或布局，跳过该child。</p><a id="more"></a><h2 id="Behavior-的普通触摸事件"><a href="#Behavior-的普通触摸事件" class="headerlink" title="Behavior 的普通触摸事件"></a>Behavior 的普通触摸事件</h2><p>onInterceptTouchEvent , onTouchEvent 。 和 onMeasureChild , onLayoutChild 类似。</p><h2 id="Behavior-实现嵌套滚动机制"><a href="#Behavior-实现嵌套滚动机制" class="headerlink" title="Behavior 实现嵌套滚动机制"></a>Behavior 实现嵌套滚动机制</h2><p>和正常的 NestedScroll 机制基本一致，api一一对应。</p><h2 id="Behavior-的-layoutDependsOn-onDependentViewChanged-onDependentViewRemoved"><a href="#Behavior-的-layoutDependsOn-onDependentViewChanged-onDependentViewRemoved" class="headerlink" title="Behavior 的 layoutDependsOn + onDependentViewChanged + onDependentViewRemoved"></a>Behavior 的 layoutDependsOn + onDependentViewChanged + onDependentViewRemoved</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * child是否要依赖dependency</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent     CoordinatorLayout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child      该Behavior对应的那个View</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dependency 要检查的View(child是否要依赖这个dependency)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 依赖, false 不依赖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在layoutDependsOn返回true的基础上之后，及时报告dependency的状态变化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent     CoordinatorLayout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child      该Behavior对应的那个View</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dependency child依赖dependency</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 处理了, false  没处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在layoutDependsOn返回true的基础上之后，报告dependency被移除了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent     CoordinatorLayout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> child      该Behavior对应的那个View</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dependency child依赖dependency</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDependentViewRemoved</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Behavior-的测量和布局&quot;&gt;&lt;a href=&quot;#Behavior-的测量和布局&quot; class=&quot;headerlink&quot; title=&quot;Behavior 的测量和布局&quot;&gt;&lt;/a&gt;Behavior 的测量和布局&lt;/h2&gt;&lt;p&gt;Behavior有 onMeasureChild , onLayoutChild 。 Coordinatorlayout 在执行 onMeasureChild 和 onLayoutChild 之前会先判断 behavior 是否有重写对应的方法并返回true。&lt;br&gt;如果返回true，则表示 behavior 接管了这个child的测量或布局，跳过该child。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coordinatorlayout" scheme="http://yoursite.com/tags/Coordinatorlayout/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2022/09/12/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2022/09/12/Java/线程池/</id>
    <published>2022-09-12T07:48:02.000Z</published>
    <updated>2022-09-13T14:27:45.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> corePoolSize,       // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,    // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime,     // 超时时间</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,          // 时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,  // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory,        // 线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">    RejectedExecutionHandler handler    // 拒绝策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>workCount 记录了运行中的线程数</p><ol><li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li><li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li><li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li></ol><h2 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h2><ul><li><p>Executors.newFixedThreadPool(int)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Executors.newCachedThreadPool()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这类线程池比较适合执行大量的耗时较少的任务。当整个线程池都处于闲置状态时，线程池中的线程都会超时而被停止这个时候CachethreadPool之中实际上是没有任何线程的。它几乎不占任何系统资源。</p><ul><li>Executors.newScheduledThreadPool(int corePoolSize)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>他的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收，ScheduledThreadPool这类线程池主要用于执行定时任务和具有固定周期的重复任务。</p><ul><li>Executors.newSingleThreadExecutor()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       <span class="comment">// 当前线程数小于 核心线程数 ，创建线程 Worker </span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">       <span class="comment">// 先尝试掺入到阻塞队列中</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 阻塞队列满了再尝试添加核心线程之外的新线程</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试创建新线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 检查是否超出最大数量限制，超出直接return false</span></span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start(); <span class="comment">// 启动线程</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Worker.run<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     runWorker(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这是一个循环，防止线程退出，多个task复用线程</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; <span class="comment">// 执行firTask或者从 阻塞队列中获取task</span></span><br><span class="line">            w.lock();</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  是否执行超时检查</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : <span class="comment">// 尝试从阻塞队列中获取任务，超时时间为 keepAliveTime</span></span><br><span class="line">                workQueue.take(); <span class="comment">// 直接获取task</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; corePoolSize,       // 核心线程数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maximumPoolSize,    // 最大线程数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; keepAliveTime,     // 超时时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    TimeUnit unit,          // 时间单位&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,  // 阻塞队列&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    ThreadFactory threadFactory,        // 线程工厂&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    RejectedExecutionHandler handler    // 拒绝策略&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>探究: AGP编译时svg资源自动生成png</title>
    <link href="http://yoursite.com/2022/08/28/Android/gradle/%E6%8E%A2%E7%A9%B6-AGP%E7%BC%96%E8%AF%91%E6%97%B6svg%E8%B5%84%E6%BA%90%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90png/"/>
    <id>http://yoursite.com/2022/08/28/Android/gradle/探究-AGP编译时svg资源自动生成png/</id>
    <published>2022-08-28T06:21:50.000Z</published>
    <updated>2022-10-16T07:32:07.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>当安卓工程的minSdk&lt;24时，项目中的svg资源如果使用到了有兼容问题的属性，同时module的 vectorDrawables.useSupportLibrary 开关为false，会自动在编译打包过程中生成png图片来解决兼容性问题。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        vectorDrawables.useSupportLibrary = <span class="keyword">false</span> </span><br><span class="line">        vectorDrawables.generatedDensities = [<span class="string">"xxhdpi"</span>] <span class="comment">// 设置只在drawable-xxhdpi目录下的生成png图片，如果不设置，最终的apk会在每一个drawable目录下有一个png</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这样兼容性的问题就解决了，但是，生成了很多冗余的png图片。本来我们使用svg就是为了缩小包体积，现在反而包体积增大了。需要去探究一下，冗余的png图片是在哪里生成的，什么情况下额外生成png图片</p><h2 id="MergeResources"><a href="#MergeResources" class="headerlink" title="MergeResources"></a>MergeResources</h2><p>基于AGP 4.1.0 版本</p><p>通过ide的全局文本查找 useSupportLibrary 出现的地方，可以找到一个明显有嫌疑的类 MergeResources 。<br>这是编译打包过程中的一个task类，需要注意的是，在子module和app，这个task有所不同。它在子module的task-name是packageDebugResource ，在app的task-name是mergeDebugResource。同样，在子module和app，表现也有所不同。</p><p>先从doFullTaskAction方法看这个task的主流程：<br>伪代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFullTaskAction</span><span class="params">()</span> <span class="keyword">throws</span> IOException, JAXBException </span>&#123;</span><br><span class="line">    ResourcePreprocessor preprocessor = getPreprocessor(); <span class="comment">// 关键1</span></span><br><span class="line"></span><br><span class="line">    File destinationDir = getOutputDir().get().getAsFile(); </span><br><span class="line">    <span class="comment">// 资源merge的最终目录</span></span><br><span class="line">    <span class="comment">// build/intermediates/package_res</span></span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">//省略</span></span><br><span class="line">    <span class="comment">// 因为是全量，删除destinationDir的所有文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有资源目录</span></span><br><span class="line">    List&lt;ResourceSet&gt; resourceSets =</span><br><span class="line">            getConfiguredResourceSets(preprocessor, getAaptEnv().getOrNull());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// task 的核心类</span></span><br><span class="line">    ResourceMerger merger = <span class="keyword">new</span> ResourceMerger(getMinSdk().get());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 创建资源编译服务类</span></span><br><span class="line">            ResourceCompilationService resourceCompiler =</span><br><span class="line">                    getResourceProcessor(</span><br><span class="line">                            getProjectName(),</span><br><span class="line">                            getPath(),</span><br><span class="line">                            getAapt2FromMaven(),</span><br><span class="line">                            workerExecutorFacade,</span><br><span class="line">                            errorFormatMode,</span><br><span class="line">                            flags,</span><br><span class="line">                            processResources,</span><br><span class="line">                            useJvmResourceCompiler,</span><br><span class="line">                            getLogger(),</span><br><span class="line">                            getAapt2DaemonBuildService().get())) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ResourceSet resourceSet : resourceSets) &#123;</span><br><span class="line">            resourceSet.loadFromFiles(<span class="keyword">new</span> LoggerWrapper(getLogger())); <span class="comment">// 关键2</span></span><br><span class="line">            merger.addDataSet(resourceSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File publicFile =</span><br><span class="line">                getPublicFile().isPresent() ? getPublicFile().get().getAsFile() : <span class="keyword">null</span>;</span><br><span class="line">        MergedResourceWriter writer =</span><br><span class="line">                <span class="keyword">new</span> MergedResourceWriter(</span><br><span class="line">                        workerExecutorFacade,</span><br><span class="line">                        destinationDir,</span><br><span class="line">                        publicFile,</span><br><span class="line">                        mergingLog,</span><br><span class="line">                        preprocessor,</span><br><span class="line">                        resourceCompiler,</span><br><span class="line">                        getIncrementalFolder(),</span><br><span class="line">                        dataBindingLayoutProcessor,</span><br><span class="line">                        mergedNotCompiledResourcesOutputDirectory,</span><br><span class="line">                        pseudoLocalesEnabled,</span><br><span class="line">                        getCrunchPng());</span><br><span class="line"></span><br><span class="line">        merger.mergeData(writer, <span class="keyword">false</span>) <span class="comment">// 关键3</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关键1-ResourcePreprocessor"><a href="#关键1-ResourcePreprocessor" class="headerlink" title="关键1 ResourcePreprocessor"></a>关键1 ResourcePreprocessor</h3><p>getPreprocessor() 返回的是一个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePreprocessor</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回预处理需要生成的file集合</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">Collection&lt;File&gt; <span class="title">getFilesToBeGenerated</span><span class="params">(@NonNull File original)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 getFilesToBeGenerated 方法返回的file集合文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateFile</span><span class="params">(@NonNull File toBeGenerated, @NonNull File original)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它的实现类是 VectorDrawableRenderer ，看名字可以判定，这就是 svg-&gt;png 的实现类（罪魁祸首）。。。先寻找它被调用的地方。</p><h3 id="关键2-ResourceSet-loadFromFiles"><a href="#关键2-ResourceSet-loadFromFiles" class="headerlink" title="关键2 ResourceSet#loadFromFiles"></a>关键2 ResourceSet#loadFromFiles</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ResourceSet resourceSet : resourceSets) &#123;</span><br><span class="line">    resourceSet.loadFromFiles(<span class="keyword">new</span> LoggerWrapper(getLogger())); <span class="comment">// 关键2</span></span><br><span class="line">    merger.addDataSet(resourceSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resourceSets 是一个res目录的集合。<br>在子module，会包含工程里module的src/main/res目录；（断点看，似乎有用的也就只有这个）<br>在app，会包含 app 的 src/main/res ，所有子module的 build/intermediates/package_res ，以及一些安卓官方库的资源目录<br>从 resourceSet.loadFromFiles 一直追，会到 ResourceSet#getResourceMergerItemsForGeneratedFiles 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ResourceMergerItem&gt; <span class="title">getResourceMergerItemsForGeneratedFiles</span><span class="params">(@NonNull File file)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MergingException </span>&#123;</span><br><span class="line">    Collection&lt;File&gt; filesToBeGenerated;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        filesToBeGenerated = mPreprocessor.getFilesToBeGenerated(file); <span class="comment">// 关键</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MergingException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;ResourceMergerItem&gt; resourceItems = <span class="keyword">new</span> ArrayList&lt;&gt;(filesToBeGenerated.size());</span><br><span class="line">    <span class="keyword">for</span> (File generatedFile : filesToBeGenerated) &#123;</span><br><span class="line">        FolderData generatedFileFolderData =</span><br><span class="line">                getFolderData(generatedFile.getParentFile());</span><br><span class="line">        resourceItems.add(</span><br><span class="line">                <span class="keyword">new</span> GeneratedResourceMergerItem(</span><br><span class="line">                        getNameForFile(generatedFile),</span><br><span class="line">                        mNamespace,</span><br><span class="line">                        generatedFile,</span><br><span class="line">                        generatedFileFolderData.type,</span><br><span class="line">                        generatedFileFolderData.folderConfiguration.getQualifierString(),</span><br><span class="line">                        mLibraryName)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resourceItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 mPreprocessor 就是 VectorDrawableRenderer ，<code>mPreprocessor.getFilesToBeGenerated(file)</code> 会返回 svg 资源文件和png兼容资源文件的集合。里面不详细看了，主要是根据useSupportLibrary 和generatedDensities 这两个gradle参数生成png文件的绝对路径。<br>这里的png路径是 build/generated/res/pngs/debug 。 这和 MergeResources task 的目标路径并不相同。<br>getResourceMergerItemsForGeneratedFiles 方法最终会将每一个资源文件抽象为ResourceMergerItem ，并返回他们的集合。</p><h3 id="关键3-merger-mergeData"><a href="#关键3-merger-mergeData" class="headerlink" title="关键3 merger#mergeData"></a>关键3 merger#mergeData</h3><p>ResourceMerger#mergeData 会调用到父类的 DataMerger#mergeData<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeData</span><span class="params">(@NonNull MergeConsumer&lt;I&gt; consumer, <span class="keyword">boolean</span> doCleanUp)</span></span>&#123;</span><br><span class="line">    consumer.start(mFactory);</span><br><span class="line">    <span class="keyword">for</span>(...) &#123;</span><br><span class="line">        ... <span class="comment">// 忽略 merge 的过程</span></span><br><span class="line">        consumer.addItem(toWrite)</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 consumer 是 MergedResourceWriter 实例。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(@NonNull <span class="keyword">final</span> ResourceMergerItem item)</span> <span class="keyword">throws</span> ConsumerException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ResourceFile.FileType type = item.getSourceType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ResourceFile.FileType.XML_VALUES) &#123;</span><br><span class="line">        mValuesResMap.put(item.getQualifiers(), item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.isTouched()) &#123;</span><br><span class="line">            File file = item.getFile();</span><br><span class="line">            String folderName = getFolderName(item);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (type == DataFile.FileType.GENERATED_FILES) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    FileGenerationParameters workItem =</span><br><span class="line">                            <span class="keyword">new</span> FileGenerationParameters(item, mPreprocessor);</span><br><span class="line">                    <span class="keyword">if</span> (workItem.resourceItem.getSourceFile() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 这个action是生成png文件的地方</span></span><br><span class="line">                        getExecutor().submit(FileGenerationWorkAction.class, workItem);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConsumerException(e, item.getSourceFile().getFile());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加资源编译 Request</span></span><br><span class="line">            mCompileResourceRequests.add(</span><br><span class="line">                    <span class="keyword">new</span> CompileResourceRequest(</span><br><span class="line">                            file, getRootFolder(), folderName, item.mIsFromDependency));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个 ResourceFile.FileType 枚举值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileType &#123;</span><br><span class="line">    SINGLE_FILE,   <span class="comment">// 表示项目中工程目录 src/main/res 原本就有的资源文件</span></span><br><span class="line">    GENERATED_FILES,  <span class="comment">// 需要生成的资源文件，生成的目录在 build/generated/res/pngs/debug </span></span><br><span class="line">    XML_VALUES  <span class="comment">// values文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是 GENERATED_FILES 会生成新文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGenerationWorkAction</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileGenerationParameters workItem;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileGenerationWorkAction</span><span class="params">(FileGenerationParameters workItem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workItem = workItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            workItem.resourcePreprocessor.generateFile(</span><br><span class="line">                    workItem.resourceItem.getFile(),</span><br><span class="line">                    workItem.resourceItem.getSourceFile().getFile());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>workItem.resourcePreprocessor 是 VectorDrawableRenderer 对象，这样生成了png文件的地方也找到了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateFile</span><span class="params">(@NonNull File toBeGenerated, @NonNull File original)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Files.createParentDirs(toBeGenerated);</span><br><span class="line">    <span class="keyword">if</span> (isXml(toBeGenerated)) &#123;</span><br><span class="line">        <span class="comment">// 目标文件如果是xml文件，直接拷贝即可</span></span><br><span class="line">        Files.copy(original, toBeGenerated);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在对应 density 的目录下生成png文件</span></span><br><span class="line">        FolderConfiguration folderConfiguration = getFolderConfiguration(toBeGenerated);</span><br><span class="line">        Density density = folderConfiguration.getDensityQualifier().getValue();</span><br><span class="line">        <span class="keyword">float</span> scaleFactor = density.getDpiValue() / (<span class="keyword">float</span>) Density.MEDIUM.getDpiValue();</span><br><span class="line">        <span class="keyword">if</span> (scaleFactor &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            scaleFactor = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        VdPreview.TargetSize imageSize = VdPreview.TargetSize.createFromScale(scaleFactor);</span><br><span class="line">        String xmlContent = Files.asCharSource(original, StandardCharsets.UTF_8).read();</span><br><span class="line">        BufferedImage image = VdPreview.getPreviewFromVectorXml(imageSize, xmlContent, <span class="keyword">null</span>);</span><br><span class="line">        ImageIO.write(image, <span class="string">"png"</span>, toBeGenerated);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>生成png文件的效果<br>工程module下有两个资源图片文件，一个是svg，一个是png。 svg图片会在 build/generated/res/pngs 下生成多个资源，工程原有的png则不会</li></ul><h3 id="编译资源"><a href="#编译资源" class="headerlink" title="编译资源"></a>编译资源</h3><p>再来看 ResourceMerger#mergeData，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeData</span><span class="params">(@NonNull MergeConsumer&lt;I&gt; consumer, <span class="keyword">boolean</span> doCleanUp)</span></span>&#123;</span><br><span class="line">    consumer.start(mFactory);</span><br><span class="line">    <span class="keyword">for</span>(...) &#123;</span><br><span class="line">        ... <span class="comment">// 忽略 merge 的过程</span></span><br><span class="line">        consumer.addItem(toWrite)</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后有一个consumer.end() </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> <span class="keyword">throws</span> ConsumerException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!mCompileResourceRequests.isEmpty()) &#123;</span><br><span class="line">        mResourceCompiler.submitCompile(</span><br><span class="line">            <span class="keyword">new</span> CompileResourceRequest(</span><br><span class="line">                    fileToCompile,</span><br><span class="line">                    request.getOutputDirectory(),</span><br><span class="line">                    request.getInputDirectoryName(),</span><br><span class="line">                    request.getInputFileIsFromDependency(),</span><br><span class="line">                    pseudoLocalesEnabled,</span><br><span class="line">                    crunchPng,</span><br><span class="line">                    ImmutableMap.of(),</span><br><span class="line">                    request.getInputFile()));</span><br><span class="line">        mCompiledFileMap.put(</span><br><span class="line">            fileToCompile.getAbsolutePath(),</span><br><span class="line">            mResourceCompiler.compileOutputFor(request).getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mResourceCompiler.submitCompile 正式提交编译。<br>mResourceCompiler 的实现在子module和app有所不同，<br>在module，实例是CopyToOutputDirectoryResourceCompilationService<br>在app，实例是 WorkerExecutorResourceCompilationService</p><ul><li>子module的资源 “编译”<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> CopyToOutputDirectoryResourceCompilationService : ResourceCompilationService &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">submitCompile</span><span class="params">(request: <span class="type">CompileResourceRequest</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">out</span> = compileOutputFor(request)</span><br><span class="line">        FileUtils.mkdirs(<span class="keyword">out</span>.parentFile)</span><br><span class="line">        FileUtils.copyFile(request.inputFile, <span class="keyword">out</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compileOutputFor</span><span class="params">(request: <span class="type">CompileResourceRequest</span>)</span></span>: File &#123;</span><br><span class="line">        <span class="keyword">val</span> parentDir = File(request.outputDirectory, request.inputDirectoryName)</span><br><span class="line">        <span class="keyword">return</span> File(parentDir, request.inputFile.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在子module比较简单，就是把 request 里的 inputFile 拷贝到目标目录。<br>如果是svg生成png的case，是 build/generated/res/pngs/ 文件拷贝到 build/intermediates/package_res/<br>如果是工程中的一般资源文件，是<code>src/main/res</code> 文件拷贝到 build/intermediates/package_res/</p><ul><li>app的资源编译<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerExecutorResourceCompilationService</span></span>(...) : ResourceCompilationService &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> requests: MutableList&lt;CompileResourceRequest&gt; = ArrayList()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">submitCompile</span><span class="params">(request: <span class="type">CompileResourceRequest</span>)</span></span> &#123;</span><br><span class="line">    requests.add(request)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">      <span class="keyword">val</span> bucketRequests = requests.filterIndexed &#123; i, _ -&gt;</span><br><span class="line">        i.rem(buckets) == bucket</span><br><span class="line">      &#125;</span><br><span class="line">      workerExecutor.submit(</span><br><span class="line">        Aapt2CompileRunnable::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>,<span class="type"></span></span></span><br><span class="line">        Aapt2CompileRunnable.Params(aapt2ServiceKey, bucketRequests, errorFormatMode, <span class="literal">true</span>)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在close方法遍历所有request，然后在Aapt2CompileRunnable进行资源编译。 输出路径是app/build/intermediates/res/merged/debug<br>对于appt2编译，我不是很了解，这里不详细说了。</p><h2 id="SVG-gt-PNG-的条件"><a href="#SVG-gt-PNG-的条件" class="headerlink" title="SVG -&gt; PNG 的条件"></a>SVG -&gt; PNG 的条件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorDrawableRenderer</span> <span class="keyword">implements</span> <span class="title">ResourcePreprocessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;File&gt; <span class="title">getFilesToBeGenerated</span><span class="params">(@NonNull File inputXmlFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FolderConfiguration originalConfiguration = getFolderConfiguration(inputXmlFile);</span><br><span class="line">        PreprocessingReason reason = getReasonForPreprocessing(inputXmlFile, originalConfiguration);</span><br><span class="line">        <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Collection&lt;File&gt; filesToBeGenerated = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        DensityQualifier densityQualifier = originalConfiguration.getDensityQualifier();</span><br><span class="line">        <span class="keyword">boolean</span> validDensityQualifier = ResourceQualifier.isValid(densityQualifier);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (mMinSdk &lt; reason.getSdkThreshold() &amp;&amp; mDensities.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Density density : mDensities) &#123;</span><br><span class="line">               FolderConfiguration newConfiguration =</span><br><span class="line">                                FolderConfiguration.copyOf(originalConfiguration);</span><br><span class="line">               newConfiguration.setDensityQualifier(<span class="keyword">new</span> DensityQualifier(density));</span><br><span class="line">               filesToBeGenerated.add(</span><br><span class="line">                   <span class="keyword">new</span> File(</span><br><span class="line">                       getDirectory(newConfiguration),</span><br><span class="line">                       inputXmlFile.getName().replace(<span class="string">".xml"</span>, <span class="string">".png"</span>))</span><br><span class="line">               );</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> filesToBeGenerated;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码省略了诸多逻辑，我们只看关心的部分。<br>首先去获取一个reason，如果reason为空，直接返回空集合。<br>如果 mMinSdk &lt; reason.getSdkThreshold() ，项目的minSdk小于 reason的sdk阈值，则往filesToBeGenerated添加一个png路径。所以要去看如何得到reason的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PreprocessingReason <span class="title">getReasonForPreprocessing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull File resourceFile, @NonNull FolderConfiguration folderConfig)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果开启了 supportLibraryIsUsed 直接返回null。 和「背景」中说的一致</span></span><br><span class="line">    <span class="keyword">if</span> (mSupportLibraryIsUsed) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果 minSdk 大于 GRADIENT_SUPPORT 的版本号，也直接返回null</span></span><br><span class="line">    <span class="comment">// PreprocessingReason.GRADIENT_SUPPORT 版本号是24。 </span></span><br><span class="line">    <span class="comment">// 即到了24版本开始就没有兼容性问题了。 minSdk &gt; 24 即无需处理</span></span><br><span class="line">    <span class="keyword">if</span> (mMinSdk &gt;= PreprocessingReason.GRADIENT_SUPPORT.getSdkThreshold()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isXml(resourceFile) || !isInDrawable(resourceFile)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> (InputStream stream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(resourceFile))) &#123;</span><br><span class="line">        XMLInputFactory factory = XMLInputFactory.newFactory();</span><br><span class="line">        XMLStreamReader xmlReader = factory.createXMLStreamReader(stream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始读取svg xml文件的内容，check每一个元素和属性</span></span><br><span class="line">        <span class="keyword">boolean</span> beforeFirstTag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (xmlReader.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> event = xmlReader.next();</span><br><span class="line">            <span class="keyword">if</span> (event == XMLStreamReader.START_ELEMENT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (beforeFirstTag) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!TAG_VECTOR.equals(xmlReader.getLocalName())) &#123;</span><br><span class="line">                        <span class="comment">// 如果不是 vector 直接不用check了</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    beforeFirstTag = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (TAG_GRADIENT.equals(xmlReader.getLocalName())) &#123;</span><br><span class="line">                        <span class="comment">// 找到 gradient 这个元素，返回一个reason</span></span><br><span class="line">                        <span class="comment">// GRADIENT_SUPPORT 的版本阈值是24</span></span><br><span class="line">                        <span class="keyword">return</span> PreprocessingReason.GRADIENT_SUPPORT;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> n = xmlReader.getAttributeCount();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        <span class="comment">// 找到 fillType 这个属性，返回一个reason 。 </span></span><br><span class="line">                        <span class="comment">// FILLTYPE_SUPPORT 的版本阈值是 24</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">"fillType"</span>.equals(xmlReader.getAttributeLocalName(i))</span><br><span class="line">                                &amp;&amp; NS_RESOURCES.equals(xmlReader.getAttributeNamespace(i))) &#123;</span><br><span class="line">                            <span class="keyword">return</span> PreprocessingReason.FILLTYPE_SUPPORT;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!beforeFirstTag &amp;&amp; mMinSdk &lt; PreprocessingReason.VECTOR_SUPPORT.getSdkThreshold()) &#123;</span><br><span class="line">            <span class="comment">// 判断是minSdk否是压根就不支持 vector ，返回一个reason</span></span><br><span class="line">            <span class="comment">// VECTOR_SUPPORT 的版本阈值是 21</span></span><br><span class="line">            <span class="keyword">return</span> PreprocessingReason.VECTOR_SUPPORT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (XMLStreamException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">                <span class="string">"Failed to parse resource file "</span> + resourceFile.getAbsolutePath(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，AGP 只会判断svg文件里的 gradient 和 fillType 这两个东西。<br>gradient是颜色渐变<br>fillType 专业性太强，搜了一圈看不懂，不知道是做什么的。。。<br>他们的版本号阈值都是24，svg文件中出现这两个东西，并且 minSdk &lt; 24 时就会触发 svg-&gt;png 的生成</p><h2 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理"></a>如何处理</h2><p>在我们的项目里，svg自动生成png的case太多了，大概接近300个资源图片。 需要去治理一波。<br>生成的png直接导致我们使用svg去减小包体积的初衷失去意义。<br>但是不能一个一个改，太费事。</p><p>有一个开源的 McImage 插件，作用是把项目中的所有资源转换成webp，我们可以模仿它</p><p>AGP提供了 variant.getAllRawAndroidResources().files 这个api，在app下使用，可以获取到所有的resource目录。 打印所有的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 子module的 build/intermediates/packaged_res 目录</span><br><span class="line">/Users/xx/PluginX/module_1/build/intermediates/packaged_res/debug</span><br><span class="line">// 依赖库的res目录</span><br><span class="line">/Users/xx/.gradle/caches/transforms-2/files-2.1/414fc23eb49f389f342a6e17218892be/appcompat-1.2.0/res</span><br><span class="line">/Users/xx/.gradle/caches/transforms-2/files-2.1/72202874f0ee490d85b35e8bc8155d2b/constraintlayout-1.1.3/res</span><br><span class="line">/Users/xx/.gradle/caches/transforms-2/files-2.1/52e4a4d01e3d8c6a6c3d516d66f6acc9/recyclerview-1.0.0/res</span><br><span class="line">/Users/xx/.gradle/caches/transforms-2/files-2.1/83248d60fee84d269b4d5ae691d6e421/jetified-appcompat-resources-1.2.0/res</span><br><span class="line">/Users/xx/.gradle/caches/transforms-2/files-2.1/5fddbd55bd0ad4a84e0959052d0c417d/coordinatorlayout-1.0.0/res</span><br><span class="line">/Users/xx/.gradle/caches/transforms-2/files-2.1/05736e5c1eb0ab8976aa5868fca67ffe/core-1.3.1/res</span><br></pre></td></tr></table></figure></p><p>结合上面 MergeResources 的分析。<br>子module会在 packageDebugResources 任务，把module所有资源汇总拷贝到 build/intermediates/packaged_res/<br>在app也能拿到所有子module汇总拷贝之后的这个目录。<br>可以在app的 mergeDebugResources 任务之前，插入一个我们自己的任务。<br>作用是收集 getAllRawAndroidResources().files 目录里的所有资源文件，查找删除同名的多余资源图片，如果存在xml后缀的svg资源和多个同名的png资源，只保留 xxhdpi 目录下的png图片资源。<br>实践来看，可行，没有报错，打出来的apk文件安装使用也都正常。 </p><p>TODO：是否可以在 mergeDebugResources 之后进行 hook ？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="http://www.youkmi.cn/2020/01/01/android-zhong-gradle-yuan-li-yi-ji-ji-zhi-shen-ru-fen-xi/" target="_blank" rel="noopener">Android中Gradle原理以及机制深入分析</a><br><a href="https://juejin.cn/post/7060337237761720334" target="_blank" rel="noopener">gradle编译打包过程分析之ProcessAndroidResources</a><br><a href="https://smallsoho.com/android/2017/04/07/McImage%E6%8F%92%E4%BB%B6%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">McImage插件解析（旧版本）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;headerlink&quot; title=&quot;背景：&quot;&gt;&lt;/a&gt;背景：&lt;/h2&gt;&lt;p&gt;当安卓工程的minSdk&amp;lt;24时，项目中的svg资源如果使用到了有兼容问题的属性，同时module的 vectorDrawables.useSupportLibrary 开关为false，会自动在编译打包过程中生成png图片来解决兼容性问题。&lt;br&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;android &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    defaultConfig &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vectorDrawables.useSupportLibrary = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vectorDrawables.generatedDensities = [&lt;span class=&quot;string&quot;&gt;&quot;xxhdpi&quot;&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;// 设置只在drawable-xxhdpi目录下的生成png图片，如果不设置，最终的apk会在每一个drawable目录下有一个png&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络相关知识点</title>
    <link href="http://yoursite.com/2022/08/27/Base/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2022/08/27/Base/网络相关知识点/</id>
    <published>2022-08-27T09:56:47.000Z</published>
    <updated>2022-09-24T09:14:51.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSI五层网络模型"><a href="#OSI五层网络模型" class="headerlink" title="OSI五层网络模型"></a>OSI五层网络模型</h2><ol><li>物理层<br>利用传输介质为数据提供物理连接，传输比特流。 wifi 、光纤 等</li><li>数据链路层<br>在两个相邻结点之间传送数据，传输数据帧</li><li>网络层<br>提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径。 IP协议</li><li>传输层<br>向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，负责向两个主机中进程之间的通信提供服务。 TCP ， UDP</li><li>应用层<br> 为用户提供的服务。 http，https 协议</li></ol><a id="more"></a><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><a href="https://segmentfault.com/a/1190000022144695" target="_blank" rel="noopener">面试准备 TCP 知识，看这一篇就够了</a></p><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client ---- SYN=1,seq=j ----------&gt; server</span><br><span class="line">client &lt;--- SYN=1,seq=k,ack=j+1 --- server</span><br><span class="line">client ---- ack=k+1 --------&gt; server</span><br></pre></td></tr></table></figure><p>为什么需要三次，而不是两次？<br>如果试了两次握手，client端第一次发送到服务端，服务端即会认为建立连接。但是网络是会延迟或丢包的，如果第一次发生了客户端的握手发生了延迟，客户端会超时重传，这样就有可能服务端收到多个建立连接的消息，导致连接建立多次。</p><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client ---- FIN=1,seq=x ----&gt; server</span><br><span class="line">client &lt;--- ack=x+1     ----- server</span><br><span class="line">client &lt;--------------------- server // 服务端传输剩余内容</span><br><span class="line">client &lt;--- FIN=1,seq=z ----&gt; server</span><br><span class="line">client ---- ack=z+1     ----&gt; server</span><br></pre></td></tr></table></figure><ol><li>客户端发送关闭连接的报文， FIN 标志位为1</li><li>服务端收到FIN后，发送确认报文</li><li>服务端继续发送剩余的报文，客户端继续接收剩余报文</li><li>服务端报文发送完毕，向客户端发送FIN报文</li><li>客户端向服务端发送确认报文，客户端等待一段时间后进入closed状态。 服务端收到确认报文即进入closed状态</li></ol><p><strong>为什么挥手要四次不是三次？</strong><br>因为客户端发起关闭连接报文时，服务端可能还有剩余的数据没有发送完毕。 要等待服务端将剩余的数据发送完毕。</p><p><strong>客户端收到FIN后为什么要等待一段时间在进入closed状态？</strong><br>因为客户端发送的确认报文有可能丢失，这样，服务端会重复发送FIN报文； 如果客户端收到FIN立即关闭，就无法处理服务端重复发送的FIN报文。</p><h3 id="和UDP相比，为什么TCP是可靠的"><a href="#和UDP相比，为什么TCP是可靠的" class="headerlink" title="和UDP相比，为什么TCP是可靠的"></a>和UDP相比，为什么TCP是可靠的</h3><p>TCP有超时重传机制。 当TCP报文发出，会启动计数器，等待接收端返回确认报文。如果长时间没有收到确认报文，会将报文重新发送</p><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="http版本迭代"><a href="#http版本迭代" class="headerlink" title="http版本迭代"></a>http版本迭代</h3><p><strong>http1.1</strong></p><ol><li><p>Connnection: Keep-Alive<br>复用tcp连接。 允许HTTP设备在事务处理结束之后将TCP连接保持在打开的状态，以便未来的HTTP请求重用现在的连接</p></li><li><p>支持只请求数据的一部分 range<br>RANGE:bytes=XXXX 表示要求服务器从文件 XXXX 字节处开始传送，断点续传</p></li></ol><p><strong>http2.0</strong></p><p>多路复用。<br>多个请求<strong>并行</strong>的复用一个连接。<br>和 keep-alive 的区别： http1.1 的复用是串行的，如果有一个请求耗时较长会阻塞。http2.0 是并行复用，不会阻塞</p><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client ---- 请求https连接  ----&gt; server</span><br><span class="line">client &lt;--- 公钥          ----&gt; server</span><br><span class="line">client ---- 生成秘钥，并用公钥加密</span><br><span class="line">client ---- 公钥加密后的秘钥 ---&gt; server</span><br><span class="line">       使用私钥解密，得到秘钥 ---- server</span><br><span class="line">client &lt;--- client 和 server使用秘钥通信 ---&gt; server // 对称加密</span><br></pre></td></tr></table></figure><h2 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h2><ol><li>get相对于post请求更安全，以为get请求的参数暴露在url上</li><li>get请求一般有长度限制，但是这并不是协议规定的长度限制。而是浏览器或服务器因为性能原因而做出的限制。</li><li>okhttp缓存的key是url。 而post请求包含了body。 所以okhttp只能缓存get请求。</li></ol><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket 支持客户端和服务端双向通信</p><h3 id="使用http协议建立连接"><a href="#使用http协议建立连接" class="headerlink" title="使用http协议建立连接"></a>使用http协议建立连接</h3><p>客户端发起协议升级请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http://127.0.0.1:3000</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==</span><br></pre></td></tr></table></figure><ul><li>Connection: Upgrade：<br>表示要升级协议</li><li>Upgrade: websocket：表示要升级到websocket协议。</li><li>Sec-WebSocket-Version: 13：表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</li><li>Sec-WebSocket-Key：与后面服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</li></ul><p>服务端返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=</span><br></pre></td></tr></table></figure><p>返回101状态码，表示WebSocket建立成功</p><h3 id="ping、pong"><a href="#ping、pong" class="headerlink" title="ping、pong"></a>ping、pong</h3><p>保持tcp连接不断开</p><h3 id="WebSocket-和-keep-alive-的区别"><a href="#WebSocket-和-keep-alive-的区别" class="headerlink" title="WebSocket 和 keep-alive 的区别"></a>WebSocket 和 keep-alive 的区别</h3><p>http 的 keep-alive 是为了复用tcp连接。 每一次http请求都必须发送完整的http报文。 只能由客户端发起请求，服务端被动响应。</p><p>WebSocket 的报文比http报文格式简单，支持服务端主动给客户端发消息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;OSI五层网络模型&quot;&gt;&lt;a href=&quot;#OSI五层网络模型&quot; class=&quot;headerlink&quot; title=&quot;OSI五层网络模型&quot;&gt;&lt;/a&gt;OSI五层网络模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;物理层&lt;br&gt;利用传输介质为数据提供物理连接，传输比特流。 wifi 、光纤 等&lt;/li&gt;
&lt;li&gt;数据链路层&lt;br&gt;在两个相邻结点之间传送数据，传输数据帧&lt;/li&gt;
&lt;li&gt;网络层&lt;br&gt;提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径。 IP协议&lt;/li&gt;
&lt;li&gt;传输层&lt;br&gt;向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，负责向两个主机中进程之间的通信提供服务。 TCP ， UDP&lt;/li&gt;
&lt;li&gt;应用层&lt;br&gt; 为用户提供的服务。 http，https 协议&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DecorView, Window, ViewRootImpl的关系</title>
    <link href="http://yoursite.com/2022/08/19/Android/Framework/DecorView-Window-ViewRootImpl%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2022/08/19/Android/Framework/DecorView-Window-ViewRootImpl的关系/</id>
    <published>2022-08-19T02:22:30.000Z</published>
    <updated>2022-08-31T16:18:29.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Window的创建"><a href="#Window的创建" class="headerlink" title="Window的创建"></a>Window的创建</h2><p>一个 activity 对应的是 PhoneWindow 。 创建的时机是在 attach </p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 PhoneWindow 的同时，会设置 WindowManager , WindowManager 是一个系统服务。 在app进程的代理类是 WindowManagerImpl， 但是 WindowManagerImpl 把实现委托给了 WindowManagerGlobal 。 </p><h2 id="DecorView-的创建"><a href="#DecorView-的创建" class="headerlink" title="DecorView 的创建"></a>DecorView 的创建</h2><p>DecorView的创建在 <code>activity.setContentView(int)</code> , 最终实现在 <code>PhoneWindow.setContentView(int)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mContentParent 是 android.R.id.content 的 view</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>); <span class="comment">// 实例化 DecorView </span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor); <span class="comment">// 返回 content 的view</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewRootImpl-的创建"><a href="#ViewRootImpl-的创建" class="headerlink" title="ViewRootImpl 的创建"></a>ViewRootImpl 的创建</h2><p>ViewRootImpl 的创建在 <code>ActivityThread#handleResumeActivity</code> 里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 activity#onResume</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> forwardBit = isForward</span><br><span class="line">            ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the window hasn't yet been added to the window manager,</span></span><br><span class="line">    <span class="comment">// and this guy didn't finish itself or start another activity,</span></span><br><span class="line">    <span class="comment">// then go ahead and add the window.</span></span><br><span class="line">    <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</span><br><span class="line">    <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            willBeVisible = ActivityTaskManager.getService().willActivityBeVisible(</span><br><span class="line">                    a.getActivityToken());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l); <span class="comment">// 主流程下一步</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The window is now visible if it has been added, we are not</span></span><br><span class="line">    <span class="comment">// simply finishing, and we are not starting another activity.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        ViewRootImpl impl = r.window.getDecorView().getViewRootImpl();</span><br><span class="line">        WindowManager.LayoutParams l = impl != <span class="keyword">null</span></span><br><span class="line">                ? impl.mWindowAttributes : r.window.getAttributes();</span><br><span class="line">        ...</span><br><span class="line">        r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">        mNumVisibleActivities++;</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用了 WindowManagerGlobal#addView(…)</p><p>activity#makeVisible()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root; <span class="comment">// 实例化 ViewRootImpl</span></span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储所有的 decorView 和 ViewRootImpl 。暂时不明白存储来做什么的</span></span><br><span class="line">        mViews.add(view); </span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定 DecorView 和 ViewRootImpl</span></span><br><span class="line">            root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 异常了，移除</span></span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h3><p>核心类是 ViewRootImpl 。 它负责和系统 WMS 交互</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">ThreadedRenderer</span>.<span class="title">DrawCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ViewRootHandler mHandler = <span class="keyword">new</span> ViewRootHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        <span class="comment">// WMS端Session的代理对象</span></span><br><span class="line">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">        mDisplay = display;</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 继承于IWindow.Stub的W对象</span></span><br><span class="line">        mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">        mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>, context);</span><br><span class="line">        <span class="comment">// 绘制相关的对象</span></span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mView = view;</span><br><span class="line">                mAttachInfo.mRootView = view;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开启绘制流程三步走</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">// 由之前的解析可知Session.addToDisplay会调用到WMS.addWindow方法</span></span><br><span class="line">            <span class="comment">// 通过session与WMS建立通信，完成window的添加</span></span><br><span class="line">            <span class="comment">// mWindowSession app进程只会有一个</span></span><br><span class="line">            <span class="comment">// mWindow 用于binder双向通信，ViewRootImpl 都会有一个</span></span><br><span class="line">            es = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                    getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,</span><br><span class="line">                    mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                    mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Window-的移除"><a href="#Window-的移除" class="headerlink" title="Window 的移除"></a>Window 的移除</h2><p>在 ActivityThread 的 handleDestroyActivity 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 activity#onDestroy</span></span><br><span class="line">    ActivityClientRecord r = performDestroyActivity(token, finishing,</span><br><span class="line">            configChanges, getNonConfigInstance, reason);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WindowManager wm = r.activity.getWindowManager();</span><br><span class="line">        View v = r.activity.mDecor;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromServer) &#123;</span><br><span class="line">                mNumVisibleActivities--;</span><br><span class="line">            &#125;</span><br><span class="line">            IBinder wtoken = v.getWindowToken();</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mWindowAdded) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                    ... <span class="comment">// window还未显示出来，pending remove</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wm.removeViewImmediate(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityTaskManager.getService().activityDestroyed(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wm.removeViewImmediate(v);</code> 是下一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowManagerGlobal#removeView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">        View curView = mRoots.get(index).getView();</span><br><span class="line">        removeViewLocked(index, immediate);</span><br><span class="line">        <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    ViewRootImpl root = mRoots.get(index);</span><br><span class="line">    View view = root.getView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通知 InputManagerService</span></span><br><span class="line">        root.getImeFocusController().onWindowDismissed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> deferred = root.die(immediate);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.assignParent(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">            mDyingViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步是 ViewRootImpl.die(boolean)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">        doDie();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果不是 immediate 加入到消息循环中</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoved) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRemoved = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAdded) &#123;</span><br><span class="line">            dispatchDetachedFromWindow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 销毁 Surface</span></span><br><span class="line">                destroySurface();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    destroySurface();</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// binder调用移除window</span></span><br><span class="line">        mWindowSession.remove(mWindow);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Window的创建&quot;&gt;&lt;a href=&quot;#Window的创建&quot; class=&quot;headerlink&quot; title=&quot;Window的创建&quot;&gt;&lt;/a&gt;Window的创建&lt;/h2&gt;&lt;p&gt;一个 activity 对应的是 PhoneWindow 。 创建的时机是在 attach &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程的原理</title>
    <link href="http://yoursite.com/2022/07/17/Kotlin/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2022/07/17/Kotlin/协程的原理/</id>
    <published>2022-07-17T05:30:18.000Z</published>
    <updated>2022-09-11T08:15:27.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="suspend-到底做了什么"><a href="#suspend-到底做了什么" class="headerlink" title="suspend 到底做了什么"></a>suspend 到底做了什么</h2><p>一个简单的协程调用<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">100</span>) <span class="comment">// 延时来模拟耗时任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">runTask</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> time = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> result = task()</span><br><span class="line">    println(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"getTask case <span class="subst">$&#123;time - System.currentTimeMillis()&#125;</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这里runTask表示一个在协程环境调用一个耗时suspend方法并获取结果。<br>看一下 runTask() 方法反编译之后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">runTask</span><span class="params">(@NotNull Continuation var1)</span> </span>&#123;</span><br><span class="line">    Object $continuation;</span><br><span class="line">    label20: &#123; <span class="comment">// 这边label可以理解为goto语句</span></span><br><span class="line">        <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> &lt;undefinedtype&gt;) &#123;</span><br><span class="line">            $continuation = (&lt;undefinedtype&gt;)var1;</span><br><span class="line">            <span class="keyword">if</span> ((((&lt;undefinedtype&gt;)$continuation).label &amp; Integer.MIN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ((&lt;undefinedtype&gt;)$continuation).label -= Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">break</span> label20;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $continuation = <span class="keyword">new</span> ContinuationImpl(var1) &#123;</span><br><span class="line">            <span class="comment">// $FF: synthetic field</span></span><br><span class="line">            Object result;</span><br><span class="line">            <span class="keyword">int</span> label;</span><br><span class="line">            <span class="keyword">long</span> J$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">invokeSuspend</span><span class="params">(@NotNull Object $result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.result = $result;</span><br><span class="line">                <span class="keyword">this</span>.label |= Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">return</span> ContinueTest.<span class="keyword">this</span>.runTask(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object $result = ((&lt;undefinedtype&gt;)$continuation).result;</span><br><span class="line">    Object var8 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">    Object var10000;</span><br><span class="line">    <span class="keyword">long</span> time;</span><br><span class="line">    <span class="keyword">switch</span>(((&lt;undefinedtype&gt;)$continuation).label) &#123; <span class="comment">// 状态机的状态值</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ResultKt.throwOnFailure($result);</span><br><span class="line">        time = System.currentTimeMillis();</span><br><span class="line">        ((&lt;undefinedtype&gt;)$continuation).J$<span class="number">0</span> = time;</span><br><span class="line">        ((&lt;undefinedtype&gt;)$continuation).label = <span class="number">1</span>;</span><br><span class="line">        var10000 = <span class="keyword">this</span>.task((Continuation)$continuation);</span><br><span class="line">        <span class="keyword">if</span> (var10000 == var8) &#123;</span><br><span class="line">            <span class="comment">// 进入挂起状态，结束</span></span><br><span class="line">            <span class="keyword">return</span> var8;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        time = ((&lt;undefinedtype&gt;)$continuation).J$<span class="number">0</span>;</span><br><span class="line">        ResultKt.throwOnFailure($result);</span><br><span class="line">        var10000 = $result;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"call to 'resume' before 'invoke' with coroutine"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String result = (String)var10000;</span><br><span class="line">    <span class="keyword">boolean</span> var5 = <span class="keyword">false</span>;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"getTask cost "</span> + (time - System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个关注点：</p><ul><li>suspend 增加了一个 <code>@NotNull Continuation var1</code> 参数， Continuation 意思是 <code>继续 再开始</code> , 可以理解为一个状态机实现的callback</li><li><code>switch(((&lt;undefinedtype&gt;)$continuation).label)</code><br>switch语句里的 continuation.label 即是状态机的状态值。<br>case 0 是执行suspend之前的代码，case 1 代表执行suspend之后的代码。 对应调用了几次suspend挂起方法，就会生成对应的case<br>在<code>case 0</code>有一个判断<br> <code>if (var10000 == var8</code><br> 可以转化为<br> <code>if (var10000 == COROUTINE_SUSPENDED)</code><br>这个判断被调用的task()是不是挂起的，因为里面做了delay，所以肯定为true, 直接return，告诉调用自己的上层自己也是挂起状态。</li></ul><p>现在，runTask() 和 task() 都是挂起的，该如何从挂起状态恢复呢？ </p><h3 id="挂起的恢复"><a href="#挂起的恢复" class="headerlink" title="挂起的恢复"></a>挂起的恢复</h3><p>在上面反编译的代码里面，有一个很明显的<code>label20:</code> 标记，这里我理解就是一个goto语句，里面首先有一个if判断，这个不知道是什么，不管它。。。然后后面有一个new实例化<code>$continuation = new ContinuationImpl(var1)</code> var1是suspend方法的Continuation入参，ContinuationImpl 继承自 BaseContinuationImpl , 我们来分析一下这个 BaseContinuationImpl 的源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: kotlin.coroutines.CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">kotlin</span>.<span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span>: kotlin.<span class="built_in">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">completion 入参是 suspend 方法，在编译阶段增加的参数 `Continuation var1` </span></span><br><span class="line"><span class="comment">在 resumeWith 方法内部，会调用 $continuation 的 resumeWith 并递归向上调用 var1 的 resumeWith</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseContinuationImpl</span></span>(</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> param = result</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            with(current) &#123; <span class="comment">// this -&gt;</span></span><br><span class="line">            <span class="comment">// ... 这个with语句，里面的变量有些是current的成员变量，注意区分...</span></span><br><span class="line">            <span class="comment">// ... kotlin //的垃圾语法糖啊</span></span><br><span class="line">                <span class="keyword">val</span> completion = completion!! <span class="comment">// 这个 completion 是 current.completion ...</span></span><br><span class="line">                <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">val</span> outcome = invokeSuspend(param) <span class="comment">// current.invokeCurrent(param)</span></span><br><span class="line">                        <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                        Result.success(outcome)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                        Result.failure(exception)</span><br><span class="line">                    &#125;</span><br><span class="line">                releaseIntercepted()</span><br><span class="line">                <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                    current = completion</span><br><span class="line">                    param = outcome</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    completion.resumeWith(outcome)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseContinuationImpl 实现了 Continuation 接口，resumeWith 在 耗时挂起执行完了之后会被调用。<br>在前面反编译的代码中创建了匿名内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$continuation = <span class="keyword">new</span> ContinuationImpl(var1) &#123;</span><br><span class="line">      Object result;</span><br><span class="line">      <span class="keyword">int</span> label;</span><br><span class="line">      <span class="keyword">long</span> J$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Nullable</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">invokeSuspend</span><span class="params">(@NotNull Object $result)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.result = $result;</span><br><span class="line">          <span class="keyword">this</span>.label |= Integer.MIN_VALUE;</span><br><span class="line">          <span class="keyword">return</span> ContinueTest.<span class="keyword">this</span>.runTask(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>continuation 的初始 label 值是0，在switch语句里，执行完suspend之前的代码后，label会设为1， 当调用完suspend方法后， BaseContinuationImpl#resumeWith 会调用 invokeSuspend 方法递归调用suspend方法 runTask() 。 如果 suspend 方法还是 挂起的，那么直接return。否则递归不断向上resume</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;suspend-到底做了什么&quot;&gt;&lt;a href=&quot;#suspend-到底做了什么&quot; class=&quot;headerlink&quot; title=&quot;suspend 到底做了什么&quot;&gt;&lt;/a&gt;suspend 到底做了什么&lt;/h2&gt;&lt;p&gt;一个简单的协程调用&lt;br&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    delay(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 延时来模拟耗时任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;runTask&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: String &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; time = System.currentTimeMillis()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; result = task()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;getTask case &lt;span class=&quot;subst&quot;&gt;$&amp;#123;time - System.currentTimeMillis()&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mmkv原理</title>
    <link href="http://yoursite.com/2022/07/10/Android/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/mmkv%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2022/07/10/Android/源码解析/mmkv原理/</id>
    <published>2022-07-10T09:03:32.000Z</published>
    <updated>2022-07-10T11:36:49.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SharedPreferences的痛点"><a href="#SharedPreferences的痛点" class="headerlink" title="SharedPreferences的痛点"></a>SharedPreferences的痛点</h2><h3 id="只能全量读取和写入"><a href="#只能全量读取和写入" class="headerlink" title="只能全量读取和写入"></a>只能全量读取和写入</h3><a id="more"></a><p>sp保存数据的文件形式是xml。每次读取都去读xml文件，解析后加入内存缓存里。每次写入都更改内存缓存的值，然后全量写入到文件里</p><h3 id="有anr的风险"><a href="#有anr的风险" class="headerlink" title="有anr的风险"></a>有anr的风险</h3><ul><li><p>在第一次载入时会产生anr<br>有一个加锁配合while循环，如果第一次使用xml文件还没有加载完成，就会pending。xml文件的全量读取本身就不快，如果xml文件过大，在首次使用时就可能会anr，在app启动过程中问题会比较明显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> defValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        Boolean v = (Boolean)mMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(mThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>commit写入导致anr<br>没啥说的，同步写入文件</p></li><li><p>apply写入导致anr<br>apply会异步写入，先写入到内存缓存，然后在子线程更新xml文件。<br>但是sp会将更新文件的问题加入到QueuedWork中。android的系统会在Activity的onStop,onPause等生命周期中，调用QueuedWork.waitToFinish，等待落盘的任务队列执行完成，如果任务队列中的任务很多，或者待写入的数据量很大时(sp文件是全量读写的)，在一些io性能差的中低端机型上就会很容易出现anr.</p></li></ul><p>具体可以参考这个文章：<a href="https://juejin.cn/post/6844904033820377096" target="_blank" rel="noopener">https://juejin.cn/post/6844904033820377096</a><br><a href="https://www.jianshu.com/p/9ae0f6842689" target="_blank" rel="noopener">https://www.jianshu.com/p/9ae0f6842689</a></p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。</p><ul><li>普通io文件操作的过程<br>Linux系统内存分为 内核空间 和 用户空间 。文件操作属于 内核空间。应用需要通过系统调用才能完成文件读取。<br>普通io操作需要先将文件拷贝到页缓存里(内核空间)，然后再从页缓存拷贝到用户空间。这需要两次拷贝。</li><li>mmap文件读写<br>mmap创建了 用户空间 到 内核空间 的映射，返回对应的指针；<br>读取文件时，文件还是一样拷贝到页缓存里(内核空间)。 因为创建了内存映射，用户空间能直接获取到文件数据。<br>写文件时，直接写入到指针地址对应的内核空间，Linux系统机制会保证内核空间到文件磁盘的写入，这样即使进程crash，也不会导致数据丢失</li></ul><h2 id="数据存储优化"><a href="#数据存储优化" class="headerlink" title="数据存储优化"></a>数据存储优化</h2><ul><li>数据组织<br>数据序列化方面我们选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。</li><li>写入优化<br>考虑到主要使用场景是频繁地进行写入更新，我们需要有增量更新的能力。我们考虑将增量 kv 对象序列化后，append 到内存末尾。<br>这样同一个 key 会有新旧若干份数据，最新的数据在最后。写入速度会很快<br>读取只需要从后往前读，读到第一个key匹配即使最新的有效数据。</li><li>空间增长<br>使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。我们需要在性能和空间上做个折中。<br>以内存 pagesize(内存页大小) 为单位申请空间，在空间用尽之前都是 append 模式；当 append 到文件末尾时，进行文件重整(去除重复key)、key 排重，尝试序列化保存排重结果；在程序启动第一次打开 mmkv 时，也会进行文件重整。<br>排重后空间还是不够用的话，将文件扩大一倍，直到空间足够。</li></ul><h2 id="多进程读写支持"><a href="#多进程读写支持" class="headerlink" title="多进程读写支持"></a>多进程读写支持</h2><p>在mmap的时候，只会返回映射内存的指针。在append和重整时可以加文件锁，保证自己的写文件成功。但是一个进程并不知道自己文件的数据是否被其他进程修改过。</p><ul><li>写指针的同步<br>因为mmkv的写入是直接append在数据末尾，mmap导致数据的大小和文件的大小并不一直，所以需要一个指针指向有效数据的末尾，称之为写指针。<br>mmkv 在每个进程内部缓存自己的写指针，然后在写入键值的同时，还要把最新的写指针位置也写到 mmap 内存中；这样每个进程只需要对比一下缓存的指针与 mmap 内存的写指针，如果不一样，就说明其他进程进行了写操作。<br>事实上 MMKV 原本就在文件头部保存了有效内存的大小，这个数值刚好就是写指针的内存偏移量，可以重用这个数值来校对写指针。</li><li>内存重整的感知<br>使用一个单调递增的序列号，每次发生内存重整，就将序列号递增。将这个序列号也放到 mmap 内存中，每个进程内部也缓存一份，只需要对比序列号是否一致，就能够知道其他进程是否触发了内存重整。</li><li>内存增长的感知<br>事实上 MMKV 在内存增长之前，会先尝试通过内存重整来腾出空间，重整后还不够空间才申请新的内存。所以内存增长可以跟内存重整一样处理。至于新的内存大小，可以通过查询文件大小来获得，无需在 mmap 内存另外存放。</li></ul><p>可以参考文档 <a href="https://cloud.tencent.com/developer/article/1354199" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1354199</a></p><h2 id="mmkv的不足"><a href="#mmkv的不足" class="headerlink" title="mmkv的不足"></a>mmkv的不足</h2><p>主要是mmap的缺点，需要提前确定好文件的大小，即 映射内存的大小。但是，映射内存的大小并不是有效数据的大小。 映射内存只是提供了一个快捷操作文件的场地。 会造成存储空间的浪费，并且映射内存的大小必须是页缓存(pagesize)的整数倍</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SharedPreferences的痛点&quot;&gt;&lt;a href=&quot;#SharedPreferences的痛点&quot; class=&quot;headerlink&quot; title=&quot;SharedPreferences的痛点&quot;&gt;&lt;/a&gt;SharedPreferences的痛点&lt;/h2&gt;&lt;h3 id=&quot;只能全量读取和写入&quot;&gt;&lt;a href=&quot;#只能全量读取和写入&quot; class=&quot;headerlink&quot; title=&quot;只能全量读取和写入&quot;&gt;&lt;/a&gt;只能全量读取和写入&lt;/h3&gt;
    
    </summary>
    
    
      <category term="源码解析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="glide" scheme="http://yoursite.com/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码解析</title>
    <link href="http://yoursite.com/2022/06/12/Android/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Retrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2022/06/12/Android/源码解析/Retrofit源码解析/</id>
    <published>2022-06-12T10:21:16.000Z</published>
    <updated>2022-10-18T16:52:22.767Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetrofitService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"query"</span>)</span><br><span class="line">    <span class="function">Observable&lt;PostInfo&gt; <span class="title">getPostInfoRx</span><span class="params">(@Query(<span class="string">"type"</span>)</span> String type, @<span class="title">Query</span><span class="params">(<span class="string">"postid"</span>)</span> String postid)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"http://www.kuaidi100.com/"</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class="comment">// 支持RxJava</span></span><br><span class="line">        .build();</span><br><span class="line">        </span><br><span class="line">RetrofitService service = retrofit.create(XxxInterface.class);</span><br><span class="line">Call&lt;PostInfo&gt; call = service.getPostInfo(<span class="string">"yuantong"</span>, <span class="string">"11111111111"</span>);</span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;PostInfo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;PostInfo&gt; call, Response&lt;PostInfo&gt; response)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"http返回："</span>, response.body().toString() + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;PostInfo&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面是 Retrofit 的主要用法，主要重要的东西有 ConverterFactory , CallAdapterFactory , retrofit.create(XxxInterface.class) 三个东西</p><h2 id="Retrofit-Builder"><a href="#Retrofit-Builder" class="headerlink" title="Retrofit.Builder()"></a>Retrofit.Builder()</h2><p>builder就是一个常见的建造者模式，没什么好说的。 有一个点需要注意一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">   <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">     callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">   <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 默认callback回调是执行在主线程的</span></span><br><span class="line">     callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">   callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">   List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">       <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">   <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">   converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">   converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">   converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">       unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == ResponseBody.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class="line">            ? StreamingResponseBodyConverter.INSTANCE</span><br><span class="line">            : BufferingResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == Void.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先插入了一个 BuiltInConverters 内置的转换器。 当返回类型是 ResponseBody 的时候就会使用 BuiltInConverters ，返回 ResponseBody 就和 okhttp 的返回一致了。</p><h2 id="Retrofit的重要部分"><a href="#Retrofit的重要部分" class="headerlink" title="Retrofit的重要部分"></a>Retrofit的重要部分</h2><ol><li>responseConverter : response的转换器<br>GsonConverterFactory 将string类型的返回值转换为javabean</li><li>callAdapter : call适配器。<br>DefaultCallAdapterFactory 生产默认的适配器。 默认的行为是将子线程的请求callback切换到主线程。<br>RxJava2CallAdapterFactory 适配rxjava</li></ol><h2 id="retrofit-create-XxxInterface-class"><a href="#retrofit-create-XxxInterface-class" class="headerlink" title="retrofit.create(XxxInterface.class)"></a>retrofit.create(XxxInterface.class)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了动态代理，create方法返回的接口对象是一个动态代理的实例</p><h2 id="loadServiceMethod"><a href="#loadServiceMethod" class="headerlink" title="loadServiceMethod"></a>loadServiceMethod</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存 + 解析Method</p><h2 id="ServiceMethod-parseAnnotations"><a href="#ServiceMethod-parseAnnotations" class="headerlink" title="ServiceMethod.parseAnnotations"></a>ServiceMethod.parseAnnotations</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在抽象父类里先调用了 <code>RequestFactory.parseAnnotations(retrofit, method);</code> 去解析方法参数的注解。<br><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</code> 里解析了返回类型，并匹配 CallAdapter 和 Converter<br>。。。抽象父类的静态方法区调用了子类的静态方法。。。有些迷惑</p><h2 id="HttpServiceMethod-parseAnnotations"><a href="#HttpServiceMethod-parseAnnotations" class="headerlink" title="HttpServiceMethod.parseAnnotations"></a>HttpServiceMethod.parseAnnotations</h2><p>RequestFactory.parseAnnotations 都是一些注解的处理，不说了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    Type adapterType;</span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">    <span class="comment">// 是协程suspend方法调用</span></span><br><span class="line">    <span class="comment">// kotli的suspend方法转成java之后会在方法参数上生成一个Continuation类型的参数</span></span><br><span class="line">      Type[] parameterTypes = method.getGenericParameterTypes(); <span class="comment">// 获取方法的所有参数类型</span></span><br><span class="line">      Type responseType = Utils.getParameterLowerBound(<span class="number">0</span>,</span><br><span class="line">          (ParameterizedType) parameterTypes[parameterTypes.length - <span class="number">1</span>]); <span class="comment">// 获取最后一个 Continuation 类型参数的泛型</span></span><br><span class="line">      <span class="keyword">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="comment">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class="line">        <span class="comment">// 获取 Response&lt;T&gt; 中泛型T的类型</span></span><br><span class="line">        responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) responseType);</span><br><span class="line">        continuationWantsResponse = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里把suspend方法的返回类型的 AdapterType 当做 Call&lt;T&gt; 来处理了</span></span><br><span class="line">      adapterType = <span class="keyword">new</span> Utils.ParameterizedTypeImpl(<span class="keyword">null</span>, Call.class, responseType);</span><br><span class="line">      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是非suspend方法，那直接取返回类型就可以了</span></span><br><span class="line">      adapterType = method.getGenericReturnType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找合适的 CallAdapterFactory 生产 CallAdapter</span></span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找合适的 ConverterFactory 生产 Converter</span></span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CallFactory 实质上就是 OkHttpClient</span></span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是返回 HttpServiceMethod 的子类，这三个子类其实就是 CallAdapted wrap 了一层。 SuspendForResponse 和 SuspendForBody 调用了协程的 await 方法去等待协程的完成（其实就是加了个Continuation的回调）</span></span><br><span class="line">    <span class="keyword">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">      <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForResponse&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">      <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">          continuationBodyNullable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="ServiceMethod-invode"><a href="#ServiceMethod-invode" class="headerlink" title="ServiceMethod.invode"></a>ServiceMethod.invode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">HttpServiceMethod</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br></pre></td></tr></table></figure><p>OkHttpCall 实现了 Retrofit 的 call 到 OkHttpCall 的转换<br>adapt 最终会调用 CallAdapter 的 adapt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OkHttpCall#enqueue</span></span><br><span class="line"> <span class="meta">@Override</span> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      call = rawCall;</span><br><span class="line">      failure = creationFailure;</span><br><span class="line">      <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 懒加载 rawCall</span></span><br><span class="line">          <span class="comment">// 传入真实请求参数，构建真正发起请求的 okhttp 的 Call 对象</span></span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="comment">// 调用 Converter 解析返回类型</span></span><br><span class="line">        response = parseResponse(rawResponse);</span><br><span class="line">        callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看一下默认的 DefaultCallAdapterFactory 是怎么实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">DefaultCallAdapterFactory</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取 Call&lt;T&gt; 的具体类型</span></span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有 SkipCallbackExecutor 这个注解，一般是没有的</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class="line">        ? <span class="keyword">null</span></span><br><span class="line">        : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span></span><br><span class="line">            ? call</span><br><span class="line">            : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">  <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.execute();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>enqueue 里的返回 onResponse 和 onFailure 都是在 callbackExecutor<br>callbackExecutor 也是在 retrofit 构建时传入的， 默认是 <code>Android.MainThreadExecutor</code> 也就是说默认 enqueue 的 callback 默认是执行在主线程的</p><h2 id="对kotlin协程的支持"><a href="#对kotlin协程的支持" class="headerlink" title="对kotlin协程的支持"></a>对kotlin协程的支持</h2><p>动态代理的api接口的方法调用支持suspend协程，具体的方法是使用 suspendCancellableCoroutine </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">suspend fun &lt;T : Any&gt; Call&lt;T&gt;.await(): T &#123;</span><br><span class="line">  <span class="keyword">return</span> suspendCancellableCoroutine &#123; continuation -&gt;</span><br><span class="line">    continuation.invokeOnCancellation &#123;</span><br><span class="line">      cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    enqueue(object : Callback&lt;T&gt; &#123;</span><br><span class="line">      <span class="function">override fun <span class="title">onResponse</span><span class="params">(call: Call&lt;T&gt;, response: Response&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (response.isSuccessful) &#123;</span><br><span class="line">          val body = response.body()</span><br><span class="line">          <span class="keyword">if</span> (body == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            continuation.resumeWithException(e)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            continuation.resume(body)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          continuation.resumeWithException(HttpException(response))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function">override fun <span class="title">onFailure</span><span class="params">(call: Call&lt;T&gt;, t: Throwable)</span> </span>&#123;</span><br><span class="line">        continuation.resumeWithException(t)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RetrofitService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GET&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;query&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Observable&amp;lt;PostInfo&amp;gt; &lt;span class=&quot;title&quot;&gt;getPostInfoRx&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(@Query(&lt;span class=&quot;string&quot;&gt;&quot;type&quot;&lt;/span&gt;)&lt;/span&gt; String type, @&lt;span class=&quot;title&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;postid&quot;&lt;/span&gt;)&lt;/span&gt; String postid)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Retrofit retrofit = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Retrofit.Builder()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .baseUrl(&lt;span class=&quot;string&quot;&gt;&quot;http://www.kuaidi100.com/&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .addConverterFactory(GsonConverterFactory.create())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) &lt;span class=&quot;comment&quot;&gt;// 支持RxJava&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RetrofitService service = retrofit.create(XxxInterface.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Call&amp;lt;PostInfo&amp;gt; call = service.getPostInfo(&lt;span class=&quot;string&quot;&gt;&quot;yuantong&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;11111111111&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;call.enqueue(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Callback&amp;lt;PostInfo&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onResponse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Call&amp;lt;PostInfo&amp;gt; call, Response&amp;lt;PostInfo&amp;gt; response)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Log.i(&lt;span class=&quot;string&quot;&gt;&quot;http返回：&quot;&lt;/span&gt;, response.body().toString() + &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onFailure&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Call&amp;lt;PostInfo&amp;gt; call, Throwable t)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RequestLayout和Invalidate</title>
    <link href="http://yoursite.com/2022/05/02/Android/Framework/RequestLayout%E5%92%8CInvalidate/"/>
    <id>http://yoursite.com/2022/05/02/Android/Framework/RequestLayout和Invalidate/</id>
    <published>2022-05-02T08:48:49.000Z</published>
    <updated>2022-08-17T08:34:43.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RequestLayout"><a href="#RequestLayout" class="headerlink" title="RequestLayout"></a>RequestLayout</h1><h2 id="标记自身"><a href="#标记自身" class="headerlink" title="标记自身"></a>标记自身</h2><p>给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。<br>并将RequestLayout向上传递。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从源码注释可以看出，如果当前View在请求布局的时候，View树正在进行布局流程的话，</span></span><br><span class="line"><span class="comment">//该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发现的时候再执行。</span></span><br><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果处于 Layout 则将该请求加入 ViewRootImpl 中的任务队列中</span></span><br><span class="line">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">        <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为当前view设置标记位 PFLAG_FORCE_LAYOUT</span></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        <span class="comment">//向父容器请求布局</span></span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 requestLayout() 的view会给自己添加标记位 <code>PFLAG_FORCE_LAYOUT</code> , <code>PFLAG_INVALIDATED</code><br>并一直parent向上递归，这个view所有的祖先都会设置上标记位</p><h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><p>会顺着view树，一路向上标记，最终到达 ViewRootImpl<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals(); <span class="comment">// 开启measure、layout、draw三步走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> scheduleTraversals() 开启绘制三步走流程。 在measure、layout、draw过程中都会判断标志位，只有需要的时候才执行</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">            widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">            <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> measure时判断了 PFLAG_FORCE_LAYOUT ，或者 measureSpec 发生了改变。 并不是所有的view都会重新measure 。在一个view调用 requestLayout 时，这个view和它的所有祖先一定会重新measure，其他view按需要判断是否重新measure。</p><p>在 <code>mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</code> 中也给layout过程做了标记</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">    <span class="comment">//判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        <span class="comment">//onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后清除PFLAG_FORCE_LAYOUT标记位</span></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remember our drawn bit</span></span><br><span class="line">            <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">            <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">            <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">            <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">            <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            ...</span><br><span class="line">            mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line">            mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">                sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> layout时判断了PFLAG_LAYOUT_REQUIRED标记，需要时才做。<br> changed 获取有一个 <code>setFrame(...)</code> 方法，里面会判断view的layout是否改变，如果改变了，会调用 <code>invalidate()</code> 进行重新draw</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 调用 View.requestLayout 方法后会依次调用 performMeasure, performLayout 和 performDraw 方法，调用者 View 及其父 View 会重新从上往下进行 measure, layout 流程，如果view顶点没有改变，不会执行 draw 流程</p><h1 id="Invalidate"><a href="#Invalidate" class="headerlink" title="Invalidate"></a>Invalidate</h1><h2 id="标记自身-1"><a href="#标记自身-1" class="headerlink" title="标记自身"></a>标记自身</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">            || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">            || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">            || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置PFLAG_DIRTY标记位</span></span><br><span class="line">        mPrivateFlags |= PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate the damage rectangle to the parent view.</span></span><br><span class="line">        <span class="comment">//把需要重绘的区域传递给父容器</span></span><br><span class="line">        <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">        <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">            <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">            damage.set(l, t, r, b);</span><br><span class="line">            <span class="comment">//调用父容器的方法，向上传递事件</span></span><br><span class="line">            p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewGroup处理并向上传递"><a href="#ViewGroup处理并向上传递" class="headerlink" title="ViewGroup处理并向上传递"></a>ViewGroup处理并向上传递</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Don't call or override this method. It is used for the implementation of</span></span><br><span class="line"><span class="comment"> * the view hierarchy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 parent 等于自身</span></span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">            mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// 循环向上遍历祖先view</span></span><br><span class="line">            View view = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                view = (View) parent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        view.getSolidColor() == <span class="number">0</span>) &#123;</span><br><span class="line">                    opaqueFlag = PFLAG_DIRTY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</span><br><span class="line">                    <span class="comment">//对当前View的标记位进行设置</span></span><br><span class="line">                    view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用ViewGrup的invalidateChildInParent，如果已经达到最顶层view,则调用ViewRootImpl的invalidateChildInParent。</span></span><br><span class="line">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[] location, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN ||</span><br><span class="line">            (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) !=</span><br><span class="line">                    FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响</span></span><br><span class="line">            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,</span><br><span class="line">                    location[CHILD_TOP_INDEX] - mScrollY);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//求并集，结果是把子视图的dirty区域转化为父容器的dirty区域</span></span><br><span class="line">                dirty.union(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = mTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dirty.intersect(<span class="number">0</span>, <span class="number">0</span>, mRight - left, mBottom - top)) &#123;</span><br><span class="line">                    dirty.setEmpty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录当前视图的mLeft和mTop值，在下一次循环中会把当前值再向父容器的坐标转化</span></span><br><span class="line">            location[CHILD_LEFT_INDEX] = left;</span><br><span class="line">            location[CHILD_TOP_INDEX] = top;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回当前视图的父容器</span></span><br><span class="line">            <span class="keyword">return</span> mParent;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewRootImpl-1"><a href="#ViewRootImpl-1" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    ...</span><br><span class="line">    invalidateRectOnScreen(dirty);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidateRectOnScreen</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用硬件加速渲染</span></span><br><span class="line">    <span class="comment">// 2. 使用软件加速渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if drawing was successful, false if an error occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw with software renderer.</span></span><br><span class="line">        <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">            canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">            <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">            <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                    || bottom != dirty.bottom) &#123;</span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Do this in native</span></span><br><span class="line">            canvas.setDensity(mDensity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪代码</span></span><br><span class="line">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里只有软件绘制的代码。<br>网上有人说invalidate只会重绘脏区域，但是这里只看到用dirty做了一个 <code>canvas = mSurface.lockCanvas(dirty);</code> 。还不是很懂局部重绘是怎么做到的。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RequestLayout&quot;&gt;&lt;a href=&quot;#RequestLayout&quot; class=&quot;headerlink&quot; title=&quot;RequestLayout&quot;&gt;&lt;/a&gt;RequestLayout&lt;/h1&gt;&lt;h2 id=&quot;标记自身&quot;&gt;&lt;a href=&quot;#标记自身&quot; class=&quot;headerlink&quot; title=&quot;标记自身&quot;&gt;&lt;/a&gt;标记自身&lt;/h2&gt;&lt;p&gt;给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。&lt;br&gt;并将RequestLayout向上传递。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程上下文和异常传播</title>
    <link href="http://yoursite.com/2022/04/11/Kotlin/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD/"/>
    <id>http://yoursite.com/2022/04/11/Kotlin/协程上下文和异常传播/</id>
    <published>2022-04-11T15:50:53.000Z</published>
    <updated>2022-04-11T16:56:12.838Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7068901166456766472#heading-6" target="_blank" rel="noopener">https://juejin.cn/post/7068901166456766472#heading-6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7068901166456766472#heading-6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.cn/post/7068901166456766472#
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>jvm虚拟机</title>
    <link href="http://yoursite.com/2022/04/07/Java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2022/04/07/Java/jvm虚拟机/</id>
    <published>2022-04-07T15:10:00.000Z</published>
    <updated>2022-09-13T05:13:50.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM架构"><a href="#JVM架构" class="headerlink" title="JVM架构"></a>JVM架构</h2><p>jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈</p><a id="more"></a><ol><li><p>方法区<br>方法区被所有线程共享。存放 类信息、类的字段信息和方法信息、常量、static类变量</p></li><li><p>Java栈<br>Java栈线程之间不共享。<br>Java栈是由很多的栈帧(stack frame)或者说帧(frame)组成的，一个栈帧包含一个Java方法调用状态。用来存放方法的局部变量、被调用时传进来的参数、返回值 以及运算的中间结果等等。</p></li><li><p>Native栈<br>用来存放Native方法的调用状态</p></li><li><p>堆<br>用于存放对象。 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。</p></li><li><p>程序计数器（PC寄存器）<br>每一个线程有一个程序计数器。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。</p></li><li><p>类加载子系统<br>读取class文件，加载Java类到内存。</p></li></ol><h2 id="基于栈的jvm-和-基于寄存器的jvm"><a href="#基于栈的jvm-和-基于寄存器的jvm" class="headerlink" title="基于栈的jvm 和 基于寄存器的jvm"></a>基于栈的jvm 和 基于寄存器的jvm</h2><p>在虚拟机栈的每一个栈帧中(即每一个方法调用中），存在一个「操作数栈」，用于存放运算的临时数据。<br>基于栈 和 基于寄存器 的区别在于这个「操作数栈」</p><ul><li>基于栈<br>对于基于栈的jvm，这个「操作数栈」的区域当然是一个栈，方法体运行过程中生成的临时数据，会压入栈中，需要的时候再从栈中弹出。<br>实现比较简单，只是单纯的压栈出栈<br>对于每一条字节码指令，无需指定操作数地址，所以单个指令长度较短<br>因为要频繁的压栈出栈，所以字节码指令会增加</li><li>基于寄存器<br>对于基于寄存器的jvm，这个「操作数栈】的区域变成了多个虚拟寄存器，方法体运行过程中的临时数据会存放到这些寄存器中。<br>避免了频繁的压栈出栈操作，所以字节码指令数量更少<br>因为要明确指定操作数地址，所以字节码单个指令长度会翻倍</li></ul><h3 id="为什么-dalvik-和-art-要基于寄存器"><a href="#为什么-dalvik-和-art-要基于寄存器" class="headerlink" title="为什么 dalvik 和 art 要基于寄存器"></a>为什么 dalvik 和 art 要基于寄存器</h3><p>从上面的分析看，很明显，基于寄存器的jvm运行更快！</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器负责动态加载Java类到Java虚拟机的内存空间中。</p><ul><li>双亲委托机制<br>“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类 路径中查找并装载目标类。这一点是从安全角度考虑的</li></ul><h2 id="GC垃圾回收机制"><a href="#GC垃圾回收机制" class="headerlink" title="GC垃圾回收机制"></a>GC垃圾回收机制</h2><h3 id="如何判断对象是否可以被回收"><a href="#如何判断对象是否可以被回收" class="headerlink" title="如何判断对象是否可以被回收"></a>如何判断对象是否可以被回收</h3><ul><li>引用计数法</li><li>根搜索算法：<ul><li>从GC root出发查找引用链，无法触及到的对象可以被回收。 </li><li>GC-root包括：虚拟机栈中引用的对象、类静态属性引用的对象、常量引用的对象</li></ul></li></ul><h3 id="强引用、弱引用、软引用、虚引用"><a href="#强引用、弱引用、软引用、虚引用" class="headerlink" title="强引用、弱引用、软引用、虚引用"></a>强引用、弱引用、软引用、虚引用</h3><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>jvm将对象分为三个区域， 新生代（Young Generation） 、 老年代（Old Generation） 和 持久代（Permanent Generation）。</p><ul><li>持久代：<ul><li>存放java类的类信息，存放静态文件，如final常量，static常量，常量池等。几乎不回收</li></ul></li><li>新生代：<ul><li>新生代使用拷贝算法：新生代中存在一个Eden区和两个Survivor区，其中一个Survivor始终为空。 eden区gc时，存活的对象会复制到其中一个survivor区。 Survivor区gc时，会拷贝到另一个空闲的Survivor区。 当对象多次gc存活一定次数之后，会移动到老年代</li><li>jvm中 eden区和Survivor区的大小为8：1</li></ul></li><li>老年代：<ul><li>使用标记整理算法。标记需要清除对象，将存活的对象往内存的一端移动，再将需要清除要回收的对象。这样的算法可以避免内存碎片的产生</li><li>大对象会一生成就会直接放到老年代。新生代容量较小，避免新生代频繁gc</li></ul></li></ul><h3 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h3><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p><p>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</p><p>方法区中类静态属性引用的对象</p><p>方法区中常量引用的对象</p><h2 id="jar文件和dex文件的差异"><a href="#jar文件和dex文件的差异" class="headerlink" title="jar文件和dex文件的差异"></a>jar文件和dex文件的差异</h2><p>一个jar文件包含多个class文件，不同的class文件之间没有关联。 如果有相同的常量信息等数据，会产生冗余，增大文件大小。<br>一个dex文件包括索引区和数据区，多个类共用一个索引区。这样相同的常量信息等可以避免重复冗余，可以大大减小文件大小。 同时，因为只有一个文件，也可以减少文件io的开销。 </p><h2 id="对象一定是在堆上的吗？"><a href="#对象一定是在堆上的吗？" class="headerlink" title="对象一定是在堆上的吗？"></a>对象一定是在堆上的吗？</h2><p>不一定，取决于不同jvm的设计优化。</p><p>在虚拟机栈的调用中，jvm会对方法体力创建的对象做逃逸分析。 通过<strong>逃逸分析</strong>，可以分析出这个对象的引用是否只存在于方法体内部。<br>如果发现某个对象并没有逃逸到方法体之外的话，就可能对其进行优化。不会将对象分配到堆上，可以减少gc的消耗。<br>具体的方法是，把这个对象拆解成若干个其中包含的若干个局部变量来代替。这个过程就是<strong>标量替换</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM架构&quot;&gt;&lt;a href=&quot;#JVM架构&quot; class=&quot;headerlink&quot; title=&quot;JVM架构&quot;&gt;&lt;/a&gt;JVM架构&lt;/h2&gt;&lt;p&gt;jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="http://yoursite.com/2022/04/04/Java/ConcurrentHashMap/"/>
    <id>http://yoursite.com/2022/04/04/Java/ConcurrentHashMap/</id>
    <published>2022-04-04T08:36:53.000Z</published>
    <updated>2022-10-06T14:29:36.333Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 </p><a id="more"></a><h2 id="1-8-之前"><a href="#1-8-之前" class="headerlink" title="1.8 之前"></a>1.8 之前</h2><p>将 table 数组划分为多个 segment ，对每一个 segment 单独加锁，不同的 segment 可以跨线程运算，提高并发效率。 </p><p>每一个segment有一个单独的table数组，类似1.7版本的 hashmap，table数组遇到哈希冲突后，同hash值的元素使用的数据结构是链表。</p><p>读是不需要加锁的，因为 segment 的 table 数组加了 volatile 修饰，HashEntry 的val和next字段也用 volatile 修饰。 一个线程改变了值，另一个线程能马上发现。</p><p>put的时候需要加锁，当put时，所在的segment还没有创建，会懒加载创建segment。实例化segment之后，会通过cas插入到segment数组中，保证线程安全。</p><p>下面是 1.8之前 ConcurrentHashMap 的 Segment 的 put 流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取锁，获取成功，node为null，代码向下执行</span></span><br><span class="line">    <span class="comment">//如果有其他线程占据锁对象，那么去做别的事情，而不是一直等待，提升效率</span></span><br><span class="line">    <span class="comment">// tryLock 通过cas获取锁</span></span><br><span class="line">    <span class="comment">//scanAndLockForPut 稍后分析</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//取hash的低位，计算HashEntry[]的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//获取索引位的元素对象</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">//获取的元素对象不为空</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">//如果是重复元素，覆盖原值</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果不是重复元素，获取链表的下一个元素，继续循环遍历链表</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//如果获取到的元素为空</span></span><br><span class="line">                <span class="comment">//当前添加的键值对的HashEntry对象已经创建</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first); <span class="comment">//头插法关联即可</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//创建当前添加的键值对的HashEntry对象</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">//添加的元素数量递增</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//判断是否需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">//需要扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//不需要扩容</span></span><br><span class="line">                    <span class="comment">//将当前添加的元素对象，存入数组角标位，完成头插法添加元素</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 四：Segment的scanAndLockForPut方法</span></span><br><span class="line"><span class="comment"> * 该方法在线程没有获取到锁的情况下，去完成HashEntry对象的创建，提升效率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取头部元素</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>；</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        <span class="comment">//获取锁失败</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//没有下一个节点，并且也不是重复元素，创建HashEntry对象，不再遍历</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                <span class="comment">//重复元素，不创建HashEntry对象，不再遍历</span></span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//继续遍历下一个节点</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">//如果尝试获取锁的次数过多，直接加锁</span></span><br><span class="line">            <span class="comment">//MAX_SCAN_RETRIES会根据可用cpu核数来确定</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            <span class="comment">//如果期间有别的线程获取锁，重新遍历</span></span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8-之后"><a href="#1-8-之后" class="headerlink" title="1.8 之后"></a>1.8 之后</h2><p>1.8之后ConcurrentHashMap改变了加锁策略，改为对哈希数组的每一个hash位置加锁；同时，将哈希冲突的链表替换为了和 HashMap 一样的红黑树。</p><h3 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h3><ul><li>为0，默认状态，代表数组未初始化， 且数组的初始容量为16</li><li>为-1，表示数组正在进行初始化</li><li>为正数，其记录的是数组的扩容阈值</li><li>小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操</li></ul><h3 id="put时如何保证线程安全"><a href="#put时如何保证线程安全" class="headerlink" title="put时如何保证线程安全"></a>put时如何保证线程安全</h3><ul><li>在put时对table哈希数组的每一个hash位置，如果为该位置为null，cas判断，然后在改位置添加元素；如果该位置不为null，则对该hash位置进行Synchronize加锁，将新元素加载链表or红黑树上。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果有空值或者空键，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//基于key计算hash值，并进行一定的扰动</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果数组还未初始化，先对数组进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">    <span class="comment">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span></span><br><span class="line">            <span class="comment">//如果cas检测没过，下一次while循环就相当于在table的这个hash位置添加新元素</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 重复判断，方式加锁之前已经有其他线程做了修改</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//普通链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//树节点，将元素添加到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//链表长度大于/等于8，将链表转成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//如果是重复键，直接将旧值返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化hash数组"><a href="#初始化hash数组" class="headerlink" title="初始化hash数组"></a>初始化hash数组</h3><ul><li>在初始化哈希数组的时候，会cas+自旋保证线程安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化底层数组 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//cas+自旋，保证线程安全，对数组进行初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果另一个线程已经初始化了数组，则不会走到这里。 会直接break</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sizeCtl为0，取默认长度16，否则去sizeCtl的值</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">//基于初始长度，构建数组对象</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算扩容阈值，并赋值给sc</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将扩容阈值，赋值给sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>ConcurrentHashMap 的扩容在transfer方法中；<br>需要注意的是，ConcurrentHashMap 有一个多线程协助扩容的机制。</p><ul><li>当一个线程在扩容的时候，在移动hash数组的元素到新数组的时候，会确定自己的开始位置 和 一个stride容量，hash数组stride内的元素自己负责扩容拷贝；然后确定一个 transferIndex 作为下次拷贝的起点。 同时在原数组的hash位置放置一个 ForwardingNode 。 </li><li>当有新的线程想要在这个hash位置插入元素时，发现这里有一个 ForwardingNode ，会协助一起扩容，帮助将原数组的元素迁移到新数组。 以 transferIndex 作为起点，stride容量内的元素自己负责协助拷贝</li><li>对于线程安全，在扩容拷贝的时候，会对hash数组要拷贝的位置进行 synchronized 加锁。在计算 transferIndex 的会使用 cas+自旋 机制保证线程安全。</li></ul><p>多线程协助扩容触发的时机： </p><ol><li>当添加元素时，发现添加的元素对用的桶位为 fwd 节点，就会先去协助扩容，然后再添加元素</li><li>当添加完元素后，判断当前元素个数达到了扩容阈值，此时发现sizeCtl的值小于0，并且新数组不为空，这个时候，会去协助扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果是扩容线程，此时新数组为null</span></span><br><span class="line">    <span class="comment">//如果是帮助扩容的线程，此时nextTab不为null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">//两倍扩容创建新数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录线程开始迁移的桶位，从后往前迁移，指向最右边</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录新数组的末尾</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED）</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// advance：代表是否可以继续推进下一个槽位，只有当前槽位数据被迁移完成之后才可以设置为 true</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//i记录当前正在迁移桶位的索引值</span></span><br><span class="line">            <span class="comment">//bound记录下一次任务迁移的开始桶位</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//--i &gt;= bound 成立表示当前线程分配的迁移任务还没有完成</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算下一次任务迁移的开始桶位，并将这个值赋值给transferIndex</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有更多的需要迁移的桶位，就进入该if</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//扩容任务线程数减1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//判断当前所有扩容任务线程是否都执行完成</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//所有扩容线程都执行完，标识结束</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前迁移的桶位没有元素，直接在该位置添加一个fwd节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//当前节点已经被迁移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前节点需要迁移，加锁迁移，保证多线程安全</span></span><br><span class="line">            <span class="comment">//此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    ... <span class="comment">// 省略代码，和 HashMap 的扩容拷贝基本一致</span></span><br><span class="line">                    setTabAt(tab, i, fwd);</span><br><span class="line">                    advance = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap" target="_blank" rel="noopener">https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://yoursite.com/2022/04/04/Java/HashMap/"/>
    <id>http://yoursite.com/2022/04/04/Java/HashMap/</id>
    <published>2022-04-04T06:23:14.000Z</published>
    <updated>2022-09-11T07:30:35.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1. 基本数据结构"></a>1. 基本数据结构</h2><p>Node&lt;K, V&gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。<br>如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小<br>如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树</p><a id="more"></a><h2 id="2-加入的元素如何确定在数组中的-index"><a href="#2-加入的元素如何确定在数组中的-index" class="headerlink" title="2. 加入的元素如何确定在数组中的 index"></a>2. 加入的元素如何确定在数组中的 index</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把新加入的元素均匀分布到数组中，我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的. 但是jdk通过<code>h &amp; (table.length -1)</code>来得到该对象的保存位，这样运算会加快。</p><h2 id="3-如何扩容"><a href="#3-如何扩容" class="headerlink" title="3. 如何扩容"></a>3. 如何扩容</h2><p>将数组的容量扩大为原来的两倍，原数组长度为oldCap，下标j的元素会被分散到 数组j 和 j+oldCap 的位置。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab;</span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 数组下表位置如果是 红黑树，逻辑和下面的链表差不多</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">            <span class="comment">// 数组下表位置如果是 链表</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="comment">// 因为 oldCap 始终为2的倍数。 (e.hash &amp; oldCap) 只会有0或1两个值，由此决定是位置 j 还是 j+oldCap</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-扩容的时机"><a href="#4-扩容的时机" class="headerlink" title="4. 扩容的时机"></a>4. 扩容的时机</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><p>当size大于一个阈值的时候，就会开始扩容。 <code>threshold = length * loadFactor</code> 是数组长度*负载因子。 负载因子默认是0.75 ，注意这个length是table数组的长度而不是HashMap的整体size（为了保证获取元素的时间复杂度接近1）。</p><p>loadFactor 是时间复杂度和空间复杂度的权衡。 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><h2 id="5-HashMap是线程不安全的。HashTable是线程安全的。"><a href="#5-HashMap是线程不安全的。HashTable是线程安全的。" class="headerlink" title="5. HashMap是线程不安全的。HashTable是线程安全的。"></a>5. HashMap是线程不安全的。HashTable是线程安全的。</h2><p>HashTable的线程安全很粗暴，将所有的map操作加一个synchronized修饰。</p><p>参考：<br><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本数据结构&quot;&gt;&lt;a href=&quot;#1-基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. 基本数据结构&quot;&gt;&lt;/a&gt;1. 基本数据结构&lt;/h2&gt;&lt;p&gt;Node&amp;lt;K, V&amp;gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。&lt;br&gt;如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小&lt;br&gt;如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>transform和asm初探</title>
    <link href="http://yoursite.com/2022/03/21/Android/gradle/transform%E5%92%8Casm%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2022/03/21/Android/gradle/transform和asm初探/</id>
    <published>2022-03-21T13:54:26.000Z</published>
    <updated>2022-05-04T08:50:41.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义RouterTransform"><a href="#自定义RouterTransform" class="headerlink" title="自定义RouterTransform"></a>自定义RouterTransform</h2><p>Transform 是AGP官方提供的接口，在 class-&gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类</p><a id="more"></a><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>因为是安卓官方提供的能力，需要在 buildSrc 的 build.gradle 中 添加 google() 仓库和安卓构建工具的依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">    implementation <span class="string">"com.android.tools.build:gradle:3.5.3"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-RouterTranform"><a href="#编写-RouterTranform" class="headerlink" title="编写 RouterTranform"></a>编写 RouterTranform</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RouterMappingTransform"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要插桩的输入类型， 这里是类文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要插桩的范围, 这里是整个工程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否支持增量</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现</span><br><span class="line">     * @param transformInvocation</span><br><span class="line">     * @throws TransformException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation)</span><br><span class="line">        throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        super.transform(transformInvocation)</span><br><span class="line"></span><br><span class="line">        println("transform start")</span><br><span class="line"></span><br><span class="line">        def collector = new RouterMappingCollector()</span><br><span class="line"></span><br><span class="line">        // 遍历所有的输入</span><br><span class="line">        transformInvocation.inputs.each &#123;</span><br><span class="line">            // 把 文件夹 类型的输入，拷贝到目标目录</span><br><span class="line">            it.directoryInputs.each &#123; directoryInput -&gt;</span><br><span class="line">                def destDir = transformInvocation.outputProvider</span><br><span class="line">                    .getContentLocation(</span><br><span class="line">                        directoryInput.name,</span><br><span class="line">                        directoryInput.contentTypes,</span><br><span class="line">                        directoryInput.scopes,</span><br><span class="line">                        Format.DIRECTORY)</span><br><span class="line"></span><br><span class="line">                collector.collect(directoryInput.file)</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.file, destDir)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 把 JAR 类型的输入，拷贝到目标目录</span><br><span class="line">            it.jarInputs.each &#123; jarInput -&gt;</span><br><span class="line">                def dest = transformInvocation.outputProvider</span><br><span class="line">                    .getContentLocation(</span><br><span class="line">                        jarInput.name,</span><br><span class="line">                        jarInput.contentTypes,</span><br><span class="line">                        jarInput.scopes, Format.JAR)</span><br><span class="line">                collector.collectFromJarFile(jarInput.file)</span><br><span class="line">                println("transform jar input path $&#123;jarInput.file.absolutePath&#125;")</span><br><span class="line">                println("transform jar output path $&#123;dest.absolutePath&#125;")</span><br><span class="line">                FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        File mappingJarFile = transformInvocation.outputProvider.</span><br><span class="line">            getContentLocation(</span><br><span class="line">                "router_mapping",</span><br><span class="line">                getOutputTypes(),</span><br><span class="line">                getScopes(),</span><br><span class="line">                Format.JAR)</span><br><span class="line"></span><br><span class="line">        println("$&#123;getName()&#125;  mappingJarFile = $mappingJarFile")</span><br><span class="line"></span><br><span class="line">        if (mappingJarFile.getParentFile().exists()) &#123;</span><br><span class="line">            mappingJarFile.getParentFile().mkdirs()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mappingJarFile.exists()) &#123;</span><br><span class="line">            mappingJarFile.delete()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将生成的字节码，写入本地文件</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(mappingJarFile)</span><br><span class="line">        JarOutputStream jarOutputStream = new JarOutputStream(fos)</span><br><span class="line">        // CLASS_NAME = "com/imooc/router/mapping/generated/RouterMapping"</span><br><span class="line">        ZipEntry zipEntry =</span><br><span class="line">            new ZipEntry(RouterMappingByteCodeBuilder.CLASS_NAME + ".class")</span><br><span class="line">        jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">        println("transform collect class $&#123;collector.mappingClassName&#125;")</span><br><span class="line">        jarOutputStream.write(</span><br><span class="line">            // 写入字节码</span><br><span class="line">            RouterMappingByteCodeBuilder.get(collector.mappingClassName)</span><br><span class="line">        )</span><br><span class="line">        jarOutputStream.closeEntry()</span><br><span class="line">        jarOutputStream.close()</span><br><span class="line">        fos.close()</span><br><span class="line"></span><br><span class="line">        println("transform end")</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>transformInvocation.inputs.each {</code><br>表示遍历所有输入</li><li><code>it.directoryInputs.each { directoryInput -&gt;</code><br>表示遍历所有目录文件输入，directoryInput 是class文件的目录</li><li><code>it.jarInputs.each { jarInput -&gt;</code><br>遍历所有jar包输入， jarInput 是jar包</li><li><code>transformInvocation.outputProvider.getContentLocation(</code><br>获取具体的输入</li><li><code>collector.collect(directoryInput.file)</code><br>这里是一个自定义逻辑，表示从 class文件 或 jar包 中找到生成的 RouterMapping 路由映射类。 </li><li><p><code>FileUtils.copyFile(jarInput.file, dest)</code><br>拷贝文件到目标目录， 最终transform执行之后会在 /…项目目录/app/build/intermediates/transforms 中生成一个RouterMappingTransform目录。 需要吧class文件和jar包都拷贝过去。有意思是，我原本以为我们工程自己的代码应该都是 class文件，都在 <code>it.directoryInputs.each { directoryInput -&gt;</code> 这个输入里。 但是后来发现，只有 app工程是 class 文件，子工程打包成了 jar 包，和其他第三方库放在了一起</p></li><li><p>后面的代码都是动态生成了一个集合了所有子工程路由注册的路由类，使用asm写入了字节码</p></li></ul><p><strong>即使我们没有对文件做任何处理，我们仍然需要把输入文件拷贝到目标目录下，否则下一个Task就没有TansformInput，如果我们没有将input目录复制到output指定目录，会导致最后的打包的apk缺少class</strong></p><h2 id="注册transform"><a href="#注册transform" class="headerlink" title="注册transform"></a>注册transform</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterPlugin2</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (project.plugins.hasPlugin(AppPlugin)) &#123;</span><br><span class="line">            <span class="comment">// hasPlugin(AppPlugin) 表示这是 app 主工程</span></span><br><span class="line">            <span class="comment">// 注册进我们的 RouterTransform</span></span><br><span class="line">            <span class="keyword">def</span> extension = project.extensions.getByType(AppExtension)</span><br><span class="line">            extension.registerTransform(<span class="keyword">new</span> RouterTransform())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件也是需要注册的。。。在resource目录的方式注册。 不写了，网上搜一下吧。</p><h2 id="使用我们的-Router"><a href="#使用我们的-Router" class="headerlink" title="使用我们的 Router"></a>使用我们的 Router</h2><p>使用反射实例化我们的类即可<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// GENERATED_MAPPING = "com.imooc.router.mapping.generated.RouterMapping"</span></span><br><span class="line">    <span class="comment">// 注意上面原来文件"/"的分割要变成"."</span></span><br><span class="line">    <span class="keyword">val</span> clazz = Class.forName(GENERATED_MAPPING)</span><br><span class="line">    <span class="keyword">val</span> method = clazz.getMethod(<span class="string">"get"</span>)</span><br><span class="line">    <span class="keyword">val</span> allMapping = method.invoke(<span class="literal">null</span>) <span class="keyword">as</span> Map&lt;String, String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allMapping?.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"init: get all mapping:"</span>)</span><br><span class="line">        allMapping.onEach &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"    <span class="subst">$&#123;it.key&#125;</span> -&gt; <span class="subst">$&#123;it.value&#125;</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mapping.putAll(allMapping)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"init: error while init router : <span class="variable">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自定义RouterTransform&quot;&gt;&lt;a href=&quot;#自定义RouterTransform&quot; class=&quot;headerlink&quot; title=&quot;自定义RouterTransform&quot;&gt;&lt;/a&gt;自定义RouterTransform&lt;/h2&gt;&lt;p&gt;Transform 是AGP官方提供的接口，在 class-&amp;gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>自定义gradle插件</title>
    <link href="http://yoursite.com/2022/03/19/Android/gradle/%E8%87%AA%E5%AE%9A%E4%B9%89gradle%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/19/Android/gradle/自定义gradle插件/</id>
    <published>2022-03-19T09:52:18.000Z</published>
    <updated>2022-05-04T08:53:22.297Z</updated>
    
    <content type="html"><![CDATA[<p>这里只记录本地插件的写法</p><h2 id="创建-buildSrc-目录"><a href="#创建-buildSrc-目录" class="headerlink" title="创建 buildSrc 目录"></a>创建 buildSrc 目录</h2><a id="more"></a><ol><li>在创建的 buildScr 目录中创建 build.gradle 文件</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"groovy"</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置源码兼容性</span></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br></pre></td></tr></table></figure><p>上面是固定写法，这里只使用了 groovy 插件，所以我们的插件代码只支持用 groovy 编写</p><ol start="2"><li><p>在 buildSrc 目录中，创建对应的 groovy 目录<br>文件路径是<br>src/main/groovy/…(包名)/</p></li><li><p>创建 自定义的插件 RouterPlugin2</p></li></ol><p>创建文件名 RouterPlugin2.Plugin<br>创建插件类，并实现 Plugin 接口</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterPlugin2</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建 res 文件暴露自己的 groovy<br>创建文件路径：<br>src/main/resources/META-INF.gradle-plugins/RouterPlugin.properties</li></ol><p>内容如下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span>=<span class="title">com</span>.<span class="title">example</span>.<span class="title">test</span>.<span class="title">RouterPlugin2</span></span></span><br></pre></td></tr></table></figure></p><p>创建的文件名 META-INF.gradle-plugins 是固定目录名，xxxx.properties 中的xxxx就是对外暴露的插件的名字。 properties文件的内容表示插件的实现类</p><h2 id="外部使用插件"><a href="#外部使用插件" class="headerlink" title="外部使用插件"></a>外部使用插件</h2><ol><li>导入插件</li></ol><p>在业务的module的 build.gradle 文件中</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"RouterPlugin2"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>向插件写入参数</li></ol><p>在 buildSrc module 中创建一个 groovy 类，代表参数的model类</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterExtension2</span> &#123;</span></span><br><span class="line">    String wiki;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>插件类读取参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> extension = project.extensions.create(<span class="string">"router"</span>, RouterExtension2)</span><br><span class="line"><span class="keyword">def</span> path = extension.wiki</span><br></pre></td></tr></table></figure></li><li><p>在业务调用方传入参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">router &#123;</span><br><span class="line">    wiki <span class="string">"$&#123;getRootDir().absolutePath&#125;/router_wiki.md"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="RouterPlugin2-的详细实现"><a href="#RouterPlugin2-的详细实现" class="headerlink" title="RouterPlugin2 的详细实现"></a>RouterPlugin2 的详细实现</h2><p>插件中要实现三个功能</p><ol><li>在使用路由注解处理器的module，都向注解处理器插入一个参数，代表路由文件生成的路径。 </li><li>在项目clean时清除掉注解中间文件</li><li>将所有module生成的注解中间文件，汇总生成一个路由wiki文档</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterPlugin2</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"$TAG apply kotlin"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> routerFileDir = <span class="keyword">new</span> File(project.getRootDir(), <span class="string">"router_mapping"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * kapt &#123;</span></span><br><span class="line"><span class="comment">         *      rguments &#123;</span></span><br><span class="line"><span class="comment">         *          arg("router_mapping", rootProject.rootProjectDir.absolutePath）</span></span><br><span class="line"><span class="comment">         *      &#125;</span></span><br><span class="line"><span class="comment">         *  &#125;</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="comment">// 1. 自动帮助用户传递路径参数到注解处理器中 start</span></span><br><span class="line">        <span class="comment">// 以下代码可以替代以上的 build.gradle 配置</span></span><br><span class="line">        <span class="keyword">if</span> (project.extensions.findByName(<span class="string">"kapt"</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            project.extensions.findByName(<span class="string">"kapt"</span>).arguments &#123;</span><br><span class="line">                arg(<span class="string">"router_file_dir"</span>, routerFileDir)</span><br><span class="line">                arg(<span class="string">"project_name"</span>, project.name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 自动帮助用户传递路径参数到注解处理器中 end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 在clean时自动清理旧的构建产物</span></span><br><span class="line">        project.clean.doFirst &#123;</span><br><span class="line">            <span class="keyword">def</span> routerMappingFile = routerFileDir</span><br><span class="line">            <span class="keyword">if</span> (routerMappingFile.exists()) &#123;</span><br><span class="line">                routerMappingFile.deleteDir()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 集合各个子project路由信息，生成路由文档</span></span><br><span class="line">        <span class="keyword">def</span> extension = project.extensions.create(<span class="string">"router"</span>, RouterExtension2)</span><br><span class="line">        project.afterEvaluate &#123;</span><br><span class="line">            <span class="comment">// 在工程完成配置阶段之后才能获取到 外部配置的参数</span></span><br><span class="line">            <span class="keyword">def</span> wikiPath = extension.wiki</span><br><span class="line">            project.tasks.findAll &#123; task -&gt;</span><br><span class="line">                <span class="comment">// 找到编译的task，compileDebugJavaWithJavac</span></span><br><span class="line">                task.name.startsWith(<span class="string">"compile"</span>) &amp;&amp; task.name.endsWith(<span class="string">"JavaWithJavac"</span>)</span><br><span class="line">            &#125;.each &#123;task -&gt;</span><br><span class="line">                task.doLast &#123;</span><br><span class="line">                    <span class="keyword">def</span> wikiFile = <span class="keyword">new</span> File(wikiPath)</span><br><span class="line">                    <span class="keyword">if</span> (!wikiFile.exists()) &#123;</span><br><span class="line">                        wikiFile.createNewFile()</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">def</span> jsonFiles = routerFileDir</span><br><span class="line">                    jsonFiles.eachFile &#123;file -&gt;</span><br><span class="line">                        <span class="keyword">def</span> content = file.readBytes()</span><br><span class="line">                        wikiFile.append(<span class="keyword">new</span> String(content))</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// write jsonFile content into wikiPath</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里只记录本地插件的写法&lt;/p&gt;&lt;h2 id=&quot;创建-buildSrc-目录&quot;&gt;&lt;a href=&quot;#创建-buildSrc-目录&quot; class=&quot;headerlink&quot; title=&quot;创建 buildSrc 目录&quot;&gt;&lt;/a&gt;创建 buildSrc 目录&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>自定义注解处理器并发布为gradle组件</title>
    <link href="http://yoursite.com/2022/03/13/Android/gradle/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E5%B9%B6%E5%8F%91%E5%B8%83%E4%B8%BAgradle%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/13/Android/gradle/自定义注解处理器并发布为gradle组件/</id>
    <published>2022-03-13T07:27:24.000Z</published>
    <updated>2022-03-13T09:10:55.158Z</updated>
    
    <content type="html"><![CDATA[<p>自定义一个基于注解的路由框架</p><h2 id="定义注解类"><a href="#定义注解类" class="headerlink" title="定义注解类"></a>定义注解类</h2><ol><li>新建一个模块 router_annotations </li><li>在 router_annotations 目录中创建 build.gradle </li></ol><a id="more"></a><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin"</span> <span class="comment">// 使用 kotlin</span></span><br><span class="line"></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 发布脚本，后面会写</span></span><br><span class="line">apply <span class="string">from :</span> rootProject.file(<span class="string">"maven-publish.gradle"</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>定义注解类</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置使用注解的对象是 类</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.CLASS)</span></span><br><span class="line"><span class="comment">// 设置注解只在编译期存在</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.BINARY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>(</span><br><span class="line">    <span class="keyword">val</span> url: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="定义注解处理器模块"><a href="#定义注解处理器模块" class="headerlink" title="定义注解处理器模块"></a>定义注解处理器模块</h2><ol><li>新建一个模块 router_compile</li><li>在 router_compile 目录中创建 build.gradle</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin"</span> <span class="comment">// 使用kotlin插件</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin-kapt"</span> <span class="comment">// 使用kotlin注解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置源码兼容性</span></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(<span class="string">":router_annotations"</span>)</span><br><span class="line">    implementation <span class="string">"com.google.auto.service:auto-service:1.0-rc6"</span></span><br><span class="line">    kapt <span class="string">"com.google.auto.service:auto-service:1.0-rc6"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 发布脚本。后面会写</span></span><br><span class="line">apply <span class="string">from :</span> rootProject.file(<span class="string">"maven-publish.gradle"</span>)</span><br></pre></td></tr></table></figure><p>在注解处理器模块，如果使用kotlin写注解处理器代码，需要引用 <code>kotlin-kapt</code> 这个插件<br><code>implementation &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 使用google的一个注解框架。<br>同时还要加上 <code>kapt &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 。 这是kotlin的写法，如果是java，需要换成<br><code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code></p><ol start="3"><li>编写注解处理器<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService(Processor::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestinationProcessor</span> : <span class="type">AbstractProcessor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">"DestinationProcessor"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">set</span>: <span class="type">MutableSet</span>&lt;<span class="type">out</span> <span class="type">TypeElement</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        roundEnvironment: <span class="type">RoundEnvironment</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (roundEnvironment.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"<span class="variable">$TAG</span> &gt;&gt;&gt;&gt; process start"</span>)</span><br><span class="line"></span><br><span class="line">        println(<span class="keyword">set</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> destinationClasses = roundEnvironment.getElementsAnnotatedWith(Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">        println(TAG + <span class="string">" "</span> + destinationClasses.size)</span><br><span class="line">        <span class="keyword">if</span> (destinationClasses.size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> destinationClasses) &#123;</span><br><span class="line">            <span class="keyword">val</span> typeElement = element <span class="keyword">as</span> TypeElement</span><br><span class="line">            <span class="keyword">val</span> destination = typeElement.getAnnotation(Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">                ?: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">val</span> url = destination.url</span><br><span class="line">            <span class="keyword">val</span> className = typeElement.qualifiedName</span><br><span class="line">            println(<span class="string">"<span class="variable">$TAG</span> <span class="variable">$url</span> <span class="variable">$className</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"<span class="variable">$TAG</span> &gt;&gt;&gt;&gt; process finish"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> mutableSetOf(</span><br><span class="line">            Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">canonicalName</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@AutoService(Processor::class)</code> 是固定写法</p><p><code>AbstractProcessor</code> 继承这个抽象类。<br>重写<code>getSupportedAnnotationTypes</code>方法，返回需要处理的注解。<br>重写<code>process</code>方法，处理注解信息。 返回值为true表示已处理这个注解，相同的注解不会再被其他注解处理器处理。<br><code>roundEnvironment.processingOver()</code>表示之前已经有处理过一轮，此时<code>roundEnvironment.elements.size==0</code> 不是很明白gradle为什么会执行多轮。。。</p><h2 id="在本地使用注解"><a href="#在本地使用注解" class="headerlink" title="在本地使用注解"></a>在本地使用注解</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation project(<span class="string">":router_annotations"</span>)</span><br><span class="line">kapt project(<span class="string">":router_compile"</span>)</span><br></pre></td></tr></table></figure><h2 id="将注解处理器打包成组件并发布"><a href="#将注解处理器打包成组件并发布" class="headerlink" title="将注解处理器打包成组件并发布"></a>将注解处理器打包成组件并发布</h2><ol><li><p>在最外层的 build.properties 中写通用参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POM_URL=..<span class="regexp">/repo  /</span>/ 发布的仓库地址，这里是本地</span><br><span class="line">GROUP_ID=com.example.test <span class="comment">// group</span></span><br><span class="line">VERSION_NAME=<span class="number">1.0</span><span class="number">.0</span> <span class="comment">// 版本</span></span><br></pre></td></tr></table></figure></li><li><p>在 router_annotation 和 router_compile 中写 group_id</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 router_annotation build.properties</span></span><br><span class="line">POM_ARTIFACT_ID=router-test-annotation</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 router_compile build.properties</span></span><br><span class="line">POM_ARTIFACT_ID=router-test-processor</span><br></pre></td></tr></table></figure></li><li><p>编写发布脚本 maven-publish.gradle</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span> <span class="comment">// 引入maven插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根目录的 gradle.properties 中获取通用参数 start</span></span><br><span class="line"><span class="keyword">def</span> rootProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">rootProperties.load(<span class="keyword">new</span> FileInputStream(project.rootProject.file(<span class="string">"gradle.properties"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> versionName = rootProperties.getProperty(<span class="string">"VERSION_NAME"</span>)</span><br><span class="line"><span class="keyword">def</span> pomUrl = rootProperties.getProperty(<span class="string">"POM_URL"</span>) <span class="comment">// ../repo</span></span><br><span class="line"><span class="keyword">def</span> groupId = rootProperties.getProperty(<span class="string">"GROUP_ID"</span>)</span><br><span class="line"><span class="comment">// 获取通用参数 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前项目的 gradle.properties 中获取参数</span></span><br><span class="line"><span class="keyword">def</span> projectProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">projectProperties.load(<span class="keyword">new</span> FileInputStream(project.file(<span class="string">"gradle.properties"</span>)))</span><br><span class="line"><span class="keyword">def</span> pomArtifactId = projectProperties.getProperty(<span class="string">"POM_ARTIFACT_ID"</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"maven-publish $versionName $pomUrl $groupId $pomArtifactId"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写maven的发布任务</span></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(<span class="string">url:</span> uri(pomUrl)) &#123;</span><br><span class="line">                pom.groupId = groupId</span><br><span class="line">                pom.artifactId = pomArtifactId</span><br><span class="line">                pom.version = versionName</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pom.whenConfigured &#123; pom -&gt;</span><br><span class="line">                pom.dependencies.forEach &#123; dep -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (dep.getVersion() == <span class="string">"unspecified"</span>) &#123;</span><br><span class="line">                        dep.setGroupId(groupId)</span><br><span class="line">                        dep.setVersion(versionName)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意有一个 <code>pom.whenConfigured { pom -&gt; ...</code> 的代码，这是因为 router_compile 应用到了 router_annotations 模块。如果不做处理，发布之后， router_comiple 模块是找不到 router_annotations 的正确位置和版本的。所以要强制制定</p><h2 id="执行发布任务"><a href="#执行发布任务" class="headerlink" title="执行发布任务"></a>执行发布任务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :router_compile:uploadArchives</span><br><span class="line">./gradlew :router_annotations:uploadArchives</span><br></pre></td></tr></table></figure><p>我们设置的 <code>POM_URL=../repo</code> 所以最终会在项目的repo目录里生成aar包。 </p><h2 id="使用发布后的组件"><a href="#使用发布后的组件" class="headerlink" title="使用发布后的组件"></a>使用发布后的组件</h2><ol><li>首先，moven本地仓库地址加入到工程里<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>buildscript.repositories 和 allprojects.repositories 都要加，这样才会应用到所有子工程</p><ol start="2"><li><p>在app模块里引用组件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"com.example.test:router-test-annotation:1.0.0"</span></span><br><span class="line">kapt <span class="string">"com.example.test:router-test-processor:1.0.0"</span></span><br></pre></td></tr></table></figure></li><li><p>gradle版本的区别</p></li></ol><p>在 gradle 7.+ 版本有很多东西不兼容，上述实现只有在 gradle 6.+ 的版本有效。 gradle 的版本升级和项目创建还是要谨慎一些。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自定义一个基于注解的路由框架&lt;/p&gt;&lt;h2 id=&quot;定义注解类&quot;&gt;&lt;a href=&quot;#定义注解类&quot; class=&quot;headerlink&quot; title=&quot;定义注解类&quot;&gt;&lt;/a&gt;定义注解类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;新建一个模块 router_annotations &lt;/li&gt;
&lt;li&gt;在 router_annotations 目录中创建 build.gradle &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>MultiDex原理</title>
    <link href="http://yoursite.com/2021/12/25/Android/Framework/MultiDex%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2021/12/25/Android/Framework/MultiDex原理/</id>
    <published>2021-12-25T10:20:52.000Z</published>
    <updated>2021-12-25T11:04:06.178Z</updated>
    
    <content type="html"><![CDATA[<p>apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.<br>为了规避安卓项目编译65536最大方法数的限制，需要做分dex</p><a id="more"></a><h2 id="1-Dalvik-和-ART-虚拟机的区别"><a href="#1-Dalvik-和-ART-虚拟机的区别" class="headerlink" title="1. Dalvik 和 ART 虚拟机的区别"></a>1. Dalvik 和 ART 虚拟机的区别</h2><p>Android5.0以上系统使用 ART 虚拟机，5.0以下使用 Dalvik 虚拟机</p><p>Dalvik 编译策略是 JIT 技术。JIT意思是Just In Time Compiler，就是即时编译技术。<br>JIT是运行时编译，是动态编译，可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间可以加快Dalvik运行速度。每次运行都需要重新编译。</p><p>AOT是指”Ahead Of Time”，与”Just In Time”不同，从字面来看是说提前编译。<br>AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex预编译，一次性将所有dex代码转换为机器码，每次运行程序的时候不用重新编译。 </p><p>Android 7.0上，JIT 编译器被再次使用，采用AOT/JIT 混合编译的策略，特点是：</p><p>应用在安装的时候dex不会再被编译<br>App运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息。<br>手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译</p><h2 id="2-不同虚拟机在-MultiDex-的区别。"><a href="#2-不同虚拟机在-MultiDex-的区别。" class="headerlink" title="2. 不同虚拟机在 MultiDex 的区别。"></a>2. 不同虚拟机在 MultiDex 的区别。</h2><ul><li>Andorid 5.0 之后，ART天然支持从apk文件中加载多个.dex文件，在应用安装期间，它会执行一个预编译操作。将所有的dex编译成一个单一的.oat文件，在应用运行是去加载这个.oat文件，而不是一个一个的加载.dex文件。<br>所以我们只需要 在 gradle 开启 multiDexEnabled true 即可</li><li>Dalvik 使用的 JIT ，JIT每次运行都需要重新编译。 所以我们需要在应用启动时手动去一个一个加载 dex 文件</li></ul><h2 id="3-在-Dalvik-加载多dex"><a href="#3-在-Dalvik-加载多dex" class="headerlink" title="3. 在 Dalvik 加载多dex"></a>3. 在 Dalvik 加载多dex</h2><p>简单来说 hook PathClassLoader 。</p><ol><li>获取到所有的dex文件</li><li>通过反射拿到DexPathList的Element数组，把dex添加到 Element数组中</li></ol><p>通过这样的方式也可以实现热热修复，将修改后的新class打包成一个dex， 然后通过反射将 新dex插入到 PathClassLoader 中的 element数组最前面。从而实现对旧类的覆盖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.&lt;br&gt;为了规避安卓项目编译65536最大方法数的限制，需要做分dex&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>技术Owner的职责</title>
    <link href="http://yoursite.com/2021/11/27/%E6%8A%80%E6%9C%AFOwner%E7%9A%84%E8%81%8C%E8%B4%A3/"/>
    <id>http://yoursite.com/2021/11/27/技术Owner的职责/</id>
    <published>2021-11-27T07:58:24.000Z</published>
    <updated>2021-11-27T08:09:40.100Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参与需求评审，完成可行性调研，完善细节。<ul><li>要督促完成UI/UE评审，埋点评审</li></ul></li><li>技术评审，输出技术方案，拆分需求子任务，给出详细排期</li><li>开始开发，定期站会，同步风险<ul><li>发生变更，更改排期</li><li>需求提测前，推进case评审</li><li>自测</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;参与需求评审，完成可行性调研，完善细节。&lt;ul&gt;
&lt;li&gt;要督促完成UI/UE评审，埋点评审&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术评审，输出技术方案，拆分需求子任务，给出详细排期&lt;/li&gt;
&lt;li&gt;开始开发，定期站会，同步风险&lt;ul&gt;
&lt;li&gt;发生变更
      
    
    </summary>
    
    
  </entry>
  
</feed>
