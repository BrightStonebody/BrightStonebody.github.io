<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[handler机制源码解析]]></title>
    <url>%2F2019%2F11%2F09%2FAndroid%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2Fhandler%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Handler机制源码解析因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。 1. Looper主要是loop()方法123456789101112131415161718192021222324public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. // 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中. // 只有调用quit方法时,next()方法再能真正的返回null return; &#125; try &#123; // msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方 msg.target.dispatchMessage(msg); &#125; finally &#123; ... // 省略代码 &#125; msg.recycleUnchecked(); &#125;&#125; 2. MessageQueue关键成员变量12345678910111213141516171819// mPtr是native的MessageQueue的指针private long mPtr; // used by native code// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个messageMessage mMessages;// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;();private IdleHandler[] mPendingIdleHandlers;private SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;private boolean mQuitting;// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.private boolean mBlocked;// The next barrier token.// Barriers are indicated by messages with a null target whose arg1 field carries the token.private int mNextBarrierToken; 构造方法1234MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; next()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 调用native层的方法,使用epoll机制,挂起当前线程. // nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; // 获取链表的头结点,即第一个message Message msg = mMessages; // 判断msg是否为同步栅栏 // 表示同步栅栏的msg, 其msg.target为null if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. // 寻找队列中第一个异步message do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // 因为上面一旦找到msg,直接return,所以执行到这里已经msg一定为null // msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到 // Process the quit message now that all pending messages have been handled. // 判断是否需要结束循环 if (mQuitting) &#123; // dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0 // 只有在这里next()方法才会返回null dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. // 当获取到的message为空, 或者message的执行时间没有到 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. // 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. // 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 1. nativePollOnce(ptr, nextPollTimeoutMillis);这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间.特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.nextPollTimeoutMillis = -1 出现的时机两种情况: 消息队列为空 遇到了同步barrier, 并且之后没有遇到异步的msg 2. IdleHandler:1234567891011public static interface IdleHandler &#123; /** * Called when the message queue has run out of messages and will now * wait for more. Return true to keep your idle handler active, false * to have it removed. This may be called if there are still messages * pending in the queue, but they are all scheduled to be dispatched * after the current time. */ // queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次 boolean queueIdle();&#125; MessageQueue中有两个IdleHandler的集合, IdleHandler是一个接, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到) 3. 同步栅栏 Barrier 定义: target为null的msg为同步栅栏 作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg 意义: 相当于为msg添加了一个优先级 quit()123456789101112131415161718192021void quit(boolean safe) &#123; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; if (safe) &#123; // 这个方法会去除所有的msg.when &gt; now 的msg removeAllFutureMessagesLocked(); &#125; else &#123; // 没有任何判断, 直接去除所有的msg removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. // 因为在next()方法中才会调用dispose()方法销毁消息队 // 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法 nativeWake(mPtr); &#125;&#125; nativeWake(mPtr)123456789101112131415161718192021222324252627282930313233343536373839404142434445boolean enqueueMessage(Message msg, long when) &#123; ... // 省略代码 synchronized (this) &#123; if (mQuitting) &#123; msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 1. 插入顺序:之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序 2. needWake判断是否需要唤醒线程.needWake=true的具体时机, 可以翻上面nativePollOnce中出现永久阻塞的时机]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RemoteView刷新view]]></title>
    <url>%2F2019%2F09%2F15%2FAndroid%2FRemoteView%E5%88%B7%E6%96%B0View%2F</url>
    <content type="text"><![CDATA[RemoteView刷新View通知栏在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。 在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了 关于Intent由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。 在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。 也就是说，Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView全局刷新view避免卡顿]]></title>
    <url>%2F2019%2F09%2F15%2FAndroid%2FRecyclerView%E5%85%A8%E5%B1%80%E5%88%B7%E6%96%B0view%E9%81%BF%E5%85%8D%E5%8D%A1%E9%A1%BF%2F</url>
    <content type="text"><![CDATA[RecyclerView全局刷新View避免卡顿onBindViewHolder(VH holder, int position， List payloads)这个方法默认是调用普通的onBindViewHolder方法。我们可以重写这个方法，在payloads参数为空时，执行默认的onBindViewHolder，在其不为空时，刷新每个item特定的view在调用notifyxxxx类似方法的时候，调用包含payload参数的重载方法 问题：实践了上面的方法，发现卡顿的问题得到了缓解，但是并没有完全解决 创建并操作自己的ViewHolder缓存还是有卡顿的原因：在调用notifyxxxx相关方法时，即使添加了payload参数，依然会有很多item刷新时走onCreateViewHolder方法，在这里进行inflate操作会非常耗时。所以要想办法跳过onCreateViewHolder方法 创建自己的viewholder缓存 创建缓存集合 1private List&lt;ViewHolder&gt; holderList = new ArrayList&lt;&gt;(); 添加到集合 1234holder.itemView.setTag(itemData));if (!holderList.contains(holder)) &#123; holderList.add(holder);&#125; 因为在添加之前做了是否包含的判断，所以集合中按道理之后包含显示的ViewHolder以及缓存的ViewHolder，集合的size并不会无限制的增长。 刷新123456public void update()&#123; for (ViewHolder holder : holderList) &#123; ItemData itemData = (ItemData) holder.itemView.getTag(); // update view &#125;&#125; 卡顿问题解决]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView缓存机制总结]]></title>
    <url>%2F2019%2F08%2F15%2FAndroid%2FRecyclerView%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[RecyclerView缓存机制总结基本概念scrapped:A “scrapped” view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse RecyclerView中涉及到缓存的集合 mAttachedScrap 显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。 mChangedScrap 显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生 mCachedViews 在屏幕外的Holder。缓存，幕刃大小为2。 mRecyclerPool 在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法 mAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。mRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。 RecyclerView获取Holder的顺序(sdk 28) getChangedScrapViewForPosition getScrapOrHiddenOrCachedHolderForPosition getScrapOrCachedViewForId getChildViewHolder mViewCacheExtension.getViewForPositionAndType getRecycledViewPool().getRecycledView mAdapter.createViewHolder 四级缓存 mAttachedScrap mChangedScrap mCacheView mViewCacheExtension mRecyclerPool ListView的缓存机制缓存的集合 mActiveViews 屏幕内的view，可直接重用 mScrapViews 屏幕外的view，需要调用bind 与RecyclerView的不同 缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。 RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView） RecyclerView可以实现局部刷新， ListView不行 参考：RecyclerView源码分析缓存机制 RecyclerView的缓存机制 Android ListView 与 RecyclerView 对比浅析–缓存机制]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发机制]]></title>
    <url>%2F2019%2F08%2F13%2FAndroid%2F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[事件分发机制dispatchTouchEventViewGroup 的 dispatchTouchEvent 方法伪代码1234567891011public boolean dispatchTouchEvent()&#123; boolean consume = false; if (onInterceptTouchEvent(ev))&#123; consume = super.dispatchTouchEvent(); &#125;else&#123; consume = child.dispatchTouchEvent(ev); if (!consume) consume = super.dispatchTouchEvent(ev) &#125; return consume;&#125; 解释：在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理 源代码dispatchTouchEvent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// Handle an initial down.if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. // 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null cancelAndClearTouchTargets(ev); resetTouchState();&#125;// Check for interception.final boolean intercepted;// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素// mFirstTouchTarget赋值在addTouchTarget方法中if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125;.... //省略代码// Check for cancelation.final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;// Update list of touch targets for pointer down, if needed.final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;TouchTarget newTouchTarget = null;boolean alreadyDispatchedToNewTouchTarget = false;if (!canceled &amp;&amp; !intercepted) &#123; ... //省略部分代码 for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; ... //省略部分代码 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; ... // 省略部分代码 if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. // 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环 .... // 省略部分代码 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; ... //省略代码 &#125; ... // 省略部分代码&#125;... // 省略部分代码// Dispatch to touch targets.if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. // 说明没有子view消费掉这个事件，所以交给父类处理 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; else &#123; ... // 省略代码&#125; dispatchTransformedTouchEvent12345678910111213141516171819private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理 final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; ... // 省略代码&#125; addTouchTargetmFirstTarget 赋值的地方 123456private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;&#125; 需要注意的点ActionDown ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理 ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位 ActionMove、ActionUp 等其他事件 若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截 若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理 (以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到) requestDisallowInterceptTouchEvent(true) 子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。 但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位 View 的 dispatchTouchEvent 方法如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法 123456789101112131415161718public boolean dispatchTouchEvent(MotionEvent event) &#123; ... // 省略代码 ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; ... // 省略代码 return result;&#125;]]></content>
      <tags>
        <tag>View</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LayoutInflater解析]]></title>
    <url>%2F2019%2F08%2F13%2FAndroid%2FLayoutInflater%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LayoutInflater解析源码1View result = root; 12345678910111213// Temp is the root view that was found in the xmlfinal View temp = createViewFromTag(root, name, inflaterContext, attrs);ViewGroup.LayoutParams params = null;if (root != null) &#123; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125;&#125; 123456789101112131415// Inflate all children under temp against its context.rInflateChildren(parser, temp, attrs, true);// We are supposed to attach all the views we found (int temp)// to root. Do that now.if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params);&#125;// Decide whether to return the root that was passed in or the// top view found in xml.if (root == null || !attachToRoot) &#123; result = temp;&#125; 1return result; 使用方法1LayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ; 第一个参数是layout资源文件id 第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam 第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中 需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view]]></content>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scale动画组合使用的坑]]></title>
    <url>%2F2019%2F08%2F02%2FAndroid%2FScale%E5%8A%A8%E7%94%BB%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Scale动画组合使用的坑API1Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0); 参数1: X的初始值参数2: X的最终值参数3: Y的初始值参数4: Y的最终值参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放参数6: X轴缩放轴点，1f表示以View的最右端为轴点参数7: Y轴，同参数5参数8: Y轴，同参数6 问题一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小1234567891011121314// start animation AnimationSet animationSet = new AnimationSet(false); Animation alpha = new AlphaAnimation(0, 100); alpha.setDuration(80); Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0); scale.setDuration(160); scale.setInterpolator(PathInterpolatorCompat.create(0.32f, 0.66f, 0.6f, 1f)); Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0); scale2.setDuration(70); scale2.setStartOffset(160); animationSet.addAnimation(scale); animationSet.addAnimation(scale2); animationSet.addAnimation(alpha); tv.startAnimation(animationSet); 但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小 原因scale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子123Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);scale2.setDuration(70);scale2.setStartOffset(160);]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal]]></title>
    <url>%2F2019%2F07%2F22%2FJava%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal作用当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量 源码分析set()12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; createMap()方法：123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 查看Thread类的代码：123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value get()方法12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; 其中的ThreadLocalMap.Entry123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己 总结Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Text相关计算]]></title>
    <url>%2F2019%2F07%2F19%2FAndroid%2FText%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[Text相关计算Text的相关属性Baseline上方的值为正，下方的值为负 TextSize和TextView大小的转换相关参数包括： 所使用字体(fallback的话不影响)的UPM(Units Per EM) ascent/descent属性 top/bottom参数 禁止includePadding时, TextView实际占据高度是 (ascent - descent) / UPM * textSize 开启includePadding时, TextView实际占据高度是 (top - bottom) / UPM * textSize 参考Paint 绘制文字属性TextView文字实际高度分析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView设置item的间距]]></title>
    <url>%2F2019%2F07%2F09%2FAndroid%2FRecyclerView%E8%AE%BE%E7%BD%AEitem%E7%9A%84%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[RecyclerView设置item的间距关于GridLayoutManager当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，实际上就是将屏幕均分为四份，每一份都是180px宽（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。 自定义ItemDecorationgetItemOffsets方法设置ItemView的内嵌偏移长度 ItemView 外面会包裹着一个矩形（outRect）内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔相当于为item添加了padding 常用的getItemOffsets的计算 123456789101112131415161718192021222324252627282930313233343536373839// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等public class EmojiItemDecoration extends RecyclerView.ItemDecoration &#123; private int mNumColumn; private int mVerticalSpacing; private int mItemWidth; private int mItemHorizontalSpacing; private boolean mInitSpacing = false; public EmojiItemDecoration(int column, int itemWidth, int verticalSpacing) &#123; mNumColumn = column; mItemWidth = itemWidth; mVerticalSpacing = verticalSpacing; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; if (!mInitSpacing) &#123; mInitSpacing = true; int parentWidth = parent.getWidth(); mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + 1); &#125; int position = parent.getChildAdapterPosition(view); int column = position % mNumColumn; outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn; outRect.right = (column + 1) * mItemHorizontalSpacing / mNumColumn; if (position &lt; mNumColumn) &#123; outRect.top = Dimensions.pxFromDp(12); &#125; if (position &gt;= mNumColumn) &#123; outRect.top = mVerticalSpacing; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[startService()和bindService()]]></title>
    <url>%2F2019%2F07%2F04%2FAndroid%2FstartService-%E5%92%8CbindService%2F</url>
    <content type="text"><![CDATA[startService()和bindService()的区别 生命周期上的差别startService()执行startService时，Service经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。 多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。但是每次调用startService，onStartCommand方法都会被调用。无论startService调用多少次，stopService只需要调用一次就能够终止Service BindService()bindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。 onBind返回值是null调用bindService开启服务，生命周期执行的方法依次是：onCreate() ==&gt; onBind();调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。 onBind返回值不为null这时候调用bindService开启服务，生命周期执行的方法依次是：onCreate() ==&gt; onBind() ==&gt; onServiceConnected();可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。总结第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。 既使用startService又使用bindService的情况如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。 参考链接:https://my.oschina.net/tingzi/blog/376545https://www.jianshu.com/p/d870f99b675c]]></content>
      <categories>
        <category>Android</category>
        <category>Service</category>
      </categories>
      <tags>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrollBy(),scrollTo()和Scroller]]></title>
    <url>%2F2019%2F06%2F16%2FAndroid%2FscrollBy-scrollTo-%E5%92%8CScroller%2F</url>
    <content type="text"><![CDATA[scrollBy(),scrollTo()和Scroller作用用于对View进行滚动注意： 滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）比如：TextView滚动的是内部的text而不是整个view 滚动的方向与坐标轴正方向相反比如：scrollBy(20,0)最后显示，view会向左移动因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码) scrollBy() 和 scrollTo()的区别scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。 Scroller利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移 使用步骤Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤： 创建Scroller的实例 调用startScroll()方法来初始化滚动数据并刷新界面 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 代码：实现自定义的简单ViewPager123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.example.work3;import android.content.Context;import android.support.v4.view.ViewConfigurationCompat;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.ViewConfiguration;import android.view.ViewGroup;import android.widget.Scroller;public class ScrollLayout extends ViewGroup &#123; private final String TAG = "test_scroll"; private Scroller mScroller; // 可以判定为拖动的最小滑动距离 private int mTouchSlop; // 落下的屏幕坐标 private float mXDown; // 当前的屏幕坐标 private float mXMove; // 上一次Action_MMOVE的屏幕坐标 private float mLastMove; // 界面可滑动的左边界 private int mLeftBorder; // 界面可滑动的右边界 private int mRightBorder; public ScrollLayout(Context context) &#123; super(context); init(context); &#125; public ScrollLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; public ScrollLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; mScroller = new Scroller(context); // 获取系统定义的mTouchSlop值 mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context)); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec); &#125; &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (!changed) return; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); childView.layout(i * childView.getMeasuredWidth(), 0, (i + 1) * childView.getMeasuredWidth(), childView.getMeasuredHeight()); &#125; // 初始化左右边界 mLeftBorder = getChildAt(0).getLeft(); mRightBorder = getChildAt(childCount - 1).getRight(); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: mXDown = ev.getRawX(); mLastMove = mXDown; break; case MotionEvent.ACTION_MOVE: mXMove = ev.getRawX(); float diff = Math.abs(mXMove - mXDown); mLastMove = mXMove; // 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件 if (diff &gt; mTouchSlop) &#123; return true; &#125; break; case MotionEvent.ACTION_UP: break; default: break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: &#123; mXMove = event.getRawX(); int scrolledX = (int) (mLastMove - mXMove); if (getScrollX() + scrolledX &lt; mLeftBorder) &#123; scrollTo(mLeftBorder, 0); return true; &#125; else if (getScrollX() + scrolledX + getWidth() &gt; mRightBorder) &#123; scrollTo(mRightBorder - getWidth(), 0); return true; &#125; // view随着手指的拖动进行滚动 scrollBy(scrolledX, 0); Log.i(TAG, "onTouchEvent: " + getChildAt(1).getLeft()); mLastMove = mXMove; break; &#125; case MotionEvent.ACTION_UP: &#123; // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面 int targetIndex = (getScrollX() + getWidth() / 2) / getWidth(); int dx = targetIndex * getWidth() - getScrollX(); // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面 mScroller.startScroll(getScrollX(), 0, dx, 0); // 对view重绘 invalidate(); break; &#125; &#125; return super.onTouchEvent(event); &#125; @Override public void computeScroll() &#123; // computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法 if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); // 对view重绘 invalidate(); &#125; &#125;&#125; getScrollX()方法返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。原点（0，0）是初始化时内容显示的位置。 参考Android getScrollX()详解 Android Scroller完全解析，关于Scroller你所需知道的一切]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql配置相关]]></title>
    <url>%2F2019%2F05%2F04%2FLinux%2Fmysql%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[1. 尽量使用MariaDB而不是mysql之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了 而且，mysql的命令行终端很明显有bug，没有MariaDB好用 2. MariaDB更新密码mariadb的安装可以查看官网，上面有yum安装的教程。安装之后默认是没有密码的。需要更新密码。另外，发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的 中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ‘‘@’localhost’之类的报错。没有找到原因和解决办法，最后是直接重置了vps 1. mysql_secure_installation 命令安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码 2. 登陆mysql更改密码12345678# 2.1 更新 mysql 库中 user 表的字段：use mysql; UPDATE user SET password=password('newpassword') WHERE user='root'; flush privileges; exit; # 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法SET password for 'root'@'localhost'=password('newpassword'); 3. mysql配置远程登录1. 给用户远程登录权限：12345use mysqlupdate user set host='%' where user ='root';FLUSH PRIVILEGES;grant all privileges on *.* to root@'%' identified by "password";FLUSH PRIVILEGES; root可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码 使用以下命令可以查看用户的登录权限 1select host,user,password,plugin from user; 注意root密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。可以使用如下命令更改加密方式： 1update user set plugin='mysql_native_password' where user='root'; 2. lnmp环境配置iptableslnmp一键安装环境默认是禁用iptables远程登录的， 查看iptables规则：1iptables -L -n --line-numbers 输入样例如下：可以看到3306端口的target为drop 删除对应的drop规则 1iptables -D INPUT 5 iptables的使用参考：https://www.vpser.net/security/linux-iptables.html 3.非集成centos环境开放3306端口centos-7以上firewalld 防火墙（centos-7）运行命令,并重启： 12firewall-cmd --zone=public --add-port=3306/tcp --permanentfirewall-cmd --reload centos-7以前iptables 防火墙（centos6.5及其以前）运行命令 1vim /etc/sysconfig/iptables 在文件内添加下面命令行，然后重启 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT 1service iptables restart]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apt常用命令]]></title>
    <url>%2F2019%2F05%2F02%2FLinux%2Fapt%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[apt常用命令参考：apt命令安装指定版本 更新 sudo apt-get update //更新源sudo apt-get upgrade //更新已安装的包sudo apt-get dist-upgrade //升级系统sudo apt-get dselect-upgrade //使用 dselect 升级 查询 apt-cache search package//搜索包 apt-cache show package//获取包的相关信息，如说明、大小、版本等 apt-cache depends package//了解使用依赖apt-cache rdepends package//是查看该包被哪些包依赖 12345apt-cache madison &lt;package name&gt; //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。apt-cache policy &lt;&lt;package name&gt;&gt; /*将列出所有来源的版本。信息会比上面详细一点*/apt-show-versions -a &lt;&lt;package name&gt;&gt; //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u &lt;&gt;来查询是否有升级版本。 安装 sudo apt-get install package//安装包 sudo apt-get install package - - reinstall//重新安装包 sudo apt-get -f install//修复安装 (“-f = ——fix-missing”) 删除sudo apt-get remove package删除包 sudo apt-get remove package - - purge删除包，包括删除配置文件等sudo apt-get clean &amp;&amp; sudo apt-get autoclean清理无用的包sudo apt-get check检查是否有损坏的依赖 其他 sudo apt-get build-dep package安装相关的编译环境apt-get source package下载该包的源代码]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为手机的内存泄露]]></title>
    <url>%2F2019%2F04%2F19%2FAndroid%2F%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[华为手机的内存泄露最近在开发的时候，使用我的华为手机做真机调试，发现LeakCanary一直有内存泄露报出。一开始我以为是我使用MVP模式开发导致的，使用WeakReference和一些其他的处理之后，发现这个内存泄露还是存在。然后我用模拟器调试，发现模拟器竟然没有内存泄漏报出。想到这可能是手机的问题。应该是国内手机厂商对系统的魔改造成的。 我的手机系统是华为EMUI9.0 &amp;&amp; Android9.0 以下是我找到的网上的解决方案： 参考链接https://www.jianshu.com/p/95242060320f inputMethodManager.mLastSrvView泄露123456789101112131415161718192021222324252627282930313233public class FixMemLeak &#123; private static Field field; private static boolean hasField = true; public static void fixLeak(Context context) &#123; if (!hasField) &#123; return; &#125; InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); if (imm == null) &#123; return; &#125; String[] arr = new String[]&#123;"mLastSrvView"&#125;; for (String param : arr) &#123; try &#123; if (field == null) &#123; field = imm.getClass().getDeclaredField(param); &#125; if (field == null) &#123; hasField = false; &#125; if (field != null) &#123; field.setAccessible(true); field.set(imm, null); &#125; &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;&#125; 在BaseActivity的onDestroy()方法里执行这个fexLeak()方法，然后所有的Activity继承BaseActivity。然后就没有报错了 Toast$TN.mWM 泄露泄露出现在显示一个Toast之后。这个就更迷了，网上我没有找到相关的解释。同样的在模拟器上没有出现这样的内存泄露。 最终的解决方法是：在使用Toast时，传入的Context参数使用ApplicationContext而不是Activity。然后就没有内存泄露报出了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity class {} does not exist]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid%2FActivity-class-does-not-exist%2F</url>
    <content type="text"><![CDATA[Activity class {} does not exist有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。 解决办法：使用adb命令1adb uninstall [包名] 估计可能是调试的APP没有彻底卸载造成的。]]></content>
      <categories>
        <category>Android</category>
        <category>AndroidStudio</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVP模式防止内存泄露]]></title>
    <url>%2F2019%2F04%2F15%2FAndroid%2FMVP%E6%A8%A1%E5%BC%8F%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[MVP模式防止内存泄露参考链接https://jocherch.github.io/mvp/mvp-memory-leak/https://blog.csdn.net/Xiong_IT/article/details/52610729 发生内存泄露的原因由于Presenter经常性地需要执行一些耗时的操作，例如，我们经常使用的网络请求数据。当 Presenter 持有了 Activity 的强引用，如果在请求结束之前，Activity 被销毁了，那么由于网络请求还没有返回，导致 Presenter 一直持有 Activity 对象的引用，使得该对象无法被系统回收，此时就发生了内存泄露。 解决方案：通过弱引用和 Activity / Fragment 的生命周期来解决这个问题。 Model12345interface BaseMvpModel&#123; public void mvpCancleTasks(); // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api &#125; View123456789101112interface BaseMvpView&#123; public void mvpDetachView(); /* 例如 @Override public void onDestroy() &#123; super.onDestroy(); mPresenter.mvpDestroy(); mPresenter = null; &#125; */&#125; Presenter123456789101112interface BaseMvpPresenter&#123; public void mvpDestory(); /*例如: public void mvpDestory() &#123; view = null; if(modle != null) &#123; modle.mvpaCncleTasks(); modle = null; &#125; &#125; */&#125; 这里只是创建了一个BaseInterface用于让mvp的接口去继承，没有做更加详细的封装，仅仅由于提示。主要是不同的模块处理可能会有不同的操作 注意要使用WeakReference并不是在任何情况下Activity的onDestroy都会被调用（其它原因导致Activity对象还在被引用，就不会回调onDestroy方法），一旦这种情况发生，弱引用也能够保证不会造成内存泄露。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>内存泄露</tag>
        <tag>MVP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity管理类的封装]]></title>
    <url>%2F2019%2F04%2F14%2FAndroid%2FActivity%E7%AE%A1%E7%90%86%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[使用场景有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的 我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class FinishActivityManager extends BaseActivity &#123; private FinishActivityManager() &#123; &#125; private static FinishActivityManager sManager; private Stack&lt;WeakReference&lt;Activity&gt;&gt; mActivityStack; public static FinishActivityManager getManager() &#123; if (sManager == null) &#123; synchronized (FinishActivityManager.class) &#123; if (sManager == null) &#123; sManager = new FinishActivityManager(); &#125; &#125; &#125; return sManager; &#125; /** * 添加Activity到栈 * @param activity */ public void addActivity(Activity activity) &#123; if (mActivityStack == null) &#123; mActivityStack = new Stack&lt;&gt;(); &#125; mActivityStack.add(new WeakReference&lt;&gt;(activity)); &#125; /** * 检查弱引用是否释放，若释放，则从栈中清理掉该元素 */ public void checkWeakReference() &#123; if (mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity temp = activityReference.get(); if (temp == null) &#123; it.remove(); &#125; &#125; &#125; &#125; /** * 获取当前Activity（栈中最后一个压入的） * @return */ public Activity currentActivity() &#123; checkWeakReference(); if (mActivityStack != null &amp;&amp; !mActivityStack.isEmpty()) &#123; return mActivityStack.lastElement().get(); &#125; return null; &#125; /** * 关闭当前Activity（栈中最后一个压入的） */ public void finishActivity() &#123; Activity activity = currentActivity(); if (activity != null) &#123; finishActivity(activity); &#125; &#125; /** * 关闭指定的Activity * @param activity */ public void finishActivity(Activity activity) &#123; if (activity != null &amp;&amp; mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity temp = activityReference.get(); // 清理掉已经释放的activity if (temp == null) &#123; it.remove(); continue; &#125; if (temp == activity) &#123; it.remove(); &#125; &#125; activity.finish(); &#125; &#125; /** * 关闭指定类名的所有Activity * @param cls */ public void finishActivity(Class&lt;?&gt; cls) &#123; if (mActivityStack != null) &#123; // 使用迭代器进行安全删除 for (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123; WeakReference&lt;Activity&gt; activityReference = it.next(); Activity activity = activityReference.get(); // 清理掉已经释放的activity if (activity == null) &#123; it.remove(); continue; &#125; if (activity.getClass().equals(cls)) &#123; it.remove(); activity.finish(); &#125; &#125; &#125; &#125; /** * 结束所有Activity */ public void finishAllActivity() &#123; if (mActivityStack != null) &#123; for (WeakReference&lt;Activity&gt; activityReference : mActivityStack) &#123; Activity activity = activityReference.get(); if (activity != null) &#123; activity.finish(); &#125; &#125; mActivityStack.clear(); &#125; &#125; /** * 退出应用程序 */ public void exitApp() &#123; try &#123; finishAllActivity(); // 退出JVM,释放所占内存资源,0表示正常退出 System.exit(0); // 从系统中kill掉应用程序 android.os.Process.killProcess(android.os.Process.myPid()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后是一个BaseActivity类， 重写onCreate和onDestory方法 1234567891011121314151617181920212223242526package com.example.chenlei.test;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.util.Log;public class BaseActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MyActivityManager.addActivity(this); Log.i("有activity新添加", "onCreate: "); &#125; @Override protected void onDestroy() &#123; Log.i("有activity被销毁", "onDestroy: "+ MyActivityManager.getSize()); MyActivityManager.finishActivity(this); super.onDestroy(); &#125;&#125; 接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作 网上原文：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Studio解决依赖冲突]]></title>
    <url>%2F2019%2F04%2F14%2FAndroid%2FAndroid-Studio%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[Android-Studio解决依赖冲突我们做android项目通常会引入很多第三方库， 有时候不同的第三方库会出现依赖冲突，导致添加依赖后就android-studio就报错。做项目是要添加glide库，直接添加最新版本 4.8，《第一行代码》中介绍使用的版本是3.7。 结果就是4.8的版本一添加依赖就报错，在build.gradle文件中报错buildtool版本冲突。我在网上找到了如下的文章，解决方法是一样的，做一个笔记。需要说明的 glide4.+ 的版本和 3.+ 的版本，提供的api接口的操作形式发生了变化，而且google上搜到说版本升级之后其实性能没有多大提升 原文：https://blog.csdn.net/victor888886/article/details/73714141 以下是网上的文章内容：最近刚接手一个项目，里面模块有三四个，引入的第三方包更多了。但是问题来了，新配置的studio一运行就报了错。 Error:Execution failed for task &apos;:app:processDebugManifest&apos;. Manifest merger failed : Attribute meta-data#android.support.VERSION@value value=(25.3.1) from [com.android.support:design:25.3.1] AndroidManifest.xml:27:9-31is also present at [com.android.support:support-v4:26.0.0-alpha1] AndroidManifest.xml:27:9-38 value=(26.0.0-alpha1).Suggestion: add ‘tools:replace=”android:value”’ to element at AndroidManifest.xml:25:5-27:34 to override. 可以看到，studio已经明确的指出了错误，在清单文件中Android support 库版本冲突了，而且，studio还很“人性”地给出了suggestion：清单文件25行——27行添加： tools:replace=&quot;android:value&quot; 坑就坑在这里，给出的建议完全误导人了。咳咳，下面看我详（如）细（何）解（装）释（逼）： 问题分析：看到com.android.support:design:25.3.1 和 com.android.support:support-v4:26.0.0-alpha1， 说明这个Android support库版本冲突了，解决的思想很简单，就是统一使用同一个版本的support库，比如修改掉26.0.0-alpha1的依赖，统一换成25.3.1的版本。 解决既然有了思路，那就动手试一试，全局搜索26.0.0-alpha1，统一替换为 25.3.1 正常情况下，这个是能解决问题的，但只能解决gradle里面自己引入的依赖版本问题。然而，今天碰到的坑还没完呢，同步代码以后，还是原来的错误信息！ 再次分析：问题就出在第三方库的依赖了，好多第三方库默认引用当前最新的support库，现在最新的就是26.0.0-alpha1这个版本。所以，要解决问题，就要从引入的三方库里面入手了！那么问题来了，挖掘机哪家......哦不，怎么知道哪个依赖包有冲突？下面出杀手锏了： 打开Android studio下面的terminal，输入命令：`gradle -q app:dependencies`,惊喜出现了：没有配置gradle环境变量的同学赶快去配一个吧！.. **（这里不需要配置gradle环境变量也可以，在terminal中输入命令：./gradlew -q app:dependencies效果是一样的）** 配过之后可以看到类似一下的输出： +— project :base-util| +— com.android.support:recyclerview-v7:25.3.1 ()| +— cn.qqtheme.framework:WheelPicker:1.5.1| | +— cn.qqtheme.framework:Common:1.5.1| | | +— com.android.support:support-v4:latest.release -&gt; 26.0.0-alpha1 ()| | | — com.android.support:support-annotations:latest.release -&gt; 26.0.0-alpha1| | +— com.android.support:support-v4:latest.release -&gt; 26.0.0-alpha1 ()| | — com.android.support:support-annotations:latest.release -&gt; 26.0.0-alpha1| +— com.github.CymChad:BaseRecyclerViewAdapterHelper:v1.9.8| +— io.reactivex:rxjava:1.1.8| +— io.reactivex:rxandroid:1.1.0| | — io.reactivex:rxjava:1.1.0 -&gt; 1.1.8| +— com.squareup.okhttp3:okhttp:3.2.0 -&gt; 3.4.1| | — com.squareup.okio:okio:1.9.0| +— com.squareup.retrofit2:retrofit:2.0.2| | — com.squareup.okhttp3:okhttp:3.2.0 -&gt; 3.4.1 ()| +— com.squareup.retrofit2:adapter-rxjava:2.0.2| | +— com.squareup.retrofit2:retrofit:2.0.2 ()| | — io.reactivex:rxjava:1.1.1 -&gt; 1.1.8| +— com.squareup.retrofit2:converter-gson:2.0.2| | +— com.squareup.retrofit2:retrofit:2.0.2 ()| | — com.google.code.gson:gson:2.6.1| +— com.squareup.okhttp3:logging-interceptor:3.4.1| | — com.squareup.okhttp3:okhttp:3.4.1 ()| +— com.github.zhaokaiqiang.klog:library:1.5.0| | — com.android.support:support-annotations:23.4.0 -&gt; 26.0.0-alpha1| +— com.squareup.retrofit2:converter-simplexml:2.0.2| | +— com.squareup.retrofit2:retrofit:2.0.2 ()| | — org.simpleframework:simple-xml:2.7.1| +— com.github.bumptech.glide:glide:3.7.0| +— project :base-res (*)| — com.jakewharton:butterknife:7.0.1 很明显cn.qqtheme.framework:WheelPicker这个包默认引用了最新的support库！ 最终解决：找到依赖的库，修改为下面的方式引入： compile (&apos;cn.qqtheme.framework:WheelPicker:1.5.1&apos;){ exclude group:&apos;com.android.support&apos; }]]></content>
      <categories>
        <category>Android</category>
        <category>AndroidStudio</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler防止内存泄露]]></title>
    <url>%2F2019%2F04%2F14%2FAndroid%2FHandler%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%2F</url>
    <content type="text"><![CDATA[Handler防止内存泄露1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private MyHandler mHandler = new MyHandler(this); private TextView mTextView ; private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = (MainActivity) reference.get(); if(activity != null)&#123; activity.mTextView.setText(""); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTextView = (TextView)findViewById(R.id.textview); loadData(); &#125; //loadData()方法是在子线程中，执行 private void loadData() &#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //如果你的Handler被delay（延时了）,可以做如下的处理 mHandler.removeCallbacksAndMessages(null); &#125;&#125; 解释创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息 使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jni入门]]></title>
    <url>%2F2019%2F04%2F13%2FJava%2FJni%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Jni入门参考:JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki 1、编写native方法，使用javah创建头文件123public class HelloWorld &#123; public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现&#125; 1javah -jni -classpath JniCalcINterface 参数说明：classpath：类搜索路径，这里表示从当前的 bin 目录下查找d：将生成的头文件放到当前的 jni 目录下o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h） 注意：-d和-o只能使用其中一个参数。 创建的.h文件如下123456789101112131415161718192021/* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_study_jnilearn_HelloWorld */ #ifndef _Included_com_study_jnilearn_HelloWorld #define _Included_com_study_jnilearn_HelloWorld #ifdef __cplusplus extern "C" &#123; #endif /* * Class: com_study_jnilearn_HelloWorld * Method: sayHello * Signature: (Ljava/lang/String;)Ljava/lang/String; */ JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello (JNIEnv *, jclass, jstring); #ifdef __cplusplus &#125; #endif #endif **注意 extern “C”表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern “C”后面 3、编译出so文件1gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so 参数含义: -L 表示要链接的库所在的目录。-L. 表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。 -l (L的小写) 表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test -include 包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。 -I (i 的大写) 指定头文件的所在的目录，可以使用相对路径。 -shared 指定生成动态链接库 -fPIC 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。 -o 指定编译后动态库生成的路径和文件名 4、加载动态库1234static&#123; System.loadLibrary("HelloWorld"); //方式一 System.load("/Users/yangxin/Desktop/libHelloWorld.jnilib" //方式二);&#125; 方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀方式2：指定动态库的绝对路径名，需要加上前缀和后缀 推荐使用这种方法 如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。 将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下 给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。 5、运行java程序]]></content>
      <tags>
        <tag>jni</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义ViewGroup]]></title>
    <url>%2F2019%2F04%2F13%2FAndroid%2F%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%2F</url>
    <content type="text"><![CDATA[自定义ViewGroup参考文章自定义LayoutParams关于onMeasure过程的理解Measure测量流程全解析（简洁） 下面是继承自ViewGroup的FlowLayout标签流式布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.example.test;import android.content.Context;import android.util.AttributeSet;import android.util.Log;import android.view.View;import android.view.ViewGroup;public class FlowLayout extends ViewGroup &#123; public FlowLayout(Context context) &#123; super(context); &#125; public FlowLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int specWidth = MeasureSpec.getSize(widthMeasureSpec); int specHeight = MeasureSpec.getSize(heightMeasureSpec); int specWidthMode = MeasureSpec.getMode(widthMeasureSpec); int specHeightMode = MeasureSpec.getMode(heightMeasureSpec); int count = getChildCount(); //计算child的大小 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); //measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0 //这里为了支持margin，所以用measureChildWithMargins方法 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); &#125; //计算ViewGroup自身的大小 //这里只要处理height的wrap_content情况就可以了 int height = specHeight; int width = specWidth; if (specHeightMode == MeasureSpec.AT_MOST) &#123; height = getPaddingBottom() + getPaddingTop(); int used_width = 0; int line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams(); int child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //在这一行可以容纳 if (used_width + child_width &lt;= width - getPaddingStart() - getPaddingEnd()) &#123; line_max_height = Math.max(line_max_height, child_height); used_width += child_width; &#125; else &#123; //切换到下一行 height += line_max_height; used_width = child_width; line_max_height = child_height; &#125; &#125; //加上最后一行的最大height height += line_max_height; &#125; setMeasuredDimension(width, height); &#125; private final String TAG = "test_log"; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd(); int used_width = 0; int used_height = 0; int count = getChildCount(); int last_line_max_height = 0; for (int i = 0; i &lt; count; i++) &#123; View child_view = getChildAt(i); MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams(); //用于计算是否越界时需要包含margin int child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin; int child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin; //layout时的位置，必须考虑padding int layout_l, layout_t, layout_r, layout_b; if (used_width + child_width &lt;= width) &#123; layout_l = getPaddingStart() + used_width + mlp.leftMargin; layout_t = getPaddingTop() + used_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_width += child_width; //记录该行height的最大值 last_line_max_height = Math.max(last_line_max_height, child_height); &#125; else &#123; layout_l = getPaddingStart() + mlp.leftMargin; layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin; layout_r = layout_l + child_view.getMeasuredWidth(); layout_b = layout_t + child_view.getMeasuredHeight(); used_height += last_line_max_height; used_width = child_width; last_line_max_height = child_height; &#125; child_view.layout(layout_l, layout_t, layout_r, layout_b); &#125; &#125; @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; @Override protected LayoutParams generateLayoutParams(LayoutParams p) &#123; return new MarginLayoutParams(p); &#125; @Override protected LayoutParams generateDefaultLayoutParams() &#123; return new MarginLayoutParams(super.generateDefaultLayoutParams()); &#125;&#125; 关于MeasureSpec父控件告诉子控件可获得的空间以及关于这个空间的约束条件 SpecMode EXACTLY 设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式 AT_MOST width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值 UNSPECIFIED 这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用 关于view的Measure过程我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。 这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程： ViewRootImpl.performTraversals()-&gt;performMeasure(): 这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量 DecorView.measure()-&gt;onMeasure(): DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量 ViewGroupA.measure()-&gt;onMeasure(): 这是我们自定义的一个ViewGroup(继承自ViewGroup)假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。 所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。 ViewB.measure()-&gt;onMeasure(): View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。 测量子view时MeasureSpec的生成规则 当子View的宽高设置的是具体数值时 显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。 当子View的宽高设置的是match_parent 则不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED） 当子View的宽高设置的是wrap_content, 因为这种情况父容器实在不知道子View应该多宽多高，所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。 通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。 关于LayoutParams在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。在使用中必须重写所有的generateLayoutParams()方法尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams]]></content>
      <categories>
        <category>Android</category>
        <category>View</category>
      </categories>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个cpp文件编译共享同一个.h文件的全局变量]]></title>
    <url>%2F2019%2F04%2F13%2FC%2F%E5%A4%9A%E4%B8%AAcpp%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E4%B8%AA-h%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[多个cpp文件编译共享同一个.h文件的全局变量在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案: 一个cpp文件多次#include一个.h文件 使用#ifndef 12345//在.h头文件中#ifndef &lt;标示&gt; //自定义的一个标示, 习惯性用.h文件名大写#define &lt;标示&gt;//...头文件内容#endif 原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容 这种方法只能解决一个cpp源文件中的重复include问题 多个cpp文件多次#include一个.h文件使用static关键字123//.h头文件static int i;static void func(); static修饰变量变量static标记之后，多个cpp文件include不会出现问题。但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的下面是网上的一些解释: 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。 static修饰函数函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。似乎是这样的。。。我的理解。网上说static和inline经常配合使用 使用extern关键字extern表明该变量在别的地方已经定义过了，在这里要使用那个变量 12//cpp文件extern int i; 经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。 定义在.h文件的情况下，在使用extern时，不能include定义它的.h文件。否则还是会出现重定义的问题。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C语言结构体的内存对齐]]></title>
    <url>%2F2019%2F04%2F13%2FC%2FC%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[C语言结构体的内存对齐内存对齐原则 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。） 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍 pragram pack(4)设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节 例子：123456789101112131415# pragram pack(8)struct S3&#123; double d; char c; int i;&#125;;struct S4&#123; char c1; struct S3 s3; double d;&#125;;printf("%d\n", sizeof(struct S4)); 最后的输出为 32 参考：[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园 C语言联合体union的sizeof分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
  </entry>
</search>
