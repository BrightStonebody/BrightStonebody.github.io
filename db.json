{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/push.sh","path":"push.sh","modified":0,"renderable":0},{"_id":"source/images/Gradle的构建过程.jpg","path":"images/Gradle的构建过程.jpg","modified":0,"renderable":0},{"_id":"source/images/Text相关计算.webp","path":"images/Text相关计算.webp","modified":0,"renderable":0},{"_id":"source/images/mysql_iptables.png","path":"images/mysql_iptables.png","modified":0,"renderable":0},{"_id":"source/images/startService and bindService.jpg","path":"images/startService and bindService.jpg","modified":0,"renderable":0},{"_id":"source/images/flutter相关属性和android的对应关系.webp","path":"images/flutter相关属性和android的对应关系.webp","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"source/images/fresco基本结构.jpg","path":"images/fresco基本结构.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"source/images/fresco发起请求的流程.jpg","path":"images/fresco发起请求的流程.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1}],"Cache":[{"_id":"source/push.sh","hash":"9b904e17d4a6e015e04df31078afa655e2af10b0","modified":1576930601881},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1576930601895},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1576930601895},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1576930601895},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1576930601897},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1576930601898},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1576930601898},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1576930601898},{"_id":"themes/next/README.md","hash":"a0430372844df9caea6e9bf96492775ed42a4578","modified":1576930601898},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1576930601898},{"_id":"themes/next/_config.yml","hash":"68c179ec4f462873f41c8b7747ccfb48258cdcaa","modified":1577962331868},{"_id":"themes/next/gulpfile.js","hash":"72e6d5a6e32d5f95d82e4c4d0c963d39555bb760","modified":1576930601902},{"_id":"themes/next/package.json","hash":"b7fd0a53c7cb4c40c6f236065bfed34e6188e786","modified":1576930601914},{"_id":"source/images/Gradle的构建过程.jpg","hash":"4ab64f9e14ad5b25623c820e8855d6e97d9cfcb0","modified":1592482980448},{"_id":"source/images/Text相关计算.webp","hash":"2bc79f17b9a2be8663fe5bbc8487ccfceccc3627","modified":1576930601880},{"_id":"source/images/mysql_iptables.png","hash":"9b8dc491c73623b28c41b1581c728c696ecd365e","modified":1576930601880},{"_id":"source/images/startService and bindService.jpg","hash":"e22213c4dec3f59761079a0a219ffcbbfe640ec8","modified":1576930601881},{"_id":"source/notes/boostnote.json","hash":"1d8c7454808e612994ea23361819e2f544c21b99","modified":1576930601881},{"_id":"source/categories/index.md","hash":"79a24c099c0611ec4db9c83dee34941ea6eb0ea6","modified":1576930601880},{"_id":"source/tags/index.md","hash":"ad018fd214859a5a59b26ad4e49645698e82e3dc","modified":1576930601881},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1576930601895},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"838201a0284e90843cd8e762e290c9bd7f10e993","modified":1576930601895},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"2a4ff75ccb91d9001032c08e22489096b850bf4f","modified":1576930601896},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1576930601896},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1576930601896},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1576930601896},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"b09c85aa449f46bc025317ed196ec33a877f7c23","modified":1576930601897},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1576930601897},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1576930601897},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1576930601897},{"_id":"themes/next/.github/stale.yml","hash":"941209526c2f7d916c76163c9e1ac1af9d956679","modified":1576930601897},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1576930601897},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1576930601899},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1576930601899},{"_id":"themes/next/docs/DATA-FILES.md","hash":"d0d46cb265f0efceffce82214cd36d8b82ddce13","modified":1576930601899},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1576930601899},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"08cda41b4bcf687facfda19ab39718ec7a05ae54","modified":1576930601899},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"5b4c013e0598b3211ebd899265936cfdaf7c139f","modified":1576930601899},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1576930601900},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"199e9ef3cb5928af0fe801d03d2d1aeea704cea4","modified":1576930601900},{"_id":"themes/next/docs/MATH.md","hash":"f520b336f16665e164d6edf075bdcc6aa17b31bc","modified":1576930601900},{"_id":"themes/next/languages/de.yml","hash":"3d8920676d89494d7d1c74d4238680151ea6d9df","modified":1576930601902},{"_id":"themes/next/languages/en.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1576930601903},{"_id":"themes/next/languages/es.yml","hash":"7dc1d7d5ea1078ee3b9bc8e0e8d0f15f52a7a4aa","modified":1576930601903},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1576930601903},{"_id":"themes/next/languages/fr.yml","hash":"dfdcfa536c40d06125dff373d042c50e08fcafd8","modified":1576930601903},{"_id":"themes/next/languages/fa.yml","hash":"269b5cb70774485d7dbbcf98eec72c9e84e135b2","modified":1576930601903},{"_id":"themes/next/languages/hu.yml","hash":"e4a5f43fb45acd992def3de3b600aa4df4c95ed7","modified":1576930601903},{"_id":"themes/next/languages/id.yml","hash":"5665dece8435964a27b5061d7283f339f84721f0","modified":1576930601903},{"_id":"themes/next/languages/it.yml","hash":"311597c620059dbb99474f19b2110a4485ecf70b","modified":1576930601903},{"_id":"themes/next/languages/ja.yml","hash":"4f929842b3d6aaed709ea99da679d3910ee184e5","modified":1576930601904},{"_id":"themes/next/languages/ko.yml","hash":"5f5194dd0f5a3c8484e7668bce6fbe23340e531a","modified":1576930601904},{"_id":"themes/next/languages/nl.yml","hash":"561c77ca68e9d51a5ce8c89d3361fdb033c96bba","modified":1576930601904},{"_id":"themes/next/languages/ru.yml","hash":"b485c57dd7b447406dafd0dcfdfc9356266708c9","modified":1576930601904},{"_id":"themes/next/languages/pt.yml","hash":"af9d9b581dca45ab9789ca41d3492883a911e383","modified":1576930601904},{"_id":"themes/next/languages/pt-BR.yml","hash":"13b579911e44a8b213e1860f9a50c341be1bf95e","modified":1576930601904},{"_id":"themes/next/languages/tr.yml","hash":"39caf8a3677fd6dfbd523e73f8482a509e87b603","modified":1576930601904},{"_id":"themes/next/languages/uk.yml","hash":"4cbdbb0ed09487c9b435be21ac35f62182f53283","modified":1576930601904},{"_id":"themes/next/languages/zh-CN.yml","hash":"e92e1e07a89c9fab27f445f9ec0fa35049fef38c","modified":1576930601905},{"_id":"themes/next/languages/vi.yml","hash":"3c6bb816ee7278afcddac06998c9ebe47ee19aef","modified":1576930601905},{"_id":"themes/next/languages/zh-HK.yml","hash":"93d10d6e448c519004b09b11fba980b5036c93af","modified":1576930601905},{"_id":"themes/next/layout/_layout.swig","hash":"512bdf6787b5d9fb1d40b126b0fa8e6f1018d1cd","modified":1576930601905},{"_id":"themes/next/languages/zh-TW.yml","hash":"ae2aa1c6ec1a5a01a3a3bde17bcc3a82f9a35fa7","modified":1576930601905},{"_id":"themes/next/layout/category.swig","hash":"c55debb2588e4746b02d31ec249bf0a84fdea260","modified":1576930601914},{"_id":"themes/next/layout/archive.swig","hash":"59155648f6306888077d1f1d635f63177b36148d","modified":1576930601914},{"_id":"themes/next/layout/index.swig","hash":"3bc6fb1e9707d74b96e1346d3f03fe6584f764f4","modified":1576930601914},{"_id":"themes/next/layout/page.swig","hash":"e61d64c055b6497a04affc143f47fdd0a6dc495b","modified":1576930601914},{"_id":"themes/next/layout/post.swig","hash":"382d9f9a9b35e1f369585f7f9f9b5dd6fa58d2f0","modified":1576930601914},{"_id":"themes/next/layout/tag.swig","hash":"7ff6e34d557a3da1c6a29ecd97842bf73ff213dc","modified":1576930601914},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1576930601917},{"_id":"source/images/flutter相关属性和android的对应关系.webp","hash":"a474163ef56cd229069c4187a10e783937832536","modified":1582703579987},{"_id":"source/_posts/C/多个cpp文件编译共享同一个-h文件的全局变量.md","hash":"25980caac2bba406b579b8e4a1ba67514bafede3","modified":1576930601879},{"_id":"source/_posts/C/C语言结构体的内存对齐.md","hash":"ae476f35a0e2f6f66078468ca4bc164e8cbd6175","modified":1576930601879},{"_id":"source/_posts/Android/Activity-class-does-not-exist.md","hash":"d5287902384cce9e534833df0b3adc7f9745649c","modified":1576930601873},{"_id":"source/_posts/Android/Activity管理类的封装.md","hash":"de1f2119fff62f1d1d6ecd463c45b7b6c228d98c","modified":1576930601874},{"_id":"source/_posts/Android/Handler防止内存泄露.md","hash":"841fc57855133870eabae43a7cb3669dcc2c26a1","modified":1576930601874},{"_id":"source/_posts/Android/Android自定义注解.md","hash":"b2f6b6145abce8c62f1747a909cd4dccbff75e3a","modified":1593231193593},{"_id":"source/_posts/Android/RecyclerView全局刷新的问题.md","hash":"f3f6d538b0ee11b196e4377b52a5caca04f43822","modified":1584689053201},{"_id":"source/_posts/Android/LayoutInflater解析.md","hash":"4ac3249fc7d52ac0625ff4fda6482be63be5c6f9","modified":1576930601874},{"_id":"source/_posts/Android/RecyclerView缓存机制总结.md","hash":"7fa62b2ea9934344c81ccbdf652ea16a331a8f10","modified":1576930601874},{"_id":"source/_posts/Android/MVP模式防止内存泄露.md","hash":"8f8436280ded329c572be59688b21fa4ee746b6f","modified":1576930601874},{"_id":"source/_posts/Android/RecyclerView设置item的间距.md","hash":"cc8ecaa5225d60a5052f328662f4e9611c106131","modified":1576930601876},{"_id":"source/_posts/Android/RemoteView刷新View.md","hash":"53f1d5673a4a56a2de5a7cce6368d02e42e470c0","modified":1576930601876},{"_id":"source/_posts/Android/Scale动画组合使用的坑.md","hash":"0d7411367dcdac80bcd4481a8b751f4a633136ca","modified":1576930601876},{"_id":"source/_posts/Android/Text相关计算.md","hash":"574957924eed0f9f5815d462587b72031043c6a6","modified":1584688840157},{"_id":"source/_posts/Android/gradle相关基础.md","hash":"fbedd07a913ba0294d2d602505d01ad4992054ab","modified":1593227108661},{"_id":"source/_posts/Android/scrollBy-scrollTo-和Scroller.md","hash":"1e698ef72e13593249e66b3019ff689ad76a8547","modified":1576930601876},{"_id":"source/_posts/Android/startService-和bindService.md","hash":"d73d3ff5bd01fd273b50666ab510890dad2d762f","modified":1576930601876},{"_id":"source/_posts/Android/ViewModel-LiveData和LifeCricle.md","hash":"3a656ec69913b8c204739f59da9818f54e025c92","modified":1588228626035},{"_id":"source/_posts/Android/华为手机的内存泄露.md","hash":"a3e8c2894ba3cd61273f36ab1574c5d5fa80ce5d","modified":1576930601876},{"_id":"source/_posts/Android/外部View随着RecyclerView的滚动而显示或隐藏.md","hash":"9b1e9a135890d8f6927a70874ef6f837195d8744","modified":1578583001826},{"_id":"source/_posts/Android/ViewDragHelper的使用.md","hash":"61279079206df47c0d27aa7be4d7332b449a49f9","modified":1585107753156},{"_id":"source/_posts/Android/自定义ViewGroup.md","hash":"b84521614cbf2d9f71474f274b9ba987631125b4","modified":1576930601878},{"_id":"source/_posts/Android/通知铃声的自定义遇到的问题-根据uri读取文件.md","hash":"d7a77e62f594473a450d29ab658bd376d50edeef","modified":1576930601878},{"_id":"source/_posts/Flutter/Flutter中常用布局和Android的对应关系.md","hash":"515592e374c7de62e0ecc415617fd775b17fc4d1","modified":1582703650867},{"_id":"source/_posts/Flutter/RenderObject-原理.md","hash":"b6159a37abde815d10b62dfe7be98418679f387d","modified":1600767197268},{"_id":"source/_posts/Android/kotlin协程.md","hash":"5969a7f5bfc0aa099d4d4c154e569e0db42a47d3","modified":1594803308354},{"_id":"source/_posts/Java/ThreadLocal.md","hash":"c7ce7dceb51513b75f50c7496418a145b7c2cce8","modified":1576930601879},{"_id":"source/_posts/Java/Jni入门.md","hash":"0d7b2495f71b802b54b2da3e3888e367006bb4f3","modified":1576930601879},{"_id":"source/_posts/Linux/apt常用命令.md","hash":"8cacf9e93680ced7ffc2697597210fc110abff9b","modified":1576930601879},{"_id":"source/_posts/Linux/docker的使用.md","hash":"6f01489de5c21520e7943842d6ead31a9886d2a3","modified":1576930601879},{"_id":"source/_posts/Linux/mysql配置相关.md","hash":"d123a1f405190cb72cce2aeb4e0a4530eb9a5b3b","modified":1576930601880},{"_id":"source/_posts/Java/Java获取泛型类型.md","hash":"9e495f8181558b12eb474c233202f9ecff38fd50","modified":1595509605097},{"_id":"source/_posts/Android/自动滚播TextView.md","hash":"b4d081ef74402cd6a07ceaf5ce5eaadbe6c91aac","modified":1577777328565},{"_id":"source/_posts/Flutter/flutter-ui源码-初步.md","hash":"17befd819d5d055c34f7937514ac5bbc350243db","modified":1600763370235},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"a0601577b77b8ad89742dc99f98edebf9cc45c10","modified":1576930601895},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6d79701dd0bb3757722650d9df30eeaacd83344e","modified":1576930601896},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"bf8b10715f5529cc6997501d821307895710ba58","modified":1576930601896},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"35a9e1469962a9a163abd0b83677a412516272ef","modified":1576930601896},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1576930601900},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"2665f6a9d72090f9452a8811544ff2596e8899be","modified":1576930601900},{"_id":"themes/next/docs/ru/README.md","hash":"7302b2e5318c0c13e6484aa6487be29599ebc2b2","modified":1576930601900},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"4245fe9472647226692fcbdd5a52d6e6dcd251bc","modified":1576930601901},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"fe3f5cda1975114884d84bef384a562920d70335","modified":1576930601901},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"ebacdc94f6f9724a7c6ef7c3cdde41ff7c37931a","modified":1576930601901},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"3b4dbf0d2ca12ab442b7e0e227769ce100b8a444","modified":1576930601901},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"3ef324cee2761da762eaa5d8d9b9f9601dc264bc","modified":1576930601901},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"2d60a18340c9260cd4dc81fe8acc7983d6b2d011","modified":1576930601902},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1576930601901},{"_id":"themes/next/docs/zh-CN/README.md","hash":"1766bd2e528ec148d3c5dd55e6be55449fcda94e","modified":1576930601902},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"264d131b8865bae069f8e4d78a33a0f59d28e36b","modified":1576930601902},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"8109a531d3a7f5a306e36d4304c11f0c7c180c87","modified":1576930601902},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"815676d904f92748ddf4f529bed2baf066997bc6","modified":1576930601905},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1116597ae81c391981f3a8b80fa6febe5796583d","modified":1576930601906},{"_id":"themes/next/layout/_macro/post.swig","hash":"e80d07467dcd614e940451737f4c1eaab8c8d272","modified":1576930601905},{"_id":"themes/next/layout/_partials/comments.swig","hash":"3a72e3d72980fa0944008b36b284b044d0e84b2a","modified":1576930601906},{"_id":"themes/next/layout/_partials/footer.swig","hash":"ee6ae67a3c7b99ee768afbd36882390b9f4db5b0","modified":1576930601906},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"b9d3f6534efb9e637ac46318fa07c2e5607bf830","modified":1576930601907},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1576930601908},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1576930601909},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1576930601909},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"9675acc599ffa546f05a60375c1637b0327be4fd","modified":1576930601909},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1576930601910},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1576930601910},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1576930601910},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1576930601911},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"4abfcb5dae0e6dec5e288baa3a9fe4065829b392","modified":1576930601912},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1576930601912},{"_id":"themes/next/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1576930601930},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1576930601931},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1576930601931},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1576930601931},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1576930601931},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1576930601931},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1576930601931},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1576930601931},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1576930601932},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1576930601932},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1576930601932},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1576930601932},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1576930601932},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1576930601932},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1576930601932},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1576930601932},{"_id":"themes/next/source/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1576930601933},{"_id":"themes/next/source/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1576930601932},{"_id":"themes/next/source/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1576930601933},{"_id":"themes/next/source/js/motion.js","hash":"71e5caff1d87b1b7256f61e6b318bedf495f9e75","modified":1576930601933},{"_id":"themes/next/source/js/next-boot.js","hash":"a6a82905c6abb8e0ec418ef6b0509b946b955807","modified":1576930601933},{"_id":"themes/next/source/js/utils.js","hash":"a2984bf0631756a904cd43f8e3a8f6fb15b9ceb5","modified":1576930601933},{"_id":"themes/next/scripts/events/index.js","hash":"ac2945693791e62a3046248f2a511afadcaebc16","modified":1576930601915},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1576930601934},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1576930601916},{"_id":"themes/next/scripts/filters/locals.js","hash":"6794137c0a019b09bc277a564a7c12b522893650","modified":1576930601916},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1576930601916},{"_id":"themes/next/scripts/filters/post.js","hash":"3c1e483c2c4a1c5a2f9a99b81ce0fda5fd21926b","modified":1576930601916},{"_id":"themes/next/scripts/helpers/engine.js","hash":"b357cbc5d5b39b1bb5221149e7d358135a7ba56d","modified":1576930601916},{"_id":"themes/next/scripts/helpers/font.js","hash":"32268fb4c59c5b37c1eb1c9582ab630e09e5cc7d","modified":1576930601917},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"e60e6c0aaa979d42b01685ba2a03a76fa6e059e2","modified":1576930601917},{"_id":"themes/next/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1576930601917},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1576930601917},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1576930601917},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"8fc05f22b88553bc1d96e0c925799cd97920fc6a","modified":1576930601917},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"fad54f0e9e225a70390209f63d9b3cc566a5ebcb","modified":1576930601917},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1576930601918},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1576930601918},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1576930601918},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1576930601918},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1576930601918},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1576930601918},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1576930601927},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1576930601927},{"_id":"source/_posts/Android/源码解析/Glide源码-主要流程.md","hash":"243c4ad838aa9193485edbc48b6e8d447ede30ca","modified":1576930601877},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-CacheInterceptor.md","hash":"ff3c9309b30f404a7925472871b2cda13b7732cd","modified":1576930601877},{"_id":"source/_posts/Android/源码解析/Glide源码-缓存机制.md","hash":"341b22ae64ceeb6d364ba0122692d435cb71c8e3","modified":1576930601877},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-CallServerInterceptor.md","hash":"45a46ac02727e10dd4ddfab75e316a4ff773a2de","modified":1576930601877},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor.md","hash":"fef7509aae5dbf96b77e6fb45bb84dd0aed2fd91","modified":1576930601878},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-ConnectInterceptor.md","hash":"a40125b2fd611865ef70b4fac320310098b16c10","modified":1576930601877},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-责任链的分析.md","hash":"8419f0836bc402a9b75c6c3b10a85fe3a91e5d04","modified":1576930601878},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-发起请求的主要流程.md","hash":"8c890686762cdee8db3c9234eb376425a2d5d39a","modified":1576930601878},{"_id":"source/_posts/Android/源码解析/handler机制源码解析.md","hash":"deeee8e625a3eaa09a31249e15ebf7734d1316d5","modified":1576930601878},{"_id":"source/images/fresco基本结构.jpg","hash":"e0db204389df9e7cf9624f48a283e9e11449e487","modified":1584689904747},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"f5d2c5a3421ae52888be62e2c837459d1175cc93","modified":1576930601906},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"0f4565e123e2ceccaff08316bc38151cda7fcbc4","modified":1576930601906},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"7487ca8f0e4b16351ea0d6b35dc52b0d32176d57","modified":1576930601906},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"30528a8da30994b1ef9355a72b09b2cd85a7c0e9","modified":1576930601907},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"ff33b5797f5e4b5cbcb3c222c17bc636c6b88df6","modified":1576930601907},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d488664bc16608b5f829f959c2058b4381be244a","modified":1576930601907},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"fbec9f77139e1f300509c38446416b4b26350cfa","modified":1576930601907},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"becfa683c3e5409e20cdb7b1dc8a6db331bddefe","modified":1576930601907},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1576930601908},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1576930601908},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"bebf630963c1c65fd152859a1ba316b03be17cce","modified":1576930601908},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1576930601907},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"a56e4f6ad95c106f361d354f828d1ef4810b1d76","modified":1576930601907},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"7fa01334a0ba84500e920bb9202baa08067d2ee1","modified":1576930601908},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1576930601908},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"733d6874aa4f50d1071e670a554508a5a0094eb3","modified":1576930601908},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"246ff123cbaa507f23514c0c51c6cc006685898e","modified":1576930601909},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1576930601909},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1576930601909},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1576930601909},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1576930601909},{"_id":"source/_posts/Android/源码解析/事件分发机制.md","hash":"6a66454e261027206e1ac72c6b65b384c61457dd","modified":1585061238505},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"194201cce870c1af6f5123a62cb766cd24e46217","modified":1576930601910},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"6aead2977147b7054a35c4865cac8544f3394b4f","modified":1576930601908},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1576930601910},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1576930601910},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1576930601911},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1576930601910},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1576930601911},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"1130b8bd60f3b84397974486e6586d7f0afaf836","modified":1576930601911},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"fe3cdd70224bd0c8171513a5dfed7b85deb7f23d","modified":1576930601911},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"9719cb5858896aef86c2e0bec0ace259936680c4","modified":1576930601911},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"a9c8e7987b63b9ef66e47b966aea05ac77ff920a","modified":1576930601911},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"8063f65cdaae80840fcf427b875ae606f678dfa5","modified":1576930601911},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f95bc4d7ffaddc3c0df0ef3eeeaac58ff83f560","modified":1576930601911},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1576930601912},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1576930601912},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"fb27a38f9a4b8fcba4f637b03904f7a83cc73416","modified":1576930601912},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"e456d7a2aaabe55447f78cd952b30d70a6c1e742","modified":1576930601912},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1576930601912},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1576930601912},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1576930601912},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1576930601913},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"67e63c25d509f02a6057ee9724f1b6efd647f72f","modified":1576930601913},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"ac6a3995c1330d2d73300b2427006509d0f8dba5","modified":1576930601913},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"7f2941d119abca6627561fb010dad96fa48d2092","modified":1576930601913},{"_id":"themes/next/layout/_third-party/statistics/tencent-analytics.swig","hash":"493a1ef6c8f475d4dd3156a6ab37690dc75695ea","modified":1576930601913},{"_id":"themes/next/layout/_third-party/statistics/tencent-mta.swig","hash":"198813a3f382bda4278fe3759bf0f18a5769bb33","modified":1576930601913},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"4958fa997ff6df2b2ce05341f40cc3a81b0f91bb","modified":1576930601913},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"7fa72dc60c078842979861622839b109683e05a3","modified":1576930601913},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1576930601927},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1576930601927},{"_id":"source/_posts/Android/源码解析/Fresco源码解析.md","hash":"4bef566d9b01f7cb61db3f8ebb585598c2cac5cd","modified":1584779899803},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0a25f3df1b5c39794365efde387647da81da884a","modified":1576930601927},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"52550138127ae9ebbe049bcdacd94d767c003855","modified":1576930601929},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"50bc57e66331c0f15a4527010b4ca3316ac92403","modified":1576930601930},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c261d685c5ed0df34718d94bb2ba977c0ed443e6","modified":1576930601930},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"b9d7058db61df7bbd2b58779efe45621a06ffc18","modified":1576930601930},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"bb31a17d34c9dd6f9e5082fa56955c71e32c2722","modified":1576930601930},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d8e861f2ecc1954ab8c44942fb8404b0693e1849","modified":1576930601930},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1576930601933},{"_id":"themes/next/source/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1576930601933},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1576930601934},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1576930601934},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1576930601934},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1576930601934},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1576930601934},{"_id":"themes/next/scripts/events/lib/config.js","hash":"246e55d48f2f3ef510c11594c7c08ddb93ac0928","modified":1576930601915},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1576930601915},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"311a54c0a0b6192502e68ce8c0b20e77aed3b996","modified":1576930601915},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1fc2a94b94108175848ba9541d05898c071386d0","modified":1576930601915},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1576930601915},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1576930601915},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"d2ce60980fc148bfb877981aabd07bf45d2cdcda","modified":1576930601915},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"c081166868e6428a07c51c5674b86b7a4cc9c2a8","modified":1576930601916},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"3c4bdc2a682f9889a532e1cb856bc5caeb4208e1","modified":1576930601916},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1576930601916},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"5201cd09a5e263282ccbf205f07d46f4c6d3f700","modified":1576930601916},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1576930601938},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1576930601937},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"80d359661d08b80ad561b97f8508766b3e1f6d01","modified":1576930601918},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"112f5e8f1fe5cec4419e87acfbdef0e615ed23f3","modified":1576930601919},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"47ee915d7b0a97e74140a25fbfc01c04d6781534","modified":1576930601919},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"41c7cd1b63d49476ed5fbdd26ab9411d8f44bd05","modified":1576930601921},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"170c4598cbbe49cd1527f94158d97d2320a6b906","modified":1576930601921},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"990bd301ce2de0a6b936781c58318f3945d81bc2","modified":1576930601923},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1576930601923},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"d8ba44b8e1a0332c5c1079ff65fc83d2918a5865","modified":1576930601924},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2067e15799a3a3cda8bfe7782d67a4dc42f1ef79","modified":1576930601924},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1576930601924},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1576930601925},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1576930601925},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f3c5f1dadc01042381444102d35174dacc6f079a","modified":1576930601925},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1576930601926},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1576930601925},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4341f0e057b42e8c47629bb3196fca3b49f0cc19","modified":1576930601927},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"08c2679a31f195940fe1e6c76e64799fb21cda99","modified":1576930601927},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"24a086a6904bbf5355a354403c9b0e6069f7eb01","modified":1576930601927},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"48743ac61af37a4de2026667e15a65de5e8cf542","modified":1576930601928},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e321bd62f5e04d1fdc101a470ec13604e99816a5","modified":1576930601928},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1576930601928},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1576930601928},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"eeab294e14abbae231107e1a327e907b25323136","modified":1576930601928},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"316ee13fc26d327c8862c2455211144c180cf9c1","modified":1576930601928},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1576930601928},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1576930601928},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1576930601929},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"f1f81bca31e82ccbd375f0cb9fb8dbb3beac810d","modified":1576930601929},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f5abb2ea7746586738fb4e82107fceed041708ee","modified":1576930601929},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"c0ed534696ed86560c95ab2a3541b2b42a41ed39","modified":1576930601929},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c59226767164285d6708d8762f937f93bab264ca","modified":1576930601929},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1576930601929},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0424a1fcffa1ae82fe70935972a894aca885bf9a","modified":1576930601929},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1576930601935},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1576930601935},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1576930601935},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1576930601937},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1576930601919},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1576930601919},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1576930601919},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6336c2b129db802221b1fd75e5fbe8aab85c0a1f","modified":1576930601919},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"98227b4de364b48b11e21efcf4f1beb2ed3ab329","modified":1576930601919},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1576930601919},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1576930601920},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"602a3c3d2785965b23412b5c219dfe74b5fb0844","modified":1576930601920},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"4b84f35e7040f9adb5cc540c366d7f9eb4c48bcc","modified":1576930601920},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"3566136c06d96b34e1e7a3eca72fb0f40a63af80","modified":1576930601920},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2e2a09dddd2a394a635bcefb6207b6cddcb784c7","modified":1576930601920},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"d557a0de91a428330b43cdae9f1ec7167d24e2e4","modified":1576930601920},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"f8ba308231cf81453e41457796e94f1ce886d855","modified":1576930601920},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1576930601920},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1576930601920},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"5248880398c1318624bdab95109c1c9fdb8eec02","modified":1576930601921},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1576930601921},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1576930601921},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1576930601921},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1576930601921},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2d9d68a431a334626d463bb1bdfbcd2ea8242e94","modified":1576930601921},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"5528a755b180312d008054653633d857aeeb6780","modified":1576930601922},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1576930601922},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1576930601921},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"0672ea2acf28dcc2cfc5244da36d3387d71a17cb","modified":1576930601922},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"4b237e2344f35e9d1f6dbc3842d5e432d478ebfd","modified":1576930601922},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"d5d85d3646d184e0340924addcfd2523fb289d00","modified":1576930601922},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1576930601922},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a7ed54e2f52185a7b6bb9a8201f6c3aa74b0cb00","modified":1576930601922},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b5ba1b3d5535ccf1e5df6f4cd8ee0147d7278be9","modified":1576930601922},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1576930601923},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1576930601923},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1576930601923},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1576930601923},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"cc4beedb56c37246d9e0f74e4b2cc34231dabc65","modified":1576930601923},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1576930601924},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"1db4ce981fe9fcb9ee4279395c29553efbb43947","modified":1576930601923},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"e2ad7ccf1865a45548e3f31c70fac2c65d6ef534","modified":1576930601924},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"9a18b186b08ec220d1b17cf83812bcdd06077814","modified":1576930601924},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"eaa62b5de4ddb18378c1a4049a172d4fa4b655d8","modified":1576930601924},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1576930601924},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"4b980363822c24b3ad85c271719210a8ad2b646e","modified":1576930601925},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"2b536832cfc81667dadd9603c8c700e44d458261","modified":1576930601924},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1576930601925},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1576930601925},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"5bf28a03ef021c27cfd713971caca5a0b9466fd1","modified":1576930601926},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"879f9cec9c88d65b2e31af4346b2bc0f6941f05d","modified":1576930601926},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"068b304be305fbfd0220276d56b93cefd968f0b6","modified":1576930601926},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1576930601926},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"419fa6cfc103d08dfd6a385ab7f24468c644d581","modified":1576930601926},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1576930601926},{"_id":"source/images/fresco发起请求的流程.jpg","hash":"cbbd3d068fc5a39146539504ce3f2d435ad9adbb","modified":1584771086587},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1576930601936},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1576930601937},{"_id":"public/atom.xml","hash":"5c2f014678ee2348401e3171271782d86c8a8290","modified":1600767204838},{"_id":"public/notes/boostnote.json","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1600766922130},{"_id":"public/content.json","hash":"32d4bfecca2665d1e45fca33592ffe9b8f9ed7aa","modified":1600767204827},{"_id":"public/search.xml","hash":"71b1f14ad4b9b34f285f71a213d68baf58967df8","modified":1600767204838},{"_id":"public/sitemap.xml","hash":"cef4e8f518e5d0f16f48db8a0afe1c9b38a392d2","modified":1600767204827},{"_id":"public/categories/index.html","hash":"eb6c1e3de44efa8f40cbd6d83d73384f17ca4b6f","modified":1600766922175},{"_id":"public/tags/index.html","hash":"9a7d4d42cd93737d107df45770a5b8a4bae4c4e9","modified":1600766922175},{"_id":"public/2020/07/23/Java/Java获取泛型类型/index.html","hash":"2900cef92f178b1ef8bcdb080a1b27b4cd4d38cd","modified":1600766922176},{"_id":"public/2020/02/26/Flutter/Flutter中常用布局和Android的对应关系/index.html","hash":"259e31cc68d365e5b70758756fc2d02324de2be4","modified":1600766922176},{"_id":"public/2019/09/15/Android/RemoteView刷新View/index.html","hash":"1d26a7610a762db86c15d14d038a550eb6ca3eb2","modified":1600766922176},{"_id":"public/2019/07/19/Android/Text相关计算/index.html","hash":"b8b43d5b4aca6278cf80e460e17e57c637d12fc2","modified":1600766922176},{"_id":"public/2019/05/02/Linux/apt常用命令/index.html","hash":"9c211c0d7f732ece5cc1687ca20a7fa13bdf53aa","modified":1600766922176},{"_id":"public/2019/04/16/Android/Activity-class-does-not-exist/index.html","hash":"290718a20b7eba98d314390874a810d529262832","modified":1600766922176},{"_id":"public/archives/index.html","hash":"e3fa8b5f4da341a5a633f00b8fde3633c4c9279c","modified":1600766922176},{"_id":"public/archives/page/2/index.html","hash":"5c2b129724224fde80e32ff75529fd883148211b","modified":1600766922176},{"_id":"public/archives/page/3/index.html","hash":"31d1d76d06057a2706375eba6c1debdcbceb6391","modified":1600766922176},{"_id":"public/archives/page/4/index.html","hash":"42c881248f95852adf15788a714ba514e5d87c1a","modified":1600766922176},{"_id":"public/archives/page/5/index.html","hash":"1fad78cab6cc8e8c1191502e2b1c5357d86763f4","modified":1600766922176},{"_id":"public/archives/2019/index.html","hash":"01c24a8e1abb1900bcb45a5f26214ab805c44af8","modified":1600766922176},{"_id":"public/archives/2019/page/2/index.html","hash":"c8ef1025f8ab817c4f58db6871be7dc8ec0884c4","modified":1600766922176},{"_id":"public/archives/2019/page/3/index.html","hash":"93dff198038de8b0d75c24e7953bf5125964b71b","modified":1600766922176},{"_id":"public/archives/2019/page/4/index.html","hash":"19c54556c1fc26805b78f20110b40b3a0b80bb3f","modified":1600766922177},{"_id":"public/archives/2019/04/index.html","hash":"3428fe8c71aeae65b47c598c370531e7337a2b9f","modified":1600766922177},{"_id":"public/archives/2019/05/index.html","hash":"8ce1656bd1cf31846f2f779d40363e01af5cdcda","modified":1600766922177},{"_id":"public/archives/2019/06/index.html","hash":"452276b01a3797513573eacfeddead91d8b6d199","modified":1600766922177},{"_id":"public/archives/2019/07/index.html","hash":"ba8bb931eb8ba9404aef0067157e6f152cb5a266","modified":1600766922177},{"_id":"public/archives/2019/08/index.html","hash":"5a6d0dc7cbc817c2f1ab4d738a44fd3b81d34ee8","modified":1600766922177},{"_id":"public/archives/2019/09/index.html","hash":"83fcebc0d0141bdbe9193a0cfe8b89727a5a1c04","modified":1600766922177},{"_id":"public/archives/2019/12/index.html","hash":"0791c71659019e38c1ca0d18c69177b813bbf36e","modified":1600766922177},{"_id":"public/archives/2019/11/index.html","hash":"7613c2d9e00562a2b8780680d5944ef0abd0b91d","modified":1600766922177},{"_id":"public/archives/2020/index.html","hash":"0ea495e2c7d5085a0dbefcf9a4d7f0a2274b2a1c","modified":1600766922177},{"_id":"public/archives/2020/01/index.html","hash":"64eec6a2432443940d243cdf33260f01daf28d39","modified":1600766922177},{"_id":"public/archives/2020/02/index.html","hash":"f000cf6d95f7fad4dbe6d569a6ba306de50e1a73","modified":1600766922177},{"_id":"public/archives/2020/03/index.html","hash":"acf343d7550b8d2e46c7fbc891a7a0c425bb5e82","modified":1600766922177},{"_id":"public/archives/2020/06/index.html","hash":"42a547e3f963a995ca278555028442c04cfbdabe","modified":1600766922177},{"_id":"public/archives/2020/07/index.html","hash":"7c8f5257f1afbfe84d80ec076975c36e4ab6f88a","modified":1600766922177},{"_id":"public/archives/2020/08/index.html","hash":"4164e519c64b08a784416b52bcf50a959691c66a","modified":1600766922177},{"_id":"public/categories/C-C/index.html","hash":"38df559c98a5b471a7a01304d1f1f543b1962ad1","modified":1600766922177},{"_id":"public/categories/Android/index.html","hash":"0dc5c38553d34c7d792008fc7c18f194c42a0c8a","modified":1600766922177},{"_id":"public/categories/Android/page/2/index.html","hash":"59d2ffe701b9a1a5d0feea8232c7112cdfb15da9","modified":1600766922178},{"_id":"public/categories/Android/page/3/index.html","hash":"269bcca082da0dae378b6fb41ed713528ea8e068","modified":1600766922178},{"_id":"public/categories/Android/View/index.html","hash":"67cf4f7f6de027d36f194685f3ff9d9611a09b0e","modified":1600766922178},{"_id":"public/categories/Android/AndroidStudio/index.html","hash":"423e68ae5a3318c55c0a35f34fa72a395dbffc71","modified":1600766922178},{"_id":"public/categories/Android/Service/index.html","hash":"470f743f5ca4b8c06351c2cc671ddcd7aa4ee09d","modified":1600766922178},{"_id":"public/categories/Flutter/index.html","hash":"1a34c2c700e8de5342fcfb7eefb37bf9c170301e","modified":1600766922178},{"_id":"public/categories/java/index.html","hash":"1d2d5da880bba9b4e384a0dc9b5610227ec1e82b","modified":1600766922178},{"_id":"public/categories/Kotlin/index.html","hash":"7fc7f932a608a0e12973e2b686f7f800e721ebc7","modified":1600766922178},{"_id":"public/categories/java/多线程/index.html","hash":"75ddc5681292ce248af94f92dc9d68449f56aa78","modified":1600766922178},{"_id":"public/categories/Linux/index.html","hash":"d97ac387a60dee89ab7a506c4fd8ad341db38cea","modified":1600766922178},{"_id":"public/categories/Java/index.html","hash":"a7ab0ae29c5d8d3f0e467c0d660d40384642997c","modified":1600766922178},{"_id":"public/tags/AndroidStudio/index.html","hash":"a86b9a6b564e57f44918b58909df58ce86ab55c3","modified":1600766922178},{"_id":"public/tags/Activity/index.html","hash":"afa73fa2014d36f3cc2d72cd76f4335da834a7fb","modified":1600766922178},{"_id":"public/tags/注解/index.html","hash":"7c13089db47ee2192fd3a443c81e11100fb2a047","modified":1600766922178},{"_id":"public/tags/Android/index.html","hash":"da5aa9f2b1080f64e42f1b58c4cd9544bfe3315b","modified":1600766922178},{"_id":"public/tags/View/index.html","hash":"716b38ec5a5eb8138ce21713255e29fd9e4a7fea","modified":1600766922178},{"_id":"public/tags/View/page/2/index.html","hash":"a3551a113bc83009367b62b0b288ec65a89964d2","modified":1600766922178},{"_id":"public/tags/Handler/index.html","hash":"08ec7bc043a36838a99908b96b4eae922027167c","modified":1600766922178},{"_id":"public/tags/内存泄露/index.html","hash":"aa25c87e41888f1e73719713692a32753c94a930","modified":1600766922178},{"_id":"public/tags/RecyclerView/index.html","hash":"f72a3eca1b1662d0d6f4125f1d241c3c92dc9b50","modified":1600766922178},{"_id":"public/tags/MVP/index.html","hash":"a522db68976f4d41ac71ce09d6e62e9114fb218a","modified":1600766922178},{"_id":"public/tags/Animation/index.html","hash":"5e5edd9ff3e0fee4f409a0606df883d7382ff677","modified":1600766922178},{"_id":"public/tags/Gradle/index.html","hash":"965650766d25e907fd775b99a9d5a1defa43cbcd","modified":1600766922178},{"_id":"public/tags/Service/index.html","hash":"c4ac8fe4839a06778da66bc4515982d631f0a74a","modified":1600766922178},{"_id":"public/tags/Notification/index.html","hash":"a5bc452580846b26da24fa8fe5066c6aeda9f272","modified":1600766922179},{"_id":"public/tags/Uri/index.html","hash":"5eaa0a4bf75dc6598609e865e917bff0f049b2b7","modified":1600766922179},{"_id":"public/tags/Flutter/index.html","hash":"d6fe251a956dfce642139de2e79ff18db4f3f97c","modified":1600766922179},{"_id":"public/tags/多线程/index.html","hash":"99a6184d686a6e929f0443069119ab9bdb0029cf","modified":1600766922179},{"_id":"public/tags/Kotlin/index.html","hash":"5e2c5c05cc523408a1f0010fc1227614a9f873f7","modified":1600766922179},{"_id":"public/tags/jni/index.html","hash":"e5fbcb3c2aa492e67b1c9882ce3abe2fbaa98643","modified":1600766922179},{"_id":"public/tags/Linux/index.html","hash":"317840110e2df85a0eb7e754a34ddcd47770f2b0","modified":1600766922179},{"_id":"public/tags/Docker/index.html","hash":"0d94bb9340f90523aeaa1e83005eb78936c0bded","modified":1600766922179},{"_id":"public/tags/mysql/index.html","hash":"5503b02bffa3a002a4577a6f6959bede4dadc633","modified":1600766922179},{"_id":"public/tags/Java/index.html","hash":"073698235801a39929b8a543e253ff999cdc82e5","modified":1600766922179},{"_id":"public/tags/glide/index.html","hash":"0b987ba973eacc57ac7aac9a0101a8cdbd6194ef","modified":1600766922179},{"_id":"public/tags/源码解析/index.html","hash":"a05ce6f9e12094e9e0b1235472a460b49c88939e","modified":1600766922179},{"_id":"public/tags/okhttp3/index.html","hash":"a1b5785731e240589bb0e9ddf5eac949a608d02c","modified":1600766922179},{"_id":"public/tags/源码分析/index.html","hash":"f48a479cde4a52870438e04cd87a47f4801767cb","modified":1600766922179},{"_id":"public/tags/Okhttp3/index.html","hash":"493216a04ad99a40a409cffd78c24926ea3ab033","modified":1600766922179},{"_id":"public/tags/Fresco/index.html","hash":"8bcfe3e9fcf922bfdb833b90f4dd95645882c5f6","modified":1600766922179},{"_id":"public/2020/07/15/Android/kotlin协程/index.html","hash":"7688d1d704cd4822909029357671934cc0763ce6","modified":1600766922179},{"_id":"public/2020/06/27/Android/Android自定义注解/index.html","hash":"189d68dbb42d7487d1f1c5b77a6bf630935ae3f1","modified":1600766922179},{"_id":"public/2020/06/18/Android/gradle相关基础/index.html","hash":"52afcf5ca9c71e981f94656734cf717484517ac1","modified":1600766922179},{"_id":"public/2020/03/20/Android/源码解析/Fresco源码解析/index.html","hash":"5c40b177606797627fb6ef2c2c8680c7be436e9f","modified":1600766922179},{"_id":"public/2020/02/19/Android/ViewDragHelper的使用/index.html","hash":"a1ca63805f31689aff2bd0e307b5644f515b8567","modified":1600766922179},{"_id":"public/2020/01/09/Android/外部View随着RecyclerView的滚动而显示或隐藏/index.html","hash":"1eb2c74e06656ae4d146a58f861abda95dd6a18e","modified":1600766922179},{"_id":"public/2019/12/31/Android/自动滚播TextView/index.html","hash":"194d8e4f98970da669695480de324c4841257a36","modified":1600766922179},{"_id":"public/2019/12/21/Android/ViewModel-LiveData和LifeCricle/index.html","hash":"39f07e5974f7bc490b03c30f4b3e2b6afb92ebae","modified":1600766922180},{"_id":"public/2019/11/18/Android/源码解析/Glide源码-缓存机制/index.html","hash":"65fdba98108cc3d52e492118cd271c650a68cc13","modified":1600766922180},{"_id":"public/2019/11/18/Android/源码解析/Glide源码-主要流程/index.html","hash":"4d010f541f4273677f03aa016505d4321eed4333","modified":1600766922180},{"_id":"public/2019/11/17/Android/源码解析/OkHttp3源码-CallServerInterceptor/index.html","hash":"17f99c58c4f3eccfa2c99fdafe6cc668910da031","modified":1600766922180},{"_id":"public/2019/11/15/Android/源码解析/OkHttp3源码-ConnectInterceptor/index.html","hash":"9e0fe2c885d96314615428a9cd7080f77e3db930","modified":1600766922180},{"_id":"public/2019/11/14/Android/源码解析/OkHttp3源码-CacheInterceptor/index.html","hash":"def37fb2c214259d97b9d157a50dbabac17be8b0","modified":1600766922180},{"_id":"public/2019/11/14/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor/index.html","hash":"78f51aa381948a0c9206a4ca19bc5f94e927bab2","modified":1600766922180},{"_id":"public/2019/11/14/Android/源码解析/OkHttp3源码-责任链的分析/index.html","hash":"153ed6c5a3f1ed525f5b4809cfc9db9401125a76","modified":1600766922180},{"_id":"public/2019/11/13/Android/源码解析/OkHttp3源码-发起请求的主要流程/index.html","hash":"0864e37670c5fe576b5f356781ddd0aa1517708c","modified":1600766922180},{"_id":"public/2019/11/12/Linux/docker的使用/index.html","hash":"a6b9d4dee041719de17a86540de1dbff1e8ff069","modified":1600766922180},{"_id":"public/2019/11/09/Android/源码解析/handler机制源码解析/index.html","hash":"ff6f08408dae2243e98beb478095ab2f21cad242","modified":1600766922180},{"_id":"public/2019/09/15/Android/RecyclerView全局刷新的问题/index.html","hash":"90d598cc2da32c463d6d1e298792e6130bdc88ef","modified":1600766922180},{"_id":"public/2019/08/28/Android/通知铃声的自定义遇到的问题-根据uri读取文件/index.html","hash":"9cd9e7c1e691b45dad763b2ed1a557d45f488539","modified":1600766922180},{"_id":"public/2019/08/15/Android/RecyclerView缓存机制总结/index.html","hash":"e520e725a61739f879e9ce205f840a5989f1240f","modified":1600766922180},{"_id":"public/2019/08/13/Android/源码解析/事件分发机制/index.html","hash":"1779b2f2754cc4ba677cdab41b939f974f92f167","modified":1600766922180},{"_id":"public/2019/08/13/Android/LayoutInflater解析/index.html","hash":"b48540b6fd6f3384d4fd9283027676f02ef3c6e7","modified":1600766922180},{"_id":"public/2019/08/02/Android/Scale动画组合使用的坑/index.html","hash":"62b6e1349208544ae5c8743c6f4ed95cc852c2c5","modified":1600766922180},{"_id":"public/2019/07/22/Java/ThreadLocal/index.html","hash":"ba8c9311f023ff06f166885455d24b39ebcd2509","modified":1600766922180},{"_id":"public/2019/07/09/Android/RecyclerView设置item的间距/index.html","hash":"94929f8be882d6c4e109dfee8949539352cd47f4","modified":1600766922180},{"_id":"public/2019/07/04/Android/startService-和bindService/index.html","hash":"3b2a8cc9f2948d0c7d95f86756e0dda6412b9f02","modified":1600766922181},{"_id":"public/2019/05/04/Linux/mysql配置相关/index.html","hash":"c29320f38a0d785cf23628a71a4602a0358951bf","modified":1600766922181},{"_id":"public/2019/06/16/Android/scrollBy-scrollTo-和Scroller/index.html","hash":"3be892448e85f908344edef7ed995d87c7416a37","modified":1600766922181},{"_id":"public/2019/04/19/Android/华为手机的内存泄露/index.html","hash":"2cbd6f535482137ef459c6ea0584d41d58e981cc","modified":1600766922181},{"_id":"public/2019/04/15/Android/MVP模式防止内存泄露/index.html","hash":"babd4451b7ee186c6a2f39dc843a1cadd072c75d","modified":1600766922181},{"_id":"public/2019/04/14/Android/Activity管理类的封装/index.html","hash":"c8c2d0f998d37adae315d84f24e3362e1c503d55","modified":1600766922181},{"_id":"public/2019/04/14/Android/Handler防止内存泄露/index.html","hash":"54cb341ecdcc4cff01872d9dc1dc332e6edbdba0","modified":1600766922181},{"_id":"public/2019/04/13/Java/Jni入门/index.html","hash":"bc4ed780c7eab627984919c97a3afc1d198f1af3","modified":1600766922181},{"_id":"public/2019/04/13/Android/自定义ViewGroup/index.html","hash":"09705a8d5e0817c6c3808acf8cd181f4c2d31404","modified":1600766922181},{"_id":"public/2019/04/13/C/多个cpp文件编译共享同一个-h文件的全局变量/index.html","hash":"b5bb1a0e51130081c715ba6b5be40609fc7aad9d","modified":1600766922181},{"_id":"public/2019/04/13/C/C语言结构体的内存对齐/index.html","hash":"8b11251f532f7610dab5a21b43f869748fc6fd35","modified":1600766922181},{"_id":"public/index.html","hash":"9a9b3936aaec3a3518d12421b6a987585bb0687d","modified":1600767204845},{"_id":"public/page/2/index.html","hash":"2a55ea887bfc58fc7e84c929576e17560dc1adab","modified":1600766922181},{"_id":"public/page/3/index.html","hash":"fc8d1fe1af71c0e7d5f4639dd25738f5827ad297","modified":1600766922181},{"_id":"public/page/4/index.html","hash":"3fbf99cacf85011ee6d2537ae2e6a15c65aefe50","modified":1600766922181},{"_id":"public/page/5/index.html","hash":"5c0013543c1826b150e14b4aecc2092375a4ff57","modified":1600766922181},{"_id":"public/2020/09/22/Flutter/RenderObject-原理/index.html","hash":"0fcc9dbf19bbacda422f0dcfc946fb595cec5a18","modified":1600767204845},{"_id":"public/archives/2020/09/index.html","hash":"e853919840c1dcd798d38e5c05affb2a31f3d498","modified":1600766922185},{"_id":"public/tags/RenderObject/index.html","hash":"1da740df23e9c43ce5d2df9e0f48637c3bd555c6","modified":1600766922185},{"_id":"public/2020/08/14/Flutter/flutter-ui源码-初步/index.html","hash":"41161db27fdb9e7b18ac4efe6d44661504a5f2e3","modified":1600766922185},{"_id":"public/push.sh","hash":"9b904e17d4a6e015e04df31078afa655e2af10b0","modified":1600766922188},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1600766922188},{"_id":"public/images/mysql_iptables.png","hash":"9b8dc491c73623b28c41b1581c728c696ecd365e","modified":1600766922188},{"_id":"public/images/startService and bindService.jpg","hash":"e22213c4dec3f59761079a0a219ffcbbfe640ec8","modified":1600766922188},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1600766922188},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1600766922188},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1600766922188},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1600766922188},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1600766922189},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1600766922189},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1600766922189},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1600766922189},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1600766922189},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1600766922189},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1600766922189},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1600766922189},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1600766922189},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1600766922189},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1600766922189},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1600766922189},{"_id":"public/images/Gradle的构建过程.jpg","hash":"4ab64f9e14ad5b25623c820e8855d6e97d9cfcb0","modified":1600766922541},{"_id":"public/images/Text相关计算.webp","hash":"2bc79f17b9a2be8663fe5bbc8487ccfceccc3627","modified":1600766922542},{"_id":"public/images/flutter相关属性和android的对应关系.webp","hash":"a474163ef56cd229069c4187a10e783937832536","modified":1600766922543},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1600766922543},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1600766922543},{"_id":"public/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1600766922546},{"_id":"public/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1600766922546},{"_id":"public/js/motion.js","hash":"71e5caff1d87b1b7256f61e6b318bedf495f9e75","modified":1600766922546},{"_id":"public/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1600766922546},{"_id":"public/js/utils.js","hash":"a2984bf0631756a904cd43f8e3a8f6fb15b9ceb5","modified":1600766922546},{"_id":"public/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1600766922546},{"_id":"public/js/next-boot.js","hash":"a6a82905c6abb8e0ec418ef6b0509b946b955807","modified":1600766922547},{"_id":"public/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1600766922547},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1600766922547},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1600766922547},{"_id":"public/css/main.css","hash":"7b18f4567d008ec9c2efe57b3db81f3c098ae983","modified":1600766922547},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1600766922547},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1600766922547},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1600766922547},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1600766922547},{"_id":"public/images/fresco基本结构.jpg","hash":"e0db204389df9e7cf9624f48a283e9e11449e487","modified":1600766922586},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1600766922586},{"_id":"public/images/fresco发起请求的流程.jpg","hash":"cbbd3d068fc5a39146539504ce3f2d435ad9adbb","modified":1600766922598}],"Category":[{"name":"C/C++","_id":"ckfdrakq300058mzmhohjbncw"},{"name":"Android","_id":"ckfdrakqc000e8mzmalkng1mt"},{"name":"View","parent":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakql00118mzmqueldp8e"},{"name":"AndroidStudio","parent":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqm00168mzms4yl0epm"},{"name":"Service","parent":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakr5002o8mzmlhp3kj7r"},{"name":"Flutter","_id":"ckfdrakrb00378mzmhwoummw5"},{"name":"java","_id":"ckfdrakre003e8mzmiqnvisu7"},{"name":"Kotlin","_id":"ckfdrakrg003k8mzmlfe2bx03"},{"name":"多线程","parent":"ckfdrakre003e8mzmiqnvisu7","_id":"ckfdrakri003q8mzm9zh4e5ia"},{"name":"Linux","_id":"ckfdrakrl003x8mzmgn3zkw2b"},{"name":"Java","_id":"ckfdrakrn00488mzmd2ku1aoc"}],"Data":[],"Page":[{"_content":"{\n  \"folders\": [],\n  \"version\": \"1.0\"\n}\n","source":"notes/boostnote.json","raw":"{\n  \"folders\": [],\n  \"version\": \"1.0\"\n}\n","date":"2019-12-21T12:16:41.881Z","updated":"2019-12-21T12:16:41.881Z","path":"notes/boostnote.json","layout":"false","title":"","comments":1,"_id":"ckfdrakp900008mzmpacz1yzu","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2019-04-13T04:54:42.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-04-13 12:54:42\ntype: \"categories\"\n---\n","updated":"2019-12-21T12:16:41.880Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckfdrakpa00018mzmfnrk480d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-04-14T12:06:37.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-04-14 20:06:37\ntype: \"tags\"\n---\n","updated":"2019-12-21T12:16:41.881Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckfdrakpc00028mzm17yrrjff","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"多个cpp文件编译共享同一个.h文件的全局变量","date":"2019-04-13T05:12:22.000Z","_content":"\n# 多个cpp文件编译共享同一个.h文件的全局变量\n\n在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案:\n\n## 一个cpp文件多次#include一个.h文件\n> 使用#ifndef\n\n```c++\n//在.h头文件中\n#ifndef <标示> //自定义的一个标示, 习惯性用.h文件名大写\n#define <标示>\n//...头文件内容\n#endif\n```\n原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容\n\n**这种方法只能解决一个cpp源文件中的重复include问题**\n\n## 多个cpp文件多次#include一个.h文件\n### 使用static关键字\n```c++\n//.h头文件\nstatic int i;\nstatic void func();\n```\n* #### static修饰变量\n变量static标记之后，多个cpp文件include不会出现问题。\n**但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的**\n下面是网上的一些解释:\n> 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。\n> \n> 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。\n\n* #### static修饰函数\n函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。\n*似乎是这样的。。。我的理解。网上说static和inline经常配合使用*\n\n### 使用extern关键字\nextern表明该变量在别的地方已经定义过了，在这里要使用那个变量\n\n```c++\n//cpp文件\nextern int i;\n```\n经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。\n\n定义在.h文件的情况下，**在使用extern时，不能include定义它的.h文件。**否则还是会出现重定义的问题。\n","source":"_posts/C/多个cpp文件编译共享同一个-h文件的全局变量.md","raw":"---\ntitle: 多个cpp文件编译共享同一个.h文件的全局变量\ndate: 2019-04-13 13:12:22\ncategories: \n- C/C++\ntags:\n---\n\n# 多个cpp文件编译共享同一个.h文件的全局变量\n\n在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案:\n\n## 一个cpp文件多次#include一个.h文件\n> 使用#ifndef\n\n```c++\n//在.h头文件中\n#ifndef <标示> //自定义的一个标示, 习惯性用.h文件名大写\n#define <标示>\n//...头文件内容\n#endif\n```\n原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容\n\n**这种方法只能解决一个cpp源文件中的重复include问题**\n\n## 多个cpp文件多次#include一个.h文件\n### 使用static关键字\n```c++\n//.h头文件\nstatic int i;\nstatic void func();\n```\n* #### static修饰变量\n变量static标记之后，多个cpp文件include不会出现问题。\n**但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的**\n下面是网上的一些解释:\n> 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。\n> \n> 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。\n\n* #### static修饰函数\n函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。\n*似乎是这样的。。。我的理解。网上说static和inline经常配合使用*\n\n### 使用extern关键字\nextern表明该变量在别的地方已经定义过了，在这里要使用那个变量\n\n```c++\n//cpp文件\nextern int i;\n```\n经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。\n\n定义在.h文件的情况下，**在使用extern时，不能include定义它的.h文件。**否则还是会出现重定义的问题。\n","slug":"C/多个cpp文件编译共享同一个-h文件的全局变量","published":1,"updated":"2019-12-21T12:16:41.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakpy00038mzmsnix8a1w","content":"<h1 id=\"多个cpp文件编译共享同一个-h文件的全局变量\"><a href=\"#多个cpp文件编译共享同一个-h文件的全局变量\" class=\"headerlink\" title=\"多个cpp文件编译共享同一个.h文件的全局变量\"></a>多个cpp文件编译共享同一个.h文件的全局变量</h1><a id=\"more\"></a><p>在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案:</p>\n<h2 id=\"一个cpp文件多次-include一个-h文件\"><a href=\"#一个cpp文件多次-include一个-h文件\" class=\"headerlink\" title=\"一个cpp文件多次#include一个.h文件\"></a>一个cpp文件多次#include一个.h文件</h2><blockquote>\n<p>使用#ifndef</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在.h头文件中</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> <span class=\"meta-string\">&lt;标示&gt; //自定义的一个标示, 习惯性用.h文件名大写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> <span class=\"meta-string\">&lt;标示&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//...头文件内容</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容</p>\n<p><strong>这种方法只能解决一个cpp源文件中的重复include问题</strong></p>\n<h2 id=\"多个cpp文件多次-include一个-h文件\"><a href=\"#多个cpp文件多次-include一个-h文件\" class=\"headerlink\" title=\"多个cpp文件多次#include一个.h文件\"></a>多个cpp文件多次#include一个.h文件</h2><h3 id=\"使用static关键字\"><a href=\"#使用static关键字\" class=\"headerlink\" title=\"使用static关键字\"></a>使用static关键字</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h头文件</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"static修饰变量\"><a href=\"#static修饰变量\" class=\"headerlink\" title=\"static修饰变量\"></a>static修饰变量</h4><p>变量static标记之后，多个cpp文件include不会出现问题。<br><strong>但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的</strong><br>下面是网上的一些解释:</p>\n<blockquote>\n<p>定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。</p>\n<p>假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。</p>\n</blockquote>\n</li>\n<li><h4 id=\"static修饰函数\"><a href=\"#static修饰函数\" class=\"headerlink\" title=\"static修饰函数\"></a>static修饰函数</h4><p>函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。<br><em>似乎是这样的。。。我的理解。网上说static和inline经常配合使用</em></p>\n</li>\n</ul>\n<h3 id=\"使用extern关键字\"><a href=\"#使用extern关键字\" class=\"headerlink\" title=\"使用extern关键字\"></a>使用extern关键字</h3><p>extern表明该变量在别的地方已经定义过了，在这里要使用那个变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cpp文件</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i;</span><br></pre></td></tr></table></figure>\n<p>经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。</p>\n<p>定义在.h文件的情况下，<strong>在使用extern时，不能include定义它的.h文件。</strong>否则还是会出现重定义的问题。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"多个cpp文件编译共享同一个-h文件的全局变量\"><a href=\"#多个cpp文件编译共享同一个-h文件的全局变量\" class=\"headerlink\" title=\"多个cpp文件编译共享同一个.h文件的全局变量\"></a>多个cpp文件编译共享同一个.h文件的全局变量</h1>","more":"<p>在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案:</p>\n<h2 id=\"一个cpp文件多次-include一个-h文件\"><a href=\"#一个cpp文件多次-include一个-h文件\" class=\"headerlink\" title=\"一个cpp文件多次#include一个.h文件\"></a>一个cpp文件多次#include一个.h文件</h2><blockquote>\n<p>使用#ifndef</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在.h头文件中</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> <span class=\"meta-string\">&lt;标示&gt; //自定义的一个标示, 习惯性用.h文件名大写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> <span class=\"meta-string\">&lt;标示&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//...头文件内容</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容</p>\n<p><strong>这种方法只能解决一个cpp源文件中的重复include问题</strong></p>\n<h2 id=\"多个cpp文件多次-include一个-h文件\"><a href=\"#多个cpp文件多次-include一个-h文件\" class=\"headerlink\" title=\"多个cpp文件多次#include一个.h文件\"></a>多个cpp文件多次#include一个.h文件</h2><h3 id=\"使用static关键字\"><a href=\"#使用static关键字\" class=\"headerlink\" title=\"使用static关键字\"></a>使用static关键字</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h头文件</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"static修饰变量\"><a href=\"#static修饰变量\" class=\"headerlink\" title=\"static修饰变量\"></a>static修饰变量</h4><p>变量static标记之后，多个cpp文件include不会出现问题。<br><strong>但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的</strong><br>下面是网上的一些解释:</p>\n<blockquote>\n<p>定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。</p>\n<p>假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。</p>\n</blockquote>\n</li>\n<li><h4 id=\"static修饰函数\"><a href=\"#static修饰函数\" class=\"headerlink\" title=\"static修饰函数\"></a>static修饰函数</h4><p>函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。<br><em>似乎是这样的。。。我的理解。网上说static和inline经常配合使用</em></p>\n</li>\n</ul>\n<h3 id=\"使用extern关键字\"><a href=\"#使用extern关键字\" class=\"headerlink\" title=\"使用extern关键字\"></a>使用extern关键字</h3><p>extern表明该变量在别的地方已经定义过了，在这里要使用那个变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cpp文件</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i;</span><br></pre></td></tr></table></figure>\n<p>经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。</p>\n<p>定义在.h文件的情况下，<strong>在使用extern时，不能include定义它的.h文件。</strong>否则还是会出现重定义的问题。</p>\n"},{"title":"C语言结构体的内存对齐","date":"2019-04-13T05:11:14.000Z","_content":"\n# C语言结构体的内存对齐\n\n## 内存对齐原则\n* 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数\n\n* 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。）\n\n* 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍\n\n## pragram pack(4)\n设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节\n\n## 例子：\n```c++\n# pragram pack(8)\n\nstruct S3\n{\n    double d;\n    char c;\n    int i;\n};\nstruct S4\n{\n    char c1;\n    struct S3 s3;\n    double d;\n};\nprintf(\"%d\\n\", sizeof(struct S4));\n```\n\n最后的输出为 32\n\n## 参考：\n[[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园](https://www.cnblogs.com/zwh0214/p/8833314.html)\n\n## C语言联合体union的sizeof\n\n**分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。**\n\n","source":"_posts/C/C语言结构体的内存对齐.md","raw":"---\ntitle: C语言结构体的内存对齐\ndate: 2019-04-13 13:11:14\ncategories: \n- C/C++\ntags:\n---\n\n# C语言结构体的内存对齐\n\n## 内存对齐原则\n* 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数\n\n* 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。）\n\n* 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍\n\n## pragram pack(4)\n设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节\n\n## 例子：\n```c++\n# pragram pack(8)\n\nstruct S3\n{\n    double d;\n    char c;\n    int i;\n};\nstruct S4\n{\n    char c1;\n    struct S3 s3;\n    double d;\n};\nprintf(\"%d\\n\", sizeof(struct S4));\n```\n\n最后的输出为 32\n\n## 参考：\n[[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园](https://www.cnblogs.com/zwh0214/p/8833314.html)\n\n## C语言联合体union的sizeof\n\n**分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。**\n\n","slug":"C/C语言结构体的内存对齐","published":1,"updated":"2019-12-21T12:16:41.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakq100048mzmwgqbfyru","content":"<h1 id=\"C语言结构体的内存对齐\"><a href=\"#C语言结构体的内存对齐\" class=\"headerlink\" title=\"C语言结构体的内存对齐\"></a>C语言结构体的内存对齐</h1><h2 id=\"内存对齐原则\"><a href=\"#内存对齐原则\" class=\"headerlink\" title=\"内存对齐原则\"></a>内存对齐原则</h2><ul>\n<li><p>数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数</p>\n</li>\n<li><p>结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。）</p>\n</li>\n<li><p>结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍</p>\n</li>\n</ul><a id=\"more\"></a>\n<h2 id=\"pragram-pack-4\"><a href=\"#pragram-pack-4\" class=\"headerlink\" title=\"pragram pack(4)\"></a>pragram pack(4)</h2><p>设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节</p>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># pragram pack(8)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S4</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> c1;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span> <span class=\"title\">s3</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(struct S4));</span><br></pre></td></tr></table></figure>\n<p>最后的输出为 32</p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://www.cnblogs.com/zwh0214/p/8833314.html\" target=\"_blank\" rel=\"noopener\">[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园</a></p>\n<h2 id=\"C语言联合体union的sizeof\"><a href=\"#C语言联合体union的sizeof\" class=\"headerlink\" title=\"C语言联合体union的sizeof\"></a>C语言联合体union的sizeof</h2><p><strong>分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"C语言结构体的内存对齐\"><a href=\"#C语言结构体的内存对齐\" class=\"headerlink\" title=\"C语言结构体的内存对齐\"></a>C语言结构体的内存对齐</h1><h2 id=\"内存对齐原则\"><a href=\"#内存对齐原则\" class=\"headerlink\" title=\"内存对齐原则\"></a>内存对齐原则</h2><ul>\n<li><p>数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数</p>\n</li>\n<li><p>结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。）</p>\n</li>\n<li><p>结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍</p>\n</li>\n</ul>","more":"\n<h2 id=\"pragram-pack-4\"><a href=\"#pragram-pack-4\" class=\"headerlink\" title=\"pragram pack(4)\"></a>pragram pack(4)</h2><p>设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节</p>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># pragram pack(8)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S4</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> c1;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span> <span class=\"title\">s3</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(struct S4));</span><br></pre></td></tr></table></figure>\n<p>最后的输出为 32</p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://www.cnblogs.com/zwh0214/p/8833314.html\" target=\"_blank\" rel=\"noopener\">[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园</a></p>\n<h2 id=\"C语言联合体union的sizeof\"><a href=\"#C语言联合体union的sizeof\" class=\"headerlink\" title=\"C语言联合体union的sizeof\"></a>C语言联合体union的sizeof</h2><p><strong>分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。</strong></p>\n"},{"title":"Activity class {} does not exist","date":"2019-04-16T11:23:35.000Z","_content":"\n# Activity class {} does not exist\n\n有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。\n\n**解决办法：**\n使用adb命令\n```shell\nadb uninstall [包名]\n```\n\n估计可能是调试的APP没有彻底卸载造成的。","source":"_posts/Android/Activity-class-does-not-exist.md","raw":"---\ntitle: 'Activity class {} does not exist'\ndate: 2019-04-16 19:23:35\ntags:\n- AndroidStudio\ncategories:\n- Android\n- AndroidStudio\n---\n\n# Activity class {} does not exist\n\n有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。\n\n**解决办法：**\n使用adb命令\n```shell\nadb uninstall [包名]\n```\n\n估计可能是调试的APP没有彻底卸载造成的。","slug":"Android/Activity-class-does-not-exist","published":1,"updated":"2019-12-21T12:16:41.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakq400068mzmcfbh0mgc","content":"<h1 id=\"Activity-class-does-not-exist\"><a href=\"#Activity-class-does-not-exist\" class=\"headerlink\" title=\"Activity class {} does not exist\"></a>Activity class {} does not exist</h1><a id=\"more\"></a><p>有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。</p>\n<p><strong>解决办法：</strong><br>使用adb命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb uninstall [包名]</span><br></pre></td></tr></table></figure></p>\n<p>估计可能是调试的APP没有彻底卸载造成的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Activity-class-does-not-exist\"><a href=\"#Activity-class-does-not-exist\" class=\"headerlink\" title=\"Activity class {} does not exist\"></a>Activity class {} does not exist</h1>","more":"<p>有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。</p>\n<p><strong>解决办法：</strong><br>使用adb命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb uninstall [包名]</span><br></pre></td></tr></table></figure></p>\n<p>估计可能是调试的APP没有彻底卸载造成的。</p>\n"},{"title":"Activity管理类的封装","date":"2019-04-14T11:41:50.000Z","_content":"\n### 使用场景\n有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的\n\n我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。\n**这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用**\n\n```java\npublic class FinishActivityManager extends BaseActivity {\n    private FinishActivityManager() {\n    }\n    private static FinishActivityManager sManager;\n    private Stack<WeakReference<Activity>> mActivityStack;\n    public static FinishActivityManager getManager() {\n        if (sManager == null) {\n            synchronized (FinishActivityManager.class) {\n                if (sManager == null) {\n                    sManager = new FinishActivityManager();\n                }\n            }\n        }\n        return sManager;\n    }\n    /**\n     * 添加Activity到栈\n     * @param activity\n     */\n    public void addActivity(Activity activity) {\n        if (mActivityStack == null) {\n            mActivityStack = new Stack<>();\n        }\n        mActivityStack.add(new WeakReference<>(activity));\n    }\n    /**\n     * 检查弱引用是否释放，若释放，则从栈中清理掉该元素\n     */\n    public void checkWeakReference() {\n        if (mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity temp = activityReference.get();\n                if (temp == null) {\n                    it.remove();\n                }\n            }\n        }\n    }\n    /**\n     * 获取当前Activity（栈中最后一个压入的）\n     * @return\n     */\n    public Activity currentActivity() {\n        checkWeakReference();\n        if (mActivityStack != null && !mActivityStack.isEmpty()) {\n            return mActivityStack.lastElement().get();\n        }\n        return null;\n    }\n    /**\n     * 关闭当前Activity（栈中最后一个压入的）\n     */\n    public void finishActivity() {\n        Activity activity = currentActivity();\n        if (activity != null) {\n            finishActivity(activity);\n        }\n    }\n    /**\n     * 关闭指定的Activity\n     * @param activity\n     */\n    public void finishActivity(Activity activity) {\n        if (activity != null && mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity temp = activityReference.get();\n                // 清理掉已经释放的activity\n                if (temp == null) {\n                    it.remove();\n                    continue;\n                }\n                if (temp == activity) {\n                    it.remove();\n                }\n            }\n            activity.finish();\n        }\n    }\n    /**\n     * 关闭指定类名的所有Activity\n     * @param cls\n     */\n    public void finishActivity(Class<?> cls) {\n        if (mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity activity = activityReference.get();\n                // 清理掉已经释放的activity\n                if (activity == null) {\n                    it.remove();\n                    continue;\n                }\n                if (activity.getClass().equals(cls)) {\n                    it.remove();\n                    activity.finish();\n                }\n            }\n        }\n    }\n    /**\n     * 结束所有Activity\n     */\n    public void finishAllActivity() {\n        if (mActivityStack != null) {\n            for (WeakReference<Activity> activityReference : mActivityStack) {\n                Activity activity = activityReference.get();\n                if (activity != null) {\n                    activity.finish();\n                }\n            }\n            mActivityStack.clear();\n        }\n    }\n    /**\n     * 退出应用程序\n     */\n    public void exitApp() {\n        try {\n            finishAllActivity();\n            // 退出JVM,释放所占内存资源,0表示正常退出\n            System.exit(0);\n            // 从系统中kill掉应用程序\n            android.os.Process.killProcess(android.os.Process.myPid());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n然后是一个BaseActivity类， 重写onCreate和onDestory方法\n\n```java\npackage com.example.chenlei.test;\n\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\n\npublic class BaseActivity extends AppCompatActivity {\n\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        MyActivityManager.addActivity(this);\n        Log.i(\"有activity新添加\", \"onCreate: \");\n    }\n\n\n\n    @Override\n    protected void onDestroy() {\n        Log.i(\"有activity被销毁\", \"onDestroy: \"+ MyActivityManager.getSize());\n        MyActivityManager.finishActivity(this);\n        super.onDestroy();\n    }\n}\n\n```\n\n接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作\n\n\n网上原文：\n<http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html>\n","source":"_posts/Android/Activity管理类的封装.md","raw":"---\ntitle: Activity管理类的封装\ndate: 2019-04-14 19:41:50\ntags:\n- Activity\ncategories:\n- Android\n---\n\n### 使用场景\n有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的\n\n我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。\n**这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用**\n\n```java\npublic class FinishActivityManager extends BaseActivity {\n    private FinishActivityManager() {\n    }\n    private static FinishActivityManager sManager;\n    private Stack<WeakReference<Activity>> mActivityStack;\n    public static FinishActivityManager getManager() {\n        if (sManager == null) {\n            synchronized (FinishActivityManager.class) {\n                if (sManager == null) {\n                    sManager = new FinishActivityManager();\n                }\n            }\n        }\n        return sManager;\n    }\n    /**\n     * 添加Activity到栈\n     * @param activity\n     */\n    public void addActivity(Activity activity) {\n        if (mActivityStack == null) {\n            mActivityStack = new Stack<>();\n        }\n        mActivityStack.add(new WeakReference<>(activity));\n    }\n    /**\n     * 检查弱引用是否释放，若释放，则从栈中清理掉该元素\n     */\n    public void checkWeakReference() {\n        if (mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity temp = activityReference.get();\n                if (temp == null) {\n                    it.remove();\n                }\n            }\n        }\n    }\n    /**\n     * 获取当前Activity（栈中最后一个压入的）\n     * @return\n     */\n    public Activity currentActivity() {\n        checkWeakReference();\n        if (mActivityStack != null && !mActivityStack.isEmpty()) {\n            return mActivityStack.lastElement().get();\n        }\n        return null;\n    }\n    /**\n     * 关闭当前Activity（栈中最后一个压入的）\n     */\n    public void finishActivity() {\n        Activity activity = currentActivity();\n        if (activity != null) {\n            finishActivity(activity);\n        }\n    }\n    /**\n     * 关闭指定的Activity\n     * @param activity\n     */\n    public void finishActivity(Activity activity) {\n        if (activity != null && mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity temp = activityReference.get();\n                // 清理掉已经释放的activity\n                if (temp == null) {\n                    it.remove();\n                    continue;\n                }\n                if (temp == activity) {\n                    it.remove();\n                }\n            }\n            activity.finish();\n        }\n    }\n    /**\n     * 关闭指定类名的所有Activity\n     * @param cls\n     */\n    public void finishActivity(Class<?> cls) {\n        if (mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity activity = activityReference.get();\n                // 清理掉已经释放的activity\n                if (activity == null) {\n                    it.remove();\n                    continue;\n                }\n                if (activity.getClass().equals(cls)) {\n                    it.remove();\n                    activity.finish();\n                }\n            }\n        }\n    }\n    /**\n     * 结束所有Activity\n     */\n    public void finishAllActivity() {\n        if (mActivityStack != null) {\n            for (WeakReference<Activity> activityReference : mActivityStack) {\n                Activity activity = activityReference.get();\n                if (activity != null) {\n                    activity.finish();\n                }\n            }\n            mActivityStack.clear();\n        }\n    }\n    /**\n     * 退出应用程序\n     */\n    public void exitApp() {\n        try {\n            finishAllActivity();\n            // 退出JVM,释放所占内存资源,0表示正常退出\n            System.exit(0);\n            // 从系统中kill掉应用程序\n            android.os.Process.killProcess(android.os.Process.myPid());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n然后是一个BaseActivity类， 重写onCreate和onDestory方法\n\n```java\npackage com.example.chenlei.test;\n\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\n\npublic class BaseActivity extends AppCompatActivity {\n\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        MyActivityManager.addActivity(this);\n        Log.i(\"有activity新添加\", \"onCreate: \");\n    }\n\n\n\n    @Override\n    protected void onDestroy() {\n        Log.i(\"有activity被销毁\", \"onDestroy: \"+ MyActivityManager.getSize());\n        MyActivityManager.finishActivity(this);\n        super.onDestroy();\n    }\n}\n\n```\n\n接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作\n\n\n网上原文：\n<http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html>\n","slug":"Android/Activity管理类的封装","published":1,"updated":"2019-12-21T12:16:41.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakq500078mzms9at9vp0","content":"<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的</p><a id=\"more\"></a>\n<p>我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。<br><strong>这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinishActivityManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">FinishActivityManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> FinishActivityManager sManager;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;WeakReference&lt;Activity&gt;&gt; mActivityStack;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinishActivityManager <span class=\"title\">getManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (FinishActivityManager.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    sManager = <span class=\"keyword\">new</span> FinishActivityManager();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加Activity到栈</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addActivity</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mActivityStack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mActivityStack.add(<span class=\"keyword\">new</span> WeakReference&lt;&gt;(activity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查弱引用是否释放，若释放，则从栈中清理掉该元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkWeakReference</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity temp = activityReference.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取当前Activity（栈中最后一个压入的）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">currentActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        checkWeakReference();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span> &amp;&amp; !mActivityStack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mActivityStack.lastElement().get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭当前Activity（栈中最后一个压入的）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Activity activity = currentActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            finishActivity(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭指定的Activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span> &amp;&amp; mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity temp = activityReference.get();</span><br><span class=\"line\">                <span class=\"comment\">// 清理掉已经释放的activity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == activity) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activity.finish();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭指定类名的所有Activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cls</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity activity = activityReference.get();</span><br><span class=\"line\">                <span class=\"comment\">// 清理掉已经释放的activity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity.getClass().equals(cls)) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    activity.finish();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 结束所有Activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishAllActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (WeakReference&lt;Activity&gt; activityReference : mActivityStack) &#123;</span><br><span class=\"line\">                Activity activity = activityReference.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    activity.finish();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mActivityStack.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 退出应用程序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exitApp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            finishAllActivity();</span><br><span class=\"line\">            <span class=\"comment\">// 退出JVM,释放所占内存资源,0表示正常退出</span></span><br><span class=\"line\">            System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 从系统中kill掉应用程序</span></span><br><span class=\"line\">            android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是一个BaseActivity类， 重写onCreate和onDestory方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.chenlei.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.annotation.Nullable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        MyActivityManager.addActivity(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"有activity新添加\"</span>, <span class=\"string\">\"onCreate: \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"有activity被销毁\"</span>, <span class=\"string\">\"onDestroy: \"</span>+ MyActivityManager.getSize());</span><br><span class=\"line\">        MyActivityManager.finishActivity(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作</p>\n<p>网上原文：<br><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html\" target=\"_blank\" rel=\"noopener\">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的</p>","more":"\n<p>我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。<br><strong>这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinishActivityManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">FinishActivityManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> FinishActivityManager sManager;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;WeakReference&lt;Activity&gt;&gt; mActivityStack;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinishActivityManager <span class=\"title\">getManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (FinishActivityManager.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    sManager = <span class=\"keyword\">new</span> FinishActivityManager();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加Activity到栈</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addActivity</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mActivityStack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mActivityStack.add(<span class=\"keyword\">new</span> WeakReference&lt;&gt;(activity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查弱引用是否释放，若释放，则从栈中清理掉该元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkWeakReference</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity temp = activityReference.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取当前Activity（栈中最后一个压入的）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">currentActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        checkWeakReference();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span> &amp;&amp; !mActivityStack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mActivityStack.lastElement().get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭当前Activity（栈中最后一个压入的）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Activity activity = currentActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            finishActivity(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭指定的Activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span> &amp;&amp; mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity temp = activityReference.get();</span><br><span class=\"line\">                <span class=\"comment\">// 清理掉已经释放的activity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == activity) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activity.finish();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭指定类名的所有Activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cls</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity activity = activityReference.get();</span><br><span class=\"line\">                <span class=\"comment\">// 清理掉已经释放的activity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity.getClass().equals(cls)) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    activity.finish();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 结束所有Activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishAllActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (WeakReference&lt;Activity&gt; activityReference : mActivityStack) &#123;</span><br><span class=\"line\">                Activity activity = activityReference.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    activity.finish();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mActivityStack.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 退出应用程序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exitApp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            finishAllActivity();</span><br><span class=\"line\">            <span class=\"comment\">// 退出JVM,释放所占内存资源,0表示正常退出</span></span><br><span class=\"line\">            System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 从系统中kill掉应用程序</span></span><br><span class=\"line\">            android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是一个BaseActivity类， 重写onCreate和onDestory方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.chenlei.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.annotation.Nullable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        MyActivityManager.addActivity(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"有activity新添加\"</span>, <span class=\"string\">\"onCreate: \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"有activity被销毁\"</span>, <span class=\"string\">\"onDestroy: \"</span>+ MyActivityManager.getSize());</span><br><span class=\"line\">        MyActivityManager.finishActivity(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作</p>\n<p>网上原文：<br><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html\" target=\"_blank\" rel=\"noopener\">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html</a></p>\n"},{"title":"Android自定义注解","date":"2020-06-27T03:06:02.000Z","_content":"\n因为要自定义一个页面导航工具，需要使用自定义注解\n\n## 1. 创建Java Library\n\n创建两个新的module，**创建时module一定要选择Java Library**\n\n两个module分别是:\n* libnavannotation 注解\n* libnavcompile 注解处理器\n\n\n\n## 2. 定义注解\n\n定义两个注解ActivityDestination, FragmentDestination\n\n```kotlin\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class ActivityDestination(\n    val pageUrl: String,\n    val needLogin: Boolean = false,\n    val asStarter: Boolean = false\n)\n```\n\n```kotlin\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class FragmentDestination(\n    val pageUrl: String,\n    val needLogin: Boolean = false,\n    val asStarter: Boolean = false\n)\n```\n\n## 3. 定义注解处理器（关键）\n\n### 3.1 配置build.gradle\n\n```groovy\napply plugin: 'java-library'\napply plugin: 'kotlin'\napply plugin: 'kotlin-kapt'\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    implementation 'com.alibaba:fastjson:1.2.59'\n\n    implementation project(':libnavannotation')\n    implementation 'com.google.auto.service:auto-service:1.0-rc6'\n//    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'\n    kapt 'com.google.auto.service:auto-service:1.0-rc6'\n}\n\nsourceCompatibility = \"8\"\ntargetCompatibility = \"8\"\n```\n\n需要注意以下几点：\n* 如果注解处理器是使用kotlin编写的，那么，一定要添加`kotlin-kapt`插件\n* implementation 导入annotation注解模块\n* 导入auto-service注解处理器依赖，如果是纯Java代码，可以使用`annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'`， **如果是kotlin代码，必须使用`    kapt 'com.google.auto.service:auto-service:1.0-rc6'`。** 我这里还implementation了auto-service\n\n### 3.2 编写注解处理器\n\n```kotlin\n\n@AutoService(Processor::class)\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\n@SupportedAnnotationTypes(\n    \"com.example.libnavannotation.ActivityDestination\",\n    \"com.example.libnavannotation.FragmentDestination\"\n)\nclass NavProcessor : AbstractProcessor() {\n\n    override fun init(processingEnv: ProcessingEnvironment) {\n        super.init(processingEnv)\n        \n        ...\n        \n    }\n\n    override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {\n\n        ...\n        \n    }\n}\n```\n\n**注意注解处理器类上面的几个注解**\n\n### 3.3 创建processor configuration file\n\n这里取决于gradle的版本，**高版本必须创建processor配置文件，否则不会执行注解处理器的代码**\n\n* 需要在注解处理器所在module的 main 底下新建一个package，名称为 resources\n* 在 `resources` 底下新建文件 `META-INF/services/javax.annotation.processing.Processor`\n* 在 `javax.annotation.processing.Processor` 下写入 注解处理器的全名称  eg: `com.example.libnavcompiler.NavProcessor`\n\n## 4. 使用注解\n\n在Android工程module中配置build.gradle\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\n\n...\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    ...\n\n    implementation project(\":libnavannotation\")\n//    annotationProcessor project(\":libnavcompiler\")\n    kapt project(\":libnavcompiler\")\n}\n```\n\n导入 注解module、注解处理器module\nkotlin相关的注意事项和 注解处理器module 中的一样\n\n```kotlin\n@FragmentDestination(pageUrl = \"main/tabs/home\", asStarter = true)\nclass HomeFragment : Fragment() {\n    \n    ...\n\n}\n```\n\n在build中点击`make project`，即可执行直接处理器中的代码。如果遇到不成功，可以`rebuild`再试一次\n\n## 参考\n\n[教你如何完全解析Kotlin中的注解](https://juejin.im/post/5cb7ebeee51d456e8833394b#heading-0)\n\n[Android 开发之 自定义注解处理器](https://juejin.im/post/5e58dca26fb9a07cb24aa1d6#heading-4)\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android自定义注解.md","raw":"---\ntitle: Android自定义注解\ndate: 2020-06-27 11:06:02\ntags:\n- 注解\ncategories:\n- Android\n---\n\n因为要自定义一个页面导航工具，需要使用自定义注解\n\n## 1. 创建Java Library\n\n创建两个新的module，**创建时module一定要选择Java Library**\n\n两个module分别是:\n* libnavannotation 注解\n* libnavcompile 注解处理器\n\n\n\n## 2. 定义注解\n\n定义两个注解ActivityDestination, FragmentDestination\n\n```kotlin\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class ActivityDestination(\n    val pageUrl: String,\n    val needLogin: Boolean = false,\n    val asStarter: Boolean = false\n)\n```\n\n```kotlin\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class FragmentDestination(\n    val pageUrl: String,\n    val needLogin: Boolean = false,\n    val asStarter: Boolean = false\n)\n```\n\n## 3. 定义注解处理器（关键）\n\n### 3.1 配置build.gradle\n\n```groovy\napply plugin: 'java-library'\napply plugin: 'kotlin'\napply plugin: 'kotlin-kapt'\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    implementation 'com.alibaba:fastjson:1.2.59'\n\n    implementation project(':libnavannotation')\n    implementation 'com.google.auto.service:auto-service:1.0-rc6'\n//    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'\n    kapt 'com.google.auto.service:auto-service:1.0-rc6'\n}\n\nsourceCompatibility = \"8\"\ntargetCompatibility = \"8\"\n```\n\n需要注意以下几点：\n* 如果注解处理器是使用kotlin编写的，那么，一定要添加`kotlin-kapt`插件\n* implementation 导入annotation注解模块\n* 导入auto-service注解处理器依赖，如果是纯Java代码，可以使用`annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'`， **如果是kotlin代码，必须使用`    kapt 'com.google.auto.service:auto-service:1.0-rc6'`。** 我这里还implementation了auto-service\n\n### 3.2 编写注解处理器\n\n```kotlin\n\n@AutoService(Processor::class)\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\n@SupportedAnnotationTypes(\n    \"com.example.libnavannotation.ActivityDestination\",\n    \"com.example.libnavannotation.FragmentDestination\"\n)\nclass NavProcessor : AbstractProcessor() {\n\n    override fun init(processingEnv: ProcessingEnvironment) {\n        super.init(processingEnv)\n        \n        ...\n        \n    }\n\n    override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {\n\n        ...\n        \n    }\n}\n```\n\n**注意注解处理器类上面的几个注解**\n\n### 3.3 创建processor configuration file\n\n这里取决于gradle的版本，**高版本必须创建processor配置文件，否则不会执行注解处理器的代码**\n\n* 需要在注解处理器所在module的 main 底下新建一个package，名称为 resources\n* 在 `resources` 底下新建文件 `META-INF/services/javax.annotation.processing.Processor`\n* 在 `javax.annotation.processing.Processor` 下写入 注解处理器的全名称  eg: `com.example.libnavcompiler.NavProcessor`\n\n## 4. 使用注解\n\n在Android工程module中配置build.gradle\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\n\n...\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    ...\n\n    implementation project(\":libnavannotation\")\n//    annotationProcessor project(\":libnavcompiler\")\n    kapt project(\":libnavcompiler\")\n}\n```\n\n导入 注解module、注解处理器module\nkotlin相关的注意事项和 注解处理器module 中的一样\n\n```kotlin\n@FragmentDestination(pageUrl = \"main/tabs/home\", asStarter = true)\nclass HomeFragment : Fragment() {\n    \n    ...\n\n}\n```\n\n在build中点击`make project`，即可执行直接处理器中的代码。如果遇到不成功，可以`rebuild`再试一次\n\n## 参考\n\n[教你如何完全解析Kotlin中的注解](https://juejin.im/post/5cb7ebeee51d456e8833394b#heading-0)\n\n[Android 开发之 自定义注解处理器](https://juejin.im/post/5e58dca26fb9a07cb24aa1d6#heading-4)\n\n\n\n\n\n\n\n\n\n","slug":"Android/Android自定义注解","published":1,"updated":"2020-06-27T04:13:13.593Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakq700098mzm84rt7hid","content":"<p>因为要自定义一个页面导航工具，需要使用自定义注解</p><a id=\"more\"></a>\n<h2 id=\"1-创建Java-Library\"><a href=\"#1-创建Java-Library\" class=\"headerlink\" title=\"1. 创建Java Library\"></a>1. 创建Java Library</h2><p>创建两个新的module，<strong>创建时module一定要选择Java Library</strong></p>\n<p>两个module分别是:</p>\n<ul>\n<li>libnavannotation 注解</li>\n<li>libnavcompile 注解处理器</li>\n</ul>\n<h2 id=\"2-定义注解\"><a href=\"#2-定义注解\" class=\"headerlink\" title=\"2. 定义注解\"></a>2. 定义注解</h2><p>定义两个注解ActivityDestination, FragmentDestination</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityDestination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pageUrl: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> needLogin: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> asStarter: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentDestination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pageUrl: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> needLogin: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> asStarter: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-定义注解处理器（关键）\"><a href=\"#3-定义注解处理器（关键）\" class=\"headerlink\" title=\"3. 定义注解处理器（关键）\"></a>3. 定义注解处理器（关键）</h2><h3 id=\"3-1-配置build-gradle\"><a href=\"#3-1-配置build-gradle\" class=\"headerlink\" title=\"3.1 配置build.gradle\"></a>3.1 配置build.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    implementation <span class=\"string\">'com.alibaba:fastjson:1.2.59'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">':libnavannotation'</span>)</span><br><span class=\"line\">    implementation <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\"><span class=\"comment\">//    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\">    kapt <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"8\"</span></span><br></pre></td></tr></table></figure>\n<p>需要注意以下几点：</p>\n<ul>\n<li>如果注解处理器是使用kotlin编写的，那么，一定要添加<code>kotlin-kapt</code>插件</li>\n<li>implementation 导入annotation注解模块</li>\n<li>导入auto-service注解处理器依赖，如果是纯Java代码，可以使用<code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>， <strong>如果是kotlin代码，必须使用<code>kapt &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>。</strong> 我这里还implementation了auto-service</li>\n</ul>\n<h3 id=\"3-2-编写注解处理器\"><a href=\"#3-2-编写注解处理器\" class=\"headerlink\" title=\"3.2 编写注解处理器\"></a>3.2 编写注解处理器</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@AutoService(Processor::class)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"meta-string\">\"com.example.libnavannotation.ActivityDestination\"</span>,</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"meta-string\">\"com.example.libnavannotation.FragmentDestination\"</span></span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NavProcessor</span> : <span class=\"type\">AbstractProcessor</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">init</span><span class=\"params\">(processingEnv: <span class=\"type\">ProcessingEnvironment</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(processingEnv)</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(annotations: <span class=\"type\">Set</span>&lt;<span class=\"type\">TypeElement</span>&gt;, roundEnv: <span class=\"type\">RoundEnvironment</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意注解处理器类上面的几个注解</strong></p>\n<h3 id=\"3-3-创建processor-configuration-file\"><a href=\"#3-3-创建processor-configuration-file\" class=\"headerlink\" title=\"3.3 创建processor configuration file\"></a>3.3 创建processor configuration file</h3><p>这里取决于gradle的版本，<strong>高版本必须创建processor配置文件，否则不会执行注解处理器的代码</strong></p>\n<ul>\n<li>需要在注解处理器所在module的 main 底下新建一个package，名称为 resources</li>\n<li>在 <code>resources</code> 底下新建文件 <code>META-INF/services/javax.annotation.processing.Processor</code></li>\n<li>在 <code>javax.annotation.processing.Processor</code> 下写入 注解处理器的全名称  eg: <code>com.example.libnavcompiler.NavProcessor</code></li>\n</ul>\n<h2 id=\"4-使用注解\"><a href=\"#4-使用注解\" class=\"headerlink\" title=\"4. 使用注解\"></a>4. 使用注解</h2><p>在Android工程module中配置build.gradle</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android-extensions'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">\":libnavannotation\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//    annotationProcessor project(\":libnavcompiler\")</span></span><br><span class=\"line\">    kapt project(<span class=\"string\">\":libnavcompiler\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>导入 注解module、注解处理器module<br>kotlin相关的注意事项和 注解处理器module 中的一样</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FragmentDestination(pageUrl = <span class=\"meta-string\">\"main/tabs/home\"</span>, asStarter = true)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeFragment</span> : <span class=\"type\">Fragment</span></span>() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在build中点击<code>make project</code>，即可执行直接处理器中的代码。如果遇到不成功，可以<code>rebuild</code>再试一次</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/post/5cb7ebeee51d456e8833394b#heading-0\" target=\"_blank\" rel=\"noopener\">教你如何完全解析Kotlin中的注解</a></p>\n<p><a href=\"https://juejin.im/post/5e58dca26fb9a07cb24aa1d6#heading-4\" target=\"_blank\" rel=\"noopener\">Android 开发之 自定义注解处理器</a></p>\n","site":{"data":{}},"excerpt":"<p>因为要自定义一个页面导航工具，需要使用自定义注解</p>","more":"\n<h2 id=\"1-创建Java-Library\"><a href=\"#1-创建Java-Library\" class=\"headerlink\" title=\"1. 创建Java Library\"></a>1. 创建Java Library</h2><p>创建两个新的module，<strong>创建时module一定要选择Java Library</strong></p>\n<p>两个module分别是:</p>\n<ul>\n<li>libnavannotation 注解</li>\n<li>libnavcompile 注解处理器</li>\n</ul>\n<h2 id=\"2-定义注解\"><a href=\"#2-定义注解\" class=\"headerlink\" title=\"2. 定义注解\"></a>2. 定义注解</h2><p>定义两个注解ActivityDestination, FragmentDestination</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityDestination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pageUrl: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> needLogin: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> asStarter: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentDestination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pageUrl: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> needLogin: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> asStarter: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-定义注解处理器（关键）\"><a href=\"#3-定义注解处理器（关键）\" class=\"headerlink\" title=\"3. 定义注解处理器（关键）\"></a>3. 定义注解处理器（关键）</h2><h3 id=\"3-1-配置build-gradle\"><a href=\"#3-1-配置build-gradle\" class=\"headerlink\" title=\"3.1 配置build.gradle\"></a>3.1 配置build.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    implementation <span class=\"string\">'com.alibaba:fastjson:1.2.59'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">':libnavannotation'</span>)</span><br><span class=\"line\">    implementation <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\"><span class=\"comment\">//    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\">    kapt <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"8\"</span></span><br></pre></td></tr></table></figure>\n<p>需要注意以下几点：</p>\n<ul>\n<li>如果注解处理器是使用kotlin编写的，那么，一定要添加<code>kotlin-kapt</code>插件</li>\n<li>implementation 导入annotation注解模块</li>\n<li>导入auto-service注解处理器依赖，如果是纯Java代码，可以使用<code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>， <strong>如果是kotlin代码，必须使用<code>kapt &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>。</strong> 我这里还implementation了auto-service</li>\n</ul>\n<h3 id=\"3-2-编写注解处理器\"><a href=\"#3-2-编写注解处理器\" class=\"headerlink\" title=\"3.2 编写注解处理器\"></a>3.2 编写注解处理器</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@AutoService(Processor::class)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"meta-string\">\"com.example.libnavannotation.ActivityDestination\"</span>,</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"meta-string\">\"com.example.libnavannotation.FragmentDestination\"</span></span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NavProcessor</span> : <span class=\"type\">AbstractProcessor</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">init</span><span class=\"params\">(processingEnv: <span class=\"type\">ProcessingEnvironment</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(processingEnv)</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(annotations: <span class=\"type\">Set</span>&lt;<span class=\"type\">TypeElement</span>&gt;, roundEnv: <span class=\"type\">RoundEnvironment</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意注解处理器类上面的几个注解</strong></p>\n<h3 id=\"3-3-创建processor-configuration-file\"><a href=\"#3-3-创建processor-configuration-file\" class=\"headerlink\" title=\"3.3 创建processor configuration file\"></a>3.3 创建processor configuration file</h3><p>这里取决于gradle的版本，<strong>高版本必须创建processor配置文件，否则不会执行注解处理器的代码</strong></p>\n<ul>\n<li>需要在注解处理器所在module的 main 底下新建一个package，名称为 resources</li>\n<li>在 <code>resources</code> 底下新建文件 <code>META-INF/services/javax.annotation.processing.Processor</code></li>\n<li>在 <code>javax.annotation.processing.Processor</code> 下写入 注解处理器的全名称  eg: <code>com.example.libnavcompiler.NavProcessor</code></li>\n</ul>\n<h2 id=\"4-使用注解\"><a href=\"#4-使用注解\" class=\"headerlink\" title=\"4. 使用注解\"></a>4. 使用注解</h2><p>在Android工程module中配置build.gradle</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android-extensions'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">\":libnavannotation\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//    annotationProcessor project(\":libnavcompiler\")</span></span><br><span class=\"line\">    kapt project(<span class=\"string\">\":libnavcompiler\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>导入 注解module、注解处理器module<br>kotlin相关的注意事项和 注解处理器module 中的一样</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FragmentDestination(pageUrl = <span class=\"meta-string\">\"main/tabs/home\"</span>, asStarter = true)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeFragment</span> : <span class=\"type\">Fragment</span></span>() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在build中点击<code>make project</code>，即可执行直接处理器中的代码。如果遇到不成功，可以<code>rebuild</code>再试一次</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/post/5cb7ebeee51d456e8833394b#heading-0\" target=\"_blank\" rel=\"noopener\">教你如何完全解析Kotlin中的注解</a></p>\n<p><a href=\"https://juejin.im/post/5e58dca26fb9a07cb24aa1d6#heading-4\" target=\"_blank\" rel=\"noopener\">Android 开发之 自定义注解处理器</a></p>\n"},{"title":"LayoutInflater解析","date":"2019-08-13T12:31:21.000Z","Categories":["Android","View"],"_content":"\n# LayoutInflater解析\n\n## 源码\n\n```\nView result = root;\n```\n\n``` \n// Temp is the root view that was found in the xml\nfinal View temp = createViewFromTag(root, name, inflaterContext, attrs);\n\nViewGroup.LayoutParams params = null;\nif (root != null) {\n    // Create layout params that match root, if supplied\n    params = root.generateLayoutParams(attrs);\n    if (!attachToRoot) {\n        // Set the layout params for temp if we are not\n        // attaching. (If we are, we use addView, below)\n        temp.setLayoutParams(params);\n    }\n}\n```\n\n``` \n// Inflate all children under temp against its context.\n\nrInflateChildren(parser, temp, attrs, true);\n\n// We are supposed to attach all the views we found (int temp)\n// to root. Do that now.\nif (root != null && attachToRoot) {\n    root.addView(temp, params);\n}\n\n// Decide whether to return the root that was passed in or the\n// top view found in xml.\nif (root == null || !attachToRoot) {\n    result = temp;\n}\n```\n\n```\nreturn result;\n```\n\n### 使用方法\n```\nLayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ;\n```\n* 第一个参数是layout资源文件id\n* 第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam\n* 第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中\n\n**需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view**\n\n","source":"_posts/Android/LayoutInflater解析.md","raw":"---\ntitle: LayoutInflater解析\ndate: 2019-08-13 20:31:21\ntags:\n- Android\n- View\nCategories:\n- Android\n- View\n---\n\n# LayoutInflater解析\n\n## 源码\n\n```\nView result = root;\n```\n\n``` \n// Temp is the root view that was found in the xml\nfinal View temp = createViewFromTag(root, name, inflaterContext, attrs);\n\nViewGroup.LayoutParams params = null;\nif (root != null) {\n    // Create layout params that match root, if supplied\n    params = root.generateLayoutParams(attrs);\n    if (!attachToRoot) {\n        // Set the layout params for temp if we are not\n        // attaching. (If we are, we use addView, below)\n        temp.setLayoutParams(params);\n    }\n}\n```\n\n``` \n// Inflate all children under temp against its context.\n\nrInflateChildren(parser, temp, attrs, true);\n\n// We are supposed to attach all the views we found (int temp)\n// to root. Do that now.\nif (root != null && attachToRoot) {\n    root.addView(temp, params);\n}\n\n// Decide whether to return the root that was passed in or the\n// top view found in xml.\nif (root == null || !attachToRoot) {\n    result = temp;\n}\n```\n\n```\nreturn result;\n```\n\n### 使用方法\n```\nLayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ;\n```\n* 第一个参数是layout资源文件id\n* 第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam\n* 第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中\n\n**需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view**\n\n","slug":"Android/LayoutInflater解析","published":1,"updated":"2019-12-21T12:16:41.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqa000b8mzmzbuw69cw","content":"<h1 id=\"LayoutInflater解析\"><a href=\"#LayoutInflater解析\" class=\"headerlink\" title=\"LayoutInflater解析\"></a>LayoutInflater解析</h1><h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View result = root;</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Temp is the root view that was found in the xml</span><br><span class=\"line\">final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\"></span><br><span class=\"line\">ViewGroup.LayoutParams params = null;</span><br><span class=\"line\">if (root != null) &#123;</span><br><span class=\"line\">    // Create layout params that match root, if supplied</span><br><span class=\"line\">    params = root.generateLayoutParams(attrs);</span><br><span class=\"line\">    if (!attachToRoot) &#123;</span><br><span class=\"line\">        // Set the layout params for temp if we are not</span><br><span class=\"line\">        // attaching. (If we are, we use addView, below)</span><br><span class=\"line\">        temp.setLayoutParams(params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Inflate all children under temp against its context.</span><br><span class=\"line\"></span><br><span class=\"line\">rInflateChildren(parser, temp, attrs, true);</span><br><span class=\"line\"></span><br><span class=\"line\">// We are supposed to attach all the views we found (int temp)</span><br><span class=\"line\">// to root. Do that now.</span><br><span class=\"line\">if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class=\"line\">    root.addView(temp, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Decide whether to return the root that was passed in or the</span><br><span class=\"line\">// top view found in xml.</span><br><span class=\"line\">if (root == null || !attachToRoot) &#123;</span><br><span class=\"line\">    result = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return result;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数是layout资源文件id</li>\n<li>第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam</li>\n<li>第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中</li>\n</ul>\n<p><strong>需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"LayoutInflater解析\"><a href=\"#LayoutInflater解析\" class=\"headerlink\" title=\"LayoutInflater解析\"></a>LayoutInflater解析</h1><h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View result = root;</span><br></pre></td></tr></table></figure>","more":"\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Temp is the root view that was found in the xml</span><br><span class=\"line\">final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\"></span><br><span class=\"line\">ViewGroup.LayoutParams params = null;</span><br><span class=\"line\">if (root != null) &#123;</span><br><span class=\"line\">    // Create layout params that match root, if supplied</span><br><span class=\"line\">    params = root.generateLayoutParams(attrs);</span><br><span class=\"line\">    if (!attachToRoot) &#123;</span><br><span class=\"line\">        // Set the layout params for temp if we are not</span><br><span class=\"line\">        // attaching. (If we are, we use addView, below)</span><br><span class=\"line\">        temp.setLayoutParams(params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Inflate all children under temp against its context.</span><br><span class=\"line\"></span><br><span class=\"line\">rInflateChildren(parser, temp, attrs, true);</span><br><span class=\"line\"></span><br><span class=\"line\">// We are supposed to attach all the views we found (int temp)</span><br><span class=\"line\">// to root. Do that now.</span><br><span class=\"line\">if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class=\"line\">    root.addView(temp, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Decide whether to return the root that was passed in or the</span><br><span class=\"line\">// top view found in xml.</span><br><span class=\"line\">if (root == null || !attachToRoot) &#123;</span><br><span class=\"line\">    result = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return result;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数是layout资源文件id</li>\n<li>第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam</li>\n<li>第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中</li>\n</ul>\n<p><strong>需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view</strong></p>\n"},{"title":"Handler防止内存泄露","date":"2019-04-14T10:59:55.000Z","_content":"\n# Handler防止内存泄露\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyHandler mHandler = new MyHandler(this);\n    private TextView mTextView ;\n    private static class MyHandler extends Handler {\n        private WeakReference<Context> reference;\n        public MyHandler(Context context) {\n            reference = new WeakReference<>(context);\n        }\n        @Override\n        public void handleMessage(Message msg) {\n            MainActivity activity = (MainActivity) reference.get();\n            if(activity != null){\n                activity.mTextView.setText(\"\");\n            }\n        }\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mTextView = (TextView)findViewById(R.id.textview);\n        loadData();\n    }\n   //loadData()方法是在子线程中，执行\n    private void loadData() {\n        //...request\n        Message message = Message.obtain();\n        mHandler.sendMessage(message);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        //如果你的Handler被delay（延时了）,可以做如下的处理\n        mHandler.removeCallbacksAndMessages(null);\n    }\n}\n```\n\n## 解释\n\n创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息\n\n使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。\n\n\n\n","source":"_posts/Android/Handler防止内存泄露.md","raw":"---\ntitle: Handler防止内存泄露\ndate: 2019-04-14 18:59:55\ntags:\n- Handler\n- 内存泄露\ncategories: \n- Android\n---\n\n# Handler防止内存泄露\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyHandler mHandler = new MyHandler(this);\n    private TextView mTextView ;\n    private static class MyHandler extends Handler {\n        private WeakReference<Context> reference;\n        public MyHandler(Context context) {\n            reference = new WeakReference<>(context);\n        }\n        @Override\n        public void handleMessage(Message msg) {\n            MainActivity activity = (MainActivity) reference.get();\n            if(activity != null){\n                activity.mTextView.setText(\"\");\n            }\n        }\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mTextView = (TextView)findViewById(R.id.textview);\n        loadData();\n    }\n   //loadData()方法是在子线程中，执行\n    private void loadData() {\n        //...request\n        Message message = Message.obtain();\n        mHandler.sendMessage(message);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        //如果你的Handler被delay（延时了）,可以做如下的处理\n        mHandler.removeCallbacksAndMessages(null);\n    }\n}\n```\n\n## 解释\n\n创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息\n\n使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。\n\n\n\n","slug":"Android/Handler防止内存泄露","published":1,"updated":"2019-12-21T12:16:41.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqb000c8mzmqg0w0x2p","content":"<h1 id=\"Handler防止内存泄露\"><a href=\"#Handler防止内存泄露\" class=\"headerlink\" title=\"Handler防止内存泄露\"></a>Handler防止内存泄露</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyHandler mHandler = <span class=\"keyword\">new</span> MyHandler(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextView mTextView ;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> WeakReference&lt;Context&gt; reference;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyHandler</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">            reference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            MainActivity activity = (MainActivity) reference.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                activity.mTextView.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class=\"line\">        loadData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//loadData()方法是在子线程中，执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...request</span></span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        mHandler.sendMessage(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">        <span class=\"comment\">//如果你的Handler被delay（延时了）,可以做如下的处理</span></span><br><span class=\"line\">        mHandler.removeCallbacksAndMessages(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息</p>\n<p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Handler防止内存泄露\"><a href=\"#Handler防止内存泄露\" class=\"headerlink\" title=\"Handler防止内存泄露\"></a>Handler防止内存泄露</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyHandler mHandler = <span class=\"keyword\">new</span> MyHandler(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextView mTextView ;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> WeakReference&lt;Context&gt; reference;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyHandler</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">            reference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            MainActivity activity = (MainActivity) reference.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                activity.mTextView.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class=\"line\">        loadData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//loadData()方法是在子线程中，执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...request</span></span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        mHandler.sendMessage(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">        <span class=\"comment\">//如果你的Handler被delay（延时了）,可以做如下的处理</span></span><br><span class=\"line\">        mHandler.removeCallbacksAndMessages(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息</p>\n<p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。</p>\n"},{"title":"RecyclerView全局刷新的问题","date":"2019-09-15T07:33:22.000Z","_content":"\n## 1. RecyclerView全局刷新避免出现闪烁\n\n闪烁是因为RecyclerView有默认的动画, 把默认动画去掉就可以了\n\n```java\nmTabListRecycler.getItemAnimator().setChangeDuration(0);\n((SimpleItemAnimator) mTabListRecycler.getItemAnimator()).setSupportsChangeAnimations(false);\n```\n\n## 2. RecyclerView全局刷新避免出现滚动\n\n```java\nmTabListRecycler.setHasFixedSize(true);\n```\nsetHasFixedSize(true)的意思是表示, RecyclerView的大小是不收Adapter的内容影响的, 这样RecyclerView绘制的时候会有很多优化. 同时也能够解决刷新的滚动问题\n\n## 3. RecyclerView全局刷新View避免卡顿\n\n### 3.1 onBindViewHolder(VH holder, int position， List<Object> payloads)\n\n这个方法默认是调用普通的onBindViewHolder方法。\n我们可以重写这个方法，在payloads参数为空时，执行默认的onBindViewHolder，在其不为空时，刷新每个item特定的view\n在调用notifyxxxx类似方法的时候，调用包含payload参数的重载方法\n\n#### 问题：\n实践了上面的方法，发现卡顿的问题得到了缓解，但是并没有完全解决\n\n### 3.2 创建并操作自己的ViewHolder缓存\n\n#### 还是有卡顿的原因：\n\n在调用notifyxxxx相关方法时，即使添加了payload参数，依然会有很多item刷新时走onCreateViewHolder方法，在这里进行inflate操作会非常耗时。所以要想办法跳过onCreateViewHolder方法\n\n##### 创建自己的viewholder缓存\n\n1. 创建缓存集合\n```\nprivate List<ViewHolder> holderList = new ArrayList<>();\n```\n\n2. 添加到集合\n```\nholder.itemView.setTag(itemData));\nif (!holderList.contains(holder)) {\n    holderList.add(holder);\n}\n```\n因为在添加之前做了是否包含的判断，所以集合中按道理之后包含显示的ViewHolder以及缓存的ViewHolder，集合的size并不会无限制的增长。\n\n3. 刷新\n```\npublic void update(){\n    for (ViewHolder holder : holderList) { \n        ItemData itemData = (ItemData) holder.itemView.getTag();\n        // update view\n    }\n}\n```\n卡顿问题解决","source":"_posts/Android/RecyclerView全局刷新的问题.md","raw":"---\ntitle: RecyclerView全局刷新的问题\ndate: 2019-09-15 15:33:22\ntags:\n- Android\n- View\n- RecyclerView\ncategories:\n- Android\n- View\n---\n\n## 1. RecyclerView全局刷新避免出现闪烁\n\n闪烁是因为RecyclerView有默认的动画, 把默认动画去掉就可以了\n\n```java\nmTabListRecycler.getItemAnimator().setChangeDuration(0);\n((SimpleItemAnimator) mTabListRecycler.getItemAnimator()).setSupportsChangeAnimations(false);\n```\n\n## 2. RecyclerView全局刷新避免出现滚动\n\n```java\nmTabListRecycler.setHasFixedSize(true);\n```\nsetHasFixedSize(true)的意思是表示, RecyclerView的大小是不收Adapter的内容影响的, 这样RecyclerView绘制的时候会有很多优化. 同时也能够解决刷新的滚动问题\n\n## 3. RecyclerView全局刷新View避免卡顿\n\n### 3.1 onBindViewHolder(VH holder, int position， List<Object> payloads)\n\n这个方法默认是调用普通的onBindViewHolder方法。\n我们可以重写这个方法，在payloads参数为空时，执行默认的onBindViewHolder，在其不为空时，刷新每个item特定的view\n在调用notifyxxxx类似方法的时候，调用包含payload参数的重载方法\n\n#### 问题：\n实践了上面的方法，发现卡顿的问题得到了缓解，但是并没有完全解决\n\n### 3.2 创建并操作自己的ViewHolder缓存\n\n#### 还是有卡顿的原因：\n\n在调用notifyxxxx相关方法时，即使添加了payload参数，依然会有很多item刷新时走onCreateViewHolder方法，在这里进行inflate操作会非常耗时。所以要想办法跳过onCreateViewHolder方法\n\n##### 创建自己的viewholder缓存\n\n1. 创建缓存集合\n```\nprivate List<ViewHolder> holderList = new ArrayList<>();\n```\n\n2. 添加到集合\n```\nholder.itemView.setTag(itemData));\nif (!holderList.contains(holder)) {\n    holderList.add(holder);\n}\n```\n因为在添加之前做了是否包含的判断，所以集合中按道理之后包含显示的ViewHolder以及缓存的ViewHolder，集合的size并不会无限制的增长。\n\n3. 刷新\n```\npublic void update(){\n    for (ViewHolder holder : holderList) { \n        ItemData itemData = (ItemData) holder.itemView.getTag();\n        // update view\n    }\n}\n```\n卡顿问题解决","slug":"Android/RecyclerView全局刷新的问题","published":1,"updated":"2020-03-20T07:24:13.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqc000h8mzmif6fe1y1","content":"<h2 id=\"1-RecyclerView全局刷新避免出现闪烁\"><a href=\"#1-RecyclerView全局刷新避免出现闪烁\" class=\"headerlink\" title=\"1. RecyclerView全局刷新避免出现闪烁\"></a>1. RecyclerView全局刷新避免出现闪烁</h2><a id=\"more\"></a><p>闪烁是因为RecyclerView有默认的动画, 把默认动画去掉就可以了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mTabListRecycler.getItemAnimator().setChangeDuration(<span class=\"number\">0</span>);</span><br><span class=\"line\">((SimpleItemAnimator) mTabListRecycler.getItemAnimator()).setSupportsChangeAnimations(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-RecyclerView全局刷新避免出现滚动\"><a href=\"#2-RecyclerView全局刷新避免出现滚动\" class=\"headerlink\" title=\"2. RecyclerView全局刷新避免出现滚动\"></a>2. RecyclerView全局刷新避免出现滚动</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mTabListRecycler.setHasFixedSize(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>setHasFixedSize(true)的意思是表示, RecyclerView的大小是不收Adapter的内容影响的, 这样RecyclerView绘制的时候会有很多优化. 同时也能够解决刷新的滚动问题</p>\n<h2 id=\"3-RecyclerView全局刷新View避免卡顿\"><a href=\"#3-RecyclerView全局刷新View避免卡顿\" class=\"headerlink\" title=\"3. RecyclerView全局刷新View避免卡顿\"></a>3. RecyclerView全局刷新View避免卡顿</h2><h3 id=\"3-1-onBindViewHolder-VH-holder-int-position，-List-payloads\"><a href=\"#3-1-onBindViewHolder-VH-holder-int-position，-List-payloads\" class=\"headerlink\" title=\"3.1 onBindViewHolder(VH holder, int position， List payloads)\"></a>3.1 onBindViewHolder(VH holder, int position， List<object> payloads)</object></h3><p>这个方法默认是调用普通的onBindViewHolder方法。<br>我们可以重写这个方法，在payloads参数为空时，执行默认的onBindViewHolder，在其不为空时，刷新每个item特定的view<br>在调用notifyxxxx类似方法的时候，调用包含payload参数的重载方法</p>\n<h4 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h4><p>实践了上面的方法，发现卡顿的问题得到了缓解，但是并没有完全解决</p>\n<h3 id=\"3-2-创建并操作自己的ViewHolder缓存\"><a href=\"#3-2-创建并操作自己的ViewHolder缓存\" class=\"headerlink\" title=\"3.2 创建并操作自己的ViewHolder缓存\"></a>3.2 创建并操作自己的ViewHolder缓存</h3><h4 id=\"还是有卡顿的原因：\"><a href=\"#还是有卡顿的原因：\" class=\"headerlink\" title=\"还是有卡顿的原因：\"></a>还是有卡顿的原因：</h4><p>在调用notifyxxxx相关方法时，即使添加了payload参数，依然会有很多item刷新时走onCreateViewHolder方法，在这里进行inflate操作会非常耗时。所以要想办法跳过onCreateViewHolder方法</p>\n<h5 id=\"创建自己的viewholder缓存\"><a href=\"#创建自己的viewholder缓存\" class=\"headerlink\" title=\"创建自己的viewholder缓存\"></a>创建自己的viewholder缓存</h5><ol>\n<li><p>创建缓存集合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;ViewHolder&gt; holderList = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加到集合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">holder.itemView.setTag(itemData));</span><br><span class=\"line\">if (!holderList.contains(holder)) &#123;</span><br><span class=\"line\">    holderList.add(holder);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>因为在添加之前做了是否包含的判断，所以集合中按道理之后包含显示的ViewHolder以及缓存的ViewHolder，集合的size并不会无限制的增长。</p>\n<ol start=\"3\">\n<li>刷新<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void update()&#123;</span><br><span class=\"line\">    for (ViewHolder holder : holderList) &#123; </span><br><span class=\"line\">        ItemData itemData = (ItemData) holder.itemView.getTag();</span><br><span class=\"line\">        // update view</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>卡顿问题解决</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-RecyclerView全局刷新避免出现闪烁\"><a href=\"#1-RecyclerView全局刷新避免出现闪烁\" class=\"headerlink\" title=\"1. RecyclerView全局刷新避免出现闪烁\"></a>1. RecyclerView全局刷新避免出现闪烁</h2>","more":"<p>闪烁是因为RecyclerView有默认的动画, 把默认动画去掉就可以了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mTabListRecycler.getItemAnimator().setChangeDuration(<span class=\"number\">0</span>);</span><br><span class=\"line\">((SimpleItemAnimator) mTabListRecycler.getItemAnimator()).setSupportsChangeAnimations(<span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-RecyclerView全局刷新避免出现滚动\"><a href=\"#2-RecyclerView全局刷新避免出现滚动\" class=\"headerlink\" title=\"2. RecyclerView全局刷新避免出现滚动\"></a>2. RecyclerView全局刷新避免出现滚动</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mTabListRecycler.setHasFixedSize(<span class=\"keyword\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>setHasFixedSize(true)的意思是表示, RecyclerView的大小是不收Adapter的内容影响的, 这样RecyclerView绘制的时候会有很多优化. 同时也能够解决刷新的滚动问题</p>\n<h2 id=\"3-RecyclerView全局刷新View避免卡顿\"><a href=\"#3-RecyclerView全局刷新View避免卡顿\" class=\"headerlink\" title=\"3. RecyclerView全局刷新View避免卡顿\"></a>3. RecyclerView全局刷新View避免卡顿</h2><h3 id=\"3-1-onBindViewHolder-VH-holder-int-position，-List-payloads\"><a href=\"#3-1-onBindViewHolder-VH-holder-int-position，-List-payloads\" class=\"headerlink\" title=\"3.1 onBindViewHolder(VH holder, int position， List payloads)\"></a>3.1 onBindViewHolder(VH holder, int position， List<object> payloads)</object></h3><p>这个方法默认是调用普通的onBindViewHolder方法。<br>我们可以重写这个方法，在payloads参数为空时，执行默认的onBindViewHolder，在其不为空时，刷新每个item特定的view<br>在调用notifyxxxx类似方法的时候，调用包含payload参数的重载方法</p>\n<h4 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h4><p>实践了上面的方法，发现卡顿的问题得到了缓解，但是并没有完全解决</p>\n<h3 id=\"3-2-创建并操作自己的ViewHolder缓存\"><a href=\"#3-2-创建并操作自己的ViewHolder缓存\" class=\"headerlink\" title=\"3.2 创建并操作自己的ViewHolder缓存\"></a>3.2 创建并操作自己的ViewHolder缓存</h3><h4 id=\"还是有卡顿的原因：\"><a href=\"#还是有卡顿的原因：\" class=\"headerlink\" title=\"还是有卡顿的原因：\"></a>还是有卡顿的原因：</h4><p>在调用notifyxxxx相关方法时，即使添加了payload参数，依然会有很多item刷新时走onCreateViewHolder方法，在这里进行inflate操作会非常耗时。所以要想办法跳过onCreateViewHolder方法</p>\n<h5 id=\"创建自己的viewholder缓存\"><a href=\"#创建自己的viewholder缓存\" class=\"headerlink\" title=\"创建自己的viewholder缓存\"></a>创建自己的viewholder缓存</h5><ol>\n<li><p>创建缓存集合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private List&lt;ViewHolder&gt; holderList = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加到集合</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">holder.itemView.setTag(itemData));</span><br><span class=\"line\">if (!holderList.contains(holder)) &#123;</span><br><span class=\"line\">    holderList.add(holder);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>因为在添加之前做了是否包含的判断，所以集合中按道理之后包含显示的ViewHolder以及缓存的ViewHolder，集合的size并不会无限制的增长。</p>\n<ol start=\"3\">\n<li>刷新<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void update()&#123;</span><br><span class=\"line\">    for (ViewHolder holder : holderList) &#123; </span><br><span class=\"line\">        ItemData itemData = (ItemData) holder.itemView.getTag();</span><br><span class=\"line\">        // update view</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>卡顿问题解决</p>\n"},{"title":"RecyclerView缓存机制总结","date":"2019-08-14T16:31:17.000Z","_content":"\n# RecyclerView缓存机制总结\n\n## 基本概念\n**scrapped:** \nA \"scrapped\" view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse\n\n## RecyclerView中涉及到缓存的集合\n\n* mAttachedScrap\n    * 显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。\n* mChangedScrap\n    * 显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生\n* mCachedViews \n    * 在屏幕外的Holder。缓存，幕刃大小为2。\n* mRecyclerPool\n    * 在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法\n\nmAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。\nmRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法\n**很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。**\n\n## RecyclerView获取Holder的顺序(sdk 28)\n\n1. getChangedScrapViewForPosition\n2. getScrapOrHiddenOrCachedHolderForPosition\n3. getScrapOrCachedViewForId\n4. getChildViewHolder\n5. mViewCacheExtension.getViewForPositionAndType\n6. getRecycledViewPool().getRecycledView\n7. mAdapter.createViewHolder\n\n## 四级缓存\n1. mAttachedScrap  mChangedScrap\n2. mCacheView\n3. mViewCacheExtension\n4. mRecyclerPool\n\n## ListView的缓存机制\n\n### 缓存的集合\n* mActiveViews \n    * 屏幕内的view，可直接重用\n* mScrapViews\n    * 屏幕外的view，需要调用bind\n\n### 与RecyclerView的不同\n1. 缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。\n2. RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。 \n而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView）\n3. RecyclerView可以实现局部刷新， ListView不行\n\n\n## 参考：\n[RecyclerView源码分析缓存机制](https://blog.jiahuan.me/2018/07/27/RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/)\n\n[RecyclerView的缓存机制](https://www.jianshu.com/p/efe81969f69d)\n\n[Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21#wechat_redirect)\n","source":"_posts/Android/RecyclerView缓存机制总结.md","raw":"---\ntitle: RecyclerView缓存机制总结\ndate: 2019-08-15 00:31:17\ntags:\n- Android\n- View\ncategories:\n- Android\n- View\n---\n\n# RecyclerView缓存机制总结\n\n## 基本概念\n**scrapped:** \nA \"scrapped\" view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse\n\n## RecyclerView中涉及到缓存的集合\n\n* mAttachedScrap\n    * 显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。\n* mChangedScrap\n    * 显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生\n* mCachedViews \n    * 在屏幕外的Holder。缓存，幕刃大小为2。\n* mRecyclerPool\n    * 在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法\n\nmAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。\nmRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法\n**很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。**\n\n## RecyclerView获取Holder的顺序(sdk 28)\n\n1. getChangedScrapViewForPosition\n2. getScrapOrHiddenOrCachedHolderForPosition\n3. getScrapOrCachedViewForId\n4. getChildViewHolder\n5. mViewCacheExtension.getViewForPositionAndType\n6. getRecycledViewPool().getRecycledView\n7. mAdapter.createViewHolder\n\n## 四级缓存\n1. mAttachedScrap  mChangedScrap\n2. mCacheView\n3. mViewCacheExtension\n4. mRecyclerPool\n\n## ListView的缓存机制\n\n### 缓存的集合\n* mActiveViews \n    * 屏幕内的view，可直接重用\n* mScrapViews\n    * 屏幕外的view，需要调用bind\n\n### 与RecyclerView的不同\n1. 缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。\n2. RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。 \n而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView）\n3. RecyclerView可以实现局部刷新， ListView不行\n\n\n## 参考：\n[RecyclerView源码分析缓存机制](https://blog.jiahuan.me/2018/07/27/RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/)\n\n[RecyclerView的缓存机制](https://www.jianshu.com/p/efe81969f69d)\n\n[Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21#wechat_redirect)\n","slug":"Android/RecyclerView缓存机制总结","published":1,"updated":"2019-12-21T12:16:41.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqd000i8mzm1yb9ui6l","content":"<h1 id=\"RecyclerView缓存机制总结\"><a href=\"#RecyclerView缓存机制总结\" class=\"headerlink\" title=\"RecyclerView缓存机制总结\"></a>RecyclerView缓存机制总结</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><a id=\"more\"></a><p><strong>scrapped:</strong><br>A “scrapped” view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse</p>\n<h2 id=\"RecyclerView中涉及到缓存的集合\"><a href=\"#RecyclerView中涉及到缓存的集合\" class=\"headerlink\" title=\"RecyclerView中涉及到缓存的集合\"></a>RecyclerView中涉及到缓存的集合</h2><ul>\n<li>mAttachedScrap<ul>\n<li>显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。</li>\n</ul>\n</li>\n<li>mChangedScrap<ul>\n<li>显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生</li>\n</ul>\n</li>\n<li>mCachedViews <ul>\n<li>在屏幕外的Holder。缓存，幕刃大小为2。</li>\n</ul>\n</li>\n<li>mRecyclerPool<ul>\n<li>在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法</li>\n</ul>\n</li>\n</ul>\n<p>mAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。<br>mRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法<br><strong>很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。</strong></p>\n<h2 id=\"RecyclerView获取Holder的顺序-sdk-28\"><a href=\"#RecyclerView获取Holder的顺序-sdk-28\" class=\"headerlink\" title=\"RecyclerView获取Holder的顺序(sdk 28)\"></a>RecyclerView获取Holder的顺序(sdk 28)</h2><ol>\n<li>getChangedScrapViewForPosition</li>\n<li>getScrapOrHiddenOrCachedHolderForPosition</li>\n<li>getScrapOrCachedViewForId</li>\n<li>getChildViewHolder</li>\n<li>mViewCacheExtension.getViewForPositionAndType</li>\n<li>getRecycledViewPool().getRecycledView</li>\n<li>mAdapter.createViewHolder</li>\n</ol>\n<h2 id=\"四级缓存\"><a href=\"#四级缓存\" class=\"headerlink\" title=\"四级缓存\"></a>四级缓存</h2><ol>\n<li>mAttachedScrap  mChangedScrap</li>\n<li>mCacheView</li>\n<li>mViewCacheExtension</li>\n<li>mRecyclerPool</li>\n</ol>\n<h2 id=\"ListView的缓存机制\"><a href=\"#ListView的缓存机制\" class=\"headerlink\" title=\"ListView的缓存机制\"></a>ListView的缓存机制</h2><h3 id=\"缓存的集合\"><a href=\"#缓存的集合\" class=\"headerlink\" title=\"缓存的集合\"></a>缓存的集合</h3><ul>\n<li>mActiveViews <ul>\n<li>屏幕内的view，可直接重用</li>\n</ul>\n</li>\n<li>mScrapViews<ul>\n<li>屏幕外的view，需要调用bind</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与RecyclerView的不同\"><a href=\"#与RecyclerView的不同\" class=\"headerlink\" title=\"与RecyclerView的不同\"></a>与RecyclerView的不同</h3><ol>\n<li>缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。</li>\n<li>RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。<br>而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView）</li>\n<li>RecyclerView可以实现局部刷新， ListView不行</li>\n</ol>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://blog.jiahuan.me/2018/07/27/RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">RecyclerView源码分析缓存机制</a></p>\n<p><a href=\"https://www.jianshu.com/p/efe81969f69d\" target=\"_blank\" rel=\"noopener\">RecyclerView的缓存机制</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578065&amp;idx=2&amp;sn=25e64a8bb7b5934cf0ce2e49549a80d6&amp;chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">Android ListView 与 RecyclerView 对比浅析–缓存机制</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"RecyclerView缓存机制总结\"><a href=\"#RecyclerView缓存机制总结\" class=\"headerlink\" title=\"RecyclerView缓存机制总结\"></a>RecyclerView缓存机制总结</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2>","more":"<p><strong>scrapped:</strong><br>A “scrapped” view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse</p>\n<h2 id=\"RecyclerView中涉及到缓存的集合\"><a href=\"#RecyclerView中涉及到缓存的集合\" class=\"headerlink\" title=\"RecyclerView中涉及到缓存的集合\"></a>RecyclerView中涉及到缓存的集合</h2><ul>\n<li>mAttachedScrap<ul>\n<li>显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。</li>\n</ul>\n</li>\n<li>mChangedScrap<ul>\n<li>显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生</li>\n</ul>\n</li>\n<li>mCachedViews <ul>\n<li>在屏幕外的Holder。缓存，幕刃大小为2。</li>\n</ul>\n</li>\n<li>mRecyclerPool<ul>\n<li>在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法</li>\n</ul>\n</li>\n</ul>\n<p>mAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。<br>mRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法<br><strong>很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。</strong></p>\n<h2 id=\"RecyclerView获取Holder的顺序-sdk-28\"><a href=\"#RecyclerView获取Holder的顺序-sdk-28\" class=\"headerlink\" title=\"RecyclerView获取Holder的顺序(sdk 28)\"></a>RecyclerView获取Holder的顺序(sdk 28)</h2><ol>\n<li>getChangedScrapViewForPosition</li>\n<li>getScrapOrHiddenOrCachedHolderForPosition</li>\n<li>getScrapOrCachedViewForId</li>\n<li>getChildViewHolder</li>\n<li>mViewCacheExtension.getViewForPositionAndType</li>\n<li>getRecycledViewPool().getRecycledView</li>\n<li>mAdapter.createViewHolder</li>\n</ol>\n<h2 id=\"四级缓存\"><a href=\"#四级缓存\" class=\"headerlink\" title=\"四级缓存\"></a>四级缓存</h2><ol>\n<li>mAttachedScrap  mChangedScrap</li>\n<li>mCacheView</li>\n<li>mViewCacheExtension</li>\n<li>mRecyclerPool</li>\n</ol>\n<h2 id=\"ListView的缓存机制\"><a href=\"#ListView的缓存机制\" class=\"headerlink\" title=\"ListView的缓存机制\"></a>ListView的缓存机制</h2><h3 id=\"缓存的集合\"><a href=\"#缓存的集合\" class=\"headerlink\" title=\"缓存的集合\"></a>缓存的集合</h3><ul>\n<li>mActiveViews <ul>\n<li>屏幕内的view，可直接重用</li>\n</ul>\n</li>\n<li>mScrapViews<ul>\n<li>屏幕外的view，需要调用bind</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与RecyclerView的不同\"><a href=\"#与RecyclerView的不同\" class=\"headerlink\" title=\"与RecyclerView的不同\"></a>与RecyclerView的不同</h3><ol>\n<li>缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。</li>\n<li>RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。<br>而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView）</li>\n<li>RecyclerView可以实现局部刷新， ListView不行</li>\n</ol>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://blog.jiahuan.me/2018/07/27/RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">RecyclerView源码分析缓存机制</a></p>\n<p><a href=\"https://www.jianshu.com/p/efe81969f69d\" target=\"_blank\" rel=\"noopener\">RecyclerView的缓存机制</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578065&amp;idx=2&amp;sn=25e64a8bb7b5934cf0ce2e49549a80d6&amp;chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">Android ListView 与 RecyclerView 对比浅析–缓存机制</a></p>\n"},{"title":"MVP模式防止内存泄露","date":"2019-04-15T00:54:27.000Z","_content":"\n# MVP模式防止内存泄露\n### 参考链接\nhttps://jocherch.github.io/mvp/mvp-memory-leak/\nhttps://blog.csdn.net/Xiong_IT/article/details/52610729\n\n### 发生内存泄露的原因\n由于Presenter经常性地需要执行一些耗时的操作，例如，我们经常使用的网络请求数据。当 Presenter 持有了 Activity 的强引用，如果在请求结束之前，Activity 被销毁了，那么由于网络请求还没有返回，导致 Presenter 一直持有 Activity 对象的引用，使得该对象无法被系统回收，此时就发生了内存泄露。\n\n**解决方案：通过弱引用和 Activity / Fragment 的生命周期来解决这个问题。**\n\n**Model**\n```java\ninterface BaseMvpModel{\n    public void mvpCancleTasks();\n        // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api\n    \n}\n```\n**View**\n```java\ninterface BaseMvpView{\n    public void mvpDetachView();\n    /*\n        例如\n        @Override\n        public void onDestroy() {\n            super.onDestroy();\n            mPresenter.mvpDestroy();\n            mPresenter = null;\n        }\n    */\n}\n```\n\n**Presenter**\n```java\ninterface BaseMvpPresenter{\n    public void mvpDestory();\n    /*例如:\n        public void mvpDestory() {\n            view = null;\n            if(modle != null) {\n                modle.mvpaCncleTasks();\n                modle = null;\n            }\n        }\n    */\n}\n```\n\n这里只是创建了一个BaseInterface用于让mvp的接口去继承，没有做更加详细的封装，仅仅由于提示。主要是不同的模块处理可能会有不同的操作\n\n**注意要使用WeakReference**\n并不是在任何情况下Activity的onDestroy都会被调用（其它原因导致Activity对象还在被引用，就不会回调onDestroy方法），一旦这种情况发生，弱引用也能够保证不会造成内存泄露。\n\n","source":"_posts/Android/MVP模式防止内存泄露.md","raw":"---\ntitle: MVP模式防止内存泄露\ndate: 2019-04-15 08:54:27\ntags:\n- MVP\n- 内存泄露\ncategories:\n- Android\n---\n\n# MVP模式防止内存泄露\n### 参考链接\nhttps://jocherch.github.io/mvp/mvp-memory-leak/\nhttps://blog.csdn.net/Xiong_IT/article/details/52610729\n\n### 发生内存泄露的原因\n由于Presenter经常性地需要执行一些耗时的操作，例如，我们经常使用的网络请求数据。当 Presenter 持有了 Activity 的强引用，如果在请求结束之前，Activity 被销毁了，那么由于网络请求还没有返回，导致 Presenter 一直持有 Activity 对象的引用，使得该对象无法被系统回收，此时就发生了内存泄露。\n\n**解决方案：通过弱引用和 Activity / Fragment 的生命周期来解决这个问题。**\n\n**Model**\n```java\ninterface BaseMvpModel{\n    public void mvpCancleTasks();\n        // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api\n    \n}\n```\n**View**\n```java\ninterface BaseMvpView{\n    public void mvpDetachView();\n    /*\n        例如\n        @Override\n        public void onDestroy() {\n            super.onDestroy();\n            mPresenter.mvpDestroy();\n            mPresenter = null;\n        }\n    */\n}\n```\n\n**Presenter**\n```java\ninterface BaseMvpPresenter{\n    public void mvpDestory();\n    /*例如:\n        public void mvpDestory() {\n            view = null;\n            if(modle != null) {\n                modle.mvpaCncleTasks();\n                modle = null;\n            }\n        }\n    */\n}\n```\n\n这里只是创建了一个BaseInterface用于让mvp的接口去继承，没有做更加详细的封装，仅仅由于提示。主要是不同的模块处理可能会有不同的操作\n\n**注意要使用WeakReference**\n并不是在任何情况下Activity的onDestroy都会被调用（其它原因导致Activity对象还在被引用，就不会回调onDestroy方法），一旦这种情况发生，弱引用也能够保证不会造成内存泄露。\n\n","slug":"Android/MVP模式防止内存泄露","published":1,"updated":"2019-12-21T12:16:41.874Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqf000m8mzm81uz56qx","content":"<h1 id=\"MVP模式防止内存泄露\"><a href=\"#MVP模式防止内存泄露\" class=\"headerlink\" title=\"MVP模式防止内存泄露\"></a>MVP模式防止内存泄露</h1><h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://jocherch.github.io/mvp/mvp-memory-leak/\" target=\"_blank\" rel=\"noopener\">https://jocherch.github.io/mvp/mvp-memory-leak/</a><br><a href=\"https://blog.csdn.net/Xiong_IT/article/details/52610729\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Xiong_IT/article/details/52610729</a></p><a id=\"more\"></a>\n<h3 id=\"发生内存泄露的原因\"><a href=\"#发生内存泄露的原因\" class=\"headerlink\" title=\"发生内存泄露的原因\"></a>发生内存泄露的原因</h3><p>由于Presenter经常性地需要执行一些耗时的操作，例如，我们经常使用的网络请求数据。当 Presenter 持有了 Activity 的强引用，如果在请求结束之前，Activity 被销毁了，那么由于网络请求还没有返回，导致 Presenter 一直持有 Activity 对象的引用，使得该对象无法被系统回收，此时就发生了内存泄露。</p>\n<p><strong>解决方案：通过弱引用和 Activity / Fragment 的生命周期来解决这个问题。</strong></p>\n<p><strong>Model</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseMvpModel</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mvpCancleTasks</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>View</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseMvpView</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mvpDetachView</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        例如</span></span><br><span class=\"line\"><span class=\"comment\">        @Override</span></span><br><span class=\"line\"><span class=\"comment\">        public void onDestroy() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            super.onDestroy();</span></span><br><span class=\"line\"><span class=\"comment\">            mPresenter.mvpDestroy();</span></span><br><span class=\"line\"><span class=\"comment\">            mPresenter = null;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Presenter</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseMvpPresenter</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mvpDestory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/*例如:</span></span><br><span class=\"line\"><span class=\"comment\">        public void mvpDestory() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            view = null;</span></span><br><span class=\"line\"><span class=\"comment\">            if(modle != null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                modle.mvpaCncleTasks();</span></span><br><span class=\"line\"><span class=\"comment\">                modle = null;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里只是创建了一个BaseInterface用于让mvp的接口去继承，没有做更加详细的封装，仅仅由于提示。主要是不同的模块处理可能会有不同的操作</p>\n<p><strong>注意要使用WeakReference</strong><br>并不是在任何情况下Activity的onDestroy都会被调用（其它原因导致Activity对象还在被引用，就不会回调onDestroy方法），一旦这种情况发生，弱引用也能够保证不会造成内存泄露。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"MVP模式防止内存泄露\"><a href=\"#MVP模式防止内存泄露\" class=\"headerlink\" title=\"MVP模式防止内存泄露\"></a>MVP模式防止内存泄露</h1><h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://jocherch.github.io/mvp/mvp-memory-leak/\" target=\"_blank\" rel=\"noopener\">https://jocherch.github.io/mvp/mvp-memory-leak/</a><br><a href=\"https://blog.csdn.net/Xiong_IT/article/details/52610729\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Xiong_IT/article/details/52610729</a></p>","more":"\n<h3 id=\"发生内存泄露的原因\"><a href=\"#发生内存泄露的原因\" class=\"headerlink\" title=\"发生内存泄露的原因\"></a>发生内存泄露的原因</h3><p>由于Presenter经常性地需要执行一些耗时的操作，例如，我们经常使用的网络请求数据。当 Presenter 持有了 Activity 的强引用，如果在请求结束之前，Activity 被销毁了，那么由于网络请求还没有返回，导致 Presenter 一直持有 Activity 对象的引用，使得该对象无法被系统回收，此时就发生了内存泄露。</p>\n<p><strong>解决方案：通过弱引用和 Activity / Fragment 的生命周期来解决这个问题。</strong></p>\n<p><strong>Model</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseMvpModel</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mvpCancleTasks</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>View</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseMvpView</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mvpDetachView</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        例如</span></span><br><span class=\"line\"><span class=\"comment\">        @Override</span></span><br><span class=\"line\"><span class=\"comment\">        public void onDestroy() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            super.onDestroy();</span></span><br><span class=\"line\"><span class=\"comment\">            mPresenter.mvpDestroy();</span></span><br><span class=\"line\"><span class=\"comment\">            mPresenter = null;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Presenter</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BaseMvpPresenter</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mvpDestory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">/*例如:</span></span><br><span class=\"line\"><span class=\"comment\">        public void mvpDestory() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            view = null;</span></span><br><span class=\"line\"><span class=\"comment\">            if(modle != null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                modle.mvpaCncleTasks();</span></span><br><span class=\"line\"><span class=\"comment\">                modle = null;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里只是创建了一个BaseInterface用于让mvp的接口去继承，没有做更加详细的封装，仅仅由于提示。主要是不同的模块处理可能会有不同的操作</p>\n<p><strong>注意要使用WeakReference</strong><br>并不是在任何情况下Activity的onDestroy都会被调用（其它原因导致Activity对象还在被引用，就不会回调onDestroy方法），一旦这种情况发生，弱引用也能够保证不会造成内存泄露。</p>\n"},{"title":"Scale动画组合使用的坑","date":"2019-08-02T01:43:37.000Z","_content":"\n# Scale动画组合使用的坑\n\n## API\n```java\n        Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n```\n参数1: X的初始值\n参数2: X的最终值\n参数3: Y的初始值\n参数4: Y的最终值\n参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放\n参数6: X轴缩放轴点，1f表示以View的最右端为轴点\n参数7: Y轴，同参数5\n参数8: Y轴，同参数6\n\n## 问题\n一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小\n```java\n// start animation\n        AnimationSet animationSet = new AnimationSet(false);\n        Animation alpha = new AlphaAnimation(0, 100);\n        alpha.setDuration(80);\n        Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n        scale.setDuration(160);\n        scale.setInterpolator(PathInterpolatorCompat.create(0.32f, 0.66f, 0.6f, 1f));\n        Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n        scale2.setDuration(70);\n        scale2.setStartOffset(160);\n        animationSet.addAnimation(scale);\n        animationSet.addAnimation(scale2);\n        animationSet.addAnimation(alpha);\n        tv.startAnimation(animationSet);\n```\n\n但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小\n\n## 原因\nscale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子\n```java\nAnimation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\nscale2.setDuration(70);\nscale2.setStartOffset(160);\n```","source":"_posts/Android/Scale动画组合使用的坑.md","raw":"---\ntitle: Scale动画组合使用的坑\ndate: 2019-08-02 09:43:37\ntags:\n- Animation\n- View\ncategories:\n- Android\n- View\n---\n\n# Scale动画组合使用的坑\n\n## API\n```java\n        Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n```\n参数1: X的初始值\n参数2: X的最终值\n参数3: Y的初始值\n参数4: Y的最终值\n参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放\n参数6: X轴缩放轴点，1f表示以View的最右端为轴点\n参数7: Y轴，同参数5\n参数8: Y轴，同参数6\n\n## 问题\n一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小\n```java\n// start animation\n        AnimationSet animationSet = new AnimationSet(false);\n        Animation alpha = new AlphaAnimation(0, 100);\n        alpha.setDuration(80);\n        Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n        scale.setDuration(160);\n        scale.setInterpolator(PathInterpolatorCompat.create(0.32f, 0.66f, 0.6f, 1f));\n        Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n        scale2.setDuration(70);\n        scale2.setStartOffset(160);\n        animationSet.addAnimation(scale);\n        animationSet.addAnimation(scale2);\n        animationSet.addAnimation(alpha);\n        tv.startAnimation(animationSet);\n```\n\n但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小\n\n## 原因\nscale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子\n```java\nAnimation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\nscale2.setDuration(70);\nscale2.setStartOffset(160);\n```","slug":"Android/Scale动画组合使用的坑","published":1,"updated":"2019-12-21T12:16:41.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqg000o8mzmmc4orls1","content":"<h1 id=\"Scale动画组合使用的坑\"><a href=\"#Scale动画组合使用的坑\" class=\"headerlink\" title=\"Scale动画组合使用的坑\"></a>Scale动画组合使用的坑</h1><h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation scale = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<p>参数1: X的初始值<br>参数2: X的最终值<br>参数3: Y的初始值<br>参数4: Y的最终值<br>参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放<br>参数6: X轴缩放轴点，1f表示以View的最右端为轴点<br>参数7: Y轴，同参数5<br>参数8: Y轴，同参数6</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// start animation</span></span><br><span class=\"line\">        AnimationSet animationSet = <span class=\"keyword\">new</span> AnimationSet(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        Animation alpha = <span class=\"keyword\">new</span> AlphaAnimation(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        alpha.setDuration(<span class=\"number\">80</span>);</span><br><span class=\"line\">        Animation scale = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">        scale.setDuration(<span class=\"number\">160</span>);</span><br><span class=\"line\">        scale.setInterpolator(PathInterpolatorCompat.create(<span class=\"number\">0.32f</span>, <span class=\"number\">0.66f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1f</span>));</span><br><span class=\"line\">        Animation scale2 = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">        scale2.setDuration(<span class=\"number\">70</span>);</span><br><span class=\"line\">        scale2.setStartOffset(<span class=\"number\">160</span>);</span><br><span class=\"line\">        animationSet.addAnimation(scale);</span><br><span class=\"line\">        animationSet.addAnimation(scale2);</span><br><span class=\"line\">        animationSet.addAnimation(alpha);</span><br><span class=\"line\">        tv.startAnimation(animationSet);</span><br></pre></td></tr></table></figure></p>\n<p>但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>scale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation scale2 = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">scale2.setDuration(<span class=\"number\">70</span>);</span><br><span class=\"line\">scale2.setStartOffset(<span class=\"number\">160</span>);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Scale动画组合使用的坑\"><a href=\"#Scale动画组合使用的坑\" class=\"headerlink\" title=\"Scale动画组合使用的坑\"></a>Scale动画组合使用的坑</h1><h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation scale = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>","more":"\n<p>参数1: X的初始值<br>参数2: X的最终值<br>参数3: Y的初始值<br>参数4: Y的最终值<br>参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放<br>参数6: X轴缩放轴点，1f表示以View的最右端为轴点<br>参数7: Y轴，同参数5<br>参数8: Y轴，同参数6</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// start animation</span></span><br><span class=\"line\">        AnimationSet animationSet = <span class=\"keyword\">new</span> AnimationSet(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        Animation alpha = <span class=\"keyword\">new</span> AlphaAnimation(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        alpha.setDuration(<span class=\"number\">80</span>);</span><br><span class=\"line\">        Animation scale = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">        scale.setDuration(<span class=\"number\">160</span>);</span><br><span class=\"line\">        scale.setInterpolator(PathInterpolatorCompat.create(<span class=\"number\">0.32f</span>, <span class=\"number\">0.66f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1f</span>));</span><br><span class=\"line\">        Animation scale2 = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">        scale2.setDuration(<span class=\"number\">70</span>);</span><br><span class=\"line\">        scale2.setStartOffset(<span class=\"number\">160</span>);</span><br><span class=\"line\">        animationSet.addAnimation(scale);</span><br><span class=\"line\">        animationSet.addAnimation(scale2);</span><br><span class=\"line\">        animationSet.addAnimation(alpha);</span><br><span class=\"line\">        tv.startAnimation(animationSet);</span><br></pre></td></tr></table></figure></p>\n<p>但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>scale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation scale2 = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">scale2.setDuration(<span class=\"number\">70</span>);</span><br><span class=\"line\">scale2.setStartOffset(<span class=\"number\">160</span>);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"RecyclerView设置item的间距","date":"2019-07-09T09:29:55.000Z","_content":"\n# RecyclerView设置item的间距\n\n## 关于GridLayoutManager\n\n当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，**实际上就是将屏幕均分为四份，每一份都是180px宽**（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。\n\n## 自定义ItemDecoration\n\n### getItemOffsets方法\n\n设置ItemView的内嵌偏移长度\n\nItemView 外面会包裹着一个矩形（outRect）\n内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔\n相当于为item添加了padding\n\n**常用的getItemOffsets的计算**\n\n```java\n// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等\npublic class EmojiItemDecoration extends RecyclerView.ItemDecoration {\n\n    private int mNumColumn;\n    private int mVerticalSpacing;\n    private int mItemWidth;\n    private int mItemHorizontalSpacing;\n    private boolean mInitSpacing = false;\n\n    public EmojiItemDecoration(int column, int itemWidth, int verticalSpacing) {\n        mNumColumn = column;\n        mItemWidth = itemWidth;\n        mVerticalSpacing = verticalSpacing;\n    }\n\n    @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {\n\n        if (!mInitSpacing) {\n            mInitSpacing = true;\n            int parentWidth = parent.getWidth();\n\n            mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + 1);\n        }\n        int position = parent.getChildAdapterPosition(view);\n        int column = position % mNumColumn;\n\n        outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn;\n        outRect.right = (column + 1) * mItemHorizontalSpacing / mNumColumn;\n        \n\n        if (position < mNumColumn) {\n            outRect.top = Dimensions.pxFromDp(12);\n        }\n\n        if (position >= mNumColumn) {\n            outRect.top = mVerticalSpacing;\n        }\n    }\n}\n```\n\n","source":"_posts/Android/RecyclerView设置item的间距.md","raw":"---\ntitle: RecyclerView设置item的间距\ndate: 2019-07-09 17:29:55\ntags:\n- View\n- RecyclerView\ncategories:\n- Android\n---\n\n# RecyclerView设置item的间距\n\n## 关于GridLayoutManager\n\n当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，**实际上就是将屏幕均分为四份，每一份都是180px宽**（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。\n\n## 自定义ItemDecoration\n\n### getItemOffsets方法\n\n设置ItemView的内嵌偏移长度\n\nItemView 外面会包裹着一个矩形（outRect）\n内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔\n相当于为item添加了padding\n\n**常用的getItemOffsets的计算**\n\n```java\n// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等\npublic class EmojiItemDecoration extends RecyclerView.ItemDecoration {\n\n    private int mNumColumn;\n    private int mVerticalSpacing;\n    private int mItemWidth;\n    private int mItemHorizontalSpacing;\n    private boolean mInitSpacing = false;\n\n    public EmojiItemDecoration(int column, int itemWidth, int verticalSpacing) {\n        mNumColumn = column;\n        mItemWidth = itemWidth;\n        mVerticalSpacing = verticalSpacing;\n    }\n\n    @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {\n\n        if (!mInitSpacing) {\n            mInitSpacing = true;\n            int parentWidth = parent.getWidth();\n\n            mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + 1);\n        }\n        int position = parent.getChildAdapterPosition(view);\n        int column = position % mNumColumn;\n\n        outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn;\n        outRect.right = (column + 1) * mItemHorizontalSpacing / mNumColumn;\n        \n\n        if (position < mNumColumn) {\n            outRect.top = Dimensions.pxFromDp(12);\n        }\n\n        if (position >= mNumColumn) {\n            outRect.top = mVerticalSpacing;\n        }\n    }\n}\n```\n\n","slug":"Android/RecyclerView设置item的间距","published":1,"updated":"2019-12-21T12:16:41.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqh000r8mzm76viv80k","content":"<h1 id=\"RecyclerView设置item的间距\"><a href=\"#RecyclerView设置item的间距\" class=\"headerlink\" title=\"RecyclerView设置item的间距\"></a>RecyclerView设置item的间距</h1><a id=\"more\"></a><h2 id=\"关于GridLayoutManager\"><a href=\"#关于GridLayoutManager\" class=\"headerlink\" title=\"关于GridLayoutManager\"></a>关于GridLayoutManager</h2><p>当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，<strong>实际上就是将屏幕均分为四份，每一份都是180px宽</strong>（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。</p>\n<h2 id=\"自定义ItemDecoration\"><a href=\"#自定义ItemDecoration\" class=\"headerlink\" title=\"自定义ItemDecoration\"></a>自定义ItemDecoration</h2><h3 id=\"getItemOffsets方法\"><a href=\"#getItemOffsets方法\" class=\"headerlink\" title=\"getItemOffsets方法\"></a>getItemOffsets方法</h3><p>设置ItemView的内嵌偏移长度</p>\n<p>ItemView 外面会包裹着一个矩形（outRect）<br>内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔<br>相当于为item添加了padding</p>\n<p><strong>常用的getItemOffsets的计算</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmojiItemDecoration</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ItemDecoration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mNumColumn;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mVerticalSpacing;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mItemWidth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mItemHorizontalSpacing;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mInitSpacing = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EmojiItemDecoration</span><span class=\"params\">(<span class=\"keyword\">int</span> column, <span class=\"keyword\">int</span> itemWidth, <span class=\"keyword\">int</span> verticalSpacing)</span> </span>&#123;</span><br><span class=\"line\">        mNumColumn = column;</span><br><span class=\"line\">        mItemWidth = itemWidth;</span><br><span class=\"line\">        mVerticalSpacing = verticalSpacing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getItemOffsets</span><span class=\"params\">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mInitSpacing) &#123;</span><br><span class=\"line\">            mInitSpacing = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> parentWidth = parent.getWidth();</span><br><span class=\"line\"></span><br><span class=\"line\">            mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> position = parent.getChildAdapterPosition(view);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> column = position % mNumColumn;</span><br><span class=\"line\"></span><br><span class=\"line\">        outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn;</span><br><span class=\"line\">        outRect.right = (column + <span class=\"number\">1</span>) * mItemHorizontalSpacing / mNumColumn;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position &lt; mNumColumn) &#123;</span><br><span class=\"line\">            outRect.top = Dimensions.pxFromDp(<span class=\"number\">12</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position &gt;= mNumColumn) &#123;</span><br><span class=\"line\">            outRect.top = mVerticalSpacing;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"RecyclerView设置item的间距\"><a href=\"#RecyclerView设置item的间距\" class=\"headerlink\" title=\"RecyclerView设置item的间距\"></a>RecyclerView设置item的间距</h1>","more":"<h2 id=\"关于GridLayoutManager\"><a href=\"#关于GridLayoutManager\" class=\"headerlink\" title=\"关于GridLayoutManager\"></a>关于GridLayoutManager</h2><p>当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，<strong>实际上就是将屏幕均分为四份，每一份都是180px宽</strong>（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。</p>\n<h2 id=\"自定义ItemDecoration\"><a href=\"#自定义ItemDecoration\" class=\"headerlink\" title=\"自定义ItemDecoration\"></a>自定义ItemDecoration</h2><h3 id=\"getItemOffsets方法\"><a href=\"#getItemOffsets方法\" class=\"headerlink\" title=\"getItemOffsets方法\"></a>getItemOffsets方法</h3><p>设置ItemView的内嵌偏移长度</p>\n<p>ItemView 外面会包裹着一个矩形（outRect）<br>内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔<br>相当于为item添加了padding</p>\n<p><strong>常用的getItemOffsets的计算</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmojiItemDecoration</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ItemDecoration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mNumColumn;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mVerticalSpacing;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mItemWidth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mItemHorizontalSpacing;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mInitSpacing = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EmojiItemDecoration</span><span class=\"params\">(<span class=\"keyword\">int</span> column, <span class=\"keyword\">int</span> itemWidth, <span class=\"keyword\">int</span> verticalSpacing)</span> </span>&#123;</span><br><span class=\"line\">        mNumColumn = column;</span><br><span class=\"line\">        mItemWidth = itemWidth;</span><br><span class=\"line\">        mVerticalSpacing = verticalSpacing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getItemOffsets</span><span class=\"params\">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mInitSpacing) &#123;</span><br><span class=\"line\">            mInitSpacing = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> parentWidth = parent.getWidth();</span><br><span class=\"line\"></span><br><span class=\"line\">            mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> position = parent.getChildAdapterPosition(view);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> column = position % mNumColumn;</span><br><span class=\"line\"></span><br><span class=\"line\">        outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn;</span><br><span class=\"line\">        outRect.right = (column + <span class=\"number\">1</span>) * mItemHorizontalSpacing / mNumColumn;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position &lt; mNumColumn) &#123;</span><br><span class=\"line\">            outRect.top = Dimensions.pxFromDp(<span class=\"number\">12</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position &gt;= mNumColumn) &#123;</span><br><span class=\"line\">            outRect.top = mVerticalSpacing;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"RemoteView刷新view","date":"2019-09-15T08:09:50.000Z","_content":"\n# RemoteView刷新View\n\n## 通知栏\n在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了\n但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。\n\n在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。\n其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了\n\n## 关于Intent\n由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。\n\n在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。\n这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。\n\n也就是说，**Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象**\n\n","source":"_posts/Android/RemoteView刷新View.md","raw":"---\ntitle: RemoteView刷新view\ndate: 2019-09-15 16:09:50\ntags:\n- Android\n- View\ncategories:\n- Android\n- View\n---\n\n# RemoteView刷新View\n\n## 通知栏\n在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了\n但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。\n\n在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。\n其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了\n\n## 关于Intent\n由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。\n\n在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。\n这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。\n\n也就是说，**Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象**\n\n","slug":"Android/RemoteView刷新View","published":1,"updated":"2019-12-21T12:16:41.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqi000t8mzmcirjmq70","content":"<h1 id=\"RemoteView刷新View\"><a href=\"#RemoteView刷新View\" class=\"headerlink\" title=\"RemoteView刷新View\"></a>RemoteView刷新View</h1><h2 id=\"通知栏\"><a href=\"#通知栏\" class=\"headerlink\" title=\"通知栏\"></a>通知栏</h2><p>在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了<br>但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。</p><a id=\"more\"></a>\n<p>在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。<br>其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了</p>\n<h2 id=\"关于Intent\"><a href=\"#关于Intent\" class=\"headerlink\" title=\"关于Intent\"></a>关于Intent</h2><p>由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。</p>\n<p>在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。<br>这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。</p>\n<p>也就是说，<strong>Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"RemoteView刷新View\"><a href=\"#RemoteView刷新View\" class=\"headerlink\" title=\"RemoteView刷新View\"></a>RemoteView刷新View</h1><h2 id=\"通知栏\"><a href=\"#通知栏\" class=\"headerlink\" title=\"通知栏\"></a>通知栏</h2><p>在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了<br>但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。</p>","more":"\n<p>在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。<br>其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了</p>\n<h2 id=\"关于Intent\"><a href=\"#关于Intent\" class=\"headerlink\" title=\"关于Intent\"></a>关于Intent</h2><p>由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。</p>\n<p>在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。<br>这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。</p>\n<p>也就是说，<strong>Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象</strong></p>\n"},{"title":"gradle相关基础","date":"2020-06-18T11:54:57.000Z","_content":"\n## Gradle中的对象\nGradle主要有三种对象\n这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：\n\n* Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。\n* Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。\n* Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。\n\n构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。\n\n## setting.gradle\n\n```groovy\ninclude ':app', ':progect_1', ':progect_2'\n```\n用于指示 Gradle 在构建应用时应将哪些模块包括在内\n\n## gradle.properties\n\n里面可以定义一些常量供build.gradle使用，如版本号等.\n然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。\n\n```groovy\nCOMPILE_SDK_VERSION = 23\nBUILD_TOOLS_VERSION = 23.0.1\nVERSION_CODE = 1\n```\n\n## build.gradle\nbuild文件有两种，一个是针对当前的Module，一个是针对项目中所有的module\n在顶层的build文件中，我们可以来添加一些子module所共有的一些配置\n\n下面是一些常用的build.gradle的配置说明\n```groovy\n// 应用插件，module中的build.gradle很多配置都是插件提供的支持\napply plugin: 'com.android.application'\n// 仓库， \nrepositories {\n    google()\n    jcenter()\n}\n// 外部依赖，添加的依赖会在这些配置的仓库中去寻找\ndependencies {\n    // \"group:name:version\"\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n}\n\n```\n\n## Task\n\n包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。\n\n* depandsOn: 依赖于其它任务\n* doFirst, doLast(<<): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作\n\napply的插件自带和很多Task，在Gradle页面的 `<项目名>/Tasks/build` 目录里面可以看到。\n我们也可以自己编写任务，自己的Task在Gradle页面的 `<项目名>/Tasks/other/` 目录里可以查找到\n\n\n## Gradle的工作流程\n\n![gradle的工作流程](/images/gradle的构建过程.jpg)\n\n* Initialization: 初始化，在多模块的项目中，就是执行settings.gradle\n* Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。  Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。\n* Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段\n\n简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。\n在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！\n\n在每一步的步骤中间可以添加hook\n\n\n\n```java\n\ntask a {\n    println 'this is a'\n    doFirst {\n        println 'this is a do first'\n    }\n    doLast {\n        println \"this is a do last\"\n    }\n}\n\ntask testBoth {\n    // 配置阶段\n    // 依赖 a task 先执行\n    dependsOn(\"a\")\n    println 'this is b'\n    doFirst {\n        // 执行阶段\n        println 'this is b first'\n    }\n    doLast {\n        // 执行阶段\n        println 'this is b last'\n    }\n}\n/**\n输出：\n\n> Configure project :\nthis is a\nthis is b\n\n> Task :a\nthis is a do first\nthis is a do last\n\n> Task :testBoth\nthis is b first\nthis is b last\n*/\n```\n\n## 解决依赖版本冲突\n\n大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。\n\n以下是我们自己解决版本冲突的一般步骤\n\n### 查看依赖报告\n运行Gradle， `<项目名称>/app/Tasks/dependencies/` 查看依赖报告，输出如下\n\n`xxxx -> xxxx` 表示依赖包自动提升到了最高版本\n\n```\n+--- androidx.lifecycle:lifecycle-extensions:2.1.0\n|    +--- androidx.lifecycle:lifecycle-runtime:2.1.0\n|    |    +--- androidx.lifecycle:lifecycle-common:2.1.0 -> 2.3.0-alpha01\n|    |    |    \\--- androidx.annotation:annotation:1.1.0\n|    |    +--- androidx.arch.core:core-common:2.1.0\n|    |    |    \\--- androidx.annotation:annotation:1.1.0\n|    |    \\--- androidx.annotation:annotation:1.1.0\n|    +--- androidx.arch.core:core-common:2.1.0 (*)\n|    +--- androidx.arch.core:core-runtime:2.1.0\n\n```\n\n### 排除传递性冲突\n\n```groovy\ncompile ('cn.qqtheme.framework:WheelPicker:1.5.1'){\n    exclude group:'com.android.support', module:\"appcompat\"\n}\n```\n\n### 强制一个版本\n```groovy\nconfigurations.all{\n    resolutionStrategy{\n        force 'androidx.appcompat:appcompat:1.1.0'\n    }\n}\n```","source":"_posts/Android/gradle相关基础.md","raw":"---\ntitle: gradle相关基础\ndate: 2020-06-18 19:54:57\ntags: \n- Gradle\ncategories:\n- Android\n---\n\n## Gradle中的对象\nGradle主要有三种对象\n这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：\n\n* Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。\n* Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。\n* Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。\n\n构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。\n\n## setting.gradle\n\n```groovy\ninclude ':app', ':progect_1', ':progect_2'\n```\n用于指示 Gradle 在构建应用时应将哪些模块包括在内\n\n## gradle.properties\n\n里面可以定义一些常量供build.gradle使用，如版本号等.\n然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。\n\n```groovy\nCOMPILE_SDK_VERSION = 23\nBUILD_TOOLS_VERSION = 23.0.1\nVERSION_CODE = 1\n```\n\n## build.gradle\nbuild文件有两种，一个是针对当前的Module，一个是针对项目中所有的module\n在顶层的build文件中，我们可以来添加一些子module所共有的一些配置\n\n下面是一些常用的build.gradle的配置说明\n```groovy\n// 应用插件，module中的build.gradle很多配置都是插件提供的支持\napply plugin: 'com.android.application'\n// 仓库， \nrepositories {\n    google()\n    jcenter()\n}\n// 外部依赖，添加的依赖会在这些配置的仓库中去寻找\ndependencies {\n    // \"group:name:version\"\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n}\n\n```\n\n## Task\n\n包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。\n\n* depandsOn: 依赖于其它任务\n* doFirst, doLast(<<): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作\n\napply的插件自带和很多Task，在Gradle页面的 `<项目名>/Tasks/build` 目录里面可以看到。\n我们也可以自己编写任务，自己的Task在Gradle页面的 `<项目名>/Tasks/other/` 目录里可以查找到\n\n\n## Gradle的工作流程\n\n![gradle的工作流程](/images/gradle的构建过程.jpg)\n\n* Initialization: 初始化，在多模块的项目中，就是执行settings.gradle\n* Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。  Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。\n* Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段\n\n简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。\n在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！\n\n在每一步的步骤中间可以添加hook\n\n\n\n```java\n\ntask a {\n    println 'this is a'\n    doFirst {\n        println 'this is a do first'\n    }\n    doLast {\n        println \"this is a do last\"\n    }\n}\n\ntask testBoth {\n    // 配置阶段\n    // 依赖 a task 先执行\n    dependsOn(\"a\")\n    println 'this is b'\n    doFirst {\n        // 执行阶段\n        println 'this is b first'\n    }\n    doLast {\n        // 执行阶段\n        println 'this is b last'\n    }\n}\n/**\n输出：\n\n> Configure project :\nthis is a\nthis is b\n\n> Task :a\nthis is a do first\nthis is a do last\n\n> Task :testBoth\nthis is b first\nthis is b last\n*/\n```\n\n## 解决依赖版本冲突\n\n大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。\n\n以下是我们自己解决版本冲突的一般步骤\n\n### 查看依赖报告\n运行Gradle， `<项目名称>/app/Tasks/dependencies/` 查看依赖报告，输出如下\n\n`xxxx -> xxxx` 表示依赖包自动提升到了最高版本\n\n```\n+--- androidx.lifecycle:lifecycle-extensions:2.1.0\n|    +--- androidx.lifecycle:lifecycle-runtime:2.1.0\n|    |    +--- androidx.lifecycle:lifecycle-common:2.1.0 -> 2.3.0-alpha01\n|    |    |    \\--- androidx.annotation:annotation:1.1.0\n|    |    +--- androidx.arch.core:core-common:2.1.0\n|    |    |    \\--- androidx.annotation:annotation:1.1.0\n|    |    \\--- androidx.annotation:annotation:1.1.0\n|    +--- androidx.arch.core:core-common:2.1.0 (*)\n|    +--- androidx.arch.core:core-runtime:2.1.0\n\n```\n\n### 排除传递性冲突\n\n```groovy\ncompile ('cn.qqtheme.framework:WheelPicker:1.5.1'){\n    exclude group:'com.android.support', module:\"appcompat\"\n}\n```\n\n### 强制一个版本\n```groovy\nconfigurations.all{\n    resolutionStrategy{\n        force 'androidx.appcompat:appcompat:1.1.0'\n    }\n}\n```","slug":"Android/gradle相关基础","published":1,"updated":"2020-06-27T03:05:08.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqj000x8mzmuv7x5oyx","content":"<h2 id=\"Gradle中的对象\"><a href=\"#Gradle中的对象\" class=\"headerlink\" title=\"Gradle中的对象\"></a>Gradle中的对象</h2><p>Gradle主要有三种对象<br>这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：</p><a id=\"more\"></a>\n<ul>\n<li>Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。</li>\n<li>Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。</li>\n<li>Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。</li>\n</ul>\n<p>构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。</p>\n<h2 id=\"setting-gradle\"><a href=\"#setting-gradle\" class=\"headerlink\" title=\"setting.gradle\"></a>setting.gradle</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">':app'</span>, <span class=\"string\">':progect_1'</span>, <span class=\"string\">':progect_2'</span></span><br></pre></td></tr></table></figure>\n<p>用于指示 Gradle 在构建应用时应将哪些模块包括在内</p>\n<h2 id=\"gradle-properties\"><a href=\"#gradle-properties\" class=\"headerlink\" title=\"gradle.properties\"></a>gradle.properties</h2><p>里面可以定义一些常量供build.gradle使用，如版本号等.<br>然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COMPILE_SDK_VERSION = <span class=\"number\">23</span></span><br><span class=\"line\">BUILD_TOOLS_VERSION = <span class=\"number\">23.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">VERSION_CODE = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"build-gradle\"><a href=\"#build-gradle\" class=\"headerlink\" title=\"build.gradle\"></a>build.gradle</h2><p>build文件有两种，一个是针对当前的Module，一个是针对项目中所有的module<br>在顶层的build文件中，我们可以来添加一些子module所共有的一些配置</p>\n<p>下面是一些常用的build.gradle的配置说明<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 应用插件，module中的build.gradle很多配置都是插件提供的支持</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"><span class=\"comment\">// 仓库， </span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    google()</span><br><span class=\"line\">    jcenter()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部依赖，添加的依赖会在这些配置的仓库中去寻找</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// \"group:name:version\"</span></span><br><span class=\"line\">    implementation <span class=\"string\">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h2><p>包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。</p>\n<ul>\n<li>depandsOn: 依赖于其它任务</li>\n<li>doFirst, doLast(&lt;&lt;): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作</li>\n</ul>\n<p>apply的插件自带和很多Task，在Gradle页面的 <code>&lt;项目名&gt;/Tasks/build</code> 目录里面可以看到。<br>我们也可以自己编写任务，自己的Task在Gradle页面的 <code>&lt;项目名&gt;/Tasks/other/</code> 目录里可以查找到</p>\n<h2 id=\"Gradle的工作流程\"><a href=\"#Gradle的工作流程\" class=\"headerlink\" title=\"Gradle的工作流程\"></a>Gradle的工作流程</h2><p><img src=\"/images/gradle的构建过程.jpg\" alt=\"gradle的工作流程\"></p>\n<ul>\n<li>Initialization: 初始化，在多模块的项目中，就是执行settings.gradle</li>\n<li>Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。  Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。</li>\n<li>Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段</li>\n</ul>\n<p>简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。<br>在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！</p>\n<p>在每一步的步骤中间可以添加hook</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">task a &#123;</span><br><span class=\"line\">    println <span class=\"string\">'this is a'</span></span><br><span class=\"line\">    doFirst &#123;</span><br><span class=\"line\">        println <span class=\"string\">'this is a do first'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">\"this is a do last\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task testBoth &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 配置阶段</span></span><br><span class=\"line\">    <span class=\"comment\">// 依赖 a task 先执行</span></span><br><span class=\"line\">    dependsOn(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\">    println <span class=\"string\">'this is b'</span></span><br><span class=\"line\">    doFirst &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\">        println <span class=\"string\">'this is b first'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\">        println <span class=\"string\">'this is b last'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">输出：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Configure project :</span></span><br><span class=\"line\"><span class=\"comment\">this is a</span></span><br><span class=\"line\"><span class=\"comment\">this is b</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Task :a</span></span><br><span class=\"line\"><span class=\"comment\">this is a do first</span></span><br><span class=\"line\"><span class=\"comment\">this is a do last</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Task :testBoth</span></span><br><span class=\"line\"><span class=\"comment\">this is b first</span></span><br><span class=\"line\"><span class=\"comment\">this is b last</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"解决依赖版本冲突\"><a href=\"#解决依赖版本冲突\" class=\"headerlink\" title=\"解决依赖版本冲突\"></a>解决依赖版本冲突</h2><p>大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。</p>\n<p>以下是我们自己解决版本冲突的一般步骤</p>\n<h3 id=\"查看依赖报告\"><a href=\"#查看依赖报告\" class=\"headerlink\" title=\"查看依赖报告\"></a>查看依赖报告</h3><p>运行Gradle， <code>&lt;项目名称&gt;/app/Tasks/dependencies/</code> 查看依赖报告，输出如下</p>\n<p><code>xxxx -&gt; xxxx</code> 表示依赖包自动提升到了最高版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--- androidx.lifecycle:lifecycle-extensions:2.1.0</span><br><span class=\"line\">|    +--- androidx.lifecycle:lifecycle-runtime:2.1.0</span><br><span class=\"line\">|    |    +--- androidx.lifecycle:lifecycle-common:2.1.0 -&gt; 2.3.0-alpha01</span><br><span class=\"line\">|    |    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    |    +--- androidx.arch.core:core-common:2.1.0</span><br><span class=\"line\">|    |    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    +--- androidx.arch.core:core-common:2.1.0 (*)</span><br><span class=\"line\">|    +--- androidx.arch.core:core-runtime:2.1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"排除传递性冲突\"><a href=\"#排除传递性冲突\" class=\"headerlink\" title=\"排除传递性冲突\"></a>排除传递性冲突</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile (<span class=\"string\">'cn.qqtheme.framework:WheelPicker:1.5.1'</span>)&#123;</span><br><span class=\"line\">    exclude <span class=\"string\">group:</span><span class=\"string\">'com.android.support'</span>, <span class=\"string\">module:</span><span class=\"string\">\"appcompat\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"强制一个版本\"><a href=\"#强制一个版本\" class=\"headerlink\" title=\"强制一个版本\"></a>强制一个版本</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations.all&#123;</span><br><span class=\"line\">    resolutionStrategy&#123;</span><br><span class=\"line\">        force <span class=\"string\">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Gradle中的对象\"><a href=\"#Gradle中的对象\" class=\"headerlink\" title=\"Gradle中的对象\"></a>Gradle中的对象</h2><p>Gradle主要有三种对象<br>这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：</p>","more":"\n<ul>\n<li>Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。</li>\n<li>Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。</li>\n<li>Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。</li>\n</ul>\n<p>构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。</p>\n<h2 id=\"setting-gradle\"><a href=\"#setting-gradle\" class=\"headerlink\" title=\"setting.gradle\"></a>setting.gradle</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">':app'</span>, <span class=\"string\">':progect_1'</span>, <span class=\"string\">':progect_2'</span></span><br></pre></td></tr></table></figure>\n<p>用于指示 Gradle 在构建应用时应将哪些模块包括在内</p>\n<h2 id=\"gradle-properties\"><a href=\"#gradle-properties\" class=\"headerlink\" title=\"gradle.properties\"></a>gradle.properties</h2><p>里面可以定义一些常量供build.gradle使用，如版本号等.<br>然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COMPILE_SDK_VERSION = <span class=\"number\">23</span></span><br><span class=\"line\">BUILD_TOOLS_VERSION = <span class=\"number\">23.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">VERSION_CODE = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"build-gradle\"><a href=\"#build-gradle\" class=\"headerlink\" title=\"build.gradle\"></a>build.gradle</h2><p>build文件有两种，一个是针对当前的Module，一个是针对项目中所有的module<br>在顶层的build文件中，我们可以来添加一些子module所共有的一些配置</p>\n<p>下面是一些常用的build.gradle的配置说明<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 应用插件，module中的build.gradle很多配置都是插件提供的支持</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"><span class=\"comment\">// 仓库， </span></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    google()</span><br><span class=\"line\">    jcenter()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部依赖，添加的依赖会在这些配置的仓库中去寻找</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// \"group:name:version\"</span></span><br><span class=\"line\">    implementation <span class=\"string\">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h2><p>包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。</p>\n<ul>\n<li>depandsOn: 依赖于其它任务</li>\n<li>doFirst, doLast(&lt;&lt;): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作</li>\n</ul>\n<p>apply的插件自带和很多Task，在Gradle页面的 <code>&lt;项目名&gt;/Tasks/build</code> 目录里面可以看到。<br>我们也可以自己编写任务，自己的Task在Gradle页面的 <code>&lt;项目名&gt;/Tasks/other/</code> 目录里可以查找到</p>\n<h2 id=\"Gradle的工作流程\"><a href=\"#Gradle的工作流程\" class=\"headerlink\" title=\"Gradle的工作流程\"></a>Gradle的工作流程</h2><p><img src=\"/images/gradle的构建过程.jpg\" alt=\"gradle的工作流程\"></p>\n<ul>\n<li>Initialization: 初始化，在多模块的项目中，就是执行settings.gradle</li>\n<li>Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。  Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。</li>\n<li>Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段</li>\n</ul>\n<p>简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。<br>在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！</p>\n<p>在每一步的步骤中间可以添加hook</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">task a &#123;</span><br><span class=\"line\">    println <span class=\"string\">'this is a'</span></span><br><span class=\"line\">    doFirst &#123;</span><br><span class=\"line\">        println <span class=\"string\">'this is a do first'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">\"this is a do last\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task testBoth &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 配置阶段</span></span><br><span class=\"line\">    <span class=\"comment\">// 依赖 a task 先执行</span></span><br><span class=\"line\">    dependsOn(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\">    println <span class=\"string\">'this is b'</span></span><br><span class=\"line\">    doFirst &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\">        println <span class=\"string\">'this is b first'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\">        println <span class=\"string\">'this is b last'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">输出：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Configure project :</span></span><br><span class=\"line\"><span class=\"comment\">this is a</span></span><br><span class=\"line\"><span class=\"comment\">this is b</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Task :a</span></span><br><span class=\"line\"><span class=\"comment\">this is a do first</span></span><br><span class=\"line\"><span class=\"comment\">this is a do last</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Task :testBoth</span></span><br><span class=\"line\"><span class=\"comment\">this is b first</span></span><br><span class=\"line\"><span class=\"comment\">this is b last</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"解决依赖版本冲突\"><a href=\"#解决依赖版本冲突\" class=\"headerlink\" title=\"解决依赖版本冲突\"></a>解决依赖版本冲突</h2><p>大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。</p>\n<p>以下是我们自己解决版本冲突的一般步骤</p>\n<h3 id=\"查看依赖报告\"><a href=\"#查看依赖报告\" class=\"headerlink\" title=\"查看依赖报告\"></a>查看依赖报告</h3><p>运行Gradle， <code>&lt;项目名称&gt;/app/Tasks/dependencies/</code> 查看依赖报告，输出如下</p>\n<p><code>xxxx -&gt; xxxx</code> 表示依赖包自动提升到了最高版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--- androidx.lifecycle:lifecycle-extensions:2.1.0</span><br><span class=\"line\">|    +--- androidx.lifecycle:lifecycle-runtime:2.1.0</span><br><span class=\"line\">|    |    +--- androidx.lifecycle:lifecycle-common:2.1.0 -&gt; 2.3.0-alpha01</span><br><span class=\"line\">|    |    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    |    +--- androidx.arch.core:core-common:2.1.0</span><br><span class=\"line\">|    |    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    +--- androidx.arch.core:core-common:2.1.0 (*)</span><br><span class=\"line\">|    +--- androidx.arch.core:core-runtime:2.1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"排除传递性冲突\"><a href=\"#排除传递性冲突\" class=\"headerlink\" title=\"排除传递性冲突\"></a>排除传递性冲突</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile (<span class=\"string\">'cn.qqtheme.framework:WheelPicker:1.5.1'</span>)&#123;</span><br><span class=\"line\">    exclude <span class=\"string\">group:</span><span class=\"string\">'com.android.support'</span>, <span class=\"string\">module:</span><span class=\"string\">\"appcompat\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"强制一个版本\"><a href=\"#强制一个版本\" class=\"headerlink\" title=\"强制一个版本\"></a>强制一个版本</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations.all&#123;</span><br><span class=\"line\">    resolutionStrategy&#123;</span><br><span class=\"line\">        force <span class=\"string\">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Text相关计算","date":"2019-07-19T03:09:42.000Z","_content":"\n# Text相关计算\n\n## Text的相关属性\n![图片](/images/Text相关计算.webp)\n\nBaseline上方的值为正，下方的值为负\n\n## TextSize和TextView大小的转换\n\n相关参数包括：\n\n* 基准点是baseline\n\n* Ascent是baseline之上至字符最高处的距离\n\n* Descent是baseline之下至字符最低处的距离\n\n* 其实是上一行字符的descent到下一行的ascent之间的距离\n\n* Top指的是指的是最高字符到baseline的值，即ascent的最大值\n\n* 同上，bottom指的是最下字符到baseline的值，即descent的最大值\n\n## 参考\n[Paint 绘制文字属性](https://www.jianshu.com/p/1728b725b4a6)\n[TextView文字实际高度分析](https://neutra.github.io/2016/TextView%E6%96%87%E5%AD%97%E5%AE%9E%E9%99%85%E9%AB%98%E5%BA%A6%E5%88%86%E6%9E%90/)\n","source":"_posts/Android/Text相关计算.md","raw":"---\ntitle: Text相关计算\ndate: 2019-07-19 11:09:42\ntags:\n- View\ncategories:\n- Android\n---\n\n# Text相关计算\n\n## Text的相关属性\n![图片](/images/Text相关计算.webp)\n\nBaseline上方的值为正，下方的值为负\n\n## TextSize和TextView大小的转换\n\n相关参数包括：\n\n* 基准点是baseline\n\n* Ascent是baseline之上至字符最高处的距离\n\n* Descent是baseline之下至字符最低处的距离\n\n* 其实是上一行字符的descent到下一行的ascent之间的距离\n\n* Top指的是指的是最高字符到baseline的值，即ascent的最大值\n\n* 同上，bottom指的是最下字符到baseline的值，即descent的最大值\n\n## 参考\n[Paint 绘制文字属性](https://www.jianshu.com/p/1728b725b4a6)\n[TextView文字实际高度分析](https://neutra.github.io/2016/TextView%E6%96%87%E5%AD%97%E5%AE%9E%E9%99%85%E9%AB%98%E5%BA%A6%E5%88%86%E6%9E%90/)\n","slug":"Android/Text相关计算","published":1,"updated":"2020-03-20T07:20:40.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakqk000z8mzmat0hw7rx","content":"<h1 id=\"Text相关计算\"><a href=\"#Text相关计算\" class=\"headerlink\" title=\"Text相关计算\"></a>Text相关计算</h1><h2 id=\"Text的相关属性\"><a href=\"#Text的相关属性\" class=\"headerlink\" title=\"Text的相关属性\"></a>Text的相关属性</h2><p><img src=\"/images/Text相关计算.webp\" alt=\"图片\"></p><p>Baseline上方的值为正，下方的值为负</p><a id=\"more\"></a>\n\n<h2 id=\"TextSize和TextView大小的转换\"><a href=\"#TextSize和TextView大小的转换\" class=\"headerlink\" title=\"TextSize和TextView大小的转换\"></a>TextSize和TextView大小的转换</h2><p>相关参数包括：</p>\n<ul>\n<li><p>基准点是baseline</p>\n</li>\n<li><p>Ascent是baseline之上至字符最高处的距离</p>\n</li>\n<li><p>Descent是baseline之下至字符最低处的距离</p>\n</li>\n<li><p>其实是上一行字符的descent到下一行的ascent之间的距离</p>\n</li>\n<li><p>Top指的是指的是最高字符到baseline的值，即ascent的最大值</p>\n</li>\n<li><p>同上，bottom指的是最下字符到baseline的值，即descent的最大值</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.jianshu.com/p/1728b725b4a6\" target=\"_blank\" rel=\"noopener\">Paint 绘制文字属性</a><br><a href=\"https://neutra.github.io/2016/TextView%E6%96%87%E5%AD%97%E5%AE%9E%E9%99%85%E9%AB%98%E5%BA%A6%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">TextView文字实际高度分析</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Text相关计算\"><a href=\"#Text相关计算\" class=\"headerlink\" title=\"Text相关计算\"></a>Text相关计算</h1><h2 id=\"Text的相关属性\"><a href=\"#Text的相关属性\" class=\"headerlink\" title=\"Text的相关属性\"></a>Text的相关属性</h2><p><img src=\"/images/Text相关计算.webp\" alt=\"图片\"></p><p>Baseline上方的值为正，下方的值为负</p>","more":"\n\n<h2 id=\"TextSize和TextView大小的转换\"><a href=\"#TextSize和TextView大小的转换\" class=\"headerlink\" title=\"TextSize和TextView大小的转换\"></a>TextSize和TextView大小的转换</h2><p>相关参数包括：</p>\n<ul>\n<li><p>基准点是baseline</p>\n</li>\n<li><p>Ascent是baseline之上至字符最高处的距离</p>\n</li>\n<li><p>Descent是baseline之下至字符最低处的距离</p>\n</li>\n<li><p>其实是上一行字符的descent到下一行的ascent之间的距离</p>\n</li>\n<li><p>Top指的是指的是最高字符到baseline的值，即ascent的最大值</p>\n</li>\n<li><p>同上，bottom指的是最下字符到baseline的值，即descent的最大值</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.jianshu.com/p/1728b725b4a6\" target=\"_blank\" rel=\"noopener\">Paint 绘制文字属性</a><br><a href=\"https://neutra.github.io/2016/TextView%E6%96%87%E5%AD%97%E5%AE%9E%E9%99%85%E9%AB%98%E5%BA%A6%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">TextView文字实际高度分析</a></p>\n"},{"title":"scrollBy(),scrollTo()和Scroller","date":"2019-06-16T12:26:14.000Z","_content":"# scrollBy(),scrollTo()和Scroller\n\n## 作用\n用于对View进行滚动\n<br>\n注意：\n1. **滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）**\n比如：TextView滚动的是内部的text而不是整个view\n2. **滚动的方向与坐标轴正方向相反**\n比如：scrollBy(20,0)\n最后显示，view会向左移动\n因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码)\n\n## scrollBy() 和 scrollTo()的区别\nscrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。\n\n## Scroller\n利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移\n### 使用步骤\nScroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：\n\n1. 创建Scroller的实例\n2. 调用startScroll()方法来初始化滚动数据并刷新界面\n3. 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑\n\n\n\n### 代码：实现自定义的简单ViewPager\n```java\npackage com.example.work3;\n\nimport android.content.Context;\nimport android.support.v4.view.ViewConfigurationCompat;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.widget.Scroller;\n\npublic class ScrollLayout extends ViewGroup {\n\n    private final String TAG = \"test_scroll\";\n    private Scroller mScroller;\n    // 可以判定为拖动的最小滑动距离\n    private int mTouchSlop;\n    // 落下的屏幕坐标\n    private float mXDown;\n    // 当前的屏幕坐标\n    private float mXMove;\n    // 上一次Action_MMOVE的屏幕坐标\n    private float mLastMove;\n    // 界面可滑动的左边界\n    private int mLeftBorder;\n    // 界面可滑动的右边界\n    private int mRightBorder;\n\n    public ScrollLayout(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public ScrollLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public ScrollLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context);\n    }\n\n    private void init(Context context) {\n        mScroller = new Scroller(context);\n        // 获取系统定义的mTouchSlop值\n        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context));\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        if (!changed)\n            return;\n        int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            View childView = getChildAt(i);\n            childView.layout(i * childView.getMeasuredWidth(), 0, (i + 1) * childView.getMeasuredWidth(), childView.getMeasuredHeight());\n        }\n        // 初始化左右边界\n        mLeftBorder = getChildAt(0).getLeft();\n        mRightBorder = getChildAt(childCount - 1).getRight();\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        switch (ev.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                mXDown = ev.getRawX();\n                mLastMove = mXDown;\n                break;\n            case MotionEvent.ACTION_MOVE:\n                mXMove = ev.getRawX();\n                float diff = Math.abs(mXMove - mXDown);\n                mLastMove = mXMove;\n                // 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件\n                if (diff > mTouchSlop) {\n                    return true;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                break;\n            default:\n                break;\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                break;\n            case MotionEvent.ACTION_MOVE: {\n                mXMove = event.getRawX();\n                int scrolledX = (int) (mLastMove - mXMove);\n                if (getScrollX() + scrolledX < mLeftBorder) {\n                    scrollTo(mLeftBorder, 0);\n                    return true;\n                } else if (getScrollX() + scrolledX + getWidth() > mRightBorder) {\n                    scrollTo(mRightBorder - getWidth(), 0);\n                    return true;\n                }\n                // view随着手指的拖动进行滚动\n                scrollBy(scrolledX, 0);\n                Log.i(TAG, \"onTouchEvent: \" + getChildAt(1).getLeft());\n                mLastMove = mXMove;\n                break;\n            }\n            case MotionEvent.ACTION_UP: {\n                // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面\n                int targetIndex = (getScrollX() + getWidth() / 2) / getWidth();\n                int dx = targetIndex * getWidth() - getScrollX();\n                // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面\n                mScroller.startScroll(getScrollX(), 0, dx, 0);\n                // 对view重绘\n                invalidate();\n                break;\n            }\n        }\n        return super.onTouchEvent(event);\n    }\n\n    @Override\n    public void computeScroll() {\n        // computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法\n        if (mScroller.computeScrollOffset()) {\n            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n            // 对view重绘\n            invalidate();\n        }\n    }\n}\n```\n\n## getScrollX()方法\n返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。\n原点（0，0）是初始化时内容显示的位置。\n\n## 参考\n[Android getScrollX()详解\n](https://blog.csdn.net/znouy/article/details/51338256)\n[Android Scroller完全解析，关于Scroller你所需知道的一切\n](https://blog.csdn.net/guolin_blog/article/details/48719871)","source":"_posts/Android/scrollBy-scrollTo-和Scroller.md","raw":"---\ntitle: 'scrollBy(),scrollTo()和Scroller'\ndate: 2019-06-16 20:26:14\ntags: \n- View\ncategories:\n- Android\n---\n# scrollBy(),scrollTo()和Scroller\n\n## 作用\n用于对View进行滚动\n<br>\n注意：\n1. **滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）**\n比如：TextView滚动的是内部的text而不是整个view\n2. **滚动的方向与坐标轴正方向相反**\n比如：scrollBy(20,0)\n最后显示，view会向左移动\n因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码)\n\n## scrollBy() 和 scrollTo()的区别\nscrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。\n\n## Scroller\n利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移\n### 使用步骤\nScroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：\n\n1. 创建Scroller的实例\n2. 调用startScroll()方法来初始化滚动数据并刷新界面\n3. 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑\n\n\n\n### 代码：实现自定义的简单ViewPager\n```java\npackage com.example.work3;\n\nimport android.content.Context;\nimport android.support.v4.view.ViewConfigurationCompat;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.widget.Scroller;\n\npublic class ScrollLayout extends ViewGroup {\n\n    private final String TAG = \"test_scroll\";\n    private Scroller mScroller;\n    // 可以判定为拖动的最小滑动距离\n    private int mTouchSlop;\n    // 落下的屏幕坐标\n    private float mXDown;\n    // 当前的屏幕坐标\n    private float mXMove;\n    // 上一次Action_MMOVE的屏幕坐标\n    private float mLastMove;\n    // 界面可滑动的左边界\n    private int mLeftBorder;\n    // 界面可滑动的右边界\n    private int mRightBorder;\n\n    public ScrollLayout(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public ScrollLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public ScrollLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context);\n    }\n\n    private void init(Context context) {\n        mScroller = new Scroller(context);\n        // 获取系统定义的mTouchSlop值\n        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context));\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        if (!changed)\n            return;\n        int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            View childView = getChildAt(i);\n            childView.layout(i * childView.getMeasuredWidth(), 0, (i + 1) * childView.getMeasuredWidth(), childView.getMeasuredHeight());\n        }\n        // 初始化左右边界\n        mLeftBorder = getChildAt(0).getLeft();\n        mRightBorder = getChildAt(childCount - 1).getRight();\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        switch (ev.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                mXDown = ev.getRawX();\n                mLastMove = mXDown;\n                break;\n            case MotionEvent.ACTION_MOVE:\n                mXMove = ev.getRawX();\n                float diff = Math.abs(mXMove - mXDown);\n                mLastMove = mXMove;\n                // 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件\n                if (diff > mTouchSlop) {\n                    return true;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                break;\n            default:\n                break;\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                break;\n            case MotionEvent.ACTION_MOVE: {\n                mXMove = event.getRawX();\n                int scrolledX = (int) (mLastMove - mXMove);\n                if (getScrollX() + scrolledX < mLeftBorder) {\n                    scrollTo(mLeftBorder, 0);\n                    return true;\n                } else if (getScrollX() + scrolledX + getWidth() > mRightBorder) {\n                    scrollTo(mRightBorder - getWidth(), 0);\n                    return true;\n                }\n                // view随着手指的拖动进行滚动\n                scrollBy(scrolledX, 0);\n                Log.i(TAG, \"onTouchEvent: \" + getChildAt(1).getLeft());\n                mLastMove = mXMove;\n                break;\n            }\n            case MotionEvent.ACTION_UP: {\n                // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面\n                int targetIndex = (getScrollX() + getWidth() / 2) / getWidth();\n                int dx = targetIndex * getWidth() - getScrollX();\n                // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面\n                mScroller.startScroll(getScrollX(), 0, dx, 0);\n                // 对view重绘\n                invalidate();\n                break;\n            }\n        }\n        return super.onTouchEvent(event);\n    }\n\n    @Override\n    public void computeScroll() {\n        // computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法\n        if (mScroller.computeScrollOffset()) {\n            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n            // 对view重绘\n            invalidate();\n        }\n    }\n}\n```\n\n## getScrollX()方法\n返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。\n原点（0，0）是初始化时内容显示的位置。\n\n## 参考\n[Android getScrollX()详解\n](https://blog.csdn.net/znouy/article/details/51338256)\n[Android Scroller完全解析，关于Scroller你所需知道的一切\n](https://blog.csdn.net/guolin_blog/article/details/48719871)","slug":"Android/scrollBy-scrollTo-和Scroller","published":1,"updated":"2019-12-21T12:16:41.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakr2002i8mzma4xiwyz9","content":"<h1 id=\"scrollBy-scrollTo-和Scroller\"><a href=\"#scrollBy-scrollTo-和Scroller\" class=\"headerlink\" title=\"scrollBy(),scrollTo()和Scroller\"></a>scrollBy(),scrollTo()和Scroller</h1><a id=\"more\"></a><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>用于对View进行滚动<br><br><br>注意：</p>\n<ol>\n<li><strong>滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）</strong><br>比如：TextView滚动的是内部的text而不是整个view</li>\n<li><strong>滚动的方向与坐标轴正方向相反</strong><br>比如：scrollBy(20,0)<br>最后显示，view会向左移动<br>因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码)</li>\n</ol>\n<h2 id=\"scrollBy-和-scrollTo-的区别\"><a href=\"#scrollBy-和-scrollTo-的区别\" class=\"headerlink\" title=\"scrollBy() 和 scrollTo()的区别\"></a>scrollBy() 和 scrollTo()的区别</h2><p>scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。</p>\n<h2 id=\"Scroller\"><a href=\"#Scroller\" class=\"headerlink\" title=\"Scroller\"></a>Scroller</h2><p>利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移</p>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p>Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p>\n<ol>\n<li>创建Scroller的实例</li>\n<li>调用startScroll()方法来初始化滚动数据并刷新界面</li>\n<li>重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</li>\n</ol>\n<h3 id=\"代码：实现自定义的简单ViewPager\"><a href=\"#代码：实现自定义的简单ViewPager\" class=\"headerlink\" title=\"代码：实现自定义的简单ViewPager\"></a>代码：实现自定义的简单ViewPager</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.work3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v4.view.ViewConfigurationCompat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.MotionEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.View;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewConfiguration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.Scroller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScrollLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"test_scroll\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Scroller mScroller;</span><br><span class=\"line\">    <span class=\"comment\">// 可以判定为拖动的最小滑动距离</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mTouchSlop;</span><br><span class=\"line\">    <span class=\"comment\">// 落下的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mXDown;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mXMove;</span><br><span class=\"line\">    <span class=\"comment\">// 上一次Action_MMOVE的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mLastMove;</span><br><span class=\"line\">    <span class=\"comment\">// 界面可滑动的左边界</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mLeftBorder;</span><br><span class=\"line\">    <span class=\"comment\">// 界面可滑动的右边界</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mRightBorder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mScroller = <span class=\"keyword\">new</span> Scroller(context);</span><br><span class=\"line\">        <span class=\"comment\">// 获取系统定义的mTouchSlop值</span></span><br><span class=\"line\">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> childCount = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</span><br><span class=\"line\">            measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!changed)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> childCount = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</span><br><span class=\"line\">            View childView = getChildAt(i);</span><br><span class=\"line\">            childView.layout(i * childView.getMeasuredWidth(), <span class=\"number\">0</span>, (i + <span class=\"number\">1</span>) * childView.getMeasuredWidth(), childView.getMeasuredHeight());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化左右边界</span></span><br><span class=\"line\">        mLeftBorder = getChildAt(<span class=\"number\">0</span>).getLeft();</span><br><span class=\"line\">        mRightBorder = getChildAt(childCount - <span class=\"number\">1</span>).getRight();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (ev.getAction()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                mXDown = ev.getRawX();</span><br><span class=\"line\">                mLastMove = mXDown;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">                mXMove = ev.getRawX();</span><br><span class=\"line\">                <span class=\"keyword\">float</span> diff = Math.abs(mXMove - mXDown);</span><br><span class=\"line\">                mLastMove = mXMove;</span><br><span class=\"line\">                <span class=\"comment\">// 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (diff &gt; mTouchSlop) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class=\"line\">                mXMove = event.getRawX();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> scrolledX = (<span class=\"keyword\">int</span>) (mLastMove - mXMove);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (getScrollX() + scrolledX &lt; mLeftBorder) &#123;</span><br><span class=\"line\">                    scrollTo(mLeftBorder, <span class=\"number\">0</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (getScrollX() + scrolledX + getWidth() &gt; mRightBorder) &#123;</span><br><span class=\"line\">                    scrollTo(mRightBorder - getWidth(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// view随着手指的拖动进行滚动</span></span><br><span class=\"line\">                scrollBy(scrolledX, <span class=\"number\">0</span>);</span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">\"onTouchEvent: \"</span> + getChildAt(<span class=\"number\">1</span>).getLeft());</span><br><span class=\"line\">                mLastMove = mXMove;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> targetIndex = (getScrollX() + getWidth() / <span class=\"number\">2</span>) / getWidth();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dx = targetIndex * getWidth() - getScrollX();</span><br><span class=\"line\">                <span class=\"comment\">// 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span></span><br><span class=\"line\">                mScroller.startScroll(getScrollX(), <span class=\"number\">0</span>, dx, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 对view重绘</span></span><br><span class=\"line\">                invalidate();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class=\"line\">            <span class=\"comment\">// 对view重绘</span></span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"getScrollX-方法\"><a href=\"#getScrollX-方法\" class=\"headerlink\" title=\"getScrollX()方法\"></a>getScrollX()方法</h2><p>返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。<br>原点（0，0）是初始化时内容显示的位置。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/znouy/article/details/51338256\" target=\"_blank\" rel=\"noopener\">Android getScrollX()详解\n</a><br><a href=\"https://blog.csdn.net/guolin_blog/article/details/48719871\" target=\"_blank\" rel=\"noopener\">Android Scroller完全解析，关于Scroller你所需知道的一切\n</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"scrollBy-scrollTo-和Scroller\"><a href=\"#scrollBy-scrollTo-和Scroller\" class=\"headerlink\" title=\"scrollBy(),scrollTo()和Scroller\"></a>scrollBy(),scrollTo()和Scroller</h1>","more":"<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>用于对View进行滚动<br><br><br>注意：</p>\n<ol>\n<li><strong>滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）</strong><br>比如：TextView滚动的是内部的text而不是整个view</li>\n<li><strong>滚动的方向与坐标轴正方向相反</strong><br>比如：scrollBy(20,0)<br>最后显示，view会向左移动<br>因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码)</li>\n</ol>\n<h2 id=\"scrollBy-和-scrollTo-的区别\"><a href=\"#scrollBy-和-scrollTo-的区别\" class=\"headerlink\" title=\"scrollBy() 和 scrollTo()的区别\"></a>scrollBy() 和 scrollTo()的区别</h2><p>scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。</p>\n<h2 id=\"Scroller\"><a href=\"#Scroller\" class=\"headerlink\" title=\"Scroller\"></a>Scroller</h2><p>利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移</p>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p>Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p>\n<ol>\n<li>创建Scroller的实例</li>\n<li>调用startScroll()方法来初始化滚动数据并刷新界面</li>\n<li>重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</li>\n</ol>\n<h3 id=\"代码：实现自定义的简单ViewPager\"><a href=\"#代码：实现自定义的简单ViewPager\" class=\"headerlink\" title=\"代码：实现自定义的简单ViewPager\"></a>代码：实现自定义的简单ViewPager</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.work3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v4.view.ViewConfigurationCompat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.MotionEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.View;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewConfiguration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.Scroller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScrollLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"test_scroll\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Scroller mScroller;</span><br><span class=\"line\">    <span class=\"comment\">// 可以判定为拖动的最小滑动距离</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mTouchSlop;</span><br><span class=\"line\">    <span class=\"comment\">// 落下的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mXDown;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mXMove;</span><br><span class=\"line\">    <span class=\"comment\">// 上一次Action_MMOVE的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mLastMove;</span><br><span class=\"line\">    <span class=\"comment\">// 界面可滑动的左边界</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mLeftBorder;</span><br><span class=\"line\">    <span class=\"comment\">// 界面可滑动的右边界</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mRightBorder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mScroller = <span class=\"keyword\">new</span> Scroller(context);</span><br><span class=\"line\">        <span class=\"comment\">// 获取系统定义的mTouchSlop值</span></span><br><span class=\"line\">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> childCount = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</span><br><span class=\"line\">            measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!changed)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> childCount = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</span><br><span class=\"line\">            View childView = getChildAt(i);</span><br><span class=\"line\">            childView.layout(i * childView.getMeasuredWidth(), <span class=\"number\">0</span>, (i + <span class=\"number\">1</span>) * childView.getMeasuredWidth(), childView.getMeasuredHeight());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化左右边界</span></span><br><span class=\"line\">        mLeftBorder = getChildAt(<span class=\"number\">0</span>).getLeft();</span><br><span class=\"line\">        mRightBorder = getChildAt(childCount - <span class=\"number\">1</span>).getRight();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (ev.getAction()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                mXDown = ev.getRawX();</span><br><span class=\"line\">                mLastMove = mXDown;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">                mXMove = ev.getRawX();</span><br><span class=\"line\">                <span class=\"keyword\">float</span> diff = Math.abs(mXMove - mXDown);</span><br><span class=\"line\">                mLastMove = mXMove;</span><br><span class=\"line\">                <span class=\"comment\">// 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (diff &gt; mTouchSlop) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class=\"line\">                mXMove = event.getRawX();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> scrolledX = (<span class=\"keyword\">int</span>) (mLastMove - mXMove);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (getScrollX() + scrolledX &lt; mLeftBorder) &#123;</span><br><span class=\"line\">                    scrollTo(mLeftBorder, <span class=\"number\">0</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (getScrollX() + scrolledX + getWidth() &gt; mRightBorder) &#123;</span><br><span class=\"line\">                    scrollTo(mRightBorder - getWidth(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// view随着手指的拖动进行滚动</span></span><br><span class=\"line\">                scrollBy(scrolledX, <span class=\"number\">0</span>);</span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">\"onTouchEvent: \"</span> + getChildAt(<span class=\"number\">1</span>).getLeft());</span><br><span class=\"line\">                mLastMove = mXMove;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> targetIndex = (getScrollX() + getWidth() / <span class=\"number\">2</span>) / getWidth();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dx = targetIndex * getWidth() - getScrollX();</span><br><span class=\"line\">                <span class=\"comment\">// 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span></span><br><span class=\"line\">                mScroller.startScroll(getScrollX(), <span class=\"number\">0</span>, dx, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 对view重绘</span></span><br><span class=\"line\">                invalidate();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class=\"line\">            <span class=\"comment\">// 对view重绘</span></span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"getScrollX-方法\"><a href=\"#getScrollX-方法\" class=\"headerlink\" title=\"getScrollX()方法\"></a>getScrollX()方法</h2><p>返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。<br>原点（0，0）是初始化时内容显示的位置。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/znouy/article/details/51338256\" target=\"_blank\" rel=\"noopener\">Android getScrollX()详解\n</a><br><a href=\"https://blog.csdn.net/guolin_blog/article/details/48719871\" target=\"_blank\" rel=\"noopener\">Android Scroller完全解析，关于Scroller你所需知道的一切\n</a></p>\n"},{"title":"startService()和bindService()","date":"2019-07-04T12:37:58.000Z","_content":"\n# startService()和bindService()的区别\n\n![](/images/startService\\ and\\ bindService)\n\n### 生命周期上的差别\n#### startService()\n执行startService时，Service经历onCreate->onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。\n\n多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。**但是每次调用startService，onStartCommand方法都会被调用。**无论startService调用多少次，stopService只需要调用一次就能够终止Service\n\n#### BindService()\nbindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。\n1. **onBind返回值是null**\n调用bindService开启服务，生命周期执行的方法依次是：\nonCreate() ==> onBind();\n**调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。** 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。\n2. **onBind返回值不为null**\n这时候调用bindService开启服务，生命周期执行的方法依次是：\nonCreate() ==> onBind() ==> onServiceConnected();\n可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。**调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。**\n并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。\n也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。\n调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。\n<br>\n**总结**\n第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。\n\n### 既使用startService又使用bindService的情况\n如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。\n\n参考链接:\n[https://my.oschina.net/tingzi/blog/376545]()\n[https://www.jianshu.com/p/d870f99b675c]()\n","source":"_posts/Android/startService-和bindService.md","raw":"---\ntitle: startService()和bindService()\ndate: 2019-07-04 20:37:58\ntags: \n- Service\ncategories:\n- Android\n- Service\n---\n\n# startService()和bindService()的区别\n\n![](/images/startService\\ and\\ bindService)\n\n### 生命周期上的差别\n#### startService()\n执行startService时，Service经历onCreate->onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。\n\n多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。**但是每次调用startService，onStartCommand方法都会被调用。**无论startService调用多少次，stopService只需要调用一次就能够终止Service\n\n#### BindService()\nbindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。\n1. **onBind返回值是null**\n调用bindService开启服务，生命周期执行的方法依次是：\nonCreate() ==> onBind();\n**调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。** 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。\n2. **onBind返回值不为null**\n这时候调用bindService开启服务，生命周期执行的方法依次是：\nonCreate() ==> onBind() ==> onServiceConnected();\n可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。**调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。**\n并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。\n也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。\n调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。\n<br>\n**总结**\n第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。\n\n### 既使用startService又使用bindService的情况\n如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。\n\n参考链接:\n[https://my.oschina.net/tingzi/blog/376545]()\n[https://www.jianshu.com/p/d870f99b675c]()\n","slug":"Android/startService-和bindService","published":1,"updated":"2019-12-21T12:16:41.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakr3002j8mzmbl2flq0a","content":"<h1 id=\"startService-和bindService-的区别\"><a href=\"#startService-和bindService-的区别\" class=\"headerlink\" title=\"startService()和bindService()的区别\"></a>startService()和bindService()的区别</h1><a id=\"more\"></a><p><img src=\"/images/startService\\ and\\ bindService\" alt></p>\n<h3 id=\"生命周期上的差别\"><a href=\"#生命周期上的差别\" class=\"headerlink\" title=\"生命周期上的差别\"></a>生命周期上的差别</h3><h4 id=\"startService\"><a href=\"#startService\" class=\"headerlink\" title=\"startService()\"></a>startService()</h4><p>执行startService时，Service经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。</p>\n<p>多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。<strong>但是每次调用startService，onStartCommand方法都会被调用。</strong>无论startService调用多少次，stopService只需要调用一次就能够终止Service</p>\n<h4 id=\"BindService\"><a href=\"#BindService\" class=\"headerlink\" title=\"BindService()\"></a>BindService()</h4><p>bindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。</p>\n<ol>\n<li><strong>onBind返回值是null</strong><br>调用bindService开启服务，生命周期执行的方法依次是：<br>onCreate() ==&gt; onBind();<br><strong>调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。</strong> 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。</li>\n<li><strong>onBind返回值不为null</strong><br>这时候调用bindService开启服务，生命周期执行的方法依次是：<br>onCreate() ==&gt; onBind() ==&gt; onServiceConnected();<br>可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。<strong>调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。</strong><br>并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。<br>也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。<br>调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。<br><br><br><strong>总结</strong><br>第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。</li>\n</ol>\n<h3 id=\"既使用startService又使用bindService的情况\"><a href=\"#既使用startService又使用bindService的情况\" class=\"headerlink\" title=\"既使用startService又使用bindService的情况\"></a>既使用startService又使用bindService的情况</h3><p>如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。</p>\n<p>参考链接:<br><a href>https://my.oschina.net/tingzi/blog/376545</a><br><a href>https://www.jianshu.com/p/d870f99b675c</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"startService-和bindService-的区别\"><a href=\"#startService-和bindService-的区别\" class=\"headerlink\" title=\"startService()和bindService()的区别\"></a>startService()和bindService()的区别</h1>","more":"<p><img src=\"/images/startService\\ and\\ bindService\" alt></p>\n<h3 id=\"生命周期上的差别\"><a href=\"#生命周期上的差别\" class=\"headerlink\" title=\"生命周期上的差别\"></a>生命周期上的差别</h3><h4 id=\"startService\"><a href=\"#startService\" class=\"headerlink\" title=\"startService()\"></a>startService()</h4><p>执行startService时，Service经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。</p>\n<p>多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。<strong>但是每次调用startService，onStartCommand方法都会被调用。</strong>无论startService调用多少次，stopService只需要调用一次就能够终止Service</p>\n<h4 id=\"BindService\"><a href=\"#BindService\" class=\"headerlink\" title=\"BindService()\"></a>BindService()</h4><p>bindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。</p>\n<ol>\n<li><strong>onBind返回值是null</strong><br>调用bindService开启服务，生命周期执行的方法依次是：<br>onCreate() ==&gt; onBind();<br><strong>调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。</strong> 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。</li>\n<li><strong>onBind返回值不为null</strong><br>这时候调用bindService开启服务，生命周期执行的方法依次是：<br>onCreate() ==&gt; onBind() ==&gt; onServiceConnected();<br>可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。<strong>调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。</strong><br>并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。<br>也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。<br>调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。<br><br><br><strong>总结</strong><br>第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。</li>\n</ol>\n<h3 id=\"既使用startService又使用bindService的情况\"><a href=\"#既使用startService又使用bindService的情况\" class=\"headerlink\" title=\"既使用startService又使用bindService的情况\"></a>既使用startService又使用bindService的情况</h3><p>如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。</p>\n<p>参考链接:<br><a href>https://my.oschina.net/tingzi/blog/376545</a><br><a href>https://www.jianshu.com/p/d870f99b675c</a></p>\n"},{"title":"华为手机的内存泄露","date":"2019-04-19T03:41:06.000Z","_content":"\n# 华为手机的内存泄露\n\n最近在开发的时候，使用我的华为手机做真机调试，发现LeakCanary一直有内存泄露报出。\n一开始我以为是我使用MVP模式开发导致的，使用WeakReference和一些其他的处理之后，发现这个内存泄露还是存在。\n然后我用模拟器调试，发现模拟器竟然没有内存泄漏报出。想到这可能是手机的问题。应该是国内手机厂商对系统的魔改造成的。\n\n我的手机系统是华为EMUI9.0  &&  Android9.0\n\n以下是我找到的网上的解决方案：\n### 参考链接\nhttps://www.jianshu.com/p/95242060320f\n\n### inputMethodManager.mLastSrvView泄露\n\n```java\npublic class FixMemLeak {\n\n    private static Field field;\n    private static boolean hasField = true;\n\n    public static void fixLeak(Context context) {\n        if (!hasField) {\n            return;\n        }\n        InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);\n        if (imm == null) {\n            return;\n        }\n\n        String[] arr = new String[]{\"mLastSrvView\"};\n        for (String param : arr) {\n            try {\n                if (field == null) {\n                    field = imm.getClass().getDeclaredField(param);\n                }\n                if (field == null) {\n                    hasField = false;\n                }\n                if (field != null) {\n                    field.setAccessible(true);\n                    field.set(imm, null);\n                }\n            } catch (Throwable t) {\n                t.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n在BaseActivity的onDestroy()方法里执行这个fexLeak()方法，然后所有的Activity继承BaseActivity。然后就没有报错了\n\n### Toast$TN.mWM 泄露\n泄露出现在显示一个Toast之后。这个就更迷了，网上我没有找到相关的解释。同样的在模拟器上没有出现这样的内存泄露。\n\n最终的解决方法是：\n在使用Toast时，传入的Context参数使用ApplicationContext而不是Activity。然后就没有内存泄露报出了。","source":"_posts/Android/华为手机的内存泄露.md","raw":"---\ntitle: 华为手机的内存泄露\ndate: 2019-04-19 11:41:06\ntags:\n- 内存泄露\ncategory:\n- Android\n---\n\n# 华为手机的内存泄露\n\n最近在开发的时候，使用我的华为手机做真机调试，发现LeakCanary一直有内存泄露报出。\n一开始我以为是我使用MVP模式开发导致的，使用WeakReference和一些其他的处理之后，发现这个内存泄露还是存在。\n然后我用模拟器调试，发现模拟器竟然没有内存泄漏报出。想到这可能是手机的问题。应该是国内手机厂商对系统的魔改造成的。\n\n我的手机系统是华为EMUI9.0  &&  Android9.0\n\n以下是我找到的网上的解决方案：\n### 参考链接\nhttps://www.jianshu.com/p/95242060320f\n\n### inputMethodManager.mLastSrvView泄露\n\n```java\npublic class FixMemLeak {\n\n    private static Field field;\n    private static boolean hasField = true;\n\n    public static void fixLeak(Context context) {\n        if (!hasField) {\n            return;\n        }\n        InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);\n        if (imm == null) {\n            return;\n        }\n\n        String[] arr = new String[]{\"mLastSrvView\"};\n        for (String param : arr) {\n            try {\n                if (field == null) {\n                    field = imm.getClass().getDeclaredField(param);\n                }\n                if (field == null) {\n                    hasField = false;\n                }\n                if (field != null) {\n                    field.setAccessible(true);\n                    field.set(imm, null);\n                }\n            } catch (Throwable t) {\n                t.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n在BaseActivity的onDestroy()方法里执行这个fexLeak()方法，然后所有的Activity继承BaseActivity。然后就没有报错了\n\n### Toast$TN.mWM 泄露\n泄露出现在显示一个Toast之后。这个就更迷了，网上我没有找到相关的解释。同样的在模拟器上没有出现这样的内存泄露。\n\n最终的解决方法是：\n在使用Toast时，传入的Context参数使用ApplicationContext而不是Activity。然后就没有内存泄露报出了。","slug":"Android/华为手机的内存泄露","published":1,"updated":"2019-12-21T12:16:41.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakr4002l8mzmu3h6jp8k","content":"<h1 id=\"华为手机的内存泄露\"><a href=\"#华为手机的内存泄露\" class=\"headerlink\" title=\"华为手机的内存泄露\"></a>华为手机的内存泄露</h1><p>最近在开发的时候，使用我的华为手机做真机调试，发现LeakCanary一直有内存泄露报出。<br>一开始我以为是我使用MVP模式开发导致的，使用WeakReference和一些其他的处理之后，发现这个内存泄露还是存在。<br>然后我用模拟器调试，发现模拟器竟然没有内存泄漏报出。想到这可能是手机的问题。应该是国内手机厂商对系统的魔改造成的。</p><a id=\"more\"></a>\n<p>我的手机系统是华为EMUI9.0  &amp;&amp;  Android9.0</p>\n<p>以下是我找到的网上的解决方案：</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://www.jianshu.com/p/95242060320f\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/95242060320f</a></p>\n<h3 id=\"inputMethodManager-mLastSrvView泄露\"><a href=\"#inputMethodManager-mLastSrvView泄露\" class=\"headerlink\" title=\"inputMethodManager.mLastSrvView泄露\"></a>inputMethodManager.mLastSrvView泄露</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FixMemLeak</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Field field;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> hasField = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fixLeak</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hasField) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (imm == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String[] arr = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"mLastSrvView\"</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String param : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (field == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    field = imm.getClass().getDeclaredField(param);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (field == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    hasField = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (field != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    field.set(imm, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                t.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在BaseActivity的onDestroy()方法里执行这个fexLeak()方法，然后所有的Activity继承BaseActivity。然后就没有报错了</p>\n<h3 id=\"Toast-TN-mWM-泄露\"><a href=\"#Toast-TN-mWM-泄露\" class=\"headerlink\" title=\"Toast$TN.mWM 泄露\"></a>Toast$TN.mWM 泄露</h3><p>泄露出现在显示一个Toast之后。这个就更迷了，网上我没有找到相关的解释。同样的在模拟器上没有出现这样的内存泄露。</p>\n<p>最终的解决方法是：<br>在使用Toast时，传入的Context参数使用ApplicationContext而不是Activity。然后就没有内存泄露报出了。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"华为手机的内存泄露\"><a href=\"#华为手机的内存泄露\" class=\"headerlink\" title=\"华为手机的内存泄露\"></a>华为手机的内存泄露</h1><p>最近在开发的时候，使用我的华为手机做真机调试，发现LeakCanary一直有内存泄露报出。<br>一开始我以为是我使用MVP模式开发导致的，使用WeakReference和一些其他的处理之后，发现这个内存泄露还是存在。<br>然后我用模拟器调试，发现模拟器竟然没有内存泄漏报出。想到这可能是手机的问题。应该是国内手机厂商对系统的魔改造成的。</p>","more":"\n<p>我的手机系统是华为EMUI9.0  &amp;&amp;  Android9.0</p>\n<p>以下是我找到的网上的解决方案：</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://www.jianshu.com/p/95242060320f\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/95242060320f</a></p>\n<h3 id=\"inputMethodManager-mLastSrvView泄露\"><a href=\"#inputMethodManager-mLastSrvView泄露\" class=\"headerlink\" title=\"inputMethodManager.mLastSrvView泄露\"></a>inputMethodManager.mLastSrvView泄露</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FixMemLeak</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Field field;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> hasField = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">fixLeak</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!hasField) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (imm == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String[] arr = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"mLastSrvView\"</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String param : arr) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (field == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    field = imm.getClass().getDeclaredField(param);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (field == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    hasField = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (field != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                    field.set(imm, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                t.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在BaseActivity的onDestroy()方法里执行这个fexLeak()方法，然后所有的Activity继承BaseActivity。然后就没有报错了</p>\n<h3 id=\"Toast-TN-mWM-泄露\"><a href=\"#Toast-TN-mWM-泄露\" class=\"headerlink\" title=\"Toast$TN.mWM 泄露\"></a>Toast$TN.mWM 泄露</h3><p>泄露出现在显示一个Toast之后。这个就更迷了，网上我没有找到相关的解释。同样的在模拟器上没有出现这样的内存泄露。</p>\n<p>最终的解决方法是：<br>在使用Toast时，传入的Context参数使用ApplicationContext而不是Activity。然后就没有内存泄露报出了。</p>\n"},{"title":"外部View随着RecyclerView的滚动而显示或隐藏","date":"2020-01-09T15:01:39.000Z","_content":"\n\n外部的View上滑显示, 下滑隐藏\n```java\nmOutsideOnScrollListener = new OnScrollListener() {\n    boolean controlsVisible = false;\n    int scrolledDistance = 0;\n\n    @Override\n    public void onScrollStateChanged(int newState) {\n        if (newState == RecyclerView.SCROLL_STATE_IDLE) {\n            scrolledDistance = 0;\n        }\n    }\n\n    @Override\n    public void onScrolled(int dx, int dy) {\n        if ((controlsVisible && dy < 0) || (!controlsVisible && dy > 0){\n            scrolledDistance += dy;\n        }\n        if (scrolledDistance < thresholdToShow && controlsVisible) {\n            //UP\n            scrolledDistance = 0;\n            controlsVisible = false;\n            view.onShow();\n        } else if (scrolledDistance >= thresholdToHide && !controlsVisible) {\n            //DOWN\n            scrolledDistance = 0;\n            controlsVisible = true;\n            view.onPause();\n        }\n    }\n};\n```\n\n* 我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。\n```java\nif ((controlsVisible && dy < 0) || (!controlsVisible && dy > 0)) {\n    scrolledDistance += dy;\n}\n```\n\n* 如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。\n\n```java\nif (scrolledDistance < thresholdToShow && controlsVisible) {\n    //UP\n    scrolledDistance = 0;\n    controlsVisible = false;\n    view.onResume();\n} else if (scrolledDistance >= thresholdToHide && !controlsVisible) {\n    //DOWN\n    scrolledDistance = 0;\n    controlsVisible = true;\n    view.onPause();\n}\n```","source":"_posts/Android/外部View随着RecyclerView的滚动而显示或隐藏.md","raw":"---\ntitle: 外部View随着RecyclerView的滚动而显示或隐藏\ndate: 2020-01-09 23:01:39\ntags:\n- RecyclerView\ncategories:\n- Android\n---\n\n\n外部的View上滑显示, 下滑隐藏\n```java\nmOutsideOnScrollListener = new OnScrollListener() {\n    boolean controlsVisible = false;\n    int scrolledDistance = 0;\n\n    @Override\n    public void onScrollStateChanged(int newState) {\n        if (newState == RecyclerView.SCROLL_STATE_IDLE) {\n            scrolledDistance = 0;\n        }\n    }\n\n    @Override\n    public void onScrolled(int dx, int dy) {\n        if ((controlsVisible && dy < 0) || (!controlsVisible && dy > 0){\n            scrolledDistance += dy;\n        }\n        if (scrolledDistance < thresholdToShow && controlsVisible) {\n            //UP\n            scrolledDistance = 0;\n            controlsVisible = false;\n            view.onShow();\n        } else if (scrolledDistance >= thresholdToHide && !controlsVisible) {\n            //DOWN\n            scrolledDistance = 0;\n            controlsVisible = true;\n            view.onPause();\n        }\n    }\n};\n```\n\n* 我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。\n```java\nif ((controlsVisible && dy < 0) || (!controlsVisible && dy > 0)) {\n    scrolledDistance += dy;\n}\n```\n\n* 如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。\n\n```java\nif (scrolledDistance < thresholdToShow && controlsVisible) {\n    //UP\n    scrolledDistance = 0;\n    controlsVisible = false;\n    view.onResume();\n} else if (scrolledDistance >= thresholdToHide && !controlsVisible) {\n    //DOWN\n    scrolledDistance = 0;\n    controlsVisible = true;\n    view.onPause();\n}\n```","slug":"Android/外部View随着RecyclerView的滚动而显示或隐藏","published":1,"updated":"2020-01-09T15:16:41.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakr4002n8mzmapxgol0g","content":"<p>外部的View上滑显示, 下滑隐藏<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mOutsideOnScrollListener = <span class=\"keyword\">new</span> OnScrollListener() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScrollStateChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE) &#123;</span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScrolled</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((controlsVisible &amp;&amp; dy &lt; <span class=\"number\">0</span>) || (!controlsVisible &amp;&amp; dy &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            scrolledDistance += dy;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//UP</span></span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            view.onShow();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//DOWN</span></span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            controlsVisible = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            view.onPause();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p><a id=\"more\"></a>\n<ul>\n<li><p>我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((controlsVisible &amp;&amp; dy &lt; <span class=\"number\">0</span>) || (!controlsVisible &amp;&amp; dy &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    scrolledDistance += dy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//UP</span></span><br><span class=\"line\">    scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">    controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    view.onResume();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//DOWN</span></span><br><span class=\"line\">    scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">    controlsVisible = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    view.onPause();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>外部的View上滑显示, 下滑隐藏<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mOutsideOnScrollListener = <span class=\"keyword\">new</span> OnScrollListener() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScrollStateChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE) &#123;</span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScrolled</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((controlsVisible &amp;&amp; dy &lt; <span class=\"number\">0</span>) || (!controlsVisible &amp;&amp; dy &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            scrolledDistance += dy;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//UP</span></span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            view.onShow();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//DOWN</span></span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            controlsVisible = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            view.onPause();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>","more":"\n<ul>\n<li><p>我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((controlsVisible &amp;&amp; dy &lt; <span class=\"number\">0</span>) || (!controlsVisible &amp;&amp; dy &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    scrolledDistance += dy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//UP</span></span><br><span class=\"line\">    scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">    controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    view.onResume();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//DOWN</span></span><br><span class=\"line\">    scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">    controlsVisible = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    view.onPause();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ViewModel,LiveData和Lifecycle","date":"2019-12-21T12:19:41.000Z","_content":"\n# ViewModel、Lifecycles和LiveData\n## 1. ViewModel:\nViewModel是Google官方提供的组件，是用来处理和存放和UI相关的数据的，可以把UI和数据进行分离。但就这一点来说的话，其实没有必要一定使用Google提供的ViewModel组件，我们使用自定义的ViewModel类同样可以达到这样的效果。\n\n还有一个很重要的特性，我们都知道，在配置改变时，Activity会出现销毁重建，比如说横竖屏切换的时候。ViewModel的生命周期和Activity是不一样的，它不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，可以将和UI相关的数据存放在ViewModel中，这样，即使Activity销毁重建，页面上显示的数据也不会丢失。\n```java\npublic abstract class ViewModel {\n    // 在ViewModel销毁的时候做回收工作，主要是为了防止ViewModel的泄漏\n    protected void onCleared() {\n    }\n}\n```\n### ViewModel的创建和存储过程\n主要是要搞清楚上面说的：Activity销毁重建的时候，ViewModel是如何保持不重建的。\n注意，这里只是在Activity因为配置改变而销毁重建的情况下。还有一种情况是，App由前台进入后台，因为内存紧张，Activity被系统销毁。这种情况下，ViewModel是无法保存数据的。\n\n以下全都以Activity举例，Fragment也是一样的\n在Activity中获取ViewModel：\n```java\nviewModel = ViewModelProviders.of(this).get(XxxViewModel.class);\n```\nViewModelProviders#of\n```java\n@NonNull\n@MainThread\npublic static ViewModelProvider of(@NonNull FragmentActivity activity,\n        @Nullable Factory factory) {\n    Application application = checkApplication(activity);\n    if (factory == null) {\n        // 使用默认的工厂类\n        // 如果想要在ViewModel的构造方法里传参，需要自定义factory类\n        factory = ViewModelProvider.AndroidViewModelFactory\n                                    .getInstance(application);\n    }\n    return new ViewModelProvider(ViewModelStores.of(activity), factory);\n}\n```\nviewModelProvider#get\n```java\n// 从ViewModelStore中获取ViewModel，没有则创建\npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {\n    ViewModel viewModel = mViewModelStore.get(key);\n    if (modelClass.isInstance(viewModel)) {\n        return (T) viewModel;\n    } else {\n        ...\n    }\n    viewModel = mFactory.create(modelClass);\n    mViewModelStore.put(key, viewModel);\n    return (T) viewModel;\n}\n\npublic class ViewModelStore {\n    // ViewModel的集合，key是由ViewModel类名构成的字符串\n    private final HashMap<String, ViewModel> mMap = new HashMap<>();\n    ...\n}\n```\nViewModelStore中存储了一个Activity/Fragment的所有ViewModel。那现在问题就转变成了探究ViewModelStore的获取和存储的过程\n\nViewModelStores#of\n```java\npublic static ViewModelStore of(@NonNull FragmentActivity activity) {\n    if (activity instanceof ViewModelStoreOwner) {\n        return ((ViewModelStoreOwner) activity).getViewModelStore();\n    }\n    return holderFragmentFor(activity).getViewModelStore();\n}\n```\n这里先判断FragmentActivity是否实现了ViewModelStoreOwner接口。不同的依赖包，实现有可能是不一样的。高版本的support-v4和androidx中的Fragment和FragmentActivity都实现了这个接口。\n```java\npublic interface ViewModelStoreOwner {\n    @NonNull\n    ViewModelStore getViewModelStore();\n}\n```\n#### 实现了ViewModelStoreOwner接口\n\nFragmentActivity\n```java\npublic class FragmentActivity extends SupportActivity implements ViewModelStoreOwner, ...{\n    private ViewModelStore mViewModelStore;\n        \n    public ViewModelStore getViewModelStore() {\n        ...\n    }\n}\n```\n\n实现了ViewModelStoreOwner接口的FragmentActivity会直接持有ViewModelStore的引用\n\n主要关注三个方法：\ngetViewModelStore()\nonCreate()\nonRetainNonConfigurationInstance()\n\n```java\npublic ViewModelStore getViewModelStore() {\n    if (this.getApplication() == null) {\n       ...\n    } else {\n        if (this.mViewModelStore == null) {\n            FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances) this.getLastNonConfigurationInstance();\n            if (nc != null) {\n                this.mViewModelStore = nc.viewModelStore;\n            }\n\n            if (this.mViewModelStore == null) {\n                this.mViewModelStore = new ViewModelStore();\n            }\n        }\n\n        return this.mViewModelStore;\n    }\n}\n\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    ...\n    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)this.getLastNonConfigurationInstance();\n    if (nc != null && nc.viewModelStore != null && this.mViewModelStore == null)\n    {\n        this.mViewModelStore = nc.viewModelStore;\n    }\n    ...\n}\n// 在页面销毁时，保存ViewModelStore\npublic final Object onRetainNonConfigurationInstance() {\n     Object custom = onRetainCustomNonConfigurationInstance();\n     ViewModelStore viewModelStore = mViewModelStore;\n     if (viewModelStore == null) {\n         // 如果NonConfigurationInstance保存了viewModelStore，把它取出来\n        NonConfigurationInstances nc = getLastNonConfigurationInstance();\n        if (nc != null) {\n            viewModelStore = nc.viewModelStore;\n          }\n       }\n     if (viewModelStore == null && custom == null) {\n          return null;\n       }\n      NonConfigurationInstances nci = new NonConfigurationInstances();\n      nci.custom = custom; \n      //把viewModelStore放到NonConfigurationInstances中并返回\n      nci.viewModelStore = viewModelStore;\n      //这样当页面被重建而销毁时ViewModelStore就被保存起来了。\n      return nci;\n}\n```\n\nViewModelStore在onCreate里会从NonConfigurationInstances里尝试取出，然后在onRetainNonConfigurationInstanc方法中保存到NonConfigurationInstances。\nonRetainNonConfigurationInstance何时被调用，数据又是怎样保存的呢？了解过Activity启动流程的都知道ActivityThread，它控制着Activity的生命周期，当ActivityThread执行performDestroyActivity这个方法时，会调用Activity#retainNonConfigurationInstances获取到保存的数据并保存到ActivityClientRecord中。\n\n```java\nActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) {\n   ...\n   ActivityClientRecord r = mActivities.get(token);\n   // 由于状态改变的destroy，这里会为true\n   if (getNonConfigInstance) {\n       //保存retainNonConfigurationInstances中的数据到ActivityClientRecord中\n       r.lastNonConfigurationInstances = r.activity\n                                          .retainNonConfigurationInstances();\n   } \n   ...\n   return r;\n}\n```\n\n当页面重建完成,ActivityThread执行了performLaunchActivity方法时，会调用Activity的attach方法,便会把刚刚存储的数据，传递进去。\n\n```java\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    activity.attach(......, r.lastNonConfigurationInstances,.....);\n    ...\n}\n```\n\n总结：Activity对应的ViewModel保存在ViewModelStore里，FragmentActivity持有ViewModelStore的引用，Activity因配置原因销毁-重建时，ViewModelStore被NonConfigurationInstances保存，重建时从保存处恢复。\n\n#### 未实现ViewModelStoreOwner接口\n\n低版本未实现ViewModelStoreOwner接口，采取的方法是在Activity中注入一个不可见的HolderFragment\n\n```java\npublic static ViewModelStore of(@NonNull FragmentActivity activity) {\n    if (activity instanceof ViewModelStoreOwner) {\n        return ((ViewModelStoreOwner) activity).getViewModelStore();\n    }\n    return holderFragmentFor(activity).getViewModelStore();\n}\n```\n\nHolderFragment:\n\n```java\npublic class HolderFragment extends Fragment implements ViewModelStoreOwner { \n    private static final HolderFragmentManager sHolderFragmentManager = new HolderFragmentManager();\n    \n    private ViewModelStore mViewModelStore = new ViewModelStore();\n    \n    public HolderFragment() {\n        setRetainInstance(true);\n    }\n \n    public static HolderFragment holderFragmentFor(FragmentActivity activity) {\n        // 在activity中插入HolderFragment\n        return sHolderFragmentManager.holderFragmentFor(activity);\n    }\n}\n```\n\nHolderFragment持有mViewModelStore的引用。在HolderFragment的构造方法中，调用了`setRetainInstance(true)`。\n控制一个fragment实例是否在activity因为配置改变而销毁重建的时候被保留。如果设置为true, fragment在activity销毁重建的时候将会被保留。同时，fragment的生命周期将会发生改变，当Activity销毁重建时，fragment生命周期中的onCreate和onDestroy将不会被执行。\n\n总结：HolderFragment实现了ViewModelStoreOwner接口，持有mViewModelStore的引用。由于Fragment和activity的生命周期是绑定的，Fragment内部可以感知到activity的生命周期。同时，通过setRetainInstance(true)，当activity被销毁重建的时候，HolderFragment并不会被销毁，导致mViewModelStore也不会被销毁\nViewModel的销毁：\n\nFragmentActivity#onDestroy\n```java\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    if (this.mViewModelStore != null && !this.isChangingConfigurations()) {\n        //当activity由于非config改变而销毁时清空mViewModelStore\n        this.mViewModelStore.clear();\n    }\n\n    this.mFragments.dispatchDestroy();\n}\n```\n\nHolderFragment#onDestroy\n```java\n@Override\npublic void onDestroy() {\n    super.onDestroy();\n    mViewModelStore.clear();\n}\n```\n\nViewModelStore#clear()\n```java\npublic final void clear() {\n    for (ViewModel vm : mMap.values()) {\n        vm.onCleared();\n    }\n    mMap.clear();\n}\n```\n\n### ViewModel实现更进一步的数据持久化\n\n上面的是 activity 在因为配置改变，销毁重建的情况，在这种情况下，ViewModel 可以自动实现数据保留和现场恢复。\n还有一种情况是，App进入后台，然后因为内存紧张，activity 被系统销毁，然后用户再次打开，activity重建。这种情况下，ViewModel默认是不能实现现场恢复的，需要借助 SavedStateHandle。\n可以简单的把 SavedStateHandle 理解为 onSaveInstanceState()的逻辑从 activity 转移到了ViewModel 中。\n\n要想使用 SavedStateHandle 需要额外导入包：\n```\nimplementation 'androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-alpha01'\n```\n\n然后在获取ViewModel时使用 SavedStateViewModelFactory\n```java\nviewModel = ViewModelProviders.of(this, \n                    new SavedStateViewModelFactory(getApplication(), this))\n                    .get(SaveStateTestViewModel.class);\n```\n\n然后在ViewModel的构造方法里传入SavedStateHandle实例，然后就可以通过SavedStateHandle保存和读取数据了。\n\n```java\npublic class SaveStateTestViewModel extends ViewModel {\n    private SavedStateHandle savedStateHandle;\n    private final MutableLiveData<String> notifyLiveData;\n\n    public SaveStateTestViewModel(SavedStateHandle handle) {\n        this.savedStateHandle = handle;\n        this.notifyLiveData = savedStateHandle.getLiveData(\"key\");\n    }\n\n    public void save(int data){\n        savedStateHandle.set(\"key2\", data);\n    }\n\n    public void setData(String data) {\n        this.notifyLiveData.setValue(data);\n    }\n\n    public MutableLiveData<String> getNotifyLiveData(){\n        return notifyLiveData;\n    }\n}\n```\n\n和 onSaveInstanceState() 的保存和恢复方式一样，不能保存复杂的数据，只能保存可以存入Bundle的那些类型。 也可以SavedStateHandle中使用LiveData的方式进行保存，这样的话稍微有那么一点的好处是你不需要特意的save和get数据，直接把在初始化的时候替换成SavedStateHandle#getLiveData就可以了\n\n## 2. Lifecycles\n\nLifecycles组件是为了方便感知Activity和Fragment的生命周期而出现的，它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。\nLifecycle包含在support library 26.1.0及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。support library在26.1.0之前，需要我们引入另外的包。\n\nlifecycle 组件包括 Lifecycle, LifecycleOwner, LifecycleObserver 三个主要类：\n  - Lifecycle 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。\n  - LifecycleOwner 仅有一个 getLifecycle() 方法，用于返回当前对象的 Lifecycle。\n  - LifecycleObserver，代表观察者\n\n```java\nLifecyclerOwner和LifecycleObserver\npublic interface LifecycleOwner {\n    Lifecycle getLifecycle();\n}\n\npublic interface LifecycleObserver {\n}\n```\n\nLifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口，是被观察者。\nLifecycleOwner#getLifecycle()返回Lifecycle实例. 这是一种解耦实现, LifecycleOwner不包含任何有关生命周期管理的逻辑, 实际的逻辑都在Lifecycle实例中, 我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏。\n并不是所有的google官方的Activity和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有FragmentActivity，AppCompatActivity和v4包下的Fragment。\nLifecycleObserver接口代表生命周期的观察者，它的实现为空。实现LifecycleObserver的类要想感知到生命周期的变化需要借助额外的注解。或者，也可以使用一些继承了LifecycleObserver的子接口。\n\n```java\npublic class MyObserver implements LifecycleObserver {     \n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)    \n    public voidactivityResume() {\n    } \n}\n```\n\n### Lifecycle中的state和event\n\n```java\npublic enum State {\n    DESTROYED,\n    INITIALIZED,\n    CREATED,\n    STARTED,\n    RESUMED;\n    public boolean isAtLeast(@NonNull State state) {\n        return compareTo(state) >= 0;\n    }\n}\n\npublic enum Event {\n    ON_CREATE,\n    ON_START,\n    ON_RESUME,\n    ON_PAUSE,\n    ON_STOP,\n    ON_DESTROY,\n    ON_ANY // ON_ANY代表任意时间\n}\n```\n\n### Lifecycle的获取生命周期的变化\n\n```java\npublic class SupportActivity extends Activity implements LifecycleOwner, Component {\n    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\n    \n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ReportFragment.injectIfNeededIn(this);\n    }\n\n    protected void onSaveInstanceState(Bundle outState) {\n        this.mLifecycleRegistry.markState(State.CREATED);\n        super.onSaveInstanceState(outState);\n    }\n\n    public Lifecycle getLifecycle() {\n        return this.mLifecycleRegistry;\n    }\n}\n```\n\nLifecycleRegistry继承了Lifecycle。SupportActivity是FragmentActivity的父类。在SupportActivity中找不到state和event分发相关的代码，这些相关内容是在ReportFragment中实现的。\n\n```java\npublic class ReportFragment extends Fragment {\n    public static void injectIfNeededIn(Activity activity) {\n        android.app.FragmentManager manager = activity.getFragmentManager();\n        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();\n\n            manager.executePendingTransactions();\n        }\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        dispatchStart(mProcessListener);\n        dispatch(Lifecycle.Event.ON_START);\n    }\n    \n    private void dispatch(Lifecycle.Event event) {\n        Activity activity = getActivity();\n        ...\n        if (activity instanceof LifecycleOwner) {\n            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\n            if (lifecycle instanceof LifecycleRegistry) {\n                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\n            }\n        }\n    }\n    ...\n}\n```\n### LifecycleRegistry#addObserver\n\nLifecycleRegistry继承了Lifecycle，是Activity和Fragment生命周期的真正管理类。 这个类里面的很多逻辑有点绕，我不太能理清楚。主要看一下addObserver这个方法：\n\n```java\npublic class LifecycleRegistry extends Lifecycle {\n\n    private FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap = new FastSafeIterableMap<>();\n    private final WeakReference<LifecycleOwner> mLifecycleOwner;\n    // 当前的state\n    private State mState;\n\n    @Override\n    public void addObserver(@NonNull LifecycleObserver observer) {\n        // observer的state初始化为DESTROYED或者INITIALIZED\n        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n    \n        if (previous != null) {\n            return;\n        }\n        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n        if (lifecycleOwner == null) {\n            // it is null we should be destroyed. Fallback quickly\n            return;\n        }\n    \n        boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;\n        // 得到一个目标state\n        State targetState = calculateTargetState(observer);\n        mAddingObserverCounter++;\n        // 当observer被add进来的时候，会进入循环，分发事件，直到observer的state==targetState\n        while ((statefulObserver.mState.compareTo(targetState) < 0\n                && mObserverMap.contains(observer))) {\n            pushParentState(statefulObserver.mState);\n            // 这里的upEvent(state)会导致statefulObserver.mState在分发的过程中不断更新\n            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\n            popParentState();\n            // mState / subling may have been changed recalculate\n            targetState = calculateTargetState(observer);\n        }\n    \n        if (!isReentrance) {\n            // we do sync only on the top level.\n            sync();\n        }\n        mAddingObserverCounter--;\n    }\n\n    private State calculateTargetState(LifecycleObserver observer) {\n        // 这里的previous指前一个加入进来的Observer\n        Entry<LifecycleObserver, ObserverWithState> previous = mObserverMap.ceil(observer);\n    \n        State siblingState = previous != null ? previous.getValue().mState : null;\n        // 这个mParentStates不知道是啥。。。\n        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)\n                : null;\n        // 这里的min(x, y)是 返回在枚举中order最小的state\n        return min(min(mState, siblingState), parentState);\n    }\n    ...\n}\n```\n\n在addObserver中，ObserverWithState将state和observer包装一下，ObserverWithState内初始的state是DESTROYED或者INITIALIZED。之后会计算一个targetState，在while循环中会不断的分发和更新event。\n\n具体效果看下面的demo：\n\n```java\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    ...\n    handler.postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            TestActivity.this.getLifecycle().addObserver(new GenericLifecycleObserver() {\n                @Override\n                public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {\n                    Log.i(\"chenlei\", \"onStateChanged: \" + event);\n                }\n            });\n        }\n    }, 5000);\n}\n```\n\n这里的GenericLifecycleObserver继承了LifecycleObserver的接口。demo中在create方法里延时5s添加一个LifecycleObserver并打印event。最后打印输出如下：\n\n可以看到从ON_CREATE到ON_RESUME在同一时刻都打印出来了\n\n### ProcessLifecycleOwner\n\nProcessLifecycleOwner实现了LifecycleOwner接口，可以监听当前应用前后台切换，并对此进行响应。\n这个类提供整个应用进程的生命周期。\n你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，Lifecycle.Event.ON_CREATE 事件只会分发一次，而 Lifecycle.Event.ON_DESTROY 永远不被分发。其他事件的分发遵守以下规则：\nProcessLifecycleOwner 会在第一个 Activity 经历 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 事件 延迟一段时间 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。\n这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。\n使用的时候，在Application中添加LifecycleObserver就可以了(实际上，在应用进程中的任意位置都可以）\n\n```java\nclass ApplicationObserver(val analytics: Analytics) : LifecycleObserver {\n    \n    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n    fun onBackground() {    }   \n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onForeground() {    }\n}\n\npublic class MyApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        ProcessLifecycleOwner.get().getLifecycle().addObserver(new ApplicationObserver());\n    }\n}\n```\n\n原理：\n\nProcessLifecycleOwnerInitializer\n```java\npublic class ProcessLifecycleOwnerInitializer extends ContentProvider {\n    @Override\n    public boolean onCreate() {\n        LifecycleDispatcher.init(getContext());\n        ProcessLifecycleOwner.init(getContext());\n        return true;\n    }\n    ...\n}\n```\n\n这个类是ProcessLifecycleOwner初始化的地方，它继承了一个ContentProvider ，这个ContentProvider声明在了Lifecycle包的AndroidManifest.xml里。\n\n这个AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。\n这里利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application 的 onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建。\n\nLifecycleDispatcher#init\n```java\nclass LifecycleDispatcher {\n\n    private static AtomicBoolean sInitialized = new AtomicBoolean(false);\n\n    static void init(Context context) {\n        if (sInitialized.getAndSet(true)) {\n            return;\n        }\n        ((Application) context.getApplicationContext())\n                .registerActivityLifecycleCallbacks(new DispatcherActivityCallback());\n    }\n\n    static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            ReportFragment.injectIfNeededIn(activity);\n        }\n        ...\n    }\n}\n```\n\n在Application中注册一个ActivityLifecycleCallbacks，在ActivityLifecycleCallbacks中有Activity所有生命周期的回调，这样就能监听到每一个Activity的创建和销毁。在onActivityCreated回调中往Activity注入一个了ReportFragment，我没看出来这里的ReportFragment的作用是什么。。\n\nProcessLifecycleOwner\n\n```java\npublic class ProcessLifecycleOwner implements LifecycleOwner {\n    private final LifecycleRegistry mRegistry = new LifecycleRegistry(this);\n    private static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner();\n    static void init(Context context) {\n        sInstance.attach(context);\n    }\n\n    private ActivityInitializationListener mInitializationListener =\n        new ActivityInitializationListener() {\n            @Override\n            public void onCreate() {\n            }\n\n            @Override\n            public void onStart() {\n                activityStarted();\n            }\n\n            @Override\n            public void onResume() {\n                activityResumed();\n            }\n        };\n\n    void attach(Context context) {\n        mHandler = new Handler();\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);\n        Application app = (Application) context.getApplicationContext();\n        app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() {\n            @Override\n            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            //在ReportFragment的生命周期中会有dispatchXxxx(mProcessListener)\n                ReportFragment.get(activity)\n                                .setProcessListener(mInitializationListener);\n            }\n    \n            @Override\n            public void onActivityPaused(Activity activity) {\n                activityPaused();\n            }\n    \n            @Override\n            public void onActivityStopped(Activity activity) {\n                activityStopped();\n            }\n        });\n    }\n\n    void activityResumed() {\n        mResumedCounter++;\n        if (mResumedCounter == 1) {\n            if (mPauseSent) {\n                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);\n                mPauseSent = false;\n            } else {\n                mHandler.removeCallbacks(mDelayedPauseRunnable);\n            }\n        }\n    }\n\n    void activityPaused() {\n        mResumedCounter--;\n        if (mResumedCounter == 0) {\n            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);\n        }\n    }\n    // 在mDelayedPauseRunnable中会调用这个方法\n    private void dispatchPauseIfNeeded() {\n        if (mResumedCounter == 0) {\n            mPauseSent = true;\n            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);\n        }\n    }\n    ...\n}\n```\n\n## 2. LiveData\nViewModel和Lifecycles分别代表数据和UI两端，这两个组件是相对比较独立的，并没有太多直接的关系。为了防止内存泄漏，ViewModel不能直接持有activity和fragment的引用。为了让更好的结合ViewModel和Lifecycles，就需要LiveData。\nLiveData是一种观察者模式, 在 Value发生变化时通知之前注册的所有观察者。同时，借助于Lifecycles，LiveData具有生命周期的感知能力。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。使用LiveData有以下的优点：\n- LiveData 只会将消息通知给活跃的观察者，非活跃观察者将不会收到消息通知。\n- 当非活跃观察者状态变为活跃的时候，LiveData会将自动将最新的消息发送给它。\n- 当相应的 Lifecycle 对象的状态变为 DESTROYED 时，LiveData会自动的移除此观察者，这样就不用担心Fragment和Activity的内存泄漏。\n- LiveData的数据发送和Observer的添加是没有顺序限制的。比如说LiveData在第1s发送消息，然后在第5s添加Observer，Observer依然能够立即接收到第1s发送出的数据，只要数据是当前最新的。这主要和LifecycleRegistry#addObserver的实现有关\n\n### 2.1 LiveData的使用\n\n#### 2.1.1 基本使用\n\n```java\n public class NameViewModel extends ViewModel {\n    private MutableLiveData<String> notifyCurrentName = new MutableLiveData<>();\n\n    private void post(){\n        notifyCurrentName.postValue(\"value\");    \n    }\n    \n    public MutableLiveData<String> getNotifyCurrentName(){\n        return notifyCurrentName;\n    }\n}\n\n// 在activity or fragment中\n// public void observe(LifecycleOwner owner, Observer<T> observer) \ngetViewModel().getNotifyCurrentName().observer(this, new Observer<String>() {\n    @Override\n    public void onChanged(@Nullable Stirng value) {\n        ...\n    }\n}\n\n// 如果不想让LiveData感知到生命周期，可以用observeForever(Observer<T> observer)\ngetViewModel().getNotifyCurrentName().observeForever(new Observer<String>() {\n    @Override\n    public void onChanged(@Nullable Stirng value) {\n        ...\n    }\n}\n```\n\n#### 2.1.2 Transformations#map\nTransformations是用来做LiveData转换的类。\nTransformations#map可以在消息分派给观察者之前对消息进行更改。\n\n```java\nLiveData<User> userLiveData = ...;\nLiveData<String> userName = Transformations.map(userLiveData, user -> {\n    user.name + \" \" + user.lastName\n});\n```\n\n#### 2.1.3 Transformations#switchMap\nswitchMap可以实现LiveData的转换，下面是一个demo，通过switchMap切换LiveData的数据源\n\n```java\npublic class MapTestViewModel extends ViewModel {\n    private MutableLiveData<String> dataSourceA = new MutableLiveData<>();\n    private MutableLiveData<String> dataSourceB = new MutableLiveData<>();\n\n    private MutableLiveData<Boolean> changeDataSource = new MutableLiveData<>();\n\n    private LiveData<String> notifyData = Transformations.switchMap(changeDataSource, new Function<Boolean, LiveData<String>>() {\n        @Override\n        public LiveData<String> apply(Boolean input) {\n            return input ? dataSourceA : dataSourceB;\n        }\n    });\n\n    public void start(Activity activity) {\n        changeDataSource.setValue(true);\n\n        Handler handler = new Handler(activity.getMainLooper());\n        handler.postDelayed(() -> {\n            dataSourceA.postValue(\"data from source A\");\n            dataSourceB.postValue(\"data from source B\");\n        }, 2000);\n        \n        handler.postDelayed(() -> {\n            changeDataSource(false);\n        }, 10000);\n    }\n\n    public void changeDataSource(boolean userA) {\n        changeDataSource.setValue(userA);\n    }\n\n    public LiveData<String> getNotifyData() {\n        return notifyData;\n    }\n}\n\n// activity\nviewModel.start(this);\nviewModel.getNotifyData().observe(MapTestActivity.this, new Observer<String>() {\n    @Override\n    public void onChanged(String s) {\n        Log.i(\"chenlei\", \"onChanged: \" + s);\n    }\n});\n```\n            \n上面的demo中，延时2s同时向dataSourceA和dataSourceB发送数据，并延时10s将数据源从A指向B。在observe中打印结果，最终dataSourceA和dataSourceB在间隔一段时间之后都能打印出来。\n每次调用changeDataSource.setValue(Boolean)，都会调用Function#apply返回一个LiveData，并将notifyData的 Observer 添加到新的LiveData上\n\n### 2.2 LiveData的原理\n\n#### 2.2.1 LiveData\n\n```java\npublic abstract class LiveData<T> {\n    // 存放Observer的集合\n    private SafeIterableMap<Observer<T>, ObserverWrapper> mObservers =                                                                 new SafeIterableMap<>();\n\n    static final int START_VERSION = -1;\n    private int mActiveCount = 0;\n    private int mVersion = START_VERSION;\n\n    ...\n    // 当LiveData的活跃Observer数量由0变成1的时候调用\n    protected void onActive() {}\n    // 当LiveData的活跃Observer数量由1变成0的时候调用\n    protected void onInactive() {}\n\n    ...\n\n    private abstract class ObserverWrapper {\n        final Observer<T> mObserver;\n        boolean mActive;\n        int mLastVersion = START_VERSION;\n    \n        ObserverWrapper(Observer<T> observer) {\n            mObserver = observer;\n        }\n    \n        abstract boolean shouldBeActive();\n    \n        boolean isAttachedTo(LifecycleOwner owner) {\n            return false;\n        }\n    \n        void detachObserver() {\n        }\n    \n        void activeStateChanged(boolean newActive) {\n            // 活跃状态没有改变则return， 防止重复发送消息\n            if (newActive == mActive) {\n                return;\n            }\n            mActive = newActive;\n            boolean wasInactive = LiveData.this.mActiveCount == 0;\n            LiveData.this.mActiveCount += mActive ? 1 : -1;\n            if (wasInactive && mActive) {\n                onActive();\n            }\n            if (LiveData.this.mActiveCount == 0 && !mActive) {\n                onInactive();\n            }\n            if (mActive) {\n                // 开始分发value\n                dispatchingValue(this);\n            }\n        }\n    }\n    ...\n}\n```\n\n#### 2.2.2 LiveData#observer\n\n```java\npublic abstract class LiveData<T> {    \n    ...\n    @MainThread\n    public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<T> observer) {\n        if (owner.getLifecycle().getCurrentState() == DESTROYED) {\n            return;\n        }\n        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        ...\n        if (existing != null) {\n            return;\n        }\n        // 将wrapper将入到lifecycleOwner的生命周期的监听中\n        owner.getLifecycle().addObserver(wrapper);\n    }\n    ...\n}\n```\n\nLifecycleBoundObserver继承自ObserverWrapper，并且实现了\n\n```java\nGenericLifecycleObserver接口。GenericLifecycleObserver接口继承自LifecycleObserver接口\npublic interface GenericLifecycleObserver extends LifecycleObserver {\n    void onStateChanged(LifecycleOwner source, Lifecycle.Event event);\n}\n```\n\n```java\nclass LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {\n    @NonNull final LifecycleOwner mOwner;\n\n    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<T> observer)\n    {\n        super(observer);\n        mOwner = owner;\n    }\n\n    @Override\n    boolean shouldBeActive() {\n        // 通过Lifecycle判断当前Observer是否活跃\n        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);\n    }\n\n    // GenericLifecycleObserver#onStatechanged\n    @Override\n    public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {\n        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n            // 当LifecycleOwner已经被销毁，remove这个Observer。\n            // removeObserver会调用detachObserver()和activeStateChanged(false)\n            // 这也是为什么LiveData可以自动防止UI泄漏的原因\n            removeObserver(mObserver);\n            return;\n        }\n        activeStateChanged(shouldBeActive());\n    }\n\n    @Override\n    boolean isAttachedTo(LifecycleOwner owner) {\n        return mOwner == owner;\n    }\n\n    @Override\n    void detachObserver() {\n        // 从LifecycleOwner中remove观察者\n        mOwner.getLifecycle().removeObserver(this);\n    }\n}\n```\n\nLiveData#observeForever\n\n```java\n@MainThread\npublic void observeForever(@NonNull Observer<T> observer) {\n    AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n    ...\n    if (existing != null) {\n        return;\n    }\n    // 因为observeForever没有LifecycleOwner，为了保持和普通observe方法的特性一致，在添加observe之后立刻检查是否有数据可以发送，\n    wrapper.activeStateChanged(true);\n}\n\nprivate class AlwaysActiveObserver extends ObserverWrapper {\n    AlwaysActiveObserver(Observer<T> observer) {\n        super(observer);\n    }\n\n    @Override\n    boolean shouldBeActive() {\n        return true;\n    }\n}\n```\n\n#### 2.2.3 LiveData#postValue()\nLiveData发送消息使用setValue或者postValue方法。其中setValue只能在主线程中使用，postValue发送消息时会自动切换到主线程。\n\n```java\npublic abstract class LiveData<T> {\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            ...\n            setValue((T) newValue);\n        }\n    };\n\n    ... \n    protected void postValue(T value) {\n        ...\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n    ...\n}\nLiveData#setValue\n@MainThread\nprotected void setValue(T value) {\n    assertMainThread(\"setValue\");\n    mVersion++;\n    mData = value;\n    dispatchingValue(null);\n}\n\nprivate void dispatchingValue(@Nullable ObserverWrapper initiator) {\n    if (mDispatchingValue) {\n        mDispatchInvalidated = true;\n        return;\n    }\n    mDispatchingValue = true;\n    do {\n        mDispatchInvalidated = false;\n        if (initiator != null) {\n            // 向特定的Observer发送数据\n            considerNotify(initiator);\n            initiator = null;\n        } else {\n            // 向所有Observer发送消息\n            for (Iterator<Map.Entry<Observer<T>, ObserverWrapper>> iterator =\n                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                considerNotify(iterator.next().getValue());\n                if (mDispatchInvalidated) {\n                    break;\n                }\n            }\n        }\n    } while (mDispatchInvalidated);\n    mDispatchingValue = false;\n}\n\nprivate void considerNotify(ObserverWrapper observer) {\n    if (!observer.mActive) {\n        return;\n    }\n    if (!observer.shouldBeActive()) {\n        observer.activeStateChanged(false);\n        return;\n    }\n    if (observer.mLastVersion >= mVersion) {\n        // 将要发送的是旧版本，扔掉\n        return;\n    }\n    observer.mLastVersion = mVersion;\n    observer.mObserver.onChanged((T) mData);\n}\n```\n","source":"_posts/Android/ViewModel-LiveData和LifeCricle.md","raw":"---\ntitle: 'ViewModel,LiveData和Lifecycle'\ndate: 2019-12-21 20:19:41\ntags:\n---\n\n# ViewModel、Lifecycles和LiveData\n## 1. ViewModel:\nViewModel是Google官方提供的组件，是用来处理和存放和UI相关的数据的，可以把UI和数据进行分离。但就这一点来说的话，其实没有必要一定使用Google提供的ViewModel组件，我们使用自定义的ViewModel类同样可以达到这样的效果。\n\n还有一个很重要的特性，我们都知道，在配置改变时，Activity会出现销毁重建，比如说横竖屏切换的时候。ViewModel的生命周期和Activity是不一样的，它不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，可以将和UI相关的数据存放在ViewModel中，这样，即使Activity销毁重建，页面上显示的数据也不会丢失。\n```java\npublic abstract class ViewModel {\n    // 在ViewModel销毁的时候做回收工作，主要是为了防止ViewModel的泄漏\n    protected void onCleared() {\n    }\n}\n```\n### ViewModel的创建和存储过程\n主要是要搞清楚上面说的：Activity销毁重建的时候，ViewModel是如何保持不重建的。\n注意，这里只是在Activity因为配置改变而销毁重建的情况下。还有一种情况是，App由前台进入后台，因为内存紧张，Activity被系统销毁。这种情况下，ViewModel是无法保存数据的。\n\n以下全都以Activity举例，Fragment也是一样的\n在Activity中获取ViewModel：\n```java\nviewModel = ViewModelProviders.of(this).get(XxxViewModel.class);\n```\nViewModelProviders#of\n```java\n@NonNull\n@MainThread\npublic static ViewModelProvider of(@NonNull FragmentActivity activity,\n        @Nullable Factory factory) {\n    Application application = checkApplication(activity);\n    if (factory == null) {\n        // 使用默认的工厂类\n        // 如果想要在ViewModel的构造方法里传参，需要自定义factory类\n        factory = ViewModelProvider.AndroidViewModelFactory\n                                    .getInstance(application);\n    }\n    return new ViewModelProvider(ViewModelStores.of(activity), factory);\n}\n```\nviewModelProvider#get\n```java\n// 从ViewModelStore中获取ViewModel，没有则创建\npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {\n    ViewModel viewModel = mViewModelStore.get(key);\n    if (modelClass.isInstance(viewModel)) {\n        return (T) viewModel;\n    } else {\n        ...\n    }\n    viewModel = mFactory.create(modelClass);\n    mViewModelStore.put(key, viewModel);\n    return (T) viewModel;\n}\n\npublic class ViewModelStore {\n    // ViewModel的集合，key是由ViewModel类名构成的字符串\n    private final HashMap<String, ViewModel> mMap = new HashMap<>();\n    ...\n}\n```\nViewModelStore中存储了一个Activity/Fragment的所有ViewModel。那现在问题就转变成了探究ViewModelStore的获取和存储的过程\n\nViewModelStores#of\n```java\npublic static ViewModelStore of(@NonNull FragmentActivity activity) {\n    if (activity instanceof ViewModelStoreOwner) {\n        return ((ViewModelStoreOwner) activity).getViewModelStore();\n    }\n    return holderFragmentFor(activity).getViewModelStore();\n}\n```\n这里先判断FragmentActivity是否实现了ViewModelStoreOwner接口。不同的依赖包，实现有可能是不一样的。高版本的support-v4和androidx中的Fragment和FragmentActivity都实现了这个接口。\n```java\npublic interface ViewModelStoreOwner {\n    @NonNull\n    ViewModelStore getViewModelStore();\n}\n```\n#### 实现了ViewModelStoreOwner接口\n\nFragmentActivity\n```java\npublic class FragmentActivity extends SupportActivity implements ViewModelStoreOwner, ...{\n    private ViewModelStore mViewModelStore;\n        \n    public ViewModelStore getViewModelStore() {\n        ...\n    }\n}\n```\n\n实现了ViewModelStoreOwner接口的FragmentActivity会直接持有ViewModelStore的引用\n\n主要关注三个方法：\ngetViewModelStore()\nonCreate()\nonRetainNonConfigurationInstance()\n\n```java\npublic ViewModelStore getViewModelStore() {\n    if (this.getApplication() == null) {\n       ...\n    } else {\n        if (this.mViewModelStore == null) {\n            FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances) this.getLastNonConfigurationInstance();\n            if (nc != null) {\n                this.mViewModelStore = nc.viewModelStore;\n            }\n\n            if (this.mViewModelStore == null) {\n                this.mViewModelStore = new ViewModelStore();\n            }\n        }\n\n        return this.mViewModelStore;\n    }\n}\n\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    ...\n    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)this.getLastNonConfigurationInstance();\n    if (nc != null && nc.viewModelStore != null && this.mViewModelStore == null)\n    {\n        this.mViewModelStore = nc.viewModelStore;\n    }\n    ...\n}\n// 在页面销毁时，保存ViewModelStore\npublic final Object onRetainNonConfigurationInstance() {\n     Object custom = onRetainCustomNonConfigurationInstance();\n     ViewModelStore viewModelStore = mViewModelStore;\n     if (viewModelStore == null) {\n         // 如果NonConfigurationInstance保存了viewModelStore，把它取出来\n        NonConfigurationInstances nc = getLastNonConfigurationInstance();\n        if (nc != null) {\n            viewModelStore = nc.viewModelStore;\n          }\n       }\n     if (viewModelStore == null && custom == null) {\n          return null;\n       }\n      NonConfigurationInstances nci = new NonConfigurationInstances();\n      nci.custom = custom; \n      //把viewModelStore放到NonConfigurationInstances中并返回\n      nci.viewModelStore = viewModelStore;\n      //这样当页面被重建而销毁时ViewModelStore就被保存起来了。\n      return nci;\n}\n```\n\nViewModelStore在onCreate里会从NonConfigurationInstances里尝试取出，然后在onRetainNonConfigurationInstanc方法中保存到NonConfigurationInstances。\nonRetainNonConfigurationInstance何时被调用，数据又是怎样保存的呢？了解过Activity启动流程的都知道ActivityThread，它控制着Activity的生命周期，当ActivityThread执行performDestroyActivity这个方法时，会调用Activity#retainNonConfigurationInstances获取到保存的数据并保存到ActivityClientRecord中。\n\n```java\nActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) {\n   ...\n   ActivityClientRecord r = mActivities.get(token);\n   // 由于状态改变的destroy，这里会为true\n   if (getNonConfigInstance) {\n       //保存retainNonConfigurationInstances中的数据到ActivityClientRecord中\n       r.lastNonConfigurationInstances = r.activity\n                                          .retainNonConfigurationInstances();\n   } \n   ...\n   return r;\n}\n```\n\n当页面重建完成,ActivityThread执行了performLaunchActivity方法时，会调用Activity的attach方法,便会把刚刚存储的数据，传递进去。\n\n```java\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    activity.attach(......, r.lastNonConfigurationInstances,.....);\n    ...\n}\n```\n\n总结：Activity对应的ViewModel保存在ViewModelStore里，FragmentActivity持有ViewModelStore的引用，Activity因配置原因销毁-重建时，ViewModelStore被NonConfigurationInstances保存，重建时从保存处恢复。\n\n#### 未实现ViewModelStoreOwner接口\n\n低版本未实现ViewModelStoreOwner接口，采取的方法是在Activity中注入一个不可见的HolderFragment\n\n```java\npublic static ViewModelStore of(@NonNull FragmentActivity activity) {\n    if (activity instanceof ViewModelStoreOwner) {\n        return ((ViewModelStoreOwner) activity).getViewModelStore();\n    }\n    return holderFragmentFor(activity).getViewModelStore();\n}\n```\n\nHolderFragment:\n\n```java\npublic class HolderFragment extends Fragment implements ViewModelStoreOwner { \n    private static final HolderFragmentManager sHolderFragmentManager = new HolderFragmentManager();\n    \n    private ViewModelStore mViewModelStore = new ViewModelStore();\n    \n    public HolderFragment() {\n        setRetainInstance(true);\n    }\n \n    public static HolderFragment holderFragmentFor(FragmentActivity activity) {\n        // 在activity中插入HolderFragment\n        return sHolderFragmentManager.holderFragmentFor(activity);\n    }\n}\n```\n\nHolderFragment持有mViewModelStore的引用。在HolderFragment的构造方法中，调用了`setRetainInstance(true)`。\n控制一个fragment实例是否在activity因为配置改变而销毁重建的时候被保留。如果设置为true, fragment在activity销毁重建的时候将会被保留。同时，fragment的生命周期将会发生改变，当Activity销毁重建时，fragment生命周期中的onCreate和onDestroy将不会被执行。\n\n总结：HolderFragment实现了ViewModelStoreOwner接口，持有mViewModelStore的引用。由于Fragment和activity的生命周期是绑定的，Fragment内部可以感知到activity的生命周期。同时，通过setRetainInstance(true)，当activity被销毁重建的时候，HolderFragment并不会被销毁，导致mViewModelStore也不会被销毁\nViewModel的销毁：\n\nFragmentActivity#onDestroy\n```java\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    if (this.mViewModelStore != null && !this.isChangingConfigurations()) {\n        //当activity由于非config改变而销毁时清空mViewModelStore\n        this.mViewModelStore.clear();\n    }\n\n    this.mFragments.dispatchDestroy();\n}\n```\n\nHolderFragment#onDestroy\n```java\n@Override\npublic void onDestroy() {\n    super.onDestroy();\n    mViewModelStore.clear();\n}\n```\n\nViewModelStore#clear()\n```java\npublic final void clear() {\n    for (ViewModel vm : mMap.values()) {\n        vm.onCleared();\n    }\n    mMap.clear();\n}\n```\n\n### ViewModel实现更进一步的数据持久化\n\n上面的是 activity 在因为配置改变，销毁重建的情况，在这种情况下，ViewModel 可以自动实现数据保留和现场恢复。\n还有一种情况是，App进入后台，然后因为内存紧张，activity 被系统销毁，然后用户再次打开，activity重建。这种情况下，ViewModel默认是不能实现现场恢复的，需要借助 SavedStateHandle。\n可以简单的把 SavedStateHandle 理解为 onSaveInstanceState()的逻辑从 activity 转移到了ViewModel 中。\n\n要想使用 SavedStateHandle 需要额外导入包：\n```\nimplementation 'androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-alpha01'\n```\n\n然后在获取ViewModel时使用 SavedStateViewModelFactory\n```java\nviewModel = ViewModelProviders.of(this, \n                    new SavedStateViewModelFactory(getApplication(), this))\n                    .get(SaveStateTestViewModel.class);\n```\n\n然后在ViewModel的构造方法里传入SavedStateHandle实例，然后就可以通过SavedStateHandle保存和读取数据了。\n\n```java\npublic class SaveStateTestViewModel extends ViewModel {\n    private SavedStateHandle savedStateHandle;\n    private final MutableLiveData<String> notifyLiveData;\n\n    public SaveStateTestViewModel(SavedStateHandle handle) {\n        this.savedStateHandle = handle;\n        this.notifyLiveData = savedStateHandle.getLiveData(\"key\");\n    }\n\n    public void save(int data){\n        savedStateHandle.set(\"key2\", data);\n    }\n\n    public void setData(String data) {\n        this.notifyLiveData.setValue(data);\n    }\n\n    public MutableLiveData<String> getNotifyLiveData(){\n        return notifyLiveData;\n    }\n}\n```\n\n和 onSaveInstanceState() 的保存和恢复方式一样，不能保存复杂的数据，只能保存可以存入Bundle的那些类型。 也可以SavedStateHandle中使用LiveData的方式进行保存，这样的话稍微有那么一点的好处是你不需要特意的save和get数据，直接把在初始化的时候替换成SavedStateHandle#getLiveData就可以了\n\n## 2. Lifecycles\n\nLifecycles组件是为了方便感知Activity和Fragment的生命周期而出现的，它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。\nLifecycle包含在support library 26.1.0及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。support library在26.1.0之前，需要我们引入另外的包。\n\nlifecycle 组件包括 Lifecycle, LifecycleOwner, LifecycleObserver 三个主要类：\n  - Lifecycle 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。\n  - LifecycleOwner 仅有一个 getLifecycle() 方法，用于返回当前对象的 Lifecycle。\n  - LifecycleObserver，代表观察者\n\n```java\nLifecyclerOwner和LifecycleObserver\npublic interface LifecycleOwner {\n    Lifecycle getLifecycle();\n}\n\npublic interface LifecycleObserver {\n}\n```\n\nLifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口，是被观察者。\nLifecycleOwner#getLifecycle()返回Lifecycle实例. 这是一种解耦实现, LifecycleOwner不包含任何有关生命周期管理的逻辑, 实际的逻辑都在Lifecycle实例中, 我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏。\n并不是所有的google官方的Activity和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有FragmentActivity，AppCompatActivity和v4包下的Fragment。\nLifecycleObserver接口代表生命周期的观察者，它的实现为空。实现LifecycleObserver的类要想感知到生命周期的变化需要借助额外的注解。或者，也可以使用一些继承了LifecycleObserver的子接口。\n\n```java\npublic class MyObserver implements LifecycleObserver {     \n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)    \n    public voidactivityResume() {\n    } \n}\n```\n\n### Lifecycle中的state和event\n\n```java\npublic enum State {\n    DESTROYED,\n    INITIALIZED,\n    CREATED,\n    STARTED,\n    RESUMED;\n    public boolean isAtLeast(@NonNull State state) {\n        return compareTo(state) >= 0;\n    }\n}\n\npublic enum Event {\n    ON_CREATE,\n    ON_START,\n    ON_RESUME,\n    ON_PAUSE,\n    ON_STOP,\n    ON_DESTROY,\n    ON_ANY // ON_ANY代表任意时间\n}\n```\n\n### Lifecycle的获取生命周期的变化\n\n```java\npublic class SupportActivity extends Activity implements LifecycleOwner, Component {\n    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\n    \n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ReportFragment.injectIfNeededIn(this);\n    }\n\n    protected void onSaveInstanceState(Bundle outState) {\n        this.mLifecycleRegistry.markState(State.CREATED);\n        super.onSaveInstanceState(outState);\n    }\n\n    public Lifecycle getLifecycle() {\n        return this.mLifecycleRegistry;\n    }\n}\n```\n\nLifecycleRegistry继承了Lifecycle。SupportActivity是FragmentActivity的父类。在SupportActivity中找不到state和event分发相关的代码，这些相关内容是在ReportFragment中实现的。\n\n```java\npublic class ReportFragment extends Fragment {\n    public static void injectIfNeededIn(Activity activity) {\n        android.app.FragmentManager manager = activity.getFragmentManager();\n        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();\n\n            manager.executePendingTransactions();\n        }\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        dispatchStart(mProcessListener);\n        dispatch(Lifecycle.Event.ON_START);\n    }\n    \n    private void dispatch(Lifecycle.Event event) {\n        Activity activity = getActivity();\n        ...\n        if (activity instanceof LifecycleOwner) {\n            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\n            if (lifecycle instanceof LifecycleRegistry) {\n                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\n            }\n        }\n    }\n    ...\n}\n```\n### LifecycleRegistry#addObserver\n\nLifecycleRegistry继承了Lifecycle，是Activity和Fragment生命周期的真正管理类。 这个类里面的很多逻辑有点绕，我不太能理清楚。主要看一下addObserver这个方法：\n\n```java\npublic class LifecycleRegistry extends Lifecycle {\n\n    private FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap = new FastSafeIterableMap<>();\n    private final WeakReference<LifecycleOwner> mLifecycleOwner;\n    // 当前的state\n    private State mState;\n\n    @Override\n    public void addObserver(@NonNull LifecycleObserver observer) {\n        // observer的state初始化为DESTROYED或者INITIALIZED\n        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n    \n        if (previous != null) {\n            return;\n        }\n        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n        if (lifecycleOwner == null) {\n            // it is null we should be destroyed. Fallback quickly\n            return;\n        }\n    \n        boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;\n        // 得到一个目标state\n        State targetState = calculateTargetState(observer);\n        mAddingObserverCounter++;\n        // 当observer被add进来的时候，会进入循环，分发事件，直到observer的state==targetState\n        while ((statefulObserver.mState.compareTo(targetState) < 0\n                && mObserverMap.contains(observer))) {\n            pushParentState(statefulObserver.mState);\n            // 这里的upEvent(state)会导致statefulObserver.mState在分发的过程中不断更新\n            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\n            popParentState();\n            // mState / subling may have been changed recalculate\n            targetState = calculateTargetState(observer);\n        }\n    \n        if (!isReentrance) {\n            // we do sync only on the top level.\n            sync();\n        }\n        mAddingObserverCounter--;\n    }\n\n    private State calculateTargetState(LifecycleObserver observer) {\n        // 这里的previous指前一个加入进来的Observer\n        Entry<LifecycleObserver, ObserverWithState> previous = mObserverMap.ceil(observer);\n    \n        State siblingState = previous != null ? previous.getValue().mState : null;\n        // 这个mParentStates不知道是啥。。。\n        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)\n                : null;\n        // 这里的min(x, y)是 返回在枚举中order最小的state\n        return min(min(mState, siblingState), parentState);\n    }\n    ...\n}\n```\n\n在addObserver中，ObserverWithState将state和observer包装一下，ObserverWithState内初始的state是DESTROYED或者INITIALIZED。之后会计算一个targetState，在while循环中会不断的分发和更新event。\n\n具体效果看下面的demo：\n\n```java\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    ...\n    handler.postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            TestActivity.this.getLifecycle().addObserver(new GenericLifecycleObserver() {\n                @Override\n                public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {\n                    Log.i(\"chenlei\", \"onStateChanged: \" + event);\n                }\n            });\n        }\n    }, 5000);\n}\n```\n\n这里的GenericLifecycleObserver继承了LifecycleObserver的接口。demo中在create方法里延时5s添加一个LifecycleObserver并打印event。最后打印输出如下：\n\n可以看到从ON_CREATE到ON_RESUME在同一时刻都打印出来了\n\n### ProcessLifecycleOwner\n\nProcessLifecycleOwner实现了LifecycleOwner接口，可以监听当前应用前后台切换，并对此进行响应。\n这个类提供整个应用进程的生命周期。\n你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，Lifecycle.Event.ON_CREATE 事件只会分发一次，而 Lifecycle.Event.ON_DESTROY 永远不被分发。其他事件的分发遵守以下规则：\nProcessLifecycleOwner 会在第一个 Activity 经历 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 事件 延迟一段时间 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。\n这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。\n使用的时候，在Application中添加LifecycleObserver就可以了(实际上，在应用进程中的任意位置都可以）\n\n```java\nclass ApplicationObserver(val analytics: Analytics) : LifecycleObserver {\n    \n    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n    fun onBackground() {    }   \n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onForeground() {    }\n}\n\npublic class MyApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        ProcessLifecycleOwner.get().getLifecycle().addObserver(new ApplicationObserver());\n    }\n}\n```\n\n原理：\n\nProcessLifecycleOwnerInitializer\n```java\npublic class ProcessLifecycleOwnerInitializer extends ContentProvider {\n    @Override\n    public boolean onCreate() {\n        LifecycleDispatcher.init(getContext());\n        ProcessLifecycleOwner.init(getContext());\n        return true;\n    }\n    ...\n}\n```\n\n这个类是ProcessLifecycleOwner初始化的地方，它继承了一个ContentProvider ，这个ContentProvider声明在了Lifecycle包的AndroidManifest.xml里。\n\n这个AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。\n这里利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application 的 onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建。\n\nLifecycleDispatcher#init\n```java\nclass LifecycleDispatcher {\n\n    private static AtomicBoolean sInitialized = new AtomicBoolean(false);\n\n    static void init(Context context) {\n        if (sInitialized.getAndSet(true)) {\n            return;\n        }\n        ((Application) context.getApplicationContext())\n                .registerActivityLifecycleCallbacks(new DispatcherActivityCallback());\n    }\n\n    static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            ReportFragment.injectIfNeededIn(activity);\n        }\n        ...\n    }\n}\n```\n\n在Application中注册一个ActivityLifecycleCallbacks，在ActivityLifecycleCallbacks中有Activity所有生命周期的回调，这样就能监听到每一个Activity的创建和销毁。在onActivityCreated回调中往Activity注入一个了ReportFragment，我没看出来这里的ReportFragment的作用是什么。。\n\nProcessLifecycleOwner\n\n```java\npublic class ProcessLifecycleOwner implements LifecycleOwner {\n    private final LifecycleRegistry mRegistry = new LifecycleRegistry(this);\n    private static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner();\n    static void init(Context context) {\n        sInstance.attach(context);\n    }\n\n    private ActivityInitializationListener mInitializationListener =\n        new ActivityInitializationListener() {\n            @Override\n            public void onCreate() {\n            }\n\n            @Override\n            public void onStart() {\n                activityStarted();\n            }\n\n            @Override\n            public void onResume() {\n                activityResumed();\n            }\n        };\n\n    void attach(Context context) {\n        mHandler = new Handler();\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);\n        Application app = (Application) context.getApplicationContext();\n        app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() {\n            @Override\n            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            //在ReportFragment的生命周期中会有dispatchXxxx(mProcessListener)\n                ReportFragment.get(activity)\n                                .setProcessListener(mInitializationListener);\n            }\n    \n            @Override\n            public void onActivityPaused(Activity activity) {\n                activityPaused();\n            }\n    \n            @Override\n            public void onActivityStopped(Activity activity) {\n                activityStopped();\n            }\n        });\n    }\n\n    void activityResumed() {\n        mResumedCounter++;\n        if (mResumedCounter == 1) {\n            if (mPauseSent) {\n                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);\n                mPauseSent = false;\n            } else {\n                mHandler.removeCallbacks(mDelayedPauseRunnable);\n            }\n        }\n    }\n\n    void activityPaused() {\n        mResumedCounter--;\n        if (mResumedCounter == 0) {\n            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);\n        }\n    }\n    // 在mDelayedPauseRunnable中会调用这个方法\n    private void dispatchPauseIfNeeded() {\n        if (mResumedCounter == 0) {\n            mPauseSent = true;\n            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);\n        }\n    }\n    ...\n}\n```\n\n## 2. LiveData\nViewModel和Lifecycles分别代表数据和UI两端，这两个组件是相对比较独立的，并没有太多直接的关系。为了防止内存泄漏，ViewModel不能直接持有activity和fragment的引用。为了让更好的结合ViewModel和Lifecycles，就需要LiveData。\nLiveData是一种观察者模式, 在 Value发生变化时通知之前注册的所有观察者。同时，借助于Lifecycles，LiveData具有生命周期的感知能力。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。使用LiveData有以下的优点：\n- LiveData 只会将消息通知给活跃的观察者，非活跃观察者将不会收到消息通知。\n- 当非活跃观察者状态变为活跃的时候，LiveData会将自动将最新的消息发送给它。\n- 当相应的 Lifecycle 对象的状态变为 DESTROYED 时，LiveData会自动的移除此观察者，这样就不用担心Fragment和Activity的内存泄漏。\n- LiveData的数据发送和Observer的添加是没有顺序限制的。比如说LiveData在第1s发送消息，然后在第5s添加Observer，Observer依然能够立即接收到第1s发送出的数据，只要数据是当前最新的。这主要和LifecycleRegistry#addObserver的实现有关\n\n### 2.1 LiveData的使用\n\n#### 2.1.1 基本使用\n\n```java\n public class NameViewModel extends ViewModel {\n    private MutableLiveData<String> notifyCurrentName = new MutableLiveData<>();\n\n    private void post(){\n        notifyCurrentName.postValue(\"value\");    \n    }\n    \n    public MutableLiveData<String> getNotifyCurrentName(){\n        return notifyCurrentName;\n    }\n}\n\n// 在activity or fragment中\n// public void observe(LifecycleOwner owner, Observer<T> observer) \ngetViewModel().getNotifyCurrentName().observer(this, new Observer<String>() {\n    @Override\n    public void onChanged(@Nullable Stirng value) {\n        ...\n    }\n}\n\n// 如果不想让LiveData感知到生命周期，可以用observeForever(Observer<T> observer)\ngetViewModel().getNotifyCurrentName().observeForever(new Observer<String>() {\n    @Override\n    public void onChanged(@Nullable Stirng value) {\n        ...\n    }\n}\n```\n\n#### 2.1.2 Transformations#map\nTransformations是用来做LiveData转换的类。\nTransformations#map可以在消息分派给观察者之前对消息进行更改。\n\n```java\nLiveData<User> userLiveData = ...;\nLiveData<String> userName = Transformations.map(userLiveData, user -> {\n    user.name + \" \" + user.lastName\n});\n```\n\n#### 2.1.3 Transformations#switchMap\nswitchMap可以实现LiveData的转换，下面是一个demo，通过switchMap切换LiveData的数据源\n\n```java\npublic class MapTestViewModel extends ViewModel {\n    private MutableLiveData<String> dataSourceA = new MutableLiveData<>();\n    private MutableLiveData<String> dataSourceB = new MutableLiveData<>();\n\n    private MutableLiveData<Boolean> changeDataSource = new MutableLiveData<>();\n\n    private LiveData<String> notifyData = Transformations.switchMap(changeDataSource, new Function<Boolean, LiveData<String>>() {\n        @Override\n        public LiveData<String> apply(Boolean input) {\n            return input ? dataSourceA : dataSourceB;\n        }\n    });\n\n    public void start(Activity activity) {\n        changeDataSource.setValue(true);\n\n        Handler handler = new Handler(activity.getMainLooper());\n        handler.postDelayed(() -> {\n            dataSourceA.postValue(\"data from source A\");\n            dataSourceB.postValue(\"data from source B\");\n        }, 2000);\n        \n        handler.postDelayed(() -> {\n            changeDataSource(false);\n        }, 10000);\n    }\n\n    public void changeDataSource(boolean userA) {\n        changeDataSource.setValue(userA);\n    }\n\n    public LiveData<String> getNotifyData() {\n        return notifyData;\n    }\n}\n\n// activity\nviewModel.start(this);\nviewModel.getNotifyData().observe(MapTestActivity.this, new Observer<String>() {\n    @Override\n    public void onChanged(String s) {\n        Log.i(\"chenlei\", \"onChanged: \" + s);\n    }\n});\n```\n            \n上面的demo中，延时2s同时向dataSourceA和dataSourceB发送数据，并延时10s将数据源从A指向B。在observe中打印结果，最终dataSourceA和dataSourceB在间隔一段时间之后都能打印出来。\n每次调用changeDataSource.setValue(Boolean)，都会调用Function#apply返回一个LiveData，并将notifyData的 Observer 添加到新的LiveData上\n\n### 2.2 LiveData的原理\n\n#### 2.2.1 LiveData\n\n```java\npublic abstract class LiveData<T> {\n    // 存放Observer的集合\n    private SafeIterableMap<Observer<T>, ObserverWrapper> mObservers =                                                                 new SafeIterableMap<>();\n\n    static final int START_VERSION = -1;\n    private int mActiveCount = 0;\n    private int mVersion = START_VERSION;\n\n    ...\n    // 当LiveData的活跃Observer数量由0变成1的时候调用\n    protected void onActive() {}\n    // 当LiveData的活跃Observer数量由1变成0的时候调用\n    protected void onInactive() {}\n\n    ...\n\n    private abstract class ObserverWrapper {\n        final Observer<T> mObserver;\n        boolean mActive;\n        int mLastVersion = START_VERSION;\n    \n        ObserverWrapper(Observer<T> observer) {\n            mObserver = observer;\n        }\n    \n        abstract boolean shouldBeActive();\n    \n        boolean isAttachedTo(LifecycleOwner owner) {\n            return false;\n        }\n    \n        void detachObserver() {\n        }\n    \n        void activeStateChanged(boolean newActive) {\n            // 活跃状态没有改变则return， 防止重复发送消息\n            if (newActive == mActive) {\n                return;\n            }\n            mActive = newActive;\n            boolean wasInactive = LiveData.this.mActiveCount == 0;\n            LiveData.this.mActiveCount += mActive ? 1 : -1;\n            if (wasInactive && mActive) {\n                onActive();\n            }\n            if (LiveData.this.mActiveCount == 0 && !mActive) {\n                onInactive();\n            }\n            if (mActive) {\n                // 开始分发value\n                dispatchingValue(this);\n            }\n        }\n    }\n    ...\n}\n```\n\n#### 2.2.2 LiveData#observer\n\n```java\npublic abstract class LiveData<T> {    \n    ...\n    @MainThread\n    public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<T> observer) {\n        if (owner.getLifecycle().getCurrentState() == DESTROYED) {\n            return;\n        }\n        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        ...\n        if (existing != null) {\n            return;\n        }\n        // 将wrapper将入到lifecycleOwner的生命周期的监听中\n        owner.getLifecycle().addObserver(wrapper);\n    }\n    ...\n}\n```\n\nLifecycleBoundObserver继承自ObserverWrapper，并且实现了\n\n```java\nGenericLifecycleObserver接口。GenericLifecycleObserver接口继承自LifecycleObserver接口\npublic interface GenericLifecycleObserver extends LifecycleObserver {\n    void onStateChanged(LifecycleOwner source, Lifecycle.Event event);\n}\n```\n\n```java\nclass LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {\n    @NonNull final LifecycleOwner mOwner;\n\n    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<T> observer)\n    {\n        super(observer);\n        mOwner = owner;\n    }\n\n    @Override\n    boolean shouldBeActive() {\n        // 通过Lifecycle判断当前Observer是否活跃\n        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);\n    }\n\n    // GenericLifecycleObserver#onStatechanged\n    @Override\n    public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {\n        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n            // 当LifecycleOwner已经被销毁，remove这个Observer。\n            // removeObserver会调用detachObserver()和activeStateChanged(false)\n            // 这也是为什么LiveData可以自动防止UI泄漏的原因\n            removeObserver(mObserver);\n            return;\n        }\n        activeStateChanged(shouldBeActive());\n    }\n\n    @Override\n    boolean isAttachedTo(LifecycleOwner owner) {\n        return mOwner == owner;\n    }\n\n    @Override\n    void detachObserver() {\n        // 从LifecycleOwner中remove观察者\n        mOwner.getLifecycle().removeObserver(this);\n    }\n}\n```\n\nLiveData#observeForever\n\n```java\n@MainThread\npublic void observeForever(@NonNull Observer<T> observer) {\n    AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n    ...\n    if (existing != null) {\n        return;\n    }\n    // 因为observeForever没有LifecycleOwner，为了保持和普通observe方法的特性一致，在添加observe之后立刻检查是否有数据可以发送，\n    wrapper.activeStateChanged(true);\n}\n\nprivate class AlwaysActiveObserver extends ObserverWrapper {\n    AlwaysActiveObserver(Observer<T> observer) {\n        super(observer);\n    }\n\n    @Override\n    boolean shouldBeActive() {\n        return true;\n    }\n}\n```\n\n#### 2.2.3 LiveData#postValue()\nLiveData发送消息使用setValue或者postValue方法。其中setValue只能在主线程中使用，postValue发送消息时会自动切换到主线程。\n\n```java\npublic abstract class LiveData<T> {\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            ...\n            setValue((T) newValue);\n        }\n    };\n\n    ... \n    protected void postValue(T value) {\n        ...\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n    ...\n}\nLiveData#setValue\n@MainThread\nprotected void setValue(T value) {\n    assertMainThread(\"setValue\");\n    mVersion++;\n    mData = value;\n    dispatchingValue(null);\n}\n\nprivate void dispatchingValue(@Nullable ObserverWrapper initiator) {\n    if (mDispatchingValue) {\n        mDispatchInvalidated = true;\n        return;\n    }\n    mDispatchingValue = true;\n    do {\n        mDispatchInvalidated = false;\n        if (initiator != null) {\n            // 向特定的Observer发送数据\n            considerNotify(initiator);\n            initiator = null;\n        } else {\n            // 向所有Observer发送消息\n            for (Iterator<Map.Entry<Observer<T>, ObserverWrapper>> iterator =\n                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                considerNotify(iterator.next().getValue());\n                if (mDispatchInvalidated) {\n                    break;\n                }\n            }\n        }\n    } while (mDispatchInvalidated);\n    mDispatchingValue = false;\n}\n\nprivate void considerNotify(ObserverWrapper observer) {\n    if (!observer.mActive) {\n        return;\n    }\n    if (!observer.shouldBeActive()) {\n        observer.activeStateChanged(false);\n        return;\n    }\n    if (observer.mLastVersion >= mVersion) {\n        // 将要发送的是旧版本，扔掉\n        return;\n    }\n    observer.mLastVersion = mVersion;\n    observer.mObserver.onChanged((T) mData);\n}\n```\n","slug":"Android/ViewModel-LiveData和LifeCricle","published":1,"updated":"2020-04-30T06:37:06.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakr6002r8mzmppsdw204","content":"<h1 id=\"ViewModel、Lifecycles和LiveData\"><a href=\"#ViewModel、Lifecycles和LiveData\" class=\"headerlink\" title=\"ViewModel、Lifecycles和LiveData\"></a>ViewModel、Lifecycles和LiveData</h1><a id=\"more\"></a><h2 id=\"1-ViewModel\"><a href=\"#1-ViewModel\" class=\"headerlink\" title=\"1. ViewModel:\"></a>1. ViewModel:</h2><p>ViewModel是Google官方提供的组件，是用来处理和存放和UI相关的数据的，可以把UI和数据进行分离。但就这一点来说的话，其实没有必要一定使用Google提供的ViewModel组件，我们使用自定义的ViewModel类同样可以达到这样的效果。</p>\n<p>还有一个很重要的特性，我们都知道，在配置改变时，Activity会出现销毁重建，比如说横竖屏切换的时候。ViewModel的生命周期和Activity是不一样的，它不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，可以将和UI相关的数据存放在ViewModel中，这样，即使Activity销毁重建，页面上显示的数据也不会丢失。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在ViewModel销毁的时候做回收工作，主要是为了防止ViewModel的泄漏</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCleared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ViewModel的创建和存储过程\"><a href=\"#ViewModel的创建和存储过程\" class=\"headerlink\" title=\"ViewModel的创建和存储过程\"></a>ViewModel的创建和存储过程</h3><p>主要是要搞清楚上面说的：Activity销毁重建的时候，ViewModel是如何保持不重建的。<br>注意，这里只是在Activity因为配置改变而销毁重建的情况下。还有一种情况是，App由前台进入后台，因为内存紧张，Activity被系统销毁。这种情况下，ViewModel是无法保存数据的。</p>\n<p>以下全都以Activity举例，Fragment也是一样的<br>在Activity中获取ViewModel：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">viewModel = ViewModelProviders.of(<span class=\"keyword\">this</span>).get(XxxViewModel.class);</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelProviders#of<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Nullable Factory factory)</span> </span>&#123;</span><br><span class=\"line\">    Application application = checkApplication(activity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (factory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用默认的工厂类</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果想要在ViewModel的构造方法里传参，需要自定义factory类</span></span><br><span class=\"line\">        factory = ViewModelProvider.AndroidViewModelFactory</span><br><span class=\"line\">                                    .getInstance(application);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>viewModelProvider#get<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从ViewModelStore中获取ViewModel，没有则创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    viewModel = mFactory.create(modelClass);</span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewModelStore</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ViewModel的集合，key是由ViewModel类名构成的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelStore中存储了一个Activity/Fragment的所有ViewModel。那现在问题就转变成了探究ViewModelStore的获取和存储的过程</p>\n<p>ViewModelStores#of<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelStore <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里先判断FragmentActivity是否实现了ViewModelStoreOwner接口。不同的依赖包，实现有可能是不一样的。高版本的support-v4和androidx中的Fragment和FragmentActivity都实现了这个接口。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ViewModelStoreOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"function\">ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现了ViewModelStoreOwner接口\"><a href=\"#实现了ViewModelStoreOwner接口\" class=\"headerlink\" title=\"实现了ViewModelStoreOwner接口\"></a>实现了ViewModelStoreOwner接口</h4><p>FragmentActivity<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">SupportActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewModelStoreOwner</span>, ...</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewModelStore mViewModelStore;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现了ViewModelStoreOwner接口的FragmentActivity会直接持有ViewModelStore的引用</p>\n<p>主要关注三个方法：<br>getViewModelStore()<br>onCreate()<br>onRetainNonConfigurationInstance()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getApplication() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances) <span class=\"keyword\">this</span>.getLastNonConfigurationInstance();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mViewModelStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)<span class=\"keyword\">this</span>.getLastNonConfigurationInstance();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span> &amp;&amp; nc.viewModelStore != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在页面销毁时，保存ViewModelStore</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">onRetainNonConfigurationInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Object custom = onRetainCustomNonConfigurationInstance();</span><br><span class=\"line\">     ViewModelStore viewModelStore = mViewModelStore;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (viewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 如果NonConfigurationInstance保存了viewModelStore，把它取出来</span></span><br><span class=\"line\">        NonConfigurationInstances nc = getLastNonConfigurationInstance();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            viewModelStore = nc.viewModelStore;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (viewModelStore == <span class=\"keyword\">null</span> &amp;&amp; custom == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">      NonConfigurationInstances nci = <span class=\"keyword\">new</span> NonConfigurationInstances();</span><br><span class=\"line\">      nci.custom = custom; </span><br><span class=\"line\">      <span class=\"comment\">//把viewModelStore放到NonConfigurationInstances中并返回</span></span><br><span class=\"line\">      nci.viewModelStore = viewModelStore;</span><br><span class=\"line\">      <span class=\"comment\">//这样当页面被重建而销毁时ViewModelStore就被保存起来了。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> nci;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ViewModelStore在onCreate里会从NonConfigurationInstances里尝试取出，然后在onRetainNonConfigurationInstanc方法中保存到NonConfigurationInstances。<br>onRetainNonConfigurationInstance何时被调用，数据又是怎样保存的呢？了解过Activity启动流程的都知道ActivityThread，它控制着Activity的生命周期，当ActivityThread执行performDestroyActivity这个方法时，会调用Activity#retainNonConfigurationInstances获取到保存的数据并保存到ActivityClientRecord中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ActivityClientRecord <span class=\"title\">performDestroyActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finishing, <span class=\"keyword\">int</span> configChanges, <span class=\"keyword\">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   ActivityClientRecord r = mActivities.get(token);</span><br><span class=\"line\">   <span class=\"comment\">// 由于状态改变的destroy，这里会为true</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (getNonConfigInstance) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//保存retainNonConfigurationInstances中的数据到ActivityClientRecord中</span></span><br><span class=\"line\">       r.lastNonConfigurationInstances = r.activity</span><br><span class=\"line\">                                          .retainNonConfigurationInstances();</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当页面重建完成,ActivityThread执行了performLaunchActivity方法时，会调用Activity的attach方法,便会把刚刚存储的数据，传递进去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    activity.attach(......, r.lastNonConfigurationInstances,.....);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：Activity对应的ViewModel保存在ViewModelStore里，FragmentActivity持有ViewModelStore的引用，Activity因配置原因销毁-重建时，ViewModelStore被NonConfigurationInstances保存，重建时从保存处恢复。</p>\n<h4 id=\"未实现ViewModelStoreOwner接口\"><a href=\"#未实现ViewModelStoreOwner接口\" class=\"headerlink\" title=\"未实现ViewModelStoreOwner接口\"></a>未实现ViewModelStoreOwner接口</h4><p>低版本未实现ViewModelStoreOwner接口，采取的方法是在Activity中注入一个不可见的HolderFragment</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelStore <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HolderFragment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewModelStoreOwner</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HolderFragmentManager sHolderFragmentManager = <span class=\"keyword\">new</span> HolderFragmentManager();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewModelStore mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HolderFragment</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        setRetainInstance(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HolderFragment <span class=\"title\">holderFragmentFor</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在activity中插入HolderFragment</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sHolderFragmentManager.holderFragmentFor(activity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HolderFragment持有mViewModelStore的引用。在HolderFragment的构造方法中，调用了<code>setRetainInstance(true)</code>。<br>控制一个fragment实例是否在activity因为配置改变而销毁重建的时候被保留。如果设置为true, fragment在activity销毁重建的时候将会被保留。同时，fragment的生命周期将会发生改变，当Activity销毁重建时，fragment生命周期中的onCreate和onDestroy将不会被执行。</p>\n<p>总结：HolderFragment实现了ViewModelStoreOwner接口，持有mViewModelStore的引用。由于Fragment和activity的生命周期是绑定的，Fragment内部可以感知到activity的生命周期。同时，通过setRetainInstance(true)，当activity被销毁重建的时候，HolderFragment并不会被销毁，导致mViewModelStore也不会被销毁<br>ViewModel的销毁：</p>\n<p>FragmentActivity#onDestroy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore != <span class=\"keyword\">null</span> &amp;&amp; !<span class=\"keyword\">this</span>.isChangingConfigurations()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当activity由于非config改变而销毁时清空mViewModelStore</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mViewModelStore.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mFragments.dispatchDestroy();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HolderFragment#onDestroy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    mViewModelStore.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelStore#clear()<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class=\"line\">        vm.onCleared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mMap.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ViewModel实现更进一步的数据持久化\"><a href=\"#ViewModel实现更进一步的数据持久化\" class=\"headerlink\" title=\"ViewModel实现更进一步的数据持久化\"></a>ViewModel实现更进一步的数据持久化</h3><p>上面的是 activity 在因为配置改变，销毁重建的情况，在这种情况下，ViewModel 可以自动实现数据保留和现场恢复。<br>还有一种情况是，App进入后台，然后因为内存紧张，activity 被系统销毁，然后用户再次打开，activity重建。这种情况下，ViewModel默认是不能实现现场恢复的，需要借助 SavedStateHandle。<br>可以简单的把 SavedStateHandle 理解为 onSaveInstanceState()的逻辑从 activity 转移到了ViewModel 中。</p>\n<p>要想使用 SavedStateHandle 需要额外导入包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &apos;androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-alpha01&apos;</span><br></pre></td></tr></table></figure></p>\n<p>然后在获取ViewModel时使用 SavedStateViewModelFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">viewModel = ViewModelProviders.of(<span class=\"keyword\">this</span>, </span><br><span class=\"line\">                    <span class=\"keyword\">new</span> SavedStateViewModelFactory(getApplication(), <span class=\"keyword\">this</span>))</span><br><span class=\"line\">                    .get(SaveStateTestViewModel.class);</span><br></pre></td></tr></table></figure></p>\n<p>然后在ViewModel的构造方法里传入SavedStateHandle实例，然后就可以通过SavedStateHandle保存和读取数据了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveStateTestViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SavedStateHandle savedStateHandle;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MutableLiveData&lt;String&gt; notifyLiveData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SaveStateTestViewModel</span><span class=\"params\">(SavedStateHandle handle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.savedStateHandle = handle;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyLiveData = savedStateHandle.getLiveData(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span>&#123;</span><br><span class=\"line\">        savedStateHandle.set(<span class=\"string\">\"key2\"</span>, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyLiveData.setValue(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"title\">getNotifyLiveData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyLiveData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和 onSaveInstanceState() 的保存和恢复方式一样，不能保存复杂的数据，只能保存可以存入Bundle的那些类型。 也可以SavedStateHandle中使用LiveData的方式进行保存，这样的话稍微有那么一点的好处是你不需要特意的save和get数据，直接把在初始化的时候替换成SavedStateHandle#getLiveData就可以了</p>\n<h2 id=\"2-Lifecycles\"><a href=\"#2-Lifecycles\" class=\"headerlink\" title=\"2. Lifecycles\"></a>2. Lifecycles</h2><p>Lifecycles组件是为了方便感知Activity和Fragment的生命周期而出现的，它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。<br>Lifecycle包含在support library 26.1.0及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。support library在26.1.0之前，需要我们引入另外的包。</p>\n<p>lifecycle 组件包括 Lifecycle, LifecycleOwner, LifecycleObserver 三个主要类：</p>\n<ul>\n<li>Lifecycle 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。</li>\n<li>LifecycleOwner 仅有一个 getLifecycle() 方法，用于返回当前对象的 Lifecycle。</li>\n<li>LifecycleObserver，代表观察者</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LifecyclerOwner和LifecycleObserver</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口，是被观察者。<br>LifecycleOwner#getLifecycle()返回Lifecycle实例. 这是一种解耦实现, LifecycleOwner不包含任何有关生命周期管理的逻辑, 实际的逻辑都在Lifecycle实例中, 我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏。<br>并不是所有的google官方的Activity和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有FragmentActivity，AppCompatActivity和v4包下的Fragment。<br>LifecycleObserver接口代表生命周期的观察者，它的实现为空。实现LifecycleObserver的类要想感知到生命周期的变化需要借助额外的注解。或者，也可以使用一些继承了LifecycleObserver的子接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">voidactivityResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lifecycle中的state和event\"><a href=\"#Lifecycle中的state和event\" class=\"headerlink\" title=\"Lifecycle中的state和event\"></a>Lifecycle中的state和event</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</span><br><span class=\"line\">    DESTROYED,</span><br><span class=\"line\">    INITIALIZED,</span><br><span class=\"line\">    CREATED,</span><br><span class=\"line\">    STARTED,</span><br><span class=\"line\">    RESUMED;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAtLeast</span><span class=\"params\">(@NonNull State state)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compareTo(state) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Event &#123;</span><br><span class=\"line\">    ON_CREATE,</span><br><span class=\"line\">    ON_START,</span><br><span class=\"line\">    ON_RESUME,</span><br><span class=\"line\">    ON_PAUSE,</span><br><span class=\"line\">    ON_STOP,</span><br><span class=\"line\">    ON_DESTROY,</span><br><span class=\"line\">    ON_ANY <span class=\"comment\">// ON_ANY代表任意时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lifecycle的获取生命周期的变化\"><a href=\"#Lifecycle的获取生命周期的变化\" class=\"headerlink\" title=\"Lifecycle的获取生命周期的变化\"></a>Lifecycle的获取生命周期的变化</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SupportActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleOwner</span>, <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LifecycleRegistry mLifecycleRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mLifecycleRegistry.markState(State.CREATED);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onSaveInstanceState(outState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mLifecycleRegistry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleRegistry继承了Lifecycle。SupportActivity是FragmentActivity的父类。在SupportActivity中找不到state和event分发相关的代码，这些相关内容是在ReportFragment中实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReportFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectIfNeededIn</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            manager.beginTransaction().add(<span class=\"keyword\">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class=\"line\"></span><br><span class=\"line\">            manager.executePendingTransactions();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        dispatchStart(mProcessListener);</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_START);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        Activity activity = getActivity();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleOwner) &#123;</span><br><span class=\"line\">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lifecycle <span class=\"keyword\">instanceof</span> LifecycleRegistry) &#123;</span><br><span class=\"line\">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LifecycleRegistry-addObserver\"><a href=\"#LifecycleRegistry-addObserver\" class=\"headerlink\" title=\"LifecycleRegistry#addObserver\"></a>LifecycleRegistry#addObserver</h3><p>LifecycleRegistry继承了Lifecycle，是Activity和Fragment生命周期的真正管理类。 这个类里面的很多逻辑有点绕，我不太能理清楚。主要看一下addObserver这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleRegistry</span> <span class=\"keyword\">extends</span> <span class=\"title\">Lifecycle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = <span class=\"keyword\">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的state</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> State mState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// observer的state初始化为DESTROYED或者INITIALIZED</span></span><br><span class=\"line\">        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">        ObserverWithState statefulObserver = <span class=\"keyword\">new</span> ObserverWithState(observer, initialState);</span><br><span class=\"line\">        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// it is null we should be destroyed. Fallback quickly</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isReentrance = mAddingObserverCounter != <span class=\"number\">0</span> || mHandlingEvent;</span><br><span class=\"line\">        <span class=\"comment\">// 得到一个目标state</span></span><br><span class=\"line\">        State targetState = calculateTargetState(observer);</span><br><span class=\"line\">        mAddingObserverCounter++;</span><br><span class=\"line\">        <span class=\"comment\">// 当observer被add进来的时候，会进入循环，分发事件，直到observer的state==targetState</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class=\"line\">            pushParentState(statefulObserver.mState);</span><br><span class=\"line\">            <span class=\"comment\">// 这里的upEvent(state)会导致statefulObserver.mState在分发的过程中不断更新</span></span><br><span class=\"line\">            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class=\"line\">            popParentState();</span><br><span class=\"line\">            <span class=\"comment\">// mState / subling may have been changed recalculate</span></span><br><span class=\"line\">            targetState = calculateTargetState(observer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isReentrance) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// we do sync only on the top level.</span></span><br><span class=\"line\">            sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAddingObserverCounter--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> State <span class=\"title\">calculateTargetState</span><span class=\"params\">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的previous指前一个加入进来的Observer</span></span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);</span><br><span class=\"line\">    </span><br><span class=\"line\">        State siblingState = previous != <span class=\"keyword\">null</span> ? previous.getValue().mState : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这个mParentStates不知道是啥。。。</span></span><br><span class=\"line\">        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class=\"number\">1</span>)</span><br><span class=\"line\">                : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的min(x, y)是 返回在枚举中order最小的state</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(min(mState, siblingState), parentState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在addObserver中，ObserverWithState将state和observer包装一下，ObserverWithState内初始的state是DESTROYED或者INITIALIZED。之后会计算一个targetState，在while循环中会不断的分发和更新event。</p>\n<p>具体效果看下面的demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    handler.postDelayed(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            TestActivity.<span class=\"keyword\">this</span>.getLifecycle().addObserver(<span class=\"keyword\">new</span> GenericLifecycleObserver() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">                    Log.i(<span class=\"string\">\"chenlei\"</span>, <span class=\"string\">\"onStateChanged: \"</span> + event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的GenericLifecycleObserver继承了LifecycleObserver的接口。demo中在create方法里延时5s添加一个LifecycleObserver并打印event。最后打印输出如下：</p>\n<p>可以看到从ON_CREATE到ON_RESUME在同一时刻都打印出来了</p>\n<h3 id=\"ProcessLifecycleOwner\"><a href=\"#ProcessLifecycleOwner\" class=\"headerlink\" title=\"ProcessLifecycleOwner\"></a>ProcessLifecycleOwner</h3><p>ProcessLifecycleOwner实现了LifecycleOwner接口，可以监听当前应用前后台切换，并对此进行响应。<br>这个类提供整个应用进程的生命周期。<br>你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，Lifecycle.Event.ON_CREATE 事件只会分发一次，而 Lifecycle.Event.ON_DESTROY 永远不被分发。其他事件的分发遵守以下规则：<br>ProcessLifecycleOwner 会在第一个 Activity 经历 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 事件 延迟一段时间 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。<br>这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。<br>使用的时候，在Application中添加LifecycleObserver就可以了(实际上，在应用进程中的任意位置都可以）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ApplicationObserver(val analytics: Analytics) : LifecycleObserver &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">onBackground</span><span class=\"params\">()</span> </span>&#123;    &#125;   </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">onForeground</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">        ProcessLifecycleOwner.get().getLifecycle().addObserver(<span class=\"keyword\">new</span> ApplicationObserver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理：</p>\n<p>ProcessLifecycleOwnerInitializer<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProcessLifecycleOwnerInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        LifecycleDispatcher.init(getContext());</span><br><span class=\"line\">        ProcessLifecycleOwner.init(getContext());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类是ProcessLifecycleOwner初始化的地方，它继承了一个ContentProvider ，这个ContentProvider声明在了Lifecycle包的AndroidManifest.xml里。</p>\n<p>这个AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。<br>这里利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application 的 onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建。</p>\n<p>LifecycleDispatcher#init<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleDispatcher</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicBoolean sInitialized = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInitialized.getAndSet(<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ((Application) context.getApplicationContext())</span><br><span class=\"line\">                .registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> DispatcherActivityCallback());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherActivityCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">EmptyActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            ReportFragment.injectIfNeededIn(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Application中注册一个ActivityLifecycleCallbacks，在ActivityLifecycleCallbacks中有Activity所有生命周期的回调，这样就能监听到每一个Activity的创建和销毁。在onActivityCreated回调中往Activity注入一个了ReportFragment，我没看出来这里的ReportFragment的作用是什么。。</p>\n<p>ProcessLifecycleOwner</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProcessLifecycleOwner</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LifecycleRegistry mRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessLifecycleOwner sInstance = <span class=\"keyword\">new</span> ProcessLifecycleOwner();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        sInstance.attach(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ActivityInitializationListener mInitializationListener =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ActivityInitializationListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                activityStarted();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                activityResumed();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler();</span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">        Application app = (Application) context.getApplicationContext();</span><br><span class=\"line\">        app.registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//在ReportFragment的生命周期中会有dispatchXxxx(mProcessListener)</span></span><br><span class=\"line\">                ReportFragment.get(activity)</span><br><span class=\"line\">                                .setProcessListener(mInitializationListener);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">                activityPaused();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">                activityStopped();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityResumed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mResumedCounter++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPauseSent) &#123;</span><br><span class=\"line\">                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class=\"line\">                mPauseSent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityPaused</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mResumedCounter--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在mDelayedPauseRunnable中会调用这个方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchPauseIfNeeded</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mPauseSent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-LiveData\"><a href=\"#2-LiveData\" class=\"headerlink\" title=\"2. LiveData\"></a>2. LiveData</h2><p>ViewModel和Lifecycles分别代表数据和UI两端，这两个组件是相对比较独立的，并没有太多直接的关系。为了防止内存泄漏，ViewModel不能直接持有activity和fragment的引用。为了让更好的结合ViewModel和Lifecycles，就需要LiveData。<br>LiveData是一种观察者模式, 在 Value发生变化时通知之前注册的所有观察者。同时，借助于Lifecycles，LiveData具有生命周期的感知能力。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。使用LiveData有以下的优点：</p>\n<ul>\n<li>LiveData 只会将消息通知给活跃的观察者，非活跃观察者将不会收到消息通知。</li>\n<li>当非活跃观察者状态变为活跃的时候，LiveData会将自动将最新的消息发送给它。</li>\n<li>当相应的 Lifecycle 对象的状态变为 DESTROYED 时，LiveData会自动的移除此观察者，这样就不用担心Fragment和Activity的内存泄漏。</li>\n<li>LiveData的数据发送和Observer的添加是没有顺序限制的。比如说LiveData在第1s发送消息，然后在第5s添加Observer，Observer依然能够立即接收到第1s发送出的数据，只要数据是当前最新的。这主要和LifecycleRegistry#addObserver的实现有关</li>\n</ul>\n<h3 id=\"2-1-LiveData的使用\"><a href=\"#2-1-LiveData的使用\" class=\"headerlink\" title=\"2.1 LiveData的使用\"></a>2.1 LiveData的使用</h3><h4 id=\"2-1-1-基本使用\"><a href=\"#2-1-1-基本使用\" class=\"headerlink\" title=\"2.1.1 基本使用\"></a>2.1.1 基本使用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; notifyCurrentName = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        notifyCurrentName.postValue(<span class=\"string\">\"value\"</span>);    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"title\">getNotifyCurrentName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyCurrentName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在activity or fragment中</span></span><br><span class=\"line\"><span class=\"comment\">// public void observe(LifecycleOwner owner, Observer&lt;T&gt; observer) </span></span><br><span class=\"line\">getViewModel().getNotifyCurrentName().observer(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Stirng value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果不想让LiveData感知到生命周期，可以用observeForever(Observer&lt;T&gt; observer)</span></span><br><span class=\"line\">getViewModel().getNotifyCurrentName().observeForever(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Stirng value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-1-2-Transformations-map\"><a href=\"#2-1-2-Transformations-map\" class=\"headerlink\" title=\"2.1.2 Transformations#map\"></a>2.1.2 Transformations#map</h4><p>Transformations是用来做LiveData转换的类。<br>Transformations#map可以在消息分派给观察者之前对消息进行更改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;User&gt; userLiveData = ...;</span><br><span class=\"line\">LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class=\"line\">    user.name + <span class=\"string\">\" \"</span> + user.lastName</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-1-3-Transformations-switchMap\"><a href=\"#2-1-3-Transformations-switchMap\" class=\"headerlink\" title=\"2.1.3 Transformations#switchMap\"></a>2.1.3 Transformations#switchMap</h4><p>switchMap可以实现LiveData的转换，下面是一个demo，通过switchMap切换LiveData的数据源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapTestViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; dataSourceA = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; dataSourceB = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;Boolean&gt; changeDataSource = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LiveData&lt;String&gt; notifyData = Transformations.switchMap(changeDataSource, <span class=\"keyword\">new</span> Function&lt;Boolean, LiveData&lt;String&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;String&gt; <span class=\"title\">apply</span><span class=\"params\">(Boolean input)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input ? dataSourceA : dataSourceB;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        changeDataSource.setValue(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Handler handler = <span class=\"keyword\">new</span> Handler(activity.getMainLooper());</span><br><span class=\"line\">        handler.postDelayed(() -&gt; &#123;</span><br><span class=\"line\">            dataSourceA.postValue(<span class=\"string\">\"data from source A\"</span>);</span><br><span class=\"line\">            dataSourceB.postValue(<span class=\"string\">\"data from source B\"</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        handler.postDelayed(() -&gt; &#123;</span><br><span class=\"line\">            changeDataSource(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">10000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">(<span class=\"keyword\">boolean</span> userA)</span> </span>&#123;</span><br><span class=\"line\">        changeDataSource.setValue(userA);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;String&gt; <span class=\"title\">getNotifyData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// activity</span></span><br><span class=\"line\">viewModel.start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">viewModel.getNotifyData().observe(MapTestActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"chenlei\"</span>, <span class=\"string\">\"onChanged: \"</span> + s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的demo中，延时2s同时向dataSourceA和dataSourceB发送数据，并延时10s将数据源从A指向B。在observe中打印结果，最终dataSourceA和dataSourceB在间隔一段时间之后都能打印出来。<br>每次调用changeDataSource.setValue(Boolean)，都会调用Function#apply返回一个LiveData，并将notifyData的 Observer 添加到新的LiveData上</p>\n<h3 id=\"2-2-LiveData的原理\"><a href=\"#2-2-LiveData的原理\" class=\"headerlink\" title=\"2.2 LiveData的原理\"></a>2.2 LiveData的原理</h3><h4 id=\"2-2-1-LiveData\"><a href=\"#2-2-1-LiveData\" class=\"headerlink\" title=\"2.2.1 LiveData\"></a>2.2.1 LiveData</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存放Observer的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SafeIterableMap&lt;Observer&lt;T&gt;, ObserverWrapper&gt; mObservers =                                                                 <span class=\"keyword\">new</span> SafeIterableMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> START_VERSION = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mActiveCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mVersion = START_VERSION;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 当LiveData的活跃Observer数量由0变成1的时候调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当LiveData的活跃Observer数量由1变成0的时候调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onInactive</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;T&gt; mObserver;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> mActive;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mLastVersion = START_VERSION;</span><br><span class=\"line\">    </span><br><span class=\"line\">        ObserverWrapper(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">            mObserver = observer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activeStateChanged</span><span class=\"params\">(<span class=\"keyword\">boolean</span> newActive)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 活跃状态没有改变则return， 防止重复发送消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newActive == mActive) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mActive = newActive;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> wasInactive = LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span>;</span><br><span class=\"line\">            LiveData.<span class=\"keyword\">this</span>.mActiveCount += mActive ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class=\"line\">                onActive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span> &amp;&amp; !mActive) &#123;</span><br><span class=\"line\">                onInactive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mActive) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 开始分发value</span></span><br><span class=\"line\">                dispatchingValue(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-2-LiveData-observer\"><a href=\"#2-2-2-LiveData-observer\" class=\"headerlink\" title=\"2.2.2 LiveData#observer\"></a>2.2.2 LiveData#observer</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"meta\">@MainThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observe</span><span class=\"params\">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LifecycleBoundObserver wrapper = <span class=\"keyword\">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class=\"line\">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将wrapper将入到lifecycleOwner的生命周期的监听中</span></span><br><span class=\"line\">        owner.getLifecycle().addObserver(wrapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleBoundObserver继承自ObserverWrapper，并且实现了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericLifecycleObserver接口。GenericLifecycleObserver接口继承自LifecycleObserver接口</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GenericLifecycleObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">GenericLifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> LifecycleOwner mOwner;</span><br><span class=\"line\"></span><br><span class=\"line\">    LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">        mOwner = owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过Lifecycle判断当前Observer是否活跃</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// GenericLifecycleObserver#onStatechanged</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当LifecycleOwner已经被销毁，remove这个Observer。</span></span><br><span class=\"line\">            <span class=\"comment\">// removeObserver会调用detachObserver()和activeStateChanged(false)</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是为什么LiveData可以自动防止UI泄漏的原因</span></span><br><span class=\"line\">            removeObserver(mObserver);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        activeStateChanged(shouldBeActive());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner == owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从LifecycleOwner中remove观察者</span></span><br><span class=\"line\">        mOwner.getLifecycle().removeObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LiveData#observeForever</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(@NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 因为observeForever没有LifecycleOwner，为了保持和普通observe方法的特性一致，在添加observe之后立刻检查是否有数据可以发送，</span></span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlwaysActiveObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;</span><br><span class=\"line\">    AlwaysActiveObserver(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-3-LiveData-postValue\"><a href=\"#2-2-3-LiveData-postValue\" class=\"headerlink\" title=\"2.2.3 LiveData#postValue()\"></a>2.2.3 LiveData#postValue()</h4><p>LiveData发送消息使用setValue或者postValue方法。其中setValue只能在主线程中使用，postValue发送消息时会自动切换到主线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            setValue((T) newValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LiveData#setValue</span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>);</span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDispatchingValue) &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initiator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向特定的Observer发送数据</span></span><br><span class=\"line\">            considerNotify(initiator);</span><br><span class=\"line\">            initiator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向所有Observer发送消息</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将要发送的是旧版本，扔掉</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"ViewModel、Lifecycles和LiveData\"><a href=\"#ViewModel、Lifecycles和LiveData\" class=\"headerlink\" title=\"ViewModel、Lifecycles和LiveData\"></a>ViewModel、Lifecycles和LiveData</h1>","more":"<h2 id=\"1-ViewModel\"><a href=\"#1-ViewModel\" class=\"headerlink\" title=\"1. ViewModel:\"></a>1. ViewModel:</h2><p>ViewModel是Google官方提供的组件，是用来处理和存放和UI相关的数据的，可以把UI和数据进行分离。但就这一点来说的话，其实没有必要一定使用Google提供的ViewModel组件，我们使用自定义的ViewModel类同样可以达到这样的效果。</p>\n<p>还有一个很重要的特性，我们都知道，在配置改变时，Activity会出现销毁重建，比如说横竖屏切换的时候。ViewModel的生命周期和Activity是不一样的，它不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，可以将和UI相关的数据存放在ViewModel中，这样，即使Activity销毁重建，页面上显示的数据也不会丢失。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在ViewModel销毁的时候做回收工作，主要是为了防止ViewModel的泄漏</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCleared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ViewModel的创建和存储过程\"><a href=\"#ViewModel的创建和存储过程\" class=\"headerlink\" title=\"ViewModel的创建和存储过程\"></a>ViewModel的创建和存储过程</h3><p>主要是要搞清楚上面说的：Activity销毁重建的时候，ViewModel是如何保持不重建的。<br>注意，这里只是在Activity因为配置改变而销毁重建的情况下。还有一种情况是，App由前台进入后台，因为内存紧张，Activity被系统销毁。这种情况下，ViewModel是无法保存数据的。</p>\n<p>以下全都以Activity举例，Fragment也是一样的<br>在Activity中获取ViewModel：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">viewModel = ViewModelProviders.of(<span class=\"keyword\">this</span>).get(XxxViewModel.class);</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelProviders#of<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Nullable Factory factory)</span> </span>&#123;</span><br><span class=\"line\">    Application application = checkApplication(activity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (factory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用默认的工厂类</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果想要在ViewModel的构造方法里传参，需要自定义factory类</span></span><br><span class=\"line\">        factory = ViewModelProvider.AndroidViewModelFactory</span><br><span class=\"line\">                                    .getInstance(application);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>viewModelProvider#get<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从ViewModelStore中获取ViewModel，没有则创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    viewModel = mFactory.create(modelClass);</span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewModelStore</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ViewModel的集合，key是由ViewModel类名构成的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelStore中存储了一个Activity/Fragment的所有ViewModel。那现在问题就转变成了探究ViewModelStore的获取和存储的过程</p>\n<p>ViewModelStores#of<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelStore <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里先判断FragmentActivity是否实现了ViewModelStoreOwner接口。不同的依赖包，实现有可能是不一样的。高版本的support-v4和androidx中的Fragment和FragmentActivity都实现了这个接口。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ViewModelStoreOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"function\">ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现了ViewModelStoreOwner接口\"><a href=\"#实现了ViewModelStoreOwner接口\" class=\"headerlink\" title=\"实现了ViewModelStoreOwner接口\"></a>实现了ViewModelStoreOwner接口</h4><p>FragmentActivity<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">SupportActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewModelStoreOwner</span>, ...</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewModelStore mViewModelStore;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现了ViewModelStoreOwner接口的FragmentActivity会直接持有ViewModelStore的引用</p>\n<p>主要关注三个方法：<br>getViewModelStore()<br>onCreate()<br>onRetainNonConfigurationInstance()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getApplication() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances) <span class=\"keyword\">this</span>.getLastNonConfigurationInstance();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mViewModelStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)<span class=\"keyword\">this</span>.getLastNonConfigurationInstance();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span> &amp;&amp; nc.viewModelStore != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在页面销毁时，保存ViewModelStore</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">onRetainNonConfigurationInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Object custom = onRetainCustomNonConfigurationInstance();</span><br><span class=\"line\">     ViewModelStore viewModelStore = mViewModelStore;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (viewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 如果NonConfigurationInstance保存了viewModelStore，把它取出来</span></span><br><span class=\"line\">        NonConfigurationInstances nc = getLastNonConfigurationInstance();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            viewModelStore = nc.viewModelStore;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (viewModelStore == <span class=\"keyword\">null</span> &amp;&amp; custom == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">      NonConfigurationInstances nci = <span class=\"keyword\">new</span> NonConfigurationInstances();</span><br><span class=\"line\">      nci.custom = custom; </span><br><span class=\"line\">      <span class=\"comment\">//把viewModelStore放到NonConfigurationInstances中并返回</span></span><br><span class=\"line\">      nci.viewModelStore = viewModelStore;</span><br><span class=\"line\">      <span class=\"comment\">//这样当页面被重建而销毁时ViewModelStore就被保存起来了。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> nci;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ViewModelStore在onCreate里会从NonConfigurationInstances里尝试取出，然后在onRetainNonConfigurationInstanc方法中保存到NonConfigurationInstances。<br>onRetainNonConfigurationInstance何时被调用，数据又是怎样保存的呢？了解过Activity启动流程的都知道ActivityThread，它控制着Activity的生命周期，当ActivityThread执行performDestroyActivity这个方法时，会调用Activity#retainNonConfigurationInstances获取到保存的数据并保存到ActivityClientRecord中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ActivityClientRecord <span class=\"title\">performDestroyActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finishing, <span class=\"keyword\">int</span> configChanges, <span class=\"keyword\">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   ActivityClientRecord r = mActivities.get(token);</span><br><span class=\"line\">   <span class=\"comment\">// 由于状态改变的destroy，这里会为true</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (getNonConfigInstance) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//保存retainNonConfigurationInstances中的数据到ActivityClientRecord中</span></span><br><span class=\"line\">       r.lastNonConfigurationInstances = r.activity</span><br><span class=\"line\">                                          .retainNonConfigurationInstances();</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当页面重建完成,ActivityThread执行了performLaunchActivity方法时，会调用Activity的attach方法,便会把刚刚存储的数据，传递进去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    activity.attach(......, r.lastNonConfigurationInstances,.....);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：Activity对应的ViewModel保存在ViewModelStore里，FragmentActivity持有ViewModelStore的引用，Activity因配置原因销毁-重建时，ViewModelStore被NonConfigurationInstances保存，重建时从保存处恢复。</p>\n<h4 id=\"未实现ViewModelStoreOwner接口\"><a href=\"#未实现ViewModelStoreOwner接口\" class=\"headerlink\" title=\"未实现ViewModelStoreOwner接口\"></a>未实现ViewModelStoreOwner接口</h4><p>低版本未实现ViewModelStoreOwner接口，采取的方法是在Activity中注入一个不可见的HolderFragment</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelStore <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HolderFragment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewModelStoreOwner</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HolderFragmentManager sHolderFragmentManager = <span class=\"keyword\">new</span> HolderFragmentManager();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewModelStore mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HolderFragment</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        setRetainInstance(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HolderFragment <span class=\"title\">holderFragmentFor</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在activity中插入HolderFragment</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sHolderFragmentManager.holderFragmentFor(activity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HolderFragment持有mViewModelStore的引用。在HolderFragment的构造方法中，调用了<code>setRetainInstance(true)</code>。<br>控制一个fragment实例是否在activity因为配置改变而销毁重建的时候被保留。如果设置为true, fragment在activity销毁重建的时候将会被保留。同时，fragment的生命周期将会发生改变，当Activity销毁重建时，fragment生命周期中的onCreate和onDestroy将不会被执行。</p>\n<p>总结：HolderFragment实现了ViewModelStoreOwner接口，持有mViewModelStore的引用。由于Fragment和activity的生命周期是绑定的，Fragment内部可以感知到activity的生命周期。同时，通过setRetainInstance(true)，当activity被销毁重建的时候，HolderFragment并不会被销毁，导致mViewModelStore也不会被销毁<br>ViewModel的销毁：</p>\n<p>FragmentActivity#onDestroy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore != <span class=\"keyword\">null</span> &amp;&amp; !<span class=\"keyword\">this</span>.isChangingConfigurations()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当activity由于非config改变而销毁时清空mViewModelStore</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mViewModelStore.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mFragments.dispatchDestroy();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HolderFragment#onDestroy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    mViewModelStore.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelStore#clear()<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class=\"line\">        vm.onCleared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mMap.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ViewModel实现更进一步的数据持久化\"><a href=\"#ViewModel实现更进一步的数据持久化\" class=\"headerlink\" title=\"ViewModel实现更进一步的数据持久化\"></a>ViewModel实现更进一步的数据持久化</h3><p>上面的是 activity 在因为配置改变，销毁重建的情况，在这种情况下，ViewModel 可以自动实现数据保留和现场恢复。<br>还有一种情况是，App进入后台，然后因为内存紧张，activity 被系统销毁，然后用户再次打开，activity重建。这种情况下，ViewModel默认是不能实现现场恢复的，需要借助 SavedStateHandle。<br>可以简单的把 SavedStateHandle 理解为 onSaveInstanceState()的逻辑从 activity 转移到了ViewModel 中。</p>\n<p>要想使用 SavedStateHandle 需要额外导入包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &apos;androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-alpha01&apos;</span><br></pre></td></tr></table></figure></p>\n<p>然后在获取ViewModel时使用 SavedStateViewModelFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">viewModel = ViewModelProviders.of(<span class=\"keyword\">this</span>, </span><br><span class=\"line\">                    <span class=\"keyword\">new</span> SavedStateViewModelFactory(getApplication(), <span class=\"keyword\">this</span>))</span><br><span class=\"line\">                    .get(SaveStateTestViewModel.class);</span><br></pre></td></tr></table></figure></p>\n<p>然后在ViewModel的构造方法里传入SavedStateHandle实例，然后就可以通过SavedStateHandle保存和读取数据了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveStateTestViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SavedStateHandle savedStateHandle;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MutableLiveData&lt;String&gt; notifyLiveData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SaveStateTestViewModel</span><span class=\"params\">(SavedStateHandle handle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.savedStateHandle = handle;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyLiveData = savedStateHandle.getLiveData(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span>&#123;</span><br><span class=\"line\">        savedStateHandle.set(<span class=\"string\">\"key2\"</span>, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyLiveData.setValue(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"title\">getNotifyLiveData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyLiveData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和 onSaveInstanceState() 的保存和恢复方式一样，不能保存复杂的数据，只能保存可以存入Bundle的那些类型。 也可以SavedStateHandle中使用LiveData的方式进行保存，这样的话稍微有那么一点的好处是你不需要特意的save和get数据，直接把在初始化的时候替换成SavedStateHandle#getLiveData就可以了</p>\n<h2 id=\"2-Lifecycles\"><a href=\"#2-Lifecycles\" class=\"headerlink\" title=\"2. Lifecycles\"></a>2. Lifecycles</h2><p>Lifecycles组件是为了方便感知Activity和Fragment的生命周期而出现的，它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。<br>Lifecycle包含在support library 26.1.0及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。support library在26.1.0之前，需要我们引入另外的包。</p>\n<p>lifecycle 组件包括 Lifecycle, LifecycleOwner, LifecycleObserver 三个主要类：</p>\n<ul>\n<li>Lifecycle 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。</li>\n<li>LifecycleOwner 仅有一个 getLifecycle() 方法，用于返回当前对象的 Lifecycle。</li>\n<li>LifecycleObserver，代表观察者</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LifecyclerOwner和LifecycleObserver</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口，是被观察者。<br>LifecycleOwner#getLifecycle()返回Lifecycle实例. 这是一种解耦实现, LifecycleOwner不包含任何有关生命周期管理的逻辑, 实际的逻辑都在Lifecycle实例中, 我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏。<br>并不是所有的google官方的Activity和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有FragmentActivity，AppCompatActivity和v4包下的Fragment。<br>LifecycleObserver接口代表生命周期的观察者，它的实现为空。实现LifecycleObserver的类要想感知到生命周期的变化需要借助额外的注解。或者，也可以使用一些继承了LifecycleObserver的子接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">voidactivityResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lifecycle中的state和event\"><a href=\"#Lifecycle中的state和event\" class=\"headerlink\" title=\"Lifecycle中的state和event\"></a>Lifecycle中的state和event</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</span><br><span class=\"line\">    DESTROYED,</span><br><span class=\"line\">    INITIALIZED,</span><br><span class=\"line\">    CREATED,</span><br><span class=\"line\">    STARTED,</span><br><span class=\"line\">    RESUMED;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAtLeast</span><span class=\"params\">(@NonNull State state)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compareTo(state) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Event &#123;</span><br><span class=\"line\">    ON_CREATE,</span><br><span class=\"line\">    ON_START,</span><br><span class=\"line\">    ON_RESUME,</span><br><span class=\"line\">    ON_PAUSE,</span><br><span class=\"line\">    ON_STOP,</span><br><span class=\"line\">    ON_DESTROY,</span><br><span class=\"line\">    ON_ANY <span class=\"comment\">// ON_ANY代表任意时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lifecycle的获取生命周期的变化\"><a href=\"#Lifecycle的获取生命周期的变化\" class=\"headerlink\" title=\"Lifecycle的获取生命周期的变化\"></a>Lifecycle的获取生命周期的变化</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SupportActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleOwner</span>, <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LifecycleRegistry mLifecycleRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mLifecycleRegistry.markState(State.CREATED);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onSaveInstanceState(outState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mLifecycleRegistry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleRegistry继承了Lifecycle。SupportActivity是FragmentActivity的父类。在SupportActivity中找不到state和event分发相关的代码，这些相关内容是在ReportFragment中实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReportFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectIfNeededIn</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            manager.beginTransaction().add(<span class=\"keyword\">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class=\"line\"></span><br><span class=\"line\">            manager.executePendingTransactions();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        dispatchStart(mProcessListener);</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_START);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        Activity activity = getActivity();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleOwner) &#123;</span><br><span class=\"line\">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lifecycle <span class=\"keyword\">instanceof</span> LifecycleRegistry) &#123;</span><br><span class=\"line\">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LifecycleRegistry-addObserver\"><a href=\"#LifecycleRegistry-addObserver\" class=\"headerlink\" title=\"LifecycleRegistry#addObserver\"></a>LifecycleRegistry#addObserver</h3><p>LifecycleRegistry继承了Lifecycle，是Activity和Fragment生命周期的真正管理类。 这个类里面的很多逻辑有点绕，我不太能理清楚。主要看一下addObserver这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleRegistry</span> <span class=\"keyword\">extends</span> <span class=\"title\">Lifecycle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = <span class=\"keyword\">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的state</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> State mState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// observer的state初始化为DESTROYED或者INITIALIZED</span></span><br><span class=\"line\">        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">        ObserverWithState statefulObserver = <span class=\"keyword\">new</span> ObserverWithState(observer, initialState);</span><br><span class=\"line\">        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// it is null we should be destroyed. Fallback quickly</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isReentrance = mAddingObserverCounter != <span class=\"number\">0</span> || mHandlingEvent;</span><br><span class=\"line\">        <span class=\"comment\">// 得到一个目标state</span></span><br><span class=\"line\">        State targetState = calculateTargetState(observer);</span><br><span class=\"line\">        mAddingObserverCounter++;</span><br><span class=\"line\">        <span class=\"comment\">// 当observer被add进来的时候，会进入循环，分发事件，直到observer的state==targetState</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class=\"line\">            pushParentState(statefulObserver.mState);</span><br><span class=\"line\">            <span class=\"comment\">// 这里的upEvent(state)会导致statefulObserver.mState在分发的过程中不断更新</span></span><br><span class=\"line\">            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class=\"line\">            popParentState();</span><br><span class=\"line\">            <span class=\"comment\">// mState / subling may have been changed recalculate</span></span><br><span class=\"line\">            targetState = calculateTargetState(observer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isReentrance) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// we do sync only on the top level.</span></span><br><span class=\"line\">            sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAddingObserverCounter--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> State <span class=\"title\">calculateTargetState</span><span class=\"params\">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的previous指前一个加入进来的Observer</span></span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);</span><br><span class=\"line\">    </span><br><span class=\"line\">        State siblingState = previous != <span class=\"keyword\">null</span> ? previous.getValue().mState : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这个mParentStates不知道是啥。。。</span></span><br><span class=\"line\">        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class=\"number\">1</span>)</span><br><span class=\"line\">                : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的min(x, y)是 返回在枚举中order最小的state</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(min(mState, siblingState), parentState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在addObserver中，ObserverWithState将state和observer包装一下，ObserverWithState内初始的state是DESTROYED或者INITIALIZED。之后会计算一个targetState，在while循环中会不断的分发和更新event。</p>\n<p>具体效果看下面的demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    handler.postDelayed(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            TestActivity.<span class=\"keyword\">this</span>.getLifecycle().addObserver(<span class=\"keyword\">new</span> GenericLifecycleObserver() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">                    Log.i(<span class=\"string\">\"chenlei\"</span>, <span class=\"string\">\"onStateChanged: \"</span> + event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的GenericLifecycleObserver继承了LifecycleObserver的接口。demo中在create方法里延时5s添加一个LifecycleObserver并打印event。最后打印输出如下：</p>\n<p>可以看到从ON_CREATE到ON_RESUME在同一时刻都打印出来了</p>\n<h3 id=\"ProcessLifecycleOwner\"><a href=\"#ProcessLifecycleOwner\" class=\"headerlink\" title=\"ProcessLifecycleOwner\"></a>ProcessLifecycleOwner</h3><p>ProcessLifecycleOwner实现了LifecycleOwner接口，可以监听当前应用前后台切换，并对此进行响应。<br>这个类提供整个应用进程的生命周期。<br>你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，Lifecycle.Event.ON_CREATE 事件只会分发一次，而 Lifecycle.Event.ON_DESTROY 永远不被分发。其他事件的分发遵守以下规则：<br>ProcessLifecycleOwner 会在第一个 Activity 经历 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 事件 延迟一段时间 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。<br>这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。<br>使用的时候，在Application中添加LifecycleObserver就可以了(实际上，在应用进程中的任意位置都可以）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ApplicationObserver(val analytics: Analytics) : LifecycleObserver &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">onBackground</span><span class=\"params\">()</span> </span>&#123;    &#125;   </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">onForeground</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">        ProcessLifecycleOwner.get().getLifecycle().addObserver(<span class=\"keyword\">new</span> ApplicationObserver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理：</p>\n<p>ProcessLifecycleOwnerInitializer<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProcessLifecycleOwnerInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        LifecycleDispatcher.init(getContext());</span><br><span class=\"line\">        ProcessLifecycleOwner.init(getContext());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类是ProcessLifecycleOwner初始化的地方，它继承了一个ContentProvider ，这个ContentProvider声明在了Lifecycle包的AndroidManifest.xml里。</p>\n<p>这个AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。<br>这里利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application 的 onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建。</p>\n<p>LifecycleDispatcher#init<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleDispatcher</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicBoolean sInitialized = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInitialized.getAndSet(<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ((Application) context.getApplicationContext())</span><br><span class=\"line\">                .registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> DispatcherActivityCallback());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherActivityCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">EmptyActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            ReportFragment.injectIfNeededIn(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Application中注册一个ActivityLifecycleCallbacks，在ActivityLifecycleCallbacks中有Activity所有生命周期的回调，这样就能监听到每一个Activity的创建和销毁。在onActivityCreated回调中往Activity注入一个了ReportFragment，我没看出来这里的ReportFragment的作用是什么。。</p>\n<p>ProcessLifecycleOwner</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProcessLifecycleOwner</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LifecycleRegistry mRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessLifecycleOwner sInstance = <span class=\"keyword\">new</span> ProcessLifecycleOwner();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        sInstance.attach(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ActivityInitializationListener mInitializationListener =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ActivityInitializationListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                activityStarted();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                activityResumed();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler();</span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">        Application app = (Application) context.getApplicationContext();</span><br><span class=\"line\">        app.registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//在ReportFragment的生命周期中会有dispatchXxxx(mProcessListener)</span></span><br><span class=\"line\">                ReportFragment.get(activity)</span><br><span class=\"line\">                                .setProcessListener(mInitializationListener);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">                activityPaused();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">                activityStopped();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityResumed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mResumedCounter++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPauseSent) &#123;</span><br><span class=\"line\">                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class=\"line\">                mPauseSent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityPaused</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mResumedCounter--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在mDelayedPauseRunnable中会调用这个方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchPauseIfNeeded</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mPauseSent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-LiveData\"><a href=\"#2-LiveData\" class=\"headerlink\" title=\"2. LiveData\"></a>2. LiveData</h2><p>ViewModel和Lifecycles分别代表数据和UI两端，这两个组件是相对比较独立的，并没有太多直接的关系。为了防止内存泄漏，ViewModel不能直接持有activity和fragment的引用。为了让更好的结合ViewModel和Lifecycles，就需要LiveData。<br>LiveData是一种观察者模式, 在 Value发生变化时通知之前注册的所有观察者。同时，借助于Lifecycles，LiveData具有生命周期的感知能力。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。使用LiveData有以下的优点：</p>\n<ul>\n<li>LiveData 只会将消息通知给活跃的观察者，非活跃观察者将不会收到消息通知。</li>\n<li>当非活跃观察者状态变为活跃的时候，LiveData会将自动将最新的消息发送给它。</li>\n<li>当相应的 Lifecycle 对象的状态变为 DESTROYED 时，LiveData会自动的移除此观察者，这样就不用担心Fragment和Activity的内存泄漏。</li>\n<li>LiveData的数据发送和Observer的添加是没有顺序限制的。比如说LiveData在第1s发送消息，然后在第5s添加Observer，Observer依然能够立即接收到第1s发送出的数据，只要数据是当前最新的。这主要和LifecycleRegistry#addObserver的实现有关</li>\n</ul>\n<h3 id=\"2-1-LiveData的使用\"><a href=\"#2-1-LiveData的使用\" class=\"headerlink\" title=\"2.1 LiveData的使用\"></a>2.1 LiveData的使用</h3><h4 id=\"2-1-1-基本使用\"><a href=\"#2-1-1-基本使用\" class=\"headerlink\" title=\"2.1.1 基本使用\"></a>2.1.1 基本使用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; notifyCurrentName = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        notifyCurrentName.postValue(<span class=\"string\">\"value\"</span>);    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"title\">getNotifyCurrentName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyCurrentName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在activity or fragment中</span></span><br><span class=\"line\"><span class=\"comment\">// public void observe(LifecycleOwner owner, Observer&lt;T&gt; observer) </span></span><br><span class=\"line\">getViewModel().getNotifyCurrentName().observer(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Stirng value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果不想让LiveData感知到生命周期，可以用observeForever(Observer&lt;T&gt; observer)</span></span><br><span class=\"line\">getViewModel().getNotifyCurrentName().observeForever(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Stirng value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-1-2-Transformations-map\"><a href=\"#2-1-2-Transformations-map\" class=\"headerlink\" title=\"2.1.2 Transformations#map\"></a>2.1.2 Transformations#map</h4><p>Transformations是用来做LiveData转换的类。<br>Transformations#map可以在消息分派给观察者之前对消息进行更改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;User&gt; userLiveData = ...;</span><br><span class=\"line\">LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class=\"line\">    user.name + <span class=\"string\">\" \"</span> + user.lastName</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-1-3-Transformations-switchMap\"><a href=\"#2-1-3-Transformations-switchMap\" class=\"headerlink\" title=\"2.1.3 Transformations#switchMap\"></a>2.1.3 Transformations#switchMap</h4><p>switchMap可以实现LiveData的转换，下面是一个demo，通过switchMap切换LiveData的数据源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapTestViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; dataSourceA = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; dataSourceB = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;Boolean&gt; changeDataSource = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LiveData&lt;String&gt; notifyData = Transformations.switchMap(changeDataSource, <span class=\"keyword\">new</span> Function&lt;Boolean, LiveData&lt;String&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;String&gt; <span class=\"title\">apply</span><span class=\"params\">(Boolean input)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input ? dataSourceA : dataSourceB;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        changeDataSource.setValue(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Handler handler = <span class=\"keyword\">new</span> Handler(activity.getMainLooper());</span><br><span class=\"line\">        handler.postDelayed(() -&gt; &#123;</span><br><span class=\"line\">            dataSourceA.postValue(<span class=\"string\">\"data from source A\"</span>);</span><br><span class=\"line\">            dataSourceB.postValue(<span class=\"string\">\"data from source B\"</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        handler.postDelayed(() -&gt; &#123;</span><br><span class=\"line\">            changeDataSource(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">10000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">(<span class=\"keyword\">boolean</span> userA)</span> </span>&#123;</span><br><span class=\"line\">        changeDataSource.setValue(userA);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;String&gt; <span class=\"title\">getNotifyData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// activity</span></span><br><span class=\"line\">viewModel.start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">viewModel.getNotifyData().observe(MapTestActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"chenlei\"</span>, <span class=\"string\">\"onChanged: \"</span> + s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的demo中，延时2s同时向dataSourceA和dataSourceB发送数据，并延时10s将数据源从A指向B。在observe中打印结果，最终dataSourceA和dataSourceB在间隔一段时间之后都能打印出来。<br>每次调用changeDataSource.setValue(Boolean)，都会调用Function#apply返回一个LiveData，并将notifyData的 Observer 添加到新的LiveData上</p>\n<h3 id=\"2-2-LiveData的原理\"><a href=\"#2-2-LiveData的原理\" class=\"headerlink\" title=\"2.2 LiveData的原理\"></a>2.2 LiveData的原理</h3><h4 id=\"2-2-1-LiveData\"><a href=\"#2-2-1-LiveData\" class=\"headerlink\" title=\"2.2.1 LiveData\"></a>2.2.1 LiveData</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存放Observer的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SafeIterableMap&lt;Observer&lt;T&gt;, ObserverWrapper&gt; mObservers =                                                                 <span class=\"keyword\">new</span> SafeIterableMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> START_VERSION = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mActiveCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mVersion = START_VERSION;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 当LiveData的活跃Observer数量由0变成1的时候调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当LiveData的活跃Observer数量由1变成0的时候调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onInactive</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;T&gt; mObserver;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> mActive;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mLastVersion = START_VERSION;</span><br><span class=\"line\">    </span><br><span class=\"line\">        ObserverWrapper(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">            mObserver = observer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activeStateChanged</span><span class=\"params\">(<span class=\"keyword\">boolean</span> newActive)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 活跃状态没有改变则return， 防止重复发送消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newActive == mActive) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mActive = newActive;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> wasInactive = LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span>;</span><br><span class=\"line\">            LiveData.<span class=\"keyword\">this</span>.mActiveCount += mActive ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class=\"line\">                onActive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span> &amp;&amp; !mActive) &#123;</span><br><span class=\"line\">                onInactive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mActive) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 开始分发value</span></span><br><span class=\"line\">                dispatchingValue(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-2-LiveData-observer\"><a href=\"#2-2-2-LiveData-observer\" class=\"headerlink\" title=\"2.2.2 LiveData#observer\"></a>2.2.2 LiveData#observer</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"meta\">@MainThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observe</span><span class=\"params\">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LifecycleBoundObserver wrapper = <span class=\"keyword\">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class=\"line\">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将wrapper将入到lifecycleOwner的生命周期的监听中</span></span><br><span class=\"line\">        owner.getLifecycle().addObserver(wrapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleBoundObserver继承自ObserverWrapper，并且实现了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericLifecycleObserver接口。GenericLifecycleObserver接口继承自LifecycleObserver接口</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GenericLifecycleObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">GenericLifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> LifecycleOwner mOwner;</span><br><span class=\"line\"></span><br><span class=\"line\">    LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">        mOwner = owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过Lifecycle判断当前Observer是否活跃</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// GenericLifecycleObserver#onStatechanged</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当LifecycleOwner已经被销毁，remove这个Observer。</span></span><br><span class=\"line\">            <span class=\"comment\">// removeObserver会调用detachObserver()和activeStateChanged(false)</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是为什么LiveData可以自动防止UI泄漏的原因</span></span><br><span class=\"line\">            removeObserver(mObserver);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        activeStateChanged(shouldBeActive());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner == owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从LifecycleOwner中remove观察者</span></span><br><span class=\"line\">        mOwner.getLifecycle().removeObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LiveData#observeForever</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(@NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 因为observeForever没有LifecycleOwner，为了保持和普通observe方法的特性一致，在添加observe之后立刻检查是否有数据可以发送，</span></span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlwaysActiveObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;</span><br><span class=\"line\">    AlwaysActiveObserver(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-3-LiveData-postValue\"><a href=\"#2-2-3-LiveData-postValue\" class=\"headerlink\" title=\"2.2.3 LiveData#postValue()\"></a>2.2.3 LiveData#postValue()</h4><p>LiveData发送消息使用setValue或者postValue方法。其中setValue只能在主线程中使用，postValue发送消息时会自动切换到主线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            setValue((T) newValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LiveData#setValue</span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>);</span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDispatchingValue) &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initiator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向特定的Observer发送数据</span></span><br><span class=\"line\">            considerNotify(initiator);</span><br><span class=\"line\">            initiator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向所有Observer发送消息</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将要发送的是旧版本，扔掉</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"自定义ViewGroup","date":"2019-04-13T05:12:35.000Z","_content":"\n# 自定义ViewGroup\n\n### 参考文章\n[自定义LayoutParams](https://blog.csdn.net/xmxkf/article/details/51500304#3-%E6%94%AF%E6%8C%81layoutmargin%E5%B1%9E%E6%80%A7)\n[关于onMeasure过程的理解](https://blog.csdn.net/xmxkf/article/details/51490283)\n[Measure测量流程全解析（简洁）](https://juejin.im/post/5ad37c476fb9a028bc2e32af)\n### 下面是继承自ViewGroup的FlowLayout标签流式布局\n```java\npackage com.example.test;\n\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.ViewGroup;\n\npublic class FlowLayout extends ViewGroup {\n    public FlowLayout(Context context) {\n        super(context);\n    }\n\n    public FlowLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int specWidth = MeasureSpec.getSize(widthMeasureSpec);\n        int specHeight = MeasureSpec.getSize(heightMeasureSpec);\n        int specWidthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int specHeightMode = MeasureSpec.getMode(heightMeasureSpec);\n\n        int count = getChildCount();\n\n        //计算child的大小\n        for (int i = 0; i < count; i++) {\n            View child = getChildAt(i);\n            //measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0\n            //这里为了支持margin，所以用measureChildWithMargins方法\n            measureChildWithMargins(child,\n                    widthMeasureSpec, 0,\n                    heightMeasureSpec, 0);\n        }\n        //计算ViewGroup自身的大小\n        //这里只要处理height的wrap_content情况就可以了\n        int height = specHeight;\n        int width = specWidth;\n        if (specHeightMode == MeasureSpec.AT_MOST) {\n            height = getPaddingBottom() + getPaddingTop();\n            int used_width = 0;\n            int line_max_height = 0;\n            for (int i = 0; i < count; i++) {\n                View child = getChildAt(i);\n                MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams();\n                int child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;\n                int child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;\n                //在这一行可以容纳\n                if (used_width + child_width <= width - getPaddingStart() - getPaddingEnd()) {\n                    line_max_height = Math.max(line_max_height, child_height);\n                    used_width += child_width;\n                } else {\n                    //切换到下一行\n                    height += line_max_height;\n                    used_width = child_width;\n                    line_max_height = child_height;\n                }\n            }\n            //加上最后一行的最大height\n            height += line_max_height;\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    private final String TAG = \"test_log\";\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        int width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd();\n        int used_width = 0;\n        int used_height = 0;\n\n        int count = getChildCount();\n        int last_line_max_height = 0;\n        for (int i = 0; i < count; i++) {\n            View child_view = getChildAt(i);\n            MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams();\n            //用于计算是否越界时需要包含margin\n            int child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;\n            int child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;\n            //layout时的位置，必须考虑padding\n            int layout_l, layout_t, layout_r, layout_b;\n            if (used_width + child_width <= width) {\n                layout_l = getPaddingStart() + used_width + mlp.leftMargin;\n                layout_t = getPaddingTop() + used_height + mlp.topMargin;\n                layout_r = layout_l + child_view.getMeasuredWidth();\n                layout_b = layout_t + child_view.getMeasuredHeight();\n\n                used_width += child_width;\n                //记录该行height的最大值\n                last_line_max_height = Math.max(last_line_max_height, child_height);\n            } else {\n                layout_l = getPaddingStart() + mlp.leftMargin;\n                layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin;\n                layout_r = layout_l + child_view.getMeasuredWidth();\n                layout_b = layout_t + child_view.getMeasuredHeight();\n\n                used_height += last_line_max_height;\n                used_width = child_width;\n\n                last_line_max_height = child_height;\n            }\n            child_view.layout(layout_l, layout_t, layout_r, layout_b);\n        }\n    }\n\n    @Override\n    public LayoutParams generateLayoutParams(AttributeSet attrs) {\n        return new MarginLayoutParams(getContext(), attrs);\n    }\n\n    @Override\n    protected LayoutParams generateLayoutParams(LayoutParams p) {\n        return new MarginLayoutParams(p);\n    }\n\n    @Override\n    protected LayoutParams generateDefaultLayoutParams() {\n        return new MarginLayoutParams(super.generateDefaultLayoutParams());\n    }\n}\n\n```\n\n### 关于MeasureSpec\n\n父控件告诉子控件可获得的空间以及关于这个空间的约束条件\n\n#### SpecMode\n\n* EXACTLY\n  * 设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式\n* AT_MOST\n  * width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值\n* UNSPECIFIED\n  * 这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用\n\n### 关于view的Measure过程\n我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。\n    这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程：\n* **ViewRootImpl.performTraversals()->performMeasure():**\n> 这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量\n* **DecorView.measure()->onMeasure():**\n> DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量\n* **ViewGroupA.measure()->onMeasure():**\n>这是我们自定义的一个ViewGroup(继承自ViewGroup)\n假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。\n    所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，**里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。**\n* **ViewB.measure()->onMeasure():**\n> View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。\n\n### 测量子view时MeasureSpec的生成规则\n1. **当子View的宽高设置的是具体数值时**\n> 显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,**此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。**\n2. **当子View的宽高设置的是match_parent**\n> 则**不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。**（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）\n3. **当子View的宽高设置的是wrap_content,**\n> 因为这种情况父容器实在不知道子View应该多宽多高，**所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。**（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。\n    \n* 通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。**所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。**\n\n### 关于LayoutParams\n在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。**在使用中必须重写所有的generateLayoutParams()方法**\n尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams\n","source":"_posts/Android/自定义ViewGroup.md","raw":"---\ntitle: 自定义ViewGroup\ndate: 2019-04-13 13:12:35\ntags:\n- View\ncategories:\n- Android\n- View\n---\n\n# 自定义ViewGroup\n\n### 参考文章\n[自定义LayoutParams](https://blog.csdn.net/xmxkf/article/details/51500304#3-%E6%94%AF%E6%8C%81layoutmargin%E5%B1%9E%E6%80%A7)\n[关于onMeasure过程的理解](https://blog.csdn.net/xmxkf/article/details/51490283)\n[Measure测量流程全解析（简洁）](https://juejin.im/post/5ad37c476fb9a028bc2e32af)\n### 下面是继承自ViewGroup的FlowLayout标签流式布局\n```java\npackage com.example.test;\n\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.ViewGroup;\n\npublic class FlowLayout extends ViewGroup {\n    public FlowLayout(Context context) {\n        super(context);\n    }\n\n    public FlowLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int specWidth = MeasureSpec.getSize(widthMeasureSpec);\n        int specHeight = MeasureSpec.getSize(heightMeasureSpec);\n        int specWidthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int specHeightMode = MeasureSpec.getMode(heightMeasureSpec);\n\n        int count = getChildCount();\n\n        //计算child的大小\n        for (int i = 0; i < count; i++) {\n            View child = getChildAt(i);\n            //measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0\n            //这里为了支持margin，所以用measureChildWithMargins方法\n            measureChildWithMargins(child,\n                    widthMeasureSpec, 0,\n                    heightMeasureSpec, 0);\n        }\n        //计算ViewGroup自身的大小\n        //这里只要处理height的wrap_content情况就可以了\n        int height = specHeight;\n        int width = specWidth;\n        if (specHeightMode == MeasureSpec.AT_MOST) {\n            height = getPaddingBottom() + getPaddingTop();\n            int used_width = 0;\n            int line_max_height = 0;\n            for (int i = 0; i < count; i++) {\n                View child = getChildAt(i);\n                MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams();\n                int child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;\n                int child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;\n                //在这一行可以容纳\n                if (used_width + child_width <= width - getPaddingStart() - getPaddingEnd()) {\n                    line_max_height = Math.max(line_max_height, child_height);\n                    used_width += child_width;\n                } else {\n                    //切换到下一行\n                    height += line_max_height;\n                    used_width = child_width;\n                    line_max_height = child_height;\n                }\n            }\n            //加上最后一行的最大height\n            height += line_max_height;\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    private final String TAG = \"test_log\";\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        int width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd();\n        int used_width = 0;\n        int used_height = 0;\n\n        int count = getChildCount();\n        int last_line_max_height = 0;\n        for (int i = 0; i < count; i++) {\n            View child_view = getChildAt(i);\n            MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams();\n            //用于计算是否越界时需要包含margin\n            int child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;\n            int child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;\n            //layout时的位置，必须考虑padding\n            int layout_l, layout_t, layout_r, layout_b;\n            if (used_width + child_width <= width) {\n                layout_l = getPaddingStart() + used_width + mlp.leftMargin;\n                layout_t = getPaddingTop() + used_height + mlp.topMargin;\n                layout_r = layout_l + child_view.getMeasuredWidth();\n                layout_b = layout_t + child_view.getMeasuredHeight();\n\n                used_width += child_width;\n                //记录该行height的最大值\n                last_line_max_height = Math.max(last_line_max_height, child_height);\n            } else {\n                layout_l = getPaddingStart() + mlp.leftMargin;\n                layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin;\n                layout_r = layout_l + child_view.getMeasuredWidth();\n                layout_b = layout_t + child_view.getMeasuredHeight();\n\n                used_height += last_line_max_height;\n                used_width = child_width;\n\n                last_line_max_height = child_height;\n            }\n            child_view.layout(layout_l, layout_t, layout_r, layout_b);\n        }\n    }\n\n    @Override\n    public LayoutParams generateLayoutParams(AttributeSet attrs) {\n        return new MarginLayoutParams(getContext(), attrs);\n    }\n\n    @Override\n    protected LayoutParams generateLayoutParams(LayoutParams p) {\n        return new MarginLayoutParams(p);\n    }\n\n    @Override\n    protected LayoutParams generateDefaultLayoutParams() {\n        return new MarginLayoutParams(super.generateDefaultLayoutParams());\n    }\n}\n\n```\n\n### 关于MeasureSpec\n\n父控件告诉子控件可获得的空间以及关于这个空间的约束条件\n\n#### SpecMode\n\n* EXACTLY\n  * 设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式\n* AT_MOST\n  * width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值\n* UNSPECIFIED\n  * 这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用\n\n### 关于view的Measure过程\n我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。\n    这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程：\n* **ViewRootImpl.performTraversals()->performMeasure():**\n> 这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量\n* **DecorView.measure()->onMeasure():**\n> DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量\n* **ViewGroupA.measure()->onMeasure():**\n>这是我们自定义的一个ViewGroup(继承自ViewGroup)\n假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。\n    所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，**里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。**\n* **ViewB.measure()->onMeasure():**\n> View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。\n\n### 测量子view时MeasureSpec的生成规则\n1. **当子View的宽高设置的是具体数值时**\n> 显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,**此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。**\n2. **当子View的宽高设置的是match_parent**\n> 则**不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。**（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）\n3. **当子View的宽高设置的是wrap_content,**\n> 因为这种情况父容器实在不知道子View应该多宽多高，**所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。**（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。\n    \n* 通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。**所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。**\n\n### 关于LayoutParams\n在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。**在使用中必须重写所有的generateLayoutParams()方法**\n尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams\n","slug":"Android/自定义ViewGroup","published":1,"updated":"2019-12-21T12:16:41.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakr6002t8mzmcc4ga6wr","content":"<h1 id=\"自定义ViewGroup\"><a href=\"#自定义ViewGroup\" class=\"headerlink\" title=\"自定义ViewGroup\"></a>自定义ViewGroup</h1><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://blog.csdn.net/xmxkf/article/details/51500304#3-%E6%94%AF%E6%8C%81layoutmargin%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">自定义LayoutParams</a><br><a href=\"https://blog.csdn.net/xmxkf/article/details/51490283\" target=\"_blank\" rel=\"noopener\">关于onMeasure过程的理解</a><br><a href=\"https://juejin.im/post/5ad37c476fb9a028bc2e32af\" target=\"_blank\" rel=\"noopener\">Measure测量流程全解析（简洁）</a></p><a id=\"more\"></a>\n<h3 id=\"下面是继承自ViewGroup的FlowLayout标签流式布局\"><a href=\"#下面是继承自ViewGroup的FlowLayout标签流式布局\" class=\"headerlink\" title=\"下面是继承自ViewGroup的FlowLayout标签流式布局\"></a>下面是继承自ViewGroup的FlowLayout标签流式布局</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.View;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewGroup;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlowLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specWidthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specHeightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = getChildCount();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//计算child的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            View child = getChildAt(i);</span><br><span class=\"line\">            <span class=\"comment\">//measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0</span></span><br><span class=\"line\">            <span class=\"comment\">//这里为了支持margin，所以用measureChildWithMargins方法</span></span><br><span class=\"line\">            measureChildWithMargins(child,</span><br><span class=\"line\">                    widthMeasureSpec, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    heightMeasureSpec, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//计算ViewGroup自身的大小</span></span><br><span class=\"line\">        <span class=\"comment\">//这里只要处理height的wrap_content情况就可以了</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> height = specHeight;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = specWidth;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specHeightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class=\"line\">            height = getPaddingBottom() + getPaddingTop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> used_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> line_max_height = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">                View child = getChildAt(i);</span><br><span class=\"line\">                MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;</span><br><span class=\"line\">                <span class=\"comment\">//在这一行可以容纳</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (used_width + child_width &lt;= width - getPaddingStart() - getPaddingEnd()) &#123;</span><br><span class=\"line\">                    line_max_height = Math.max(line_max_height, child_height);</span><br><span class=\"line\">                    used_width += child_width;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//切换到下一行</span></span><br><span class=\"line\">                    height += line_max_height;</span><br><span class=\"line\">                    used_width = child_width;</span><br><span class=\"line\">                    line_max_height = child_height;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//加上最后一行的最大height</span></span><br><span class=\"line\">            height += line_max_height;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setMeasuredDimension(width, height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"test_log\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> used_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> used_height = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last_line_max_height = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            View child_view = getChildAt(i);</span><br><span class=\"line\">            MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams();</span><br><span class=\"line\">            <span class=\"comment\">//用于计算是否越界时需要包含margin</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;</span><br><span class=\"line\">            <span class=\"comment\">//layout时的位置，必须考虑padding</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> layout_l, layout_t, layout_r, layout_b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (used_width + child_width &lt;= width) &#123;</span><br><span class=\"line\">                layout_l = getPaddingStart() + used_width + mlp.leftMargin;</span><br><span class=\"line\">                layout_t = getPaddingTop() + used_height + mlp.topMargin;</span><br><span class=\"line\">                layout_r = layout_l + child_view.getMeasuredWidth();</span><br><span class=\"line\">                layout_b = layout_t + child_view.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">                used_width += child_width;</span><br><span class=\"line\">                <span class=\"comment\">//记录该行height的最大值</span></span><br><span class=\"line\">                last_line_max_height = Math.max(last_line_max_height, child_height);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                layout_l = getPaddingStart() + mlp.leftMargin;</span><br><span class=\"line\">                layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin;</span><br><span class=\"line\">                layout_r = layout_l + child_view.getMeasuredWidth();</span><br><span class=\"line\">                layout_b = layout_t + child_view.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">                used_height += last_line_max_height;</span><br><span class=\"line\">                used_width = child_width;</span><br><span class=\"line\"></span><br><span class=\"line\">                last_line_max_height = child_height;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            child_view.layout(layout_l, layout_t, layout_r, layout_b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(getContext(), attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(LayoutParams p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> LayoutParams <span class=\"title\">generateDefaultLayoutParams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(<span class=\"keyword\">super</span>.generateDefaultLayoutParams());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于MeasureSpec\"><a href=\"#关于MeasureSpec\" class=\"headerlink\" title=\"关于MeasureSpec\"></a>关于MeasureSpec</h3><p>父控件告诉子控件可获得的空间以及关于这个空间的约束条件</p>\n<h4 id=\"SpecMode\"><a href=\"#SpecMode\" class=\"headerlink\" title=\"SpecMode\"></a>SpecMode</h4><ul>\n<li>EXACTLY<ul>\n<li>设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式</li>\n</ul>\n</li>\n<li>AT_MOST<ul>\n<li>width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值</li>\n</ul>\n</li>\n<li>UNSPECIFIED<ul>\n<li>这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关于view的Measure过程\"><a href=\"#关于view的Measure过程\" class=\"headerlink\" title=\"关于view的Measure过程\"></a>关于view的Measure过程</h3><p>我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。<br>    这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程：</p>\n<ul>\n<li><strong>ViewRootImpl.performTraversals()-&gt;performMeasure():</strong><blockquote>\n<p>这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量</p>\n</blockquote>\n</li>\n<li><strong>DecorView.measure()-&gt;onMeasure():</strong><blockquote>\n<p>DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量</p>\n</blockquote>\n</li>\n<li><strong>ViewGroupA.measure()-&gt;onMeasure():</strong><blockquote>\n<p>这是我们自定义的一个ViewGroup(继承自ViewGroup)<br>假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。<br>  所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，<strong>里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。</strong></p>\n</blockquote>\n</li>\n<li><strong>ViewB.measure()-&gt;onMeasure():</strong><blockquote>\n<p>View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"测量子view时MeasureSpec的生成规则\"><a href=\"#测量子view时MeasureSpec的生成规则\" class=\"headerlink\" title=\"测量子view时MeasureSpec的生成规则\"></a>测量子view时MeasureSpec的生成规则</h3><ol>\n<li><strong>当子View的宽高设置的是具体数值时</strong><blockquote>\n<p>显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,<strong>此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。</strong></p>\n</blockquote>\n</li>\n<li><strong>当子View的宽高设置的是match_parent</strong><blockquote>\n<p>则<strong>不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。</strong>（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）</p>\n</blockquote>\n</li>\n<li><strong>当子View的宽高设置的是wrap_content,</strong><blockquote>\n<p>因为这种情况父容器实在不知道子View应该多宽多高，<strong>所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。</strong>（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。<strong>所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。</strong></li>\n</ul>\n<h3 id=\"关于LayoutParams\"><a href=\"#关于LayoutParams\" class=\"headerlink\" title=\"关于LayoutParams\"></a>关于LayoutParams</h3><p>在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。<strong>在使用中必须重写所有的generateLayoutParams()方法</strong><br>尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"自定义ViewGroup\"><a href=\"#自定义ViewGroup\" class=\"headerlink\" title=\"自定义ViewGroup\"></a>自定义ViewGroup</h1><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://blog.csdn.net/xmxkf/article/details/51500304#3-%E6%94%AF%E6%8C%81layoutmargin%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">自定义LayoutParams</a><br><a href=\"https://blog.csdn.net/xmxkf/article/details/51490283\" target=\"_blank\" rel=\"noopener\">关于onMeasure过程的理解</a><br><a href=\"https://juejin.im/post/5ad37c476fb9a028bc2e32af\" target=\"_blank\" rel=\"noopener\">Measure测量流程全解析（简洁）</a></p>","more":"\n<h3 id=\"下面是继承自ViewGroup的FlowLayout标签流式布局\"><a href=\"#下面是继承自ViewGroup的FlowLayout标签流式布局\" class=\"headerlink\" title=\"下面是继承自ViewGroup的FlowLayout标签流式布局\"></a>下面是继承自ViewGroup的FlowLayout标签流式布局</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.View;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewGroup;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlowLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specWidthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specHeightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = getChildCount();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//计算child的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            View child = getChildAt(i);</span><br><span class=\"line\">            <span class=\"comment\">//measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0</span></span><br><span class=\"line\">            <span class=\"comment\">//这里为了支持margin，所以用measureChildWithMargins方法</span></span><br><span class=\"line\">            measureChildWithMargins(child,</span><br><span class=\"line\">                    widthMeasureSpec, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    heightMeasureSpec, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//计算ViewGroup自身的大小</span></span><br><span class=\"line\">        <span class=\"comment\">//这里只要处理height的wrap_content情况就可以了</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> height = specHeight;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = specWidth;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specHeightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class=\"line\">            height = getPaddingBottom() + getPaddingTop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> used_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> line_max_height = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">                View child = getChildAt(i);</span><br><span class=\"line\">                MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;</span><br><span class=\"line\">                <span class=\"comment\">//在这一行可以容纳</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (used_width + child_width &lt;= width - getPaddingStart() - getPaddingEnd()) &#123;</span><br><span class=\"line\">                    line_max_height = Math.max(line_max_height, child_height);</span><br><span class=\"line\">                    used_width += child_width;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//切换到下一行</span></span><br><span class=\"line\">                    height += line_max_height;</span><br><span class=\"line\">                    used_width = child_width;</span><br><span class=\"line\">                    line_max_height = child_height;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//加上最后一行的最大height</span></span><br><span class=\"line\">            height += line_max_height;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setMeasuredDimension(width, height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"test_log\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> used_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> used_height = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last_line_max_height = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            View child_view = getChildAt(i);</span><br><span class=\"line\">            MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams();</span><br><span class=\"line\">            <span class=\"comment\">//用于计算是否越界时需要包含margin</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;</span><br><span class=\"line\">            <span class=\"comment\">//layout时的位置，必须考虑padding</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> layout_l, layout_t, layout_r, layout_b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (used_width + child_width &lt;= width) &#123;</span><br><span class=\"line\">                layout_l = getPaddingStart() + used_width + mlp.leftMargin;</span><br><span class=\"line\">                layout_t = getPaddingTop() + used_height + mlp.topMargin;</span><br><span class=\"line\">                layout_r = layout_l + child_view.getMeasuredWidth();</span><br><span class=\"line\">                layout_b = layout_t + child_view.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">                used_width += child_width;</span><br><span class=\"line\">                <span class=\"comment\">//记录该行height的最大值</span></span><br><span class=\"line\">                last_line_max_height = Math.max(last_line_max_height, child_height);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                layout_l = getPaddingStart() + mlp.leftMargin;</span><br><span class=\"line\">                layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin;</span><br><span class=\"line\">                layout_r = layout_l + child_view.getMeasuredWidth();</span><br><span class=\"line\">                layout_b = layout_t + child_view.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">                used_height += last_line_max_height;</span><br><span class=\"line\">                used_width = child_width;</span><br><span class=\"line\"></span><br><span class=\"line\">                last_line_max_height = child_height;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            child_view.layout(layout_l, layout_t, layout_r, layout_b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(getContext(), attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(LayoutParams p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> LayoutParams <span class=\"title\">generateDefaultLayoutParams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(<span class=\"keyword\">super</span>.generateDefaultLayoutParams());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于MeasureSpec\"><a href=\"#关于MeasureSpec\" class=\"headerlink\" title=\"关于MeasureSpec\"></a>关于MeasureSpec</h3><p>父控件告诉子控件可获得的空间以及关于这个空间的约束条件</p>\n<h4 id=\"SpecMode\"><a href=\"#SpecMode\" class=\"headerlink\" title=\"SpecMode\"></a>SpecMode</h4><ul>\n<li>EXACTLY<ul>\n<li>设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式</li>\n</ul>\n</li>\n<li>AT_MOST<ul>\n<li>width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值</li>\n</ul>\n</li>\n<li>UNSPECIFIED<ul>\n<li>这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关于view的Measure过程\"><a href=\"#关于view的Measure过程\" class=\"headerlink\" title=\"关于view的Measure过程\"></a>关于view的Measure过程</h3><p>我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。<br>    这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程：</p>\n<ul>\n<li><strong>ViewRootImpl.performTraversals()-&gt;performMeasure():</strong><blockquote>\n<p>这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量</p>\n</blockquote>\n</li>\n<li><strong>DecorView.measure()-&gt;onMeasure():</strong><blockquote>\n<p>DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量</p>\n</blockquote>\n</li>\n<li><strong>ViewGroupA.measure()-&gt;onMeasure():</strong><blockquote>\n<p>这是我们自定义的一个ViewGroup(继承自ViewGroup)<br>假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。<br>  所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，<strong>里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。</strong></p>\n</blockquote>\n</li>\n<li><strong>ViewB.measure()-&gt;onMeasure():</strong><blockquote>\n<p>View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"测量子view时MeasureSpec的生成规则\"><a href=\"#测量子view时MeasureSpec的生成规则\" class=\"headerlink\" title=\"测量子view时MeasureSpec的生成规则\"></a>测量子view时MeasureSpec的生成规则</h3><ol>\n<li><strong>当子View的宽高设置的是具体数值时</strong><blockquote>\n<p>显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,<strong>此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。</strong></p>\n</blockquote>\n</li>\n<li><strong>当子View的宽高设置的是match_parent</strong><blockquote>\n<p>则<strong>不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。</strong>（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）</p>\n</blockquote>\n</li>\n<li><strong>当子View的宽高设置的是wrap_content,</strong><blockquote>\n<p>因为这种情况父容器实在不知道子View应该多宽多高，<strong>所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。</strong>（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。<strong>所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。</strong></li>\n</ul>\n<h3 id=\"关于LayoutParams\"><a href=\"#关于LayoutParams\" class=\"headerlink\" title=\"关于LayoutParams\"></a>关于LayoutParams</h3><p>在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。<strong>在使用中必须重写所有的generateLayoutParams()方法</strong><br>尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams</p>\n"},{"title":"ViewDragHelper的使用","date":"2020-02-19T02:36:30.000Z","_content":"\nViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部\n\n**参考**\n\n[ViewDragHelper 的基本使用](https://www.jianshu.com/p/a9e0a98e4d42)\n\n# 常用Api\n\n**初始化**\n\n```java\npublic static ViewDragHelper create(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb)\n```\n\n第一个参数是父布局, 第二个参数是自定义的监听回调\n\n**拦截事件**\n\n在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断\n\n```java\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\n    //ViewDragHelper对事件进行拦截\n    //注意, ACTION_DOWN事件不会被拦截\n    //当clampViewPositionXxx方法没有修改left或top值时, 不会拦截\n    //是的, shouldInterceptTouchEvent中会调用callback.clampViewPositionXxx方法\n    return mViewDragHelper.shouldInterceptTouchEvent(ev);\n}\n\n@Override\npublic boolean onTouchEvent(MotionEvent event) {\n    //将事件传递给ViewDragHelper进行处理\n    mViewDragHelper.processTouchEvent(event);\n    return true;\n}\n```\n\n**处理computeScroll**\n\n因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法)\n\n```java\n@Override\npublic void computeScroll() {\n    super.computeScroll();\n    if (mViewDragHelper != null && mViewDragHelper.continueSettling(true)){\n        invalidate();\n    }\n}\n```\n\n**处理CallBack回调**\n\n```java\nprivate ViewDragHelper.Callback mCallback = new ViewDragHelper.Callback() {\n\n    // tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动\n    @Override\n    public boolean tryCaptureView(View child, int pointerId) {\n    }\n\n    // clampViewPositionHorizontal() 判断水平方向上将要移动到的位置\n    // left 将要移动到的left值\n    // dx 表示速度\n    @Override\n    public int clampViewPositionHorizontal(View child, int left, int dx) {\n    }\n\n    // 同clampViewPositionHorizontal(), 换成了垂直方向而已\n    @Override\n    public int clampViewPositionVertical(View child, int top, int dy) {\n    }\n\n    // 手指拖拽后释放\n    // releasedChild 拖拽的view\n    // xvel, yvel拖拽动速度\n    @Override\n    public void onViewReleased(View releasedChild, float xvel, float yvel) {\n    }\n};\n```\n\nViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法\n\n还有一些常用的关于边缘滑动相关的重写方法\n\n在这里就不写了\n\n## 例子\n\n实现一个支持拖拽, 有粘性的ViewGroup\n\n```java\npublic class DragLayout extends LinearLayout {\n\n    private float mRaftValue = UIUtils.dip2Px(getContext(), 20); //回弹临界距离\n\n    private float mRaftYVel = 1000.0f; // 回弹临界速度\n\n    private ViewDragHelper mDragHelper;\n\n    private OnDismissListener mOnDismissListener;\n\n    private boolean mDragToggle = true;\n\n    public DragLayout(@NonNull Context context) {\n        this(context, null);\n    }\n\n    public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n    public void setOnDismissListener(OnDismissListener onDismissListener) {\n        mOnDismissListener = onDismissListener;\n    }\n\n    private void init() {\n        ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {\n            private int mCurrentTop;\n\n            @Override\n            public boolean tryCaptureView(@NonNull View child, int pointerId) {\n                return mDragToggle;\n            }\n\n\n            @Override\n            public int clampViewPositionVertical(@NonNull View child, int top, int dy) {\n                // 禁止向上滑动\n                if (top < 0) {\n                    top = 0;\n                }\n                mCurrentTop = top;\n                return top;\n            }\n\n            @Override\n            public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) {\n                super.onViewReleased(releasedChild, xvel, yvel);\n                // 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画\n                // 还需要限定一个速度，优化用户体验\n                if (mCurrentTop <= mRaftValue && yvel <= mRaftYVel) {\n                    mDragHelper.settleCapturedViewAt(0, 0);\n                    invalidate();\n                } else { // 从底部滑出\n                    if (mOnDismissListener != null) {\n                        mOnDismissListener.onDismiss();\n                    }\n                }\n            }\n\n            // 响应垂直滑动事件\n            // 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件\n            // 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中,\n            // 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截.\n            // 所以需要重写并返回一个非0值\n            @Override\n            public int getViewVerticalDragRange(@NonNull View child) {\n                return 1;\n            }\n        };\n\n        mDragHelper = ViewDragHelper.create(this, callback);\n\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        return super.dispatchTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n\n        return mDragHelper.shouldInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        try {\n            mDragHelper.processTouchEvent(event);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return true;\n    }\n\n    @Override\n    public void computeScroll() {\n        if (mDragHelper != null && mDragHelper.continueSettling(true)) {\n            invalidate();\n        }\n    }\n\n    public interface OnDismissListener {\n        void onDismiss();\n    }\n}\n```\n\n**注意** 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽","source":"_posts/Android/ViewDragHelper的使用.md","raw":"---\ntitle: ViewDragHelper的使用\ndate: 2020-02-19 10:36:30\ntags:\n- View\ncategories:\n- Android\n---\n\nViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部\n\n**参考**\n\n[ViewDragHelper 的基本使用](https://www.jianshu.com/p/a9e0a98e4d42)\n\n# 常用Api\n\n**初始化**\n\n```java\npublic static ViewDragHelper create(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb)\n```\n\n第一个参数是父布局, 第二个参数是自定义的监听回调\n\n**拦截事件**\n\n在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断\n\n```java\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\n    //ViewDragHelper对事件进行拦截\n    //注意, ACTION_DOWN事件不会被拦截\n    //当clampViewPositionXxx方法没有修改left或top值时, 不会拦截\n    //是的, shouldInterceptTouchEvent中会调用callback.clampViewPositionXxx方法\n    return mViewDragHelper.shouldInterceptTouchEvent(ev);\n}\n\n@Override\npublic boolean onTouchEvent(MotionEvent event) {\n    //将事件传递给ViewDragHelper进行处理\n    mViewDragHelper.processTouchEvent(event);\n    return true;\n}\n```\n\n**处理computeScroll**\n\n因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法)\n\n```java\n@Override\npublic void computeScroll() {\n    super.computeScroll();\n    if (mViewDragHelper != null && mViewDragHelper.continueSettling(true)){\n        invalidate();\n    }\n}\n```\n\n**处理CallBack回调**\n\n```java\nprivate ViewDragHelper.Callback mCallback = new ViewDragHelper.Callback() {\n\n    // tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动\n    @Override\n    public boolean tryCaptureView(View child, int pointerId) {\n    }\n\n    // clampViewPositionHorizontal() 判断水平方向上将要移动到的位置\n    // left 将要移动到的left值\n    // dx 表示速度\n    @Override\n    public int clampViewPositionHorizontal(View child, int left, int dx) {\n    }\n\n    // 同clampViewPositionHorizontal(), 换成了垂直方向而已\n    @Override\n    public int clampViewPositionVertical(View child, int top, int dy) {\n    }\n\n    // 手指拖拽后释放\n    // releasedChild 拖拽的view\n    // xvel, yvel拖拽动速度\n    @Override\n    public void onViewReleased(View releasedChild, float xvel, float yvel) {\n    }\n};\n```\n\nViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法\n\n还有一些常用的关于边缘滑动相关的重写方法\n\n在这里就不写了\n\n## 例子\n\n实现一个支持拖拽, 有粘性的ViewGroup\n\n```java\npublic class DragLayout extends LinearLayout {\n\n    private float mRaftValue = UIUtils.dip2Px(getContext(), 20); //回弹临界距离\n\n    private float mRaftYVel = 1000.0f; // 回弹临界速度\n\n    private ViewDragHelper mDragHelper;\n\n    private OnDismissListener mOnDismissListener;\n\n    private boolean mDragToggle = true;\n\n    public DragLayout(@NonNull Context context) {\n        this(context, null);\n    }\n\n    public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n    public void setOnDismissListener(OnDismissListener onDismissListener) {\n        mOnDismissListener = onDismissListener;\n    }\n\n    private void init() {\n        ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {\n            private int mCurrentTop;\n\n            @Override\n            public boolean tryCaptureView(@NonNull View child, int pointerId) {\n                return mDragToggle;\n            }\n\n\n            @Override\n            public int clampViewPositionVertical(@NonNull View child, int top, int dy) {\n                // 禁止向上滑动\n                if (top < 0) {\n                    top = 0;\n                }\n                mCurrentTop = top;\n                return top;\n            }\n\n            @Override\n            public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) {\n                super.onViewReleased(releasedChild, xvel, yvel);\n                // 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画\n                // 还需要限定一个速度，优化用户体验\n                if (mCurrentTop <= mRaftValue && yvel <= mRaftYVel) {\n                    mDragHelper.settleCapturedViewAt(0, 0);\n                    invalidate();\n                } else { // 从底部滑出\n                    if (mOnDismissListener != null) {\n                        mOnDismissListener.onDismiss();\n                    }\n                }\n            }\n\n            // 响应垂直滑动事件\n            // 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件\n            // 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中,\n            // 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截.\n            // 所以需要重写并返回一个非0值\n            @Override\n            public int getViewVerticalDragRange(@NonNull View child) {\n                return 1;\n            }\n        };\n\n        mDragHelper = ViewDragHelper.create(this, callback);\n\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        return super.dispatchTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n\n        return mDragHelper.shouldInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        try {\n            mDragHelper.processTouchEvent(event);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return true;\n    }\n\n    @Override\n    public void computeScroll() {\n        if (mDragHelper != null && mDragHelper.continueSettling(true)) {\n            invalidate();\n        }\n    }\n\n    public interface OnDismissListener {\n        void onDismiss();\n    }\n}\n```\n\n**注意** 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽","slug":"Android/ViewDragHelper的使用","published":1,"updated":"2020-03-25T03:42:33.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakr8002w8mzmpmfucx7z","content":"<p>ViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部</p><a id=\"more\"></a>\n<p><strong>参考</strong></p>\n<p><a href=\"https://www.jianshu.com/p/a9e0a98e4d42\" target=\"_blank\" rel=\"noopener\">ViewDragHelper 的基本使用</a></p>\n<h1 id=\"常用Api\"><a href=\"#常用Api\" class=\"headerlink\" title=\"常用Api\"></a>常用Api</h1><p><strong>初始化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewDragHelper <span class=\"title\">create</span><span class=\"params\">(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb)</span></span></span><br></pre></td></tr></table></figure>\n<p>第一个参数是父布局, 第二个参数是自定义的监听回调</p>\n<p><strong>拦截事件</strong></p>\n<p>在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ViewDragHelper对事件进行拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//注意, ACTION_DOWN事件不会被拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//当clampViewPositionXxx方法没有修改left或top值时, 不会拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//是的, shouldInterceptTouchEvent中会调用callback.clampViewPositionXxx方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将事件传递给ViewDragHelper进行处理</span></span><br><span class=\"line\">    mViewDragHelper.processTouchEvent(event);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>处理computeScroll</strong></p>\n<p>因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.computeScroll();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mViewDragHelper != <span class=\"keyword\">null</span> &amp;&amp; mViewDragHelper.continueSettling(<span class=\"keyword\">true</span>))&#123;</span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>处理CallBack回调</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ViewDragHelper.Callback mCallback = <span class=\"keyword\">new</span> ViewDragHelper.Callback() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryCaptureView</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// clampViewPositionHorizontal() 判断水平方向上将要移动到的位置</span></span><br><span class=\"line\">    <span class=\"comment\">// left 将要移动到的left值</span></span><br><span class=\"line\">    <span class=\"comment\">// dx 表示速度</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionHorizontal</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> dx)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 同clampViewPositionHorizontal(), 换成了垂直方向而已</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionVertical</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 手指拖拽后释放</span></span><br><span class=\"line\">    <span class=\"comment\">// releasedChild 拖拽的view</span></span><br><span class=\"line\">    <span class=\"comment\">// xvel, yvel拖拽动速度</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewReleased</span><span class=\"params\">(View releasedChild, <span class=\"keyword\">float</span> xvel, <span class=\"keyword\">float</span> yvel)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>ViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法</p>\n<p>还有一些常用的关于边缘滑动相关的重写方法</p>\n<p>在这里就不写了</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>实现一个支持拖拽, 有粘性的ViewGroup</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DragLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinearLayout</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mRaftValue = UIUtils.dip2Px(getContext(), <span class=\"number\">20</span>); <span class=\"comment\">//回弹临界距离</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mRaftYVel = <span class=\"number\">1000.0f</span>; <span class=\"comment\">// 回弹临界速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewDragHelper mDragHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OnDismissListener mOnDismissListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mDragToggle = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(context, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(context, attrs, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnDismissListener</span><span class=\"params\">(OnDismissListener onDismissListener)</span> </span>&#123;</span><br><span class=\"line\">        mOnDismissListener = onDismissListener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ViewDragHelper.Callback callback = <span class=\"keyword\">new</span> ViewDragHelper.Callback() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentTop;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryCaptureView</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mDragToggle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionVertical</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 禁止向上滑动</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    top = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mCurrentTop = top;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> top;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewReleased</span><span class=\"params\">(@NonNull View releasedChild, <span class=\"keyword\">float</span> xvel, <span class=\"keyword\">float</span> yvel)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onViewReleased(releasedChild, xvel, yvel);</span><br><span class=\"line\">                <span class=\"comment\">// 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画</span></span><br><span class=\"line\">                <span class=\"comment\">// 还需要限定一个速度，优化用户体验</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mCurrentTop &lt;= mRaftValue &amp;&amp; yvel &lt;= mRaftYVel) &#123;</span><br><span class=\"line\">                    mDragHelper.settleCapturedViewAt(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 从底部滑出</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mOnDismissListener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        mOnDismissListener.onDismiss();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 响应垂直滑动事件</span></span><br><span class=\"line\">            <span class=\"comment\">// 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件</span></span><br><span class=\"line\">            <span class=\"comment\">// 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中,</span></span><br><span class=\"line\">            <span class=\"comment\">// 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截.</span></span><br><span class=\"line\">            <span class=\"comment\">// 所以需要重写并返回一个非0值</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getViewVerticalDragRange</span><span class=\"params\">(@NonNull View child)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        mDragHelper = ViewDragHelper.create(<span class=\"keyword\">this</span>, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mDragHelper.processTouchEvent(event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDragHelper != <span class=\"keyword\">null</span> &amp;&amp; mDragHelper.continueSettling(<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnDismissListener</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onDismiss</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong> 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽</p>\n","site":{"data":{}},"excerpt":"<p>ViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部</p>","more":"\n<p><strong>参考</strong></p>\n<p><a href=\"https://www.jianshu.com/p/a9e0a98e4d42\" target=\"_blank\" rel=\"noopener\">ViewDragHelper 的基本使用</a></p>\n<h1 id=\"常用Api\"><a href=\"#常用Api\" class=\"headerlink\" title=\"常用Api\"></a>常用Api</h1><p><strong>初始化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewDragHelper <span class=\"title\">create</span><span class=\"params\">(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb)</span></span></span><br></pre></td></tr></table></figure>\n<p>第一个参数是父布局, 第二个参数是自定义的监听回调</p>\n<p><strong>拦截事件</strong></p>\n<p>在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ViewDragHelper对事件进行拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//注意, ACTION_DOWN事件不会被拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//当clampViewPositionXxx方法没有修改left或top值时, 不会拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//是的, shouldInterceptTouchEvent中会调用callback.clampViewPositionXxx方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将事件传递给ViewDragHelper进行处理</span></span><br><span class=\"line\">    mViewDragHelper.processTouchEvent(event);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>处理computeScroll</strong></p>\n<p>因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.computeScroll();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mViewDragHelper != <span class=\"keyword\">null</span> &amp;&amp; mViewDragHelper.continueSettling(<span class=\"keyword\">true</span>))&#123;</span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>处理CallBack回调</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ViewDragHelper.Callback mCallback = <span class=\"keyword\">new</span> ViewDragHelper.Callback() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryCaptureView</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// clampViewPositionHorizontal() 判断水平方向上将要移动到的位置</span></span><br><span class=\"line\">    <span class=\"comment\">// left 将要移动到的left值</span></span><br><span class=\"line\">    <span class=\"comment\">// dx 表示速度</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionHorizontal</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> dx)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 同clampViewPositionHorizontal(), 换成了垂直方向而已</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionVertical</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 手指拖拽后释放</span></span><br><span class=\"line\">    <span class=\"comment\">// releasedChild 拖拽的view</span></span><br><span class=\"line\">    <span class=\"comment\">// xvel, yvel拖拽动速度</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewReleased</span><span class=\"params\">(View releasedChild, <span class=\"keyword\">float</span> xvel, <span class=\"keyword\">float</span> yvel)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>ViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法</p>\n<p>还有一些常用的关于边缘滑动相关的重写方法</p>\n<p>在这里就不写了</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>实现一个支持拖拽, 有粘性的ViewGroup</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DragLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinearLayout</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mRaftValue = UIUtils.dip2Px(getContext(), <span class=\"number\">20</span>); <span class=\"comment\">//回弹临界距离</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mRaftYVel = <span class=\"number\">1000.0f</span>; <span class=\"comment\">// 回弹临界速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewDragHelper mDragHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OnDismissListener mOnDismissListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mDragToggle = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(context, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(context, attrs, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnDismissListener</span><span class=\"params\">(OnDismissListener onDismissListener)</span> </span>&#123;</span><br><span class=\"line\">        mOnDismissListener = onDismissListener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ViewDragHelper.Callback callback = <span class=\"keyword\">new</span> ViewDragHelper.Callback() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentTop;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryCaptureView</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mDragToggle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionVertical</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 禁止向上滑动</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    top = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mCurrentTop = top;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> top;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewReleased</span><span class=\"params\">(@NonNull View releasedChild, <span class=\"keyword\">float</span> xvel, <span class=\"keyword\">float</span> yvel)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onViewReleased(releasedChild, xvel, yvel);</span><br><span class=\"line\">                <span class=\"comment\">// 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画</span></span><br><span class=\"line\">                <span class=\"comment\">// 还需要限定一个速度，优化用户体验</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mCurrentTop &lt;= mRaftValue &amp;&amp; yvel &lt;= mRaftYVel) &#123;</span><br><span class=\"line\">                    mDragHelper.settleCapturedViewAt(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 从底部滑出</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mOnDismissListener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        mOnDismissListener.onDismiss();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 响应垂直滑动事件</span></span><br><span class=\"line\">            <span class=\"comment\">// 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件</span></span><br><span class=\"line\">            <span class=\"comment\">// 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中,</span></span><br><span class=\"line\">            <span class=\"comment\">// 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截.</span></span><br><span class=\"line\">            <span class=\"comment\">// 所以需要重写并返回一个非0值</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getViewVerticalDragRange</span><span class=\"params\">(@NonNull View child)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        mDragHelper = ViewDragHelper.create(<span class=\"keyword\">this</span>, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mDragHelper.processTouchEvent(event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDragHelper != <span class=\"keyword\">null</span> &amp;&amp; mDragHelper.continueSettling(<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnDismissListener</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onDismiss</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong> 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽</p>\n"},{"title":"通知铃声的自定义遇到的问题-根据uri读取文件","date":"2019-08-28T15:07:53.000Z","Categories":["Android"],"_content":"\n# 通知铃声自定义遇到的问题: 根据uri读取文件\n\n## 问题：\n在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音\n\n## 问题根源：\n### 1.从系统文件管理器中获取文件，从得到的uri中获取原始路径\n\n**所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的**\n\n网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。\n\n正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。\n\n```\nInputStream fis = getContentResolver().openInputStream(uri);\n```\n\n### 2. 将拷贝的文件转化为uri\n\n**失败的尝试：使用Uri.fromFile():**\n首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。\n\n在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法.\n\n### 3. grantUriPermission()\n\n在某些机型中，使用file自定义notification的声音，仍然不能正常工作。\n**设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning**\n为什么要选择No Filter选项才会看到这个warning。\n是因为，弹出notification是系统服务，和我们的APP项目不是一个包名\n在file转uri之后添加一个授权的语句就可以了：\n```\ngetApplicationContext().grantUriPermission(\"com.android.systemui\",\n                Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION);\n```\n包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作\n\n到这里问题就解决了\n","source":"_posts/Android/通知铃声的自定义遇到的问题-根据uri读取文件.md","raw":"---\ntitle: 通知铃声的自定义遇到的问题-根据uri读取文件\ndate: 2019-08-28 23:07:53\ntags:\n- Android\n- Notification\n- Uri\nCategories:\n- Android\n---\n\n# 通知铃声自定义遇到的问题: 根据uri读取文件\n\n## 问题：\n在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音\n\n## 问题根源：\n### 1.从系统文件管理器中获取文件，从得到的uri中获取原始路径\n\n**所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的**\n\n网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。\n\n正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。\n\n```\nInputStream fis = getContentResolver().openInputStream(uri);\n```\n\n### 2. 将拷贝的文件转化为uri\n\n**失败的尝试：使用Uri.fromFile():**\n首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。\n\n在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法.\n\n### 3. grantUriPermission()\n\n在某些机型中，使用file自定义notification的声音，仍然不能正常工作。\n**设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning**\n为什么要选择No Filter选项才会看到这个warning。\n是因为，弹出notification是系统服务，和我们的APP项目不是一个包名\n在file转uri之后添加一个授权的语句就可以了：\n```\ngetApplicationContext().grantUriPermission(\"com.android.systemui\",\n                Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION);\n```\n包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作\n\n到这里问题就解决了\n","slug":"Android/通知铃声的自定义遇到的问题-根据uri读取文件","published":1,"updated":"2019-12-21T12:16:41.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakr9002z8mzmp569zurq","content":"<h1 id=\"通知铃声自定义遇到的问题-根据uri读取文件\"><a href=\"#通知铃声自定义遇到的问题-根据uri读取文件\" class=\"headerlink\" title=\"通知铃声自定义遇到的问题: 根据uri读取文件\"></a>通知铃声自定义遇到的问题: 根据uri读取文件</h1><a id=\"more\"></a><h2 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h2><p>在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音</p>\n<h2 id=\"问题根源：\"><a href=\"#问题根源：\" class=\"headerlink\" title=\"问题根源：\"></a>问题根源：</h2><h3 id=\"1-从系统文件管理器中获取文件，从得到的uri中获取原始路径\"><a href=\"#1-从系统文件管理器中获取文件，从得到的uri中获取原始路径\" class=\"headerlink\" title=\"1.从系统文件管理器中获取文件，从得到的uri中获取原始路径\"></a>1.从系统文件管理器中获取文件，从得到的uri中获取原始路径</h3><p><strong>所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的</strong></p>\n<p>网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。</p>\n<p>正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream fis = getContentResolver().openInputStream(uri);</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-将拷贝的文件转化为uri\"><a href=\"#2-将拷贝的文件转化为uri\" class=\"headerlink\" title=\"2. 将拷贝的文件转化为uri\"></a>2. 将拷贝的文件转化为uri</h3><p><strong>失败的尝试：使用Uri.fromFile():</strong><br>首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。</p>\n<p>在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法.</p>\n<h3 id=\"3-grantUriPermission\"><a href=\"#3-grantUriPermission\" class=\"headerlink\" title=\"3. grantUriPermission()\"></a>3. grantUriPermission()</h3><p>在某些机型中，使用file自定义notification的声音，仍然不能正常工作。<br><strong>设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning</strong><br>为什么要选择No Filter选项才会看到这个warning。<br>是因为，弹出notification是系统服务，和我们的APP项目不是一个包名<br>在file转uri之后添加一个授权的语句就可以了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getApplicationContext().grantUriPermission(&quot;com.android.systemui&quot;,</span><br><span class=\"line\">                Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br></pre></td></tr></table></figure></p>\n<p>包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作</p>\n<p>到这里问题就解决了</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"通知铃声自定义遇到的问题-根据uri读取文件\"><a href=\"#通知铃声自定义遇到的问题-根据uri读取文件\" class=\"headerlink\" title=\"通知铃声自定义遇到的问题: 根据uri读取文件\"></a>通知铃声自定义遇到的问题: 根据uri读取文件</h1>","more":"<h2 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h2><p>在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音</p>\n<h2 id=\"问题根源：\"><a href=\"#问题根源：\" class=\"headerlink\" title=\"问题根源：\"></a>问题根源：</h2><h3 id=\"1-从系统文件管理器中获取文件，从得到的uri中获取原始路径\"><a href=\"#1-从系统文件管理器中获取文件，从得到的uri中获取原始路径\" class=\"headerlink\" title=\"1.从系统文件管理器中获取文件，从得到的uri中获取原始路径\"></a>1.从系统文件管理器中获取文件，从得到的uri中获取原始路径</h3><p><strong>所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的</strong></p>\n<p>网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。</p>\n<p>正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream fis = getContentResolver().openInputStream(uri);</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-将拷贝的文件转化为uri\"><a href=\"#2-将拷贝的文件转化为uri\" class=\"headerlink\" title=\"2. 将拷贝的文件转化为uri\"></a>2. 将拷贝的文件转化为uri</h3><p><strong>失败的尝试：使用Uri.fromFile():</strong><br>首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。</p>\n<p>在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法.</p>\n<h3 id=\"3-grantUriPermission\"><a href=\"#3-grantUriPermission\" class=\"headerlink\" title=\"3. grantUriPermission()\"></a>3. grantUriPermission()</h3><p>在某些机型中，使用file自定义notification的声音，仍然不能正常工作。<br><strong>设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning</strong><br>为什么要选择No Filter选项才会看到这个warning。<br>是因为，弹出notification是系统服务，和我们的APP项目不是一个包名<br>在file转uri之后添加一个授权的语句就可以了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getApplicationContext().grantUriPermission(&quot;com.android.systemui&quot;,</span><br><span class=\"line\">                Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br></pre></td></tr></table></figure></p>\n<p>包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作</p>\n<p>到这里问题就解决了</p>\n"},{"title":"Flutter中常用布局和Android的对应关系","date":"2020-02-26T07:49:51.000Z","_content":"\n![图片](/images/flutter相关属性和android的对应关系.webp)\n\n\n\n\n","source":"_posts/Flutter/Flutter中常用布局和Android的对应关系.md","raw":"---\ntitle: Flutter中常用布局和Android的对应关系\ndate: 2020-02-26 15:49:51\ntags:\n- Flutter\ncategories:\n- Flutter\n---\n\n![图片](/images/flutter相关属性和android的对应关系.webp)\n\n\n\n\n","slug":"Flutter/Flutter中常用布局和Android的对应关系","published":1,"updated":"2020-02-26T07:54:10.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakra00328mzmcqh1x92w","content":"<p><img src=\"/images/flutter相关属性和android的对应关系.webp\" alt=\"图片\"></p>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/flutter相关属性和android的对应关系.webp\" alt=\"图片\"></p>"},{"title":"RenderObject 原理","date":"2020-09-22T08:28:21.000Z","cateogries":["Flutter"],"_content":"\n\n## re\n\n<img src='https://g.gravizo.com/svg?\nabstract class AbstractList;\ninterface List;\nList <|.. AbstractList;\n'/>\n\n<img src='https://g.gravizo.com/svg?\nBoxParentData --|> ParentData\nContainerParentDataMixin --|> ParentData\nContainerBoxParentData --|> BoxParentData\nContainerBoxParentData --|> ContainerParentDataMixin\nRenderObject *-- ParentData\nRenderObjectWithChildMixin --|> RenderObject\nContainerRenderObjectMixin --|> RenderObject\nclass ContainerParentDataMixin{\n+ previousSlibling\n+ nextSibling\n};\nclass ContainerRenderObjectMixin {\n+ firstChild *-- ContainerParentDataMixin\n+ lastChild\n+ childCount\n};\nclass BoxParentData{\n+ offset\n};\nclass RenderObject{\n+ parentData\n};\n'/>\n","source":"_posts/Flutter/RenderObject-原理.md","raw":"---\ntitle: RenderObject 原理\ndate: 2020-09-22 16:28:21\ntags:\n- Flutter\n- RenderObject\ncateogries:\n- Flutter\n---\n\n\n## re\n\n<img src='https://g.gravizo.com/svg?\nabstract class AbstractList;\ninterface List;\nList <|.. AbstractList;\n'/>\n\n<img src='https://g.gravizo.com/svg?\nBoxParentData --|> ParentData\nContainerParentDataMixin --|> ParentData\nContainerBoxParentData --|> BoxParentData\nContainerBoxParentData --|> ContainerParentDataMixin\nRenderObject *-- ParentData\nRenderObjectWithChildMixin --|> RenderObject\nContainerRenderObjectMixin --|> RenderObject\nclass ContainerParentDataMixin{\n+ previousSlibling\n+ nextSibling\n};\nclass ContainerRenderObjectMixin {\n+ firstChild *-- ContainerParentDataMixin\n+ lastChild\n+ childCount\n};\nclass BoxParentData{\n+ offset\n};\nclass RenderObject{\n+ parentData\n};\n'/>\n","slug":"Flutter/RenderObject-原理","published":1,"updated":"2020-09-22T09:33:17.268Z","_id":"ckfdrakrb00358mzmm87g1ol9","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"re\"><a href=\"#re\" class=\"headerlink\" title=\"re\"></a>re</h2><p><img src=\"https://g.gravizo.com/svg?\nabstract class AbstractList;\ninterface List;\nList <|.. AbstractList;\n\"></p><p>&lt;img src=’<a href=\"https://g.gravizo.com/svg\" target=\"_blank\" rel=\"noopener\">https://g.gravizo.com/svg</a>?<br>BoxParentData –|&gt; ParentData<br>ContainerParentDataMixin –|&gt; ParentData<br>ContainerBoxParentData –|&gt; BoxParentData<br>ContainerBoxParentData –|&gt; ContainerParentDataMixin<br>RenderObject *– ParentData<br>RenderObjectWithChildMixin –|&gt; RenderObject<br>ContainerRenderObjectMixin –|&gt; RenderObject<br>class ContainerParentDataMixin{</p><a id=\"more\"></a>\n\n<ul>\n<li>previousSlibling</li>\n<li>nextSibling<br>};<br>class ContainerRenderObjectMixin {</li>\n<li>firstChild *– ContainerParentDataMixin</li>\n<li>lastChild</li>\n<li>childCount<br>};<br>class BoxParentData{</li>\n<li>offset<br>};<br>class RenderObject{</li>\n<li>parentData<br>};<br>‘/&gt;</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"re\"><a href=\"#re\" class=\"headerlink\" title=\"re\"></a>re</h2><p><img src=\"https://g.gravizo.com/svg?\nabstract class AbstractList;\ninterface List;\nList <|.. AbstractList;\n\"></p><p>&lt;img src=’<a href=\"https://g.gravizo.com/svg\" target=\"_blank\" rel=\"noopener\">https://g.gravizo.com/svg</a>?<br>BoxParentData –|&gt; ParentData<br>ContainerParentDataMixin –|&gt; ParentData<br>ContainerBoxParentData –|&gt; BoxParentData<br>ContainerBoxParentData –|&gt; ContainerParentDataMixin<br>RenderObject *– ParentData<br>RenderObjectWithChildMixin –|&gt; RenderObject<br>ContainerRenderObjectMixin –|&gt; RenderObject<br>class ContainerParentDataMixin{</p>","more":"\n\n<ul>\n<li>previousSlibling</li>\n<li>nextSibling<br>};<br>class ContainerRenderObjectMixin {</li>\n<li>firstChild *– ContainerParentDataMixin</li>\n<li>lastChild</li>\n<li>childCount<br>};<br>class BoxParentData{</li>\n<li>offset<br>};<br>class RenderObject{</li>\n<li>parentData<br>};<br>‘/&gt;</li>\n</ul>\n"},{"title":"ThreadLocal","date":"2019-07-22T05:57:12.000Z","_content":"\n# ThreadLocal\n\n## 作用\n\n**当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量**\n\n## 源码分析\n\n### set()\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n\ncreateMap()方法：\n```java\nvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n```\n查看Thread类的代码：\n```java\n/* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n**Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value**\n\n### get()方法\n```java\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n```\n其中的ThreadLocalMap.Entry\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\n**Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己**\n\n### 总结\n**Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值**\n","source":"_posts/Java/ThreadLocal.md","raw":"---\ntitle: ThreadLocal\ndate: 2019-07-22 13:57:12\ntags:\n- 多线程\ncategories:\n- java\n- 多线程\n---\n\n# ThreadLocal\n\n## 作用\n\n**当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量**\n\n## 源码分析\n\n### set()\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n\ncreateMap()方法：\n```java\nvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n```\n查看Thread类的代码：\n```java\n/* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n**Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value**\n\n### get()方法\n```java\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n```\n其中的ThreadLocalMap.Entry\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\n**Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己**\n\n### 总结\n**Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值**\n","slug":"Java/ThreadLocal","published":1,"updated":"2019-12-21T12:16:41.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakrc00388mzmtsddv9g0","content":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p><strong>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量</strong></p><a id=\"more\"></a>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>createMap()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">        t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看Thread类的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class=\"line\"><span class=\"comment\">     * by the ThreadLocal class. */</span></span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value</strong></p>\n<h3 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get()方法\"></a>get()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的ThreadLocalMap.Entry<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p><strong>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量</strong></p>","more":"\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>createMap()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">        t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看Thread类的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class=\"line\"><span class=\"comment\">     * by the ThreadLocal class. */</span></span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value</strong></p>\n<h3 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get()方法\"></a>get()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的ThreadLocalMap.Entry<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值</strong></p>\n"},{"title":"kotlin协程","date":"2020-07-15T03:30:02.000Z","_content":"\n\n## Async\n\n首先看一个例子，先后调用两个挂起函数\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了一些有用的事\n    return 29\n}\n\n/** 输出\n\nThe answer is 42\nCompleted in 2017 ms\n\n**/\n```\n\n可以发现，两个挂起函数是同步执行的，有先后顺序\n\n使用async\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了些有用的事\n    return 29\n}\n\n/** 输出\nThe answer is 42\nCompleted in 1024 ms\n**/\n```\n\n在结果耗时上，两个挂起方法达到了异步的效果。这得益于`async`关键字\n在概念上，`async` 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。\n\n## 调度器与线程\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    launch { // 运行在父协程的上下文中，即 runBlocking 主协程\n        println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Unconfined) { // 不受限的——将工作在主线程中\n        println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Default) { // 将会获取默认调度器\n        println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // 将使它获得一个新的线程\n        println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n    }    \n}\n\n/** 输出 注意先后顺序\n\nUnconfined            : I'm working in thread main @coroutine#3\nDefault               : I'm working in thread DefaultDispatcher-worker-1 @coroutine#4\nmain runBlocking      : I'm working in thread main @coroutine#2\nnewSingleThreadContext: I'm working in thread MyOwnThread @coroutine#5\n\n**/\n```\n\n* `launch { …… }` :\n    * 当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。\n* `launch(Dispatchers.Default) { …… }` :\n    * 当协程在 GlobalScope 中启动时，使用的是由` Dispatchers.Default `代表的默认调度器。 默认调度器使用共享的后台线程池。 所以` launch(Dispatchers.Default) { …… } `与` GlobalScope.launch { …… } `使用相同的调度器。 \n    `Dispatchers.Default `适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list\n* `launch(Dispatchers.IO) { …… }` :\n    * 针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 \n* `launch(newSingleThreadContext(\"...\")) { ... }` :\n    * `newSingleThreadContext` 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 `close` 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。???\n* `launch(Dispatchers.Unconfined) { ... }` :\n    * 完全没搞懂这玩意儿..\n\n\n## 在Android中使用协程作用域\n\n```kotlin\nimport kotlinx.coroutines.*\n\nclass Activity {\n    private val mainScope = MainScope()\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n\n    fun doSomething() {\n        // 在示例中启动了 10 个协程，且每个都工作了不同的时长\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // Activity 类结束\n\nfun main() = runBlocking<Unit> {\n    val activity = Activity()\n    activity.doSomething() // 运行测试函数\n    println(\"Launched coroutines\")\n    delay(500L) // 延迟半秒钟\n    println(\"Destroying activity!\")\n    activity.destroy() // 取消所有的协程\n    delay(1000) // 为了在视觉上确认它们没有工作    \n}\n```\n\n通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 `Dispatchers.Main` 作为默认调度器的 UI 应用程序 创建作用域.\n\n在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程\n\n## 异步流\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = flow { // 流构建器\n    for (i in 1..3) {\n        delay(100) // 假装我们在这里做了一些有用的事情\n        emit(i) // 发送下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // 启动并发的协程以验证主线程并未阻塞\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // 收集这个流\n    foo().collect { value -> println(value) } \n}\n\n/** 输出\n\nI'm not blocked 1\n1\nI'm not blocked 2\n2\nI'm not blocked 3\n3\n**/\n```\n\n上方的程序: \n* 名为 flow 的 Flow 类型构建器函数。\n* flow { ... } 构建块中的代码可以挂起。\n* 函数 foo() 不再标有 suspend 修饰符。\n* 流使用 emit 函数 发射 值。\n* 流使用 collect 函数 收集 值。\n\nkotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算\n\n## suspendCancellableCoroutine\n\n```kotlin\nprivate suspend fun loadPageSuspend(productCategoryType: Int, page: Int): ProductListLoadResultBean =\n            suspendCancellableCoroutine { cnt ->\n                ProductManagementAPI.requestProductList(\n                        category = productCategoryType,\n                        page = page,\n                        keyword = getKeyword(),\n                        orderBy = getOrderType(),\n                        desc =  isOrderDesc(),\n                        listener = object : INetRequestListener<ProductListLoadResultBean> {\n                            override fun onSuccess(result: DataHull<ProductListLoadResultBean>?) {\n                                result?.let {\n                                    cnt.resumeWith(Result.success(it.data))\n\n                                } ?: kotlin.run {\n                                    cnt.resumeWithException(Exception())\n                                }\n                            }\n\n                            override fun onError(error: DataHull<ProductListLoadResultBean>?, isNetError: Boolean) {\n                                cnt.resumeWithException(Exception(error?.stateBean?.message))\n                            }\n\n                        }\n                )\n            }\n```\n","source":"_posts/Android/kotlin协程.md","raw":"---\ntitle: kotlin协程\ndate: 2020-07-15 11:30:02\ntags: \n- Kotlin\ncategories:\n- Kotlin\n---\n\n\n## Async\n\n首先看一个例子，先后调用两个挂起函数\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了一些有用的事\n    return 29\n}\n\n/** 输出\n\nThe answer is 42\nCompleted in 2017 ms\n\n**/\n```\n\n可以发现，两个挂起函数是同步执行的，有先后顺序\n\n使用async\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了些有用的事\n    return 29\n}\n\n/** 输出\nThe answer is 42\nCompleted in 1024 ms\n**/\n```\n\n在结果耗时上，两个挂起方法达到了异步的效果。这得益于`async`关键字\n在概念上，`async` 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。\n\n## 调度器与线程\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    launch { // 运行在父协程的上下文中，即 runBlocking 主协程\n        println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Unconfined) { // 不受限的——将工作在主线程中\n        println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Default) { // 将会获取默认调度器\n        println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // 将使它获得一个新的线程\n        println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n    }    \n}\n\n/** 输出 注意先后顺序\n\nUnconfined            : I'm working in thread main @coroutine#3\nDefault               : I'm working in thread DefaultDispatcher-worker-1 @coroutine#4\nmain runBlocking      : I'm working in thread main @coroutine#2\nnewSingleThreadContext: I'm working in thread MyOwnThread @coroutine#5\n\n**/\n```\n\n* `launch { …… }` :\n    * 当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。\n* `launch(Dispatchers.Default) { …… }` :\n    * 当协程在 GlobalScope 中启动时，使用的是由` Dispatchers.Default `代表的默认调度器。 默认调度器使用共享的后台线程池。 所以` launch(Dispatchers.Default) { …… } `与` GlobalScope.launch { …… } `使用相同的调度器。 \n    `Dispatchers.Default `适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list\n* `launch(Dispatchers.IO) { …… }` :\n    * 针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 \n* `launch(newSingleThreadContext(\"...\")) { ... }` :\n    * `newSingleThreadContext` 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 `close` 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。???\n* `launch(Dispatchers.Unconfined) { ... }` :\n    * 完全没搞懂这玩意儿..\n\n\n## 在Android中使用协程作用域\n\n```kotlin\nimport kotlinx.coroutines.*\n\nclass Activity {\n    private val mainScope = MainScope()\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n\n    fun doSomething() {\n        // 在示例中启动了 10 个协程，且每个都工作了不同的时长\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // Activity 类结束\n\nfun main() = runBlocking<Unit> {\n    val activity = Activity()\n    activity.doSomething() // 运行测试函数\n    println(\"Launched coroutines\")\n    delay(500L) // 延迟半秒钟\n    println(\"Destroying activity!\")\n    activity.destroy() // 取消所有的协程\n    delay(1000) // 为了在视觉上确认它们没有工作    \n}\n```\n\n通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 `Dispatchers.Main` 作为默认调度器的 UI 应用程序 创建作用域.\n\n在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程\n\n## 异步流\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = flow { // 流构建器\n    for (i in 1..3) {\n        delay(100) // 假装我们在这里做了一些有用的事情\n        emit(i) // 发送下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // 启动并发的协程以验证主线程并未阻塞\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // 收集这个流\n    foo().collect { value -> println(value) } \n}\n\n/** 输出\n\nI'm not blocked 1\n1\nI'm not blocked 2\n2\nI'm not blocked 3\n3\n**/\n```\n\n上方的程序: \n* 名为 flow 的 Flow 类型构建器函数。\n* flow { ... } 构建块中的代码可以挂起。\n* 函数 foo() 不再标有 suspend 修饰符。\n* 流使用 emit 函数 发射 值。\n* 流使用 collect 函数 收集 值。\n\nkotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算\n\n## suspendCancellableCoroutine\n\n```kotlin\nprivate suspend fun loadPageSuspend(productCategoryType: Int, page: Int): ProductListLoadResultBean =\n            suspendCancellableCoroutine { cnt ->\n                ProductManagementAPI.requestProductList(\n                        category = productCategoryType,\n                        page = page,\n                        keyword = getKeyword(),\n                        orderBy = getOrderType(),\n                        desc =  isOrderDesc(),\n                        listener = object : INetRequestListener<ProductListLoadResultBean> {\n                            override fun onSuccess(result: DataHull<ProductListLoadResultBean>?) {\n                                result?.let {\n                                    cnt.resumeWith(Result.success(it.data))\n\n                                } ?: kotlin.run {\n                                    cnt.resumeWithException(Exception())\n                                }\n                            }\n\n                            override fun onError(error: DataHull<ProductListLoadResultBean>?, isNetError: Boolean) {\n                                cnt.resumeWithException(Exception(error?.stateBean?.message))\n                            }\n\n                        }\n                )\n            }\n```\n","slug":"Android/kotlin协程","published":1,"updated":"2020-07-15T08:55:08.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakrc003a8mzmnosh8q05","content":"<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><p>首先看一个例子，先后调用两个挂起函数</p><a id=\"more\"></a>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> one = doSomethingUsefulOne()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> two = doSomethingUsefulTwo()</span><br><span class=\"line\">        println(<span class=\"string\">\"The answer is <span class=\"subst\">$&#123;one + two&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">\"Completed in <span class=\"variable\">$time</span> ms\"</span>)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulOne</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">13</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulTwo</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里也做了一些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">29</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">The answer is 42</span></span><br><span class=\"line\"><span class=\"comment\">Completed in 2017 ms</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，两个挂起函数是同步执行的，有先后顺序</p>\n<p>使用async</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class=\"line\">        println(<span class=\"string\">\"The answer is <span class=\"subst\">$&#123;one.await() + two.await()&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">\"Completed in <span class=\"variable\">$time</span> ms\"</span>)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulOne</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">13</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulTwo</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里也做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">29</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\">The answer is 42</span></span><br><span class=\"line\"><span class=\"comment\">Completed in 1024 ms</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>在结果耗时上，两个挂起方法达到了异步的效果。这得益于<code>async</code>关键字<br>在概念上，<code>async</code> 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p>\n<h2 id=\"调度器与线程\"><a href=\"#调度器与线程\" class=\"headerlink\" title=\"调度器与线程\"></a>调度器与线程</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    launch &#123; <span class=\"comment\">// 运行在父协程的上下文中，即 runBlocking 主协程</span></span><br><span class=\"line\">        println(<span class=\"string\">\"main runBlocking      : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(Dispatchers.Unconfined) &#123; <span class=\"comment\">// 不受限的——将工作在主线程中</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Unconfined            : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(Dispatchers.Default) &#123; <span class=\"comment\">// 将会获取默认调度器</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Default               : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(newSingleThreadContext(<span class=\"string\">\"MyOwnThread\"</span>)) &#123; <span class=\"comment\">// 将使它获得一个新的线程</span></span><br><span class=\"line\">        println(<span class=\"string\">\"newSingleThreadContext: I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出 注意先后顺序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Unconfined            : I'm working in thread main <span class=\"doctag\">@coroutine</span>#3</span></span><br><span class=\"line\"><span class=\"comment\">Default               : I'm working in thread DefaultDispatcher-worker-1 <span class=\"doctag\">@coroutine</span>#4</span></span><br><span class=\"line\"><span class=\"comment\">main runBlocking      : I'm working in thread main <span class=\"doctag\">@coroutine</span>#2</span></span><br><span class=\"line\"><span class=\"comment\">newSingleThreadContext: I'm working in thread MyOwnThread <span class=\"doctag\">@coroutine</span>#5</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>launch { …… }</code> :<ul>\n<li>当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.Default) { …… }</code> :<ul>\n<li>当协程在 GlobalScope 中启动时，使用的是由<code>Dispatchers.Default</code>代表的默认调度器。 默认调度器使用共享的后台线程池。 所以<code>launch(Dispatchers.Default) { …… }</code>与<code>GlobalScope.launch { …… }</code>使用相同的调度器。<br><code>Dispatchers.Default</code>适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.IO) { …… }</code> :<ul>\n<li>针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 </li>\n</ul>\n</li>\n<li><code>launch(newSingleThreadContext(&quot;...&quot;)) { ... }</code> :<ul>\n<li><code>newSingleThreadContext</code> 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 <code>close</code> 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。???</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.Unconfined) { ... }</code> :<ul>\n<li>完全没搞懂这玩意儿..</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在Android中使用协程作用域\"><a href=\"#在Android中使用协程作用域\" class=\"headerlink\" title=\"在Android中使用协程作用域\"></a>在Android中使用协程作用域</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mainScope = MainScope()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mainScope.cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在示例中启动了 10 个协程，且每个都工作了不同的时长</span></span><br><span class=\"line\">        repeat(<span class=\"number\">10</span>) &#123; i -&gt;</span><br><span class=\"line\">            mainScope.launch &#123;</span><br><span class=\"line\">                delay((i + <span class=\"number\">1</span>) * <span class=\"number\">200L</span>) <span class=\"comment\">// 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span></span><br><span class=\"line\">                println(<span class=\"string\">\"Coroutine <span class=\"variable\">$i</span> is done\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// Activity 类结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> activity = Activity()</span><br><span class=\"line\">    activity.doSomething() <span class=\"comment\">// 运行测试函数</span></span><br><span class=\"line\">    println(<span class=\"string\">\"Launched coroutines\"</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">500L</span>) <span class=\"comment\">// 延迟半秒钟</span></span><br><span class=\"line\">    println(<span class=\"string\">\"Destroying activity!\"</span>)</span><br><span class=\"line\">    activity.destroy() <span class=\"comment\">// 取消所有的协程</span></span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>) <span class=\"comment\">// 为了在视觉上确认它们没有工作    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 <code>Dispatchers.Main</code> 作为默认调度器的 UI 应用程序 创建作用域.</p>\n<p>在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程</p>\n<h2 id=\"异步流\"><a href=\"#异步流\" class=\"headerlink\" title=\"异步流\"></a>异步流</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123; <span class=\"comment\">// 流构建器</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们在这里做了一些有用的事情</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发送下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class=\"line\">    launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (k <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"I'm not blocked <span class=\"variable\">$k</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 收集这个流</span></span><br><span class=\"line\">    foo().collect &#123; value -&gt; println(value) &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 1</span></span><br><span class=\"line\"><span class=\"comment\">1</span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 2</span></span><br><span class=\"line\"><span class=\"comment\">2</span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 3</span></span><br><span class=\"line\"><span class=\"comment\">3</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>上方的程序: </p>\n<ul>\n<li>名为 flow 的 Flow 类型构建器函数。</li>\n<li>flow { … } 构建块中的代码可以挂起。</li>\n<li>函数 foo() 不再标有 suspend 修饰符。</li>\n<li>流使用 emit 函数 发射 值。</li>\n<li>流使用 collect 函数 收集 值。</li>\n</ul>\n<p>kotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算</p>\n<h2 id=\"suspendCancellableCoroutine\"><a href=\"#suspendCancellableCoroutine\" class=\"headerlink\" title=\"suspendCancellableCoroutine\"></a>suspendCancellableCoroutine</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadPageSuspend</span><span class=\"params\">(productCategoryType: <span class=\"type\">Int</span>, page: <span class=\"type\">Int</span>)</span></span>: ProductListLoadResultBean =</span><br><span class=\"line\">            suspendCancellableCoroutine &#123; cnt -&gt;</span><br><span class=\"line\">                ProductManagementAPI.requestProductList(</span><br><span class=\"line\">                        category = productCategoryType,</span><br><span class=\"line\">                        page = page,</span><br><span class=\"line\">                        keyword = getKeyword(),</span><br><span class=\"line\">                        orderBy = getOrderType(),</span><br><span class=\"line\">                        desc =  isOrderDesc(),</span><br><span class=\"line\">                        listener = <span class=\"keyword\">object</span> : INetRequestListener&lt;ProductListLoadResultBean&gt; &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(result: <span class=\"type\">DataHull</span>&lt;<span class=\"type\">ProductListLoadResultBean</span>&gt;?)</span></span> &#123;</span><br><span class=\"line\">                                result?.let &#123;</span><br><span class=\"line\">                                    cnt.resumeWith(Result.success(it.<span class=\"keyword\">data</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">                                &#125; ?: kotlin.run &#123;</span><br><span class=\"line\">                                    cnt.resumeWithException(Exception())</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(error: <span class=\"type\">DataHull</span>&lt;<span class=\"type\">ProductListLoadResultBean</span>&gt;?, isNetError: <span class=\"type\">Boolean</span>)</span></span> &#123;</span><br><span class=\"line\">                                cnt.resumeWithException(Exception(error?.stateBean?.message))</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><p>首先看一个例子，先后调用两个挂起函数</p>","more":"\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> one = doSomethingUsefulOne()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> two = doSomethingUsefulTwo()</span><br><span class=\"line\">        println(<span class=\"string\">\"The answer is <span class=\"subst\">$&#123;one + two&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">\"Completed in <span class=\"variable\">$time</span> ms\"</span>)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulOne</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">13</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulTwo</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里也做了一些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">29</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">The answer is 42</span></span><br><span class=\"line\"><span class=\"comment\">Completed in 2017 ms</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，两个挂起函数是同步执行的，有先后顺序</p>\n<p>使用async</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class=\"line\">        println(<span class=\"string\">\"The answer is <span class=\"subst\">$&#123;one.await() + two.await()&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">\"Completed in <span class=\"variable\">$time</span> ms\"</span>)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulOne</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">13</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulTwo</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里也做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">29</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\">The answer is 42</span></span><br><span class=\"line\"><span class=\"comment\">Completed in 1024 ms</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>在结果耗时上，两个挂起方法达到了异步的效果。这得益于<code>async</code>关键字<br>在概念上，<code>async</code> 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p>\n<h2 id=\"调度器与线程\"><a href=\"#调度器与线程\" class=\"headerlink\" title=\"调度器与线程\"></a>调度器与线程</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    launch &#123; <span class=\"comment\">// 运行在父协程的上下文中，即 runBlocking 主协程</span></span><br><span class=\"line\">        println(<span class=\"string\">\"main runBlocking      : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(Dispatchers.Unconfined) &#123; <span class=\"comment\">// 不受限的——将工作在主线程中</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Unconfined            : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(Dispatchers.Default) &#123; <span class=\"comment\">// 将会获取默认调度器</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Default               : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(newSingleThreadContext(<span class=\"string\">\"MyOwnThread\"</span>)) &#123; <span class=\"comment\">// 将使它获得一个新的线程</span></span><br><span class=\"line\">        println(<span class=\"string\">\"newSingleThreadContext: I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出 注意先后顺序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Unconfined            : I'm working in thread main <span class=\"doctag\">@coroutine</span>#3</span></span><br><span class=\"line\"><span class=\"comment\">Default               : I'm working in thread DefaultDispatcher-worker-1 <span class=\"doctag\">@coroutine</span>#4</span></span><br><span class=\"line\"><span class=\"comment\">main runBlocking      : I'm working in thread main <span class=\"doctag\">@coroutine</span>#2</span></span><br><span class=\"line\"><span class=\"comment\">newSingleThreadContext: I'm working in thread MyOwnThread <span class=\"doctag\">@coroutine</span>#5</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>launch { …… }</code> :<ul>\n<li>当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.Default) { …… }</code> :<ul>\n<li>当协程在 GlobalScope 中启动时，使用的是由<code>Dispatchers.Default</code>代表的默认调度器。 默认调度器使用共享的后台线程池。 所以<code>launch(Dispatchers.Default) { …… }</code>与<code>GlobalScope.launch { …… }</code>使用相同的调度器。<br><code>Dispatchers.Default</code>适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.IO) { …… }</code> :<ul>\n<li>针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 </li>\n</ul>\n</li>\n<li><code>launch(newSingleThreadContext(&quot;...&quot;)) { ... }</code> :<ul>\n<li><code>newSingleThreadContext</code> 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 <code>close</code> 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。???</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.Unconfined) { ... }</code> :<ul>\n<li>完全没搞懂这玩意儿..</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在Android中使用协程作用域\"><a href=\"#在Android中使用协程作用域\" class=\"headerlink\" title=\"在Android中使用协程作用域\"></a>在Android中使用协程作用域</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mainScope = MainScope()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mainScope.cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在示例中启动了 10 个协程，且每个都工作了不同的时长</span></span><br><span class=\"line\">        repeat(<span class=\"number\">10</span>) &#123; i -&gt;</span><br><span class=\"line\">            mainScope.launch &#123;</span><br><span class=\"line\">                delay((i + <span class=\"number\">1</span>) * <span class=\"number\">200L</span>) <span class=\"comment\">// 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span></span><br><span class=\"line\">                println(<span class=\"string\">\"Coroutine <span class=\"variable\">$i</span> is done\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// Activity 类结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> activity = Activity()</span><br><span class=\"line\">    activity.doSomething() <span class=\"comment\">// 运行测试函数</span></span><br><span class=\"line\">    println(<span class=\"string\">\"Launched coroutines\"</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">500L</span>) <span class=\"comment\">// 延迟半秒钟</span></span><br><span class=\"line\">    println(<span class=\"string\">\"Destroying activity!\"</span>)</span><br><span class=\"line\">    activity.destroy() <span class=\"comment\">// 取消所有的协程</span></span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>) <span class=\"comment\">// 为了在视觉上确认它们没有工作    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 <code>Dispatchers.Main</code> 作为默认调度器的 UI 应用程序 创建作用域.</p>\n<p>在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程</p>\n<h2 id=\"异步流\"><a href=\"#异步流\" class=\"headerlink\" title=\"异步流\"></a>异步流</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123; <span class=\"comment\">// 流构建器</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们在这里做了一些有用的事情</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发送下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class=\"line\">    launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (k <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"I'm not blocked <span class=\"variable\">$k</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 收集这个流</span></span><br><span class=\"line\">    foo().collect &#123; value -&gt; println(value) &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 1</span></span><br><span class=\"line\"><span class=\"comment\">1</span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 2</span></span><br><span class=\"line\"><span class=\"comment\">2</span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 3</span></span><br><span class=\"line\"><span class=\"comment\">3</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>上方的程序: </p>\n<ul>\n<li>名为 flow 的 Flow 类型构建器函数。</li>\n<li>flow { … } 构建块中的代码可以挂起。</li>\n<li>函数 foo() 不再标有 suspend 修饰符。</li>\n<li>流使用 emit 函数 发射 值。</li>\n<li>流使用 collect 函数 收集 值。</li>\n</ul>\n<p>kotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算</p>\n<h2 id=\"suspendCancellableCoroutine\"><a href=\"#suspendCancellableCoroutine\" class=\"headerlink\" title=\"suspendCancellableCoroutine\"></a>suspendCancellableCoroutine</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadPageSuspend</span><span class=\"params\">(productCategoryType: <span class=\"type\">Int</span>, page: <span class=\"type\">Int</span>)</span></span>: ProductListLoadResultBean =</span><br><span class=\"line\">            suspendCancellableCoroutine &#123; cnt -&gt;</span><br><span class=\"line\">                ProductManagementAPI.requestProductList(</span><br><span class=\"line\">                        category = productCategoryType,</span><br><span class=\"line\">                        page = page,</span><br><span class=\"line\">                        keyword = getKeyword(),</span><br><span class=\"line\">                        orderBy = getOrderType(),</span><br><span class=\"line\">                        desc =  isOrderDesc(),</span><br><span class=\"line\">                        listener = <span class=\"keyword\">object</span> : INetRequestListener&lt;ProductListLoadResultBean&gt; &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(result: <span class=\"type\">DataHull</span>&lt;<span class=\"type\">ProductListLoadResultBean</span>&gt;?)</span></span> &#123;</span><br><span class=\"line\">                                result?.let &#123;</span><br><span class=\"line\">                                    cnt.resumeWith(Result.success(it.<span class=\"keyword\">data</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">                                &#125; ?: kotlin.run &#123;</span><br><span class=\"line\">                                    cnt.resumeWithException(Exception())</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(error: <span class=\"type\">DataHull</span>&lt;<span class=\"type\">ProductListLoadResultBean</span>&gt;?, isNetError: <span class=\"type\">Boolean</span>)</span></span> &#123;</span><br><span class=\"line\">                                cnt.resumeWithException(Exception(error?.stateBean?.message))</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Jni入门","date":"2019-04-13T05:12:47.000Z","categries":["java"],"_content":"\n# Jni入门\n\n参考:\n[JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki](http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html)\n\n### 1、编写native方法，使用javah创建头文件\n```java\npublic class HelloWorld {\n    public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现\n}\n```\n\n```java\njavah -jni -classpath JniCalcINterface \n```\n参数说明：\nclasspath：类搜索路径，这里表示从当前的 bin 目录下查找\nd：将生成的头文件放到当前的 jni 目录下\no： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）\n\n**注意：-d和-o只能使用其中一个参数。**\n\n创建的.h文件如下\n```c++\n/* DO NOT EDIT THIS FILE - it is machine generated */  \n#include <jni.h>  \n/* Header for class com_study_jnilearn_HelloWorld */  \n\n#ifndef _Included_com_study_jnilearn_HelloWorld  \n#define _Included_com_study_jnilearn_HelloWorld  \n#ifdef __cplusplus  \nextern \"C\" {  \n#endif  \n/* \n * Class:     com_study_jnilearn_HelloWorld \n * Method:    sayHello \n * Signature: (Ljava/lang/String;)Ljava/lang/String; \n */  \nJNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello  \n  (JNIEnv *, jclass, jstring);  \n\n#ifdef __cplusplus  \n}  \n#endif  \n#endif  \n```\n\n**注意 extern \"C\"表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern \"C\"后面\n\n### 3、编译出so文件\n```shell\ngcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so  \n```\n\n参数含义:\n\n-L \n* 表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。\n\n-l (L的小写)\n* 表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test\n\n-include\n* 包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。\n\n-I (i 的大写)\n* 指定头文件的所在的目录，可以使用相对路径。\n\n-shared \n* 指定生成动态链接库\n\n-fPIC\n* 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。\n\n-o \n* 指定编译后动态库生成的路径和文件名\n\n### 4、加载动态库\n```java\nstatic{\n    System.loadLibrary(\"HelloWorld\");  //方式一\n    System.load(\"/Users/yangxin/Desktop/libHelloWorld.jnilib\" //方式二);\n}\n```\n方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀\n方式2：指定动态库的绝对路径名，需要加上前缀和后缀 **推荐使用这种方法**\n\n如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。\n有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。\n\n* 将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下\n\n* 给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。\n\n### 5、运行java程序\n\n\n\n","source":"_posts/Java/Jni入门.md","raw":"---\ntitle: Jni入门\ndate: 2019-04-13 13:12:47\ncategries:\n- java\ntags:\n- jni\n---\n\n# Jni入门\n\n参考:\n[JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki](http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html)\n\n### 1、编写native方法，使用javah创建头文件\n```java\npublic class HelloWorld {\n    public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现\n}\n```\n\n```java\njavah -jni -classpath JniCalcINterface \n```\n参数说明：\nclasspath：类搜索路径，这里表示从当前的 bin 目录下查找\nd：将生成的头文件放到当前的 jni 目录下\no： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）\n\n**注意：-d和-o只能使用其中一个参数。**\n\n创建的.h文件如下\n```c++\n/* DO NOT EDIT THIS FILE - it is machine generated */  \n#include <jni.h>  \n/* Header for class com_study_jnilearn_HelloWorld */  \n\n#ifndef _Included_com_study_jnilearn_HelloWorld  \n#define _Included_com_study_jnilearn_HelloWorld  \n#ifdef __cplusplus  \nextern \"C\" {  \n#endif  \n/* \n * Class:     com_study_jnilearn_HelloWorld \n * Method:    sayHello \n * Signature: (Ljava/lang/String;)Ljava/lang/String; \n */  \nJNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello  \n  (JNIEnv *, jclass, jstring);  \n\n#ifdef __cplusplus  \n}  \n#endif  \n#endif  \n```\n\n**注意 extern \"C\"表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern \"C\"后面\n\n### 3、编译出so文件\n```shell\ngcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so  \n```\n\n参数含义:\n\n-L \n* 表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。\n\n-l (L的小写)\n* 表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test\n\n-include\n* 包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。\n\n-I (i 的大写)\n* 指定头文件的所在的目录，可以使用相对路径。\n\n-shared \n* 指定生成动态链接库\n\n-fPIC\n* 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。\n\n-o \n* 指定编译后动态库生成的路径和文件名\n\n### 4、加载动态库\n```java\nstatic{\n    System.loadLibrary(\"HelloWorld\");  //方式一\n    System.load(\"/Users/yangxin/Desktop/libHelloWorld.jnilib\" //方式二);\n}\n```\n方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀\n方式2：指定动态库的绝对路径名，需要加上前缀和后缀 **推荐使用这种方法**\n\n如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。\n有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。\n\n* 将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下\n\n* 给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。\n\n### 5、运行java程序\n\n\n\n","slug":"Java/Jni入门","published":1,"updated":"2019-12-21T12:16:41.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakrd003d8mzmy4j6bptd","content":"<h1 id=\"Jni入门\"><a href=\"#Jni入门\" class=\"headerlink\" title=\"Jni入门\"></a>Jni入门</h1><p>参考:<br><a href=\"http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html\" target=\"_blank\" rel=\"noopener\">JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki</a></p><a id=\"more\"></a>\n<h3 id=\"1、编写native方法，使用javah创建头文件\"><a href=\"#1、编写native方法，使用javah创建头文件\" class=\"headerlink\" title=\"1、编写native方法，使用javah创建头文件\"></a>1、编写native方法，使用javah创建头文件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> String <span class=\"title\">sayHello</span><span class=\"params\">(String name)</span></span>; <span class=\"comment\">// 1.声明这是一个native函数，由本地代码实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javah -jni -classpath JniCalcINterface</span><br></pre></td></tr></table></figure>\n<p>参数说明：<br>classpath：类搜索路径，这里表示从当前的 bin 目录下查找<br>d：将生成的头文件放到当前的 jni 目录下<br>o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）</p>\n<p><strong>注意：-d和-o只能使用其中一个参数。</strong></p>\n<p>创建的.h文件如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span>  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;  </span></span></span><br><span class=\"line\"><span class=\"comment\">/* Header for class com_study_jnilearn_HelloWorld */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _Included_com_study_jnilearn_HelloWorld  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _Included_com_study_jnilearn_HelloWorld  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus  </span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Class:     com_study_jnilearn_HelloWorld </span></span><br><span class=\"line\"><span class=\"comment\"> * Method:    sayHello </span></span><br><span class=\"line\"><span class=\"comment\"> * Signature: (Ljava/lang/String;)Ljava/lang/String; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello  </span><br><span class=\"line\">  (JNIEnv *, jclass, jstring);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>**注意 extern “C”表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern “C”后面</p>\n<h3 id=\"3、编译出so文件\"><a href=\"#3、编译出so文件\" class=\"headerlink\" title=\"3、编译出so文件\"></a>3、编译出so文件</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so</span><br></pre></td></tr></table></figure>\n<p>参数含义:</p>\n<p>-L </p>\n<ul>\n<li>表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。</li>\n</ul>\n<p>-l (L的小写)</p>\n<ul>\n<li>表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test</li>\n</ul>\n<p>-include</p>\n<ul>\n<li>包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。</li>\n</ul>\n<p>-I (i 的大写)</p>\n<ul>\n<li>指定头文件的所在的目录，可以使用相对路径。</li>\n</ul>\n<p>-shared </p>\n<ul>\n<li>指定生成动态链接库</li>\n</ul>\n<p>-fPIC</p>\n<ul>\n<li>表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。</li>\n</ul>\n<p>-o </p>\n<ul>\n<li>指定编译后动态库生成的路径和文件名</li>\n</ul>\n<h3 id=\"4、加载动态库\"><a href=\"#4、加载动态库\" class=\"headerlink\" title=\"4、加载动态库\"></a>4、加载动态库</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">\"HelloWorld\"</span>);  <span class=\"comment\">//方式一</span></span><br><span class=\"line\">    System.load(<span class=\"string\">\"/Users/yangxin/Desktop/libHelloWorld.jnilib\"</span> <span class=\"comment\">//方式二);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀<br>方式2：指定动态库的绝对路径名，需要加上前缀和后缀 <strong>推荐使用这种方法</strong></p>\n<p>如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。<br>有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。</p>\n<ul>\n<li><p>将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下</p>\n</li>\n<li><p>给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。</p>\n</li>\n</ul>\n<h3 id=\"5、运行java程序\"><a href=\"#5、运行java程序\" class=\"headerlink\" title=\"5、运行java程序\"></a>5、运行java程序</h3>","site":{"data":{}},"excerpt":"<h1 id=\"Jni入门\"><a href=\"#Jni入门\" class=\"headerlink\" title=\"Jni入门\"></a>Jni入门</h1><p>参考:<br><a href=\"http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html\" target=\"_blank\" rel=\"noopener\">JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki</a></p>","more":"\n<h3 id=\"1、编写native方法，使用javah创建头文件\"><a href=\"#1、编写native方法，使用javah创建头文件\" class=\"headerlink\" title=\"1、编写native方法，使用javah创建头文件\"></a>1、编写native方法，使用javah创建头文件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> String <span class=\"title\">sayHello</span><span class=\"params\">(String name)</span></span>; <span class=\"comment\">// 1.声明这是一个native函数，由本地代码实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javah -jni -classpath JniCalcINterface</span><br></pre></td></tr></table></figure>\n<p>参数说明：<br>classpath：类搜索路径，这里表示从当前的 bin 目录下查找<br>d：将生成的头文件放到当前的 jni 目录下<br>o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）</p>\n<p><strong>注意：-d和-o只能使用其中一个参数。</strong></p>\n<p>创建的.h文件如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span>  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;  </span></span></span><br><span class=\"line\"><span class=\"comment\">/* Header for class com_study_jnilearn_HelloWorld */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _Included_com_study_jnilearn_HelloWorld  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _Included_com_study_jnilearn_HelloWorld  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus  </span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Class:     com_study_jnilearn_HelloWorld </span></span><br><span class=\"line\"><span class=\"comment\"> * Method:    sayHello </span></span><br><span class=\"line\"><span class=\"comment\"> * Signature: (Ljava/lang/String;)Ljava/lang/String; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello  </span><br><span class=\"line\">  (JNIEnv *, jclass, jstring);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>**注意 extern “C”表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern “C”后面</p>\n<h3 id=\"3、编译出so文件\"><a href=\"#3、编译出so文件\" class=\"headerlink\" title=\"3、编译出so文件\"></a>3、编译出so文件</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so</span><br></pre></td></tr></table></figure>\n<p>参数含义:</p>\n<p>-L </p>\n<ul>\n<li>表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。</li>\n</ul>\n<p>-l (L的小写)</p>\n<ul>\n<li>表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test</li>\n</ul>\n<p>-include</p>\n<ul>\n<li>包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。</li>\n</ul>\n<p>-I (i 的大写)</p>\n<ul>\n<li>指定头文件的所在的目录，可以使用相对路径。</li>\n</ul>\n<p>-shared </p>\n<ul>\n<li>指定生成动态链接库</li>\n</ul>\n<p>-fPIC</p>\n<ul>\n<li>表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。</li>\n</ul>\n<p>-o </p>\n<ul>\n<li>指定编译后动态库生成的路径和文件名</li>\n</ul>\n<h3 id=\"4、加载动态库\"><a href=\"#4、加载动态库\" class=\"headerlink\" title=\"4、加载动态库\"></a>4、加载动态库</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">\"HelloWorld\"</span>);  <span class=\"comment\">//方式一</span></span><br><span class=\"line\">    System.load(<span class=\"string\">\"/Users/yangxin/Desktop/libHelloWorld.jnilib\"</span> <span class=\"comment\">//方式二);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀<br>方式2：指定动态库的绝对路径名，需要加上前缀和后缀 <strong>推荐使用这种方法</strong></p>\n<p>如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。<br>有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。</p>\n<ul>\n<li><p>将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下</p>\n</li>\n<li><p>给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。</p>\n</li>\n</ul>\n<h3 id=\"5、运行java程序\"><a href=\"#5、运行java程序\" class=\"headerlink\" title=\"5、运行java程序\"></a>5、运行java程序</h3>"},{"title":"apt常用命令","date":"2019-05-02T11:49:35.000Z","categroies":["Linux"],"_content":"\n# apt常用命令\n参考：\n[apt命令安装指定版本](https://www.centos.bz/2017/07/ubuntu-apt-cache-version-list-install-specify-version/)\n## 更新\n> sudo apt-get update     //更新源\nsudo apt-get upgrade    //更新已安装的包\nsudo apt-get dist-upgrade       //升级系统\nsudo apt-get dselect-upgrade    //使用 dselect 升级\n\n## 查询\n> apt-cache search package      \n> //搜索包　　\napt-cache show package          \n//获取包的相关信息，如说明、大小、版本等　\napt-cache depends package       \n//了解使用依赖\napt-cache rdepends package      \n//是查看该包被哪些包依赖\n\n```shell\napt-cache madison <package name>  //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。\n\napt-cache policy <<package name>>  /*将列出所有来源的版本。信息会比上面详细一点*/\n\napt-show-versions -a <<package name>> //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u <>来查询是否有升级版本。\n```\n\n## 安装\n> sudo apt-get install package      \n> //安装包　　\nsudo apt-get install package - - reinstall      \n//重新安装包　　\nsudo apt-get -f install         \n//修复安装   (\"-f = ——fix-missing\")\n\n## 删除\nsudo apt-get remove package \n删除包　　\nsudo apt-get remove package - - purge \n删除包，包括删除配置文件等\nsudo apt-get clean && sudo apt-get autoclean \n清理无用的包\nsudo apt-get check \n检查是否有损坏的依赖\n\n## 其他\n> sudo apt-get build-dep package \n> 安装相关的编译环境\napt-get source package \n下载该包的源代码\n\n\n\n","source":"_posts/Linux/apt常用命令.md","raw":"---\ntitle: apt常用命令\ndate: 2019-05-02 19:49:35\ntags: \n- Linux\ncategroies:\n- Linux\n---\n\n# apt常用命令\n参考：\n[apt命令安装指定版本](https://www.centos.bz/2017/07/ubuntu-apt-cache-version-list-install-specify-version/)\n## 更新\n> sudo apt-get update     //更新源\nsudo apt-get upgrade    //更新已安装的包\nsudo apt-get dist-upgrade       //升级系统\nsudo apt-get dselect-upgrade    //使用 dselect 升级\n\n## 查询\n> apt-cache search package      \n> //搜索包　　\napt-cache show package          \n//获取包的相关信息，如说明、大小、版本等　\napt-cache depends package       \n//了解使用依赖\napt-cache rdepends package      \n//是查看该包被哪些包依赖\n\n```shell\napt-cache madison <package name>  //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。\n\napt-cache policy <<package name>>  /*将列出所有来源的版本。信息会比上面详细一点*/\n\napt-show-versions -a <<package name>> //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u <>来查询是否有升级版本。\n```\n\n## 安装\n> sudo apt-get install package      \n> //安装包　　\nsudo apt-get install package - - reinstall      \n//重新安装包　　\nsudo apt-get -f install         \n//修复安装   (\"-f = ——fix-missing\")\n\n## 删除\nsudo apt-get remove package \n删除包　　\nsudo apt-get remove package - - purge \n删除包，包括删除配置文件等\nsudo apt-get clean && sudo apt-get autoclean \n清理无用的包\nsudo apt-get check \n检查是否有损坏的依赖\n\n## 其他\n> sudo apt-get build-dep package \n> 安装相关的编译环境\napt-get source package \n下载该包的源代码\n\n\n\n","slug":"Linux/apt常用命令","published":1,"updated":"2019-12-21T12:16:41.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakre003f8mzmwv38on8b","content":"<h1 id=\"apt常用命令\"><a href=\"#apt常用命令\" class=\"headerlink\" title=\"apt常用命令\"></a>apt常用命令</h1><p>参考：<br><a href=\"https://www.centos.bz/2017/07/ubuntu-apt-cache-version-list-install-specify-version/\" target=\"_blank\" rel=\"noopener\">apt命令安装指定版本</a></p><a id=\"more\"></a>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><blockquote>\n<p>sudo apt-get update     //更新源<br>sudo apt-get upgrade    //更新已安装的包<br>sudo apt-get dist-upgrade       //升级系统<br>sudo apt-get dselect-upgrade    //使用 dselect 升级</p>\n</blockquote>\n<h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><blockquote>\n<p>apt-cache search package<br>//搜索包　　<br>apt-cache show package<br>//获取包的相关信息，如说明、大小、版本等　<br>apt-cache depends package<br>//了解使用依赖<br>apt-cache rdepends package<br>//是查看该包被哪些包依赖</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-cache madison &lt;package name&gt;  //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。</span><br><span class=\"line\"></span><br><span class=\"line\">apt-cache policy &lt;&lt;package name&gt;&gt;  /*将列出所有来源的版本。信息会比上面详细一点*/</span><br><span class=\"line\"></span><br><span class=\"line\">apt-show-versions -a &lt;&lt;package name&gt;&gt; //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u &lt;&gt;来查询是否有升级版本。</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>sudo apt-get install package<br>//安装包　　<br>sudo apt-get install package - - reinstall<br>//重新安装包　　<br>sudo apt-get -f install<br>//修复安装   (“-f = ——fix-missing”)</p>\n</blockquote>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>sudo apt-get remove package<br>删除包　　<br>sudo apt-get remove package - - purge<br>删除包，包括删除配置文件等<br>sudo apt-get clean &amp;&amp; sudo apt-get autoclean<br>清理无用的包<br>sudo apt-get check<br>检查是否有损坏的依赖</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><blockquote>\n<p>sudo apt-get build-dep package<br>安装相关的编译环境<br>apt-get source package<br>下载该包的源代码</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"apt常用命令\"><a href=\"#apt常用命令\" class=\"headerlink\" title=\"apt常用命令\"></a>apt常用命令</h1><p>参考：<br><a href=\"https://www.centos.bz/2017/07/ubuntu-apt-cache-version-list-install-specify-version/\" target=\"_blank\" rel=\"noopener\">apt命令安装指定版本</a></p>","more":"\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><blockquote>\n<p>sudo apt-get update     //更新源<br>sudo apt-get upgrade    //更新已安装的包<br>sudo apt-get dist-upgrade       //升级系统<br>sudo apt-get dselect-upgrade    //使用 dselect 升级</p>\n</blockquote>\n<h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><blockquote>\n<p>apt-cache search package<br>//搜索包　　<br>apt-cache show package<br>//获取包的相关信息，如说明、大小、版本等　<br>apt-cache depends package<br>//了解使用依赖<br>apt-cache rdepends package<br>//是查看该包被哪些包依赖</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-cache madison &lt;package name&gt;  //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。</span><br><span class=\"line\"></span><br><span class=\"line\">apt-cache policy &lt;&lt;package name&gt;&gt;  /*将列出所有来源的版本。信息会比上面详细一点*/</span><br><span class=\"line\"></span><br><span class=\"line\">apt-show-versions -a &lt;&lt;package name&gt;&gt; //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u &lt;&gt;来查询是否有升级版本。</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>sudo apt-get install package<br>//安装包　　<br>sudo apt-get install package - - reinstall<br>//重新安装包　　<br>sudo apt-get -f install<br>//修复安装   (“-f = ——fix-missing”)</p>\n</blockquote>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>sudo apt-get remove package<br>删除包　　<br>sudo apt-get remove package - - purge<br>删除包，包括删除配置文件等<br>sudo apt-get clean &amp;&amp; sudo apt-get autoclean<br>清理无用的包<br>sudo apt-get check<br>检查是否有损坏的依赖</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><blockquote>\n<p>sudo apt-get build-dep package<br>安装相关的编译环境<br>apt-get source package<br>下载该包的源代码</p>\n</blockquote>\n"},{"title":"docker的使用","date":"2019-11-12T08:09:50.000Z","_content":"\n# docker 的使用\n\n## Docker 和 虚拟机的区别:\n\n- 实现资源隔离的方式不同:\n  - 虚拟机:\n    利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行\n  - Docker:\n    应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值\n- 隔离性:\n  虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker\n- 性能:\n  docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化\n\n## Docker Toolbox\n\n因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版.\n\n## Docker Toolbox 添加镜像加速\n\n可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题.\n\n可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好\n\n具体的配置修改, 参考:\n[http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox]()\n\n## image, container\n\n### image:\n\n镜像. 是一个包含有文件系统的面向 Docker 引擎的**只读模板**. 可以是从远端拉取的, 也可以是自己制作的\n\n### container:\n\n容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. **注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。**\n\n## 常用操作\n\n### [https://www.runoob.com/docker/docker-container-usage.html]()\n\n很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方\n\n### docker container run\n\n```shell\ndocker run -it --name string ubuntu:latest /bin/bash\n```\n\n参数说明:\n\n- -i: 交互式操作。\n- -t: 终端。\n- ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。\n- /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。\n- --name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字\n\n**注意**\n**image 每一次 docker run 之后, 都会启动一个不同的 container**, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令\n\n### 将容器转化为一个镜像\n\n```shell\ndocker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2\n```\n\n- -m: 提交的描述信息\n- -a: 指定镜像作者\n- e218edb10161：容器 ID\n- runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag\n\n**注意** 如果要制作的 image 打包上传到自己 docker hub, ' / ' 前面的用户名需要和自己 docker hub 的用户名保持一致\n\n### 使用 Dockerfile 创建镜像\n\n没试过... 以后有机会再写上\n","source":"_posts/Linux/docker的使用.md","raw":"---\ntitle: docker的使用\ndate: 2019-11-12 16:09:50\ntags:\n- Linux\n- Docker\ncategories:\n- Linux\n---\n\n# docker 的使用\n\n## Docker 和 虚拟机的区别:\n\n- 实现资源隔离的方式不同:\n  - 虚拟机:\n    利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行\n  - Docker:\n    应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值\n- 隔离性:\n  虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker\n- 性能:\n  docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化\n\n## Docker Toolbox\n\n因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版.\n\n## Docker Toolbox 添加镜像加速\n\n可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题.\n\n可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好\n\n具体的配置修改, 参考:\n[http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox]()\n\n## image, container\n\n### image:\n\n镜像. 是一个包含有文件系统的面向 Docker 引擎的**只读模板**. 可以是从远端拉取的, 也可以是自己制作的\n\n### container:\n\n容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. **注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。**\n\n## 常用操作\n\n### [https://www.runoob.com/docker/docker-container-usage.html]()\n\n很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方\n\n### docker container run\n\n```shell\ndocker run -it --name string ubuntu:latest /bin/bash\n```\n\n参数说明:\n\n- -i: 交互式操作。\n- -t: 终端。\n- ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。\n- /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。\n- --name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字\n\n**注意**\n**image 每一次 docker run 之后, 都会启动一个不同的 container**, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令\n\n### 将容器转化为一个镜像\n\n```shell\ndocker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2\n```\n\n- -m: 提交的描述信息\n- -a: 指定镜像作者\n- e218edb10161：容器 ID\n- runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag\n\n**注意** 如果要制作的 image 打包上传到自己 docker hub, ' / ' 前面的用户名需要和自己 docker hub 的用户名保持一致\n\n### 使用 Dockerfile 创建镜像\n\n没试过... 以后有机会再写上\n","slug":"Linux/docker的使用","published":1,"updated":"2019-12-21T12:16:41.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakrf003h8mzmtk7jiaxn","content":"<h1 id=\"docker-的使用\"><a href=\"#docker-的使用\" class=\"headerlink\" title=\"docker 的使用\"></a>docker 的使用</h1><h2 id=\"Docker-和-虚拟机的区别\"><a href=\"#Docker-和-虚拟机的区别\" class=\"headerlink\" title=\"Docker 和 虚拟机的区别:\"></a>Docker 和 虚拟机的区别:</h2><a id=\"more\"></a><ul>\n<li>实现资源隔离的方式不同:<ul>\n<li>虚拟机:<br>利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行</li>\n<li>Docker:<br>应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值</li>\n</ul>\n</li>\n<li>隔离性:<br>虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker</li>\n<li>性能:<br>docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化</li>\n</ul>\n<h2 id=\"Docker-Toolbox\"><a href=\"#Docker-Toolbox\" class=\"headerlink\" title=\"Docker Toolbox\"></a>Docker Toolbox</h2><p>因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版.</p>\n<h2 id=\"Docker-Toolbox-添加镜像加速\"><a href=\"#Docker-Toolbox-添加镜像加速\" class=\"headerlink\" title=\"Docker Toolbox 添加镜像加速\"></a>Docker Toolbox 添加镜像加速</h2><p>可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题.</p>\n<p>可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好</p>\n<p>具体的配置修改, 参考:<br><a href>http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox</a></p>\n<h2 id=\"image-container\"><a href=\"#image-container\" class=\"headerlink\" title=\"image, container\"></a>image, container</h2><h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image:\"></a>image:</h3><p>镜像. 是一个包含有文件系统的面向 Docker 引擎的<strong>只读模板</strong>. 可以是从远端拉取的, 也可以是自己制作的</p>\n<h3 id=\"container\"><a href=\"#container\" class=\"headerlink\" title=\"container:\"></a>container:</h3><p>容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. <strong>注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。</strong></p>\n<h2 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h2><h3 id=\"https-www-runoob-com-docker-docker-container-usage-html\"><a href=\"#https-www-runoob-com-docker-docker-container-usage-html\" class=\"headerlink\" title=\"https://www.runoob.com/docker/docker-container-usage.html\"></a><a href>https://www.runoob.com/docker/docker-container-usage.html</a></h3><p>很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方</p>\n<h3 id=\"docker-container-run\"><a href=\"#docker-container-run\" class=\"headerlink\" title=\"docker container run\"></a>docker container run</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --name string ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>\n<p>参数说明:</p>\n<ul>\n<li>-i: 交互式操作。</li>\n<li>-t: 终端。</li>\n<li>ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。</li>\n<li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>\n<li>–name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字</li>\n</ul>\n<p><strong>注意</strong><br><strong>image 每一次 docker run 之后, 都会启动一个不同的 container</strong>, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令</p>\n<h3 id=\"将容器转化为一个镜像\"><a href=\"#将容器转化为一个镜像\" class=\"headerlink\" title=\"将容器转化为一个镜像\"></a>将容器转化为一个镜像</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-m: 提交的描述信息</li>\n<li>-a: 指定镜像作者</li>\n<li>e218edb10161：容器 ID</li>\n<li>runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag</li>\n</ul>\n<p><strong>注意</strong> 如果要制作的 image 打包上传到自己 docker hub, ‘ / ‘ 前面的用户名需要和自己 docker hub 的用户名保持一致</p>\n<h3 id=\"使用-Dockerfile-创建镜像\"><a href=\"#使用-Dockerfile-创建镜像\" class=\"headerlink\" title=\"使用 Dockerfile 创建镜像\"></a>使用 Dockerfile 创建镜像</h3><p>没试过… 以后有机会再写上</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"docker-的使用\"><a href=\"#docker-的使用\" class=\"headerlink\" title=\"docker 的使用\"></a>docker 的使用</h1><h2 id=\"Docker-和-虚拟机的区别\"><a href=\"#Docker-和-虚拟机的区别\" class=\"headerlink\" title=\"Docker 和 虚拟机的区别:\"></a>Docker 和 虚拟机的区别:</h2>","more":"<ul>\n<li>实现资源隔离的方式不同:<ul>\n<li>虚拟机:<br>利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行</li>\n<li>Docker:<br>应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值</li>\n</ul>\n</li>\n<li>隔离性:<br>虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker</li>\n<li>性能:<br>docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化</li>\n</ul>\n<h2 id=\"Docker-Toolbox\"><a href=\"#Docker-Toolbox\" class=\"headerlink\" title=\"Docker Toolbox\"></a>Docker Toolbox</h2><p>因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版.</p>\n<h2 id=\"Docker-Toolbox-添加镜像加速\"><a href=\"#Docker-Toolbox-添加镜像加速\" class=\"headerlink\" title=\"Docker Toolbox 添加镜像加速\"></a>Docker Toolbox 添加镜像加速</h2><p>可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题.</p>\n<p>可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好</p>\n<p>具体的配置修改, 参考:<br><a href>http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox</a></p>\n<h2 id=\"image-container\"><a href=\"#image-container\" class=\"headerlink\" title=\"image, container\"></a>image, container</h2><h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image:\"></a>image:</h3><p>镜像. 是一个包含有文件系统的面向 Docker 引擎的<strong>只读模板</strong>. 可以是从远端拉取的, 也可以是自己制作的</p>\n<h3 id=\"container\"><a href=\"#container\" class=\"headerlink\" title=\"container:\"></a>container:</h3><p>容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. <strong>注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。</strong></p>\n<h2 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h2><h3 id=\"https-www-runoob-com-docker-docker-container-usage-html\"><a href=\"#https-www-runoob-com-docker-docker-container-usage-html\" class=\"headerlink\" title=\"https://www.runoob.com/docker/docker-container-usage.html\"></a><a href>https://www.runoob.com/docker/docker-container-usage.html</a></h3><p>很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方</p>\n<h3 id=\"docker-container-run\"><a href=\"#docker-container-run\" class=\"headerlink\" title=\"docker container run\"></a>docker container run</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --name string ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>\n<p>参数说明:</p>\n<ul>\n<li>-i: 交互式操作。</li>\n<li>-t: 终端。</li>\n<li>ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。</li>\n<li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>\n<li>–name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字</li>\n</ul>\n<p><strong>注意</strong><br><strong>image 每一次 docker run 之后, 都会启动一个不同的 container</strong>, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令</p>\n<h3 id=\"将容器转化为一个镜像\"><a href=\"#将容器转化为一个镜像\" class=\"headerlink\" title=\"将容器转化为一个镜像\"></a>将容器转化为一个镜像</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-m: 提交的描述信息</li>\n<li>-a: 指定镜像作者</li>\n<li>e218edb10161：容器 ID</li>\n<li>runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag</li>\n</ul>\n<p><strong>注意</strong> 如果要制作的 image 打包上传到自己 docker hub, ‘ / ‘ 前面的用户名需要和自己 docker hub 的用户名保持一致</p>\n<h3 id=\"使用-Dockerfile-创建镜像\"><a href=\"#使用-Dockerfile-创建镜像\" class=\"headerlink\" title=\"使用 Dockerfile 创建镜像\"></a>使用 Dockerfile 创建镜像</h3><p>没试过… 以后有机会再写上</p>\n"},{"title":"mysql配置相关","date":"2019-05-04T03:04:44.000Z","_content":"\n## 1. 尽量使用MariaDB而不是mysql\n\n之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0\n但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为**mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码**\n于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了\n\n而且，mysql的命令行终端很明显有bug，没有MariaDB好用\n\n## 2. MariaDB更新密码\nmariadb的安装可以查看官网，上面有yum安装的教程。\n安装之后默认是没有密码的。需要更新密码。\n另外，**发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的**\n\n中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ''@'localhost'之类的报错。没有找到原因和解决办法，最后是直接重置了vps\n\n#### 1. mysql_secure_installation 命令\n安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码\n\n#### 2. 登陆mysql更改密码\n\n```shell\n# 2.1 更新 mysql 库中 user 表的字段：\nuse mysql;  \nUPDATE user SET password=password('newpassword') WHERE user='root';  \nflush privileges;  \nexit;\n \n# 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法\nSET password for 'root'@'localhost'=password('newpassword');  \n\n```\n\n\n## 3. mysql配置远程登录\n\n#### 1. 给用户远程登录权限：\n```sql\nuse mysql\nupdate user set host='%' where user ='root';\nFLUSH PRIVILEGES;\ngrant all privileges  on *.* to root@'%' identified by \"password\";\nFLUSH PRIVILEGES;\n```\n\nroot可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码\n\n使用以下命令可以查看用户的登录权限\n\n```shell\nselect host,user,password,plugin from user;\n```\n\n**注意**\nroot密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。\n可以使用如下命令更改加密方式：\n\n```sql\nupdate user set plugin='mysql_native_password' where user='root';\n```\n\n#### 2. lnmp环境配置iptables\n\nlnmp一键安装环境默认是禁用iptables远程登录的，\n\n* 查看iptables规则：\n```shell\niptables -L -n --line-numbers\n```\n输入样例如下：\n![图片](/images/mysql_iptables.png)\n可以看到3306端口的target为drop\n\n* 删除对应的drop规则\n\n```shell\niptables -D INPUT 5\n```\n\n\niptables的使用参考：\n[https://www.vpser.net/security/linux-iptables.html]()\n\n#### 3.非集成centos环境开放3306端口\n\n##### centos-7以上\n\nfirewalld 防火墙（centos-7）运行命令,并重启：\n\n```shell\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\nfirewall-cmd --reload\n```\n\n##### centos-7以前\niptables 防火墙（centos6.5及其以前）运行命令\n\n```shell\nvim /etc/sysconfig/iptables\n```\n\n在文件内添加下面命令行，然后重启\n\n```shell\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\n```\n\n```shell\nservice iptables restart\n```\n\n\n","source":"_posts/Linux/mysql配置相关.md","raw":"---\ntitle: mysql配置相关\ndate: 2019-05-04 11:04:44\ntags:\n- mysql\n- Linux\ncategories:\n- Linux\n---\n\n## 1. 尽量使用MariaDB而不是mysql\n\n之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0\n但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为**mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码**\n于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了\n\n而且，mysql的命令行终端很明显有bug，没有MariaDB好用\n\n## 2. MariaDB更新密码\nmariadb的安装可以查看官网，上面有yum安装的教程。\n安装之后默认是没有密码的。需要更新密码。\n另外，**发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的**\n\n中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ''@'localhost'之类的报错。没有找到原因和解决办法，最后是直接重置了vps\n\n#### 1. mysql_secure_installation 命令\n安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码\n\n#### 2. 登陆mysql更改密码\n\n```shell\n# 2.1 更新 mysql 库中 user 表的字段：\nuse mysql;  \nUPDATE user SET password=password('newpassword') WHERE user='root';  \nflush privileges;  \nexit;\n \n# 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法\nSET password for 'root'@'localhost'=password('newpassword');  \n\n```\n\n\n## 3. mysql配置远程登录\n\n#### 1. 给用户远程登录权限：\n```sql\nuse mysql\nupdate user set host='%' where user ='root';\nFLUSH PRIVILEGES;\ngrant all privileges  on *.* to root@'%' identified by \"password\";\nFLUSH PRIVILEGES;\n```\n\nroot可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码\n\n使用以下命令可以查看用户的登录权限\n\n```shell\nselect host,user,password,plugin from user;\n```\n\n**注意**\nroot密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。\n可以使用如下命令更改加密方式：\n\n```sql\nupdate user set plugin='mysql_native_password' where user='root';\n```\n\n#### 2. lnmp环境配置iptables\n\nlnmp一键安装环境默认是禁用iptables远程登录的，\n\n* 查看iptables规则：\n```shell\niptables -L -n --line-numbers\n```\n输入样例如下：\n![图片](/images/mysql_iptables.png)\n可以看到3306端口的target为drop\n\n* 删除对应的drop规则\n\n```shell\niptables -D INPUT 5\n```\n\n\niptables的使用参考：\n[https://www.vpser.net/security/linux-iptables.html]()\n\n#### 3.非集成centos环境开放3306端口\n\n##### centos-7以上\n\nfirewalld 防火墙（centos-7）运行命令,并重启：\n\n```shell\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\nfirewall-cmd --reload\n```\n\n##### centos-7以前\niptables 防火墙（centos6.5及其以前）运行命令\n\n```shell\nvim /etc/sysconfig/iptables\n```\n\n在文件内添加下面命令行，然后重启\n\n```shell\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\n```\n\n```shell\nservice iptables restart\n```\n\n\n","slug":"Linux/mysql配置相关","published":1,"updated":"2019-12-21T12:16:41.880Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakrg003l8mzm8apkv0lb","content":"<h2 id=\"1-尽量使用MariaDB而不是mysql\"><a href=\"#1-尽量使用MariaDB而不是mysql\" class=\"headerlink\" title=\"1. 尽量使用MariaDB而不是mysql\"></a>1. 尽量使用MariaDB而不是mysql</h2><a id=\"more\"></a><p>之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0<br>但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为<strong>mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码</strong><br>于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了</p>\n<p>而且，mysql的命令行终端很明显有bug，没有MariaDB好用</p>\n<h2 id=\"2-MariaDB更新密码\"><a href=\"#2-MariaDB更新密码\" class=\"headerlink\" title=\"2. MariaDB更新密码\"></a>2. MariaDB更新密码</h2><p>mariadb的安装可以查看官网，上面有yum安装的教程。<br>安装之后默认是没有密码的。需要更新密码。<br>另外，<strong>发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的</strong></p>\n<p>中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ‘‘@’localhost’之类的报错。没有找到原因和解决办法，最后是直接重置了vps</p>\n<h4 id=\"1-mysql-secure-installation-命令\"><a href=\"#1-mysql-secure-installation-命令\" class=\"headerlink\" title=\"1. mysql_secure_installation 命令\"></a>1. mysql_secure_installation 命令</h4><p>安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码</p>\n<h4 id=\"2-登陆mysql更改密码\"><a href=\"#2-登陆mysql更改密码\" class=\"headerlink\" title=\"2. 登陆mysql更改密码\"></a>2. 登陆mysql更改密码</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 2.1 更新 mysql 库中 user 表的字段：</span><br><span class=\"line\">use mysql;  </span><br><span class=\"line\">UPDATE user SET password=password('newpassword') WHERE user='root';  </span><br><span class=\"line\">flush privileges;  </span><br><span class=\"line\">exit;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span> 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法</span><br><span class=\"line\">SET password for 'root'@'localhost'=password('newpassword');</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-mysql配置远程登录\"><a href=\"#3-mysql配置远程登录\" class=\"headerlink\" title=\"3. mysql配置远程登录\"></a>3. mysql配置远程登录</h2><h4 id=\"1-给用户远程登录权限：\"><a href=\"#1-给用户远程登录权限：\" class=\"headerlink\" title=\"1. 给用户远程登录权限：\"></a>1. 给用户远程登录权限：</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> mysql</span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> host=<span class=\"string\">'%'</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span> =<span class=\"string\">'root'</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">all</span> <span class=\"keyword\">privileges</span>  <span class=\"keyword\">on</span> *.* <span class=\"keyword\">to</span> root@<span class=\"string\">'%'</span> <span class=\"keyword\">identified</span> <span class=\"keyword\">by</span> <span class=\"string\">\"password\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>\n<p>root可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码</p>\n<p>使用以下命令可以查看用户的登录权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select host,user,password,plugin from user;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong><br>root密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。<br>可以使用如下命令更改加密方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> <span class=\"keyword\">plugin</span>=<span class=\"string\">'mysql_native_password'</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span>=<span class=\"string\">'root'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-lnmp环境配置iptables\"><a href=\"#2-lnmp环境配置iptables\" class=\"headerlink\" title=\"2. lnmp环境配置iptables\"></a>2. lnmp环境配置iptables</h4><p>lnmp一键安装环境默认是禁用iptables远程登录的，</p>\n<ul>\n<li>查看iptables规则：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -L -n --line-numbers</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入样例如下：<br><img src=\"/images/mysql_iptables.png\" alt=\"图片\"><br>可以看到3306端口的target为drop</p>\n<ul>\n<li>删除对应的drop规则</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -D INPUT 5</span><br></pre></td></tr></table></figure>\n<p>iptables的使用参考：<br><a href>https://www.vpser.net/security/linux-iptables.html</a></p>\n<h4 id=\"3-非集成centos环境开放3306端口\"><a href=\"#3-非集成centos环境开放3306端口\" class=\"headerlink\" title=\"3.非集成centos环境开放3306端口\"></a>3.非集成centos环境开放3306端口</h4><h5 id=\"centos-7以上\"><a href=\"#centos-7以上\" class=\"headerlink\" title=\"centos-7以上\"></a>centos-7以上</h5><p>firewalld 防火墙（centos-7）运行命令,并重启：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<h5 id=\"centos-7以前\"><a href=\"#centos-7以前\" class=\"headerlink\" title=\"centos-7以前\"></a>centos-7以前</h5><p>iptables 防火墙（centos6.5及其以前）运行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>\n<p>在文件内添加下面命令行，然后重启</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service iptables restart</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-尽量使用MariaDB而不是mysql\"><a href=\"#1-尽量使用MariaDB而不是mysql\" class=\"headerlink\" title=\"1. 尽量使用MariaDB而不是mysql\"></a>1. 尽量使用MariaDB而不是mysql</h2>","more":"<p>之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0<br>但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为<strong>mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码</strong><br>于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了</p>\n<p>而且，mysql的命令行终端很明显有bug，没有MariaDB好用</p>\n<h2 id=\"2-MariaDB更新密码\"><a href=\"#2-MariaDB更新密码\" class=\"headerlink\" title=\"2. MariaDB更新密码\"></a>2. MariaDB更新密码</h2><p>mariadb的安装可以查看官网，上面有yum安装的教程。<br>安装之后默认是没有密码的。需要更新密码。<br>另外，<strong>发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的</strong></p>\n<p>中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ‘‘@’localhost’之类的报错。没有找到原因和解决办法，最后是直接重置了vps</p>\n<h4 id=\"1-mysql-secure-installation-命令\"><a href=\"#1-mysql-secure-installation-命令\" class=\"headerlink\" title=\"1. mysql_secure_installation 命令\"></a>1. mysql_secure_installation 命令</h4><p>安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码</p>\n<h4 id=\"2-登陆mysql更改密码\"><a href=\"#2-登陆mysql更改密码\" class=\"headerlink\" title=\"2. 登陆mysql更改密码\"></a>2. 登陆mysql更改密码</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 2.1 更新 mysql 库中 user 表的字段：</span><br><span class=\"line\">use mysql;  </span><br><span class=\"line\">UPDATE user SET password=password('newpassword') WHERE user='root';  </span><br><span class=\"line\">flush privileges;  </span><br><span class=\"line\">exit;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span> 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法</span><br><span class=\"line\">SET password for 'root'@'localhost'=password('newpassword');</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-mysql配置远程登录\"><a href=\"#3-mysql配置远程登录\" class=\"headerlink\" title=\"3. mysql配置远程登录\"></a>3. mysql配置远程登录</h2><h4 id=\"1-给用户远程登录权限：\"><a href=\"#1-给用户远程登录权限：\" class=\"headerlink\" title=\"1. 给用户远程登录权限：\"></a>1. 给用户远程登录权限：</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> mysql</span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> host=<span class=\"string\">'%'</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span> =<span class=\"string\">'root'</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">all</span> <span class=\"keyword\">privileges</span>  <span class=\"keyword\">on</span> *.* <span class=\"keyword\">to</span> root@<span class=\"string\">'%'</span> <span class=\"keyword\">identified</span> <span class=\"keyword\">by</span> <span class=\"string\">\"password\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>\n<p>root可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码</p>\n<p>使用以下命令可以查看用户的登录权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select host,user,password,plugin from user;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong><br>root密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。<br>可以使用如下命令更改加密方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> <span class=\"keyword\">plugin</span>=<span class=\"string\">'mysql_native_password'</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span>=<span class=\"string\">'root'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-lnmp环境配置iptables\"><a href=\"#2-lnmp环境配置iptables\" class=\"headerlink\" title=\"2. lnmp环境配置iptables\"></a>2. lnmp环境配置iptables</h4><p>lnmp一键安装环境默认是禁用iptables远程登录的，</p>\n<ul>\n<li>查看iptables规则：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -L -n --line-numbers</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入样例如下：<br><img src=\"/images/mysql_iptables.png\" alt=\"图片\"><br>可以看到3306端口的target为drop</p>\n<ul>\n<li>删除对应的drop规则</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -D INPUT 5</span><br></pre></td></tr></table></figure>\n<p>iptables的使用参考：<br><a href>https://www.vpser.net/security/linux-iptables.html</a></p>\n<h4 id=\"3-非集成centos环境开放3306端口\"><a href=\"#3-非集成centos环境开放3306端口\" class=\"headerlink\" title=\"3.非集成centos环境开放3306端口\"></a>3.非集成centos环境开放3306端口</h4><h5 id=\"centos-7以上\"><a href=\"#centos-7以上\" class=\"headerlink\" title=\"centos-7以上\"></a>centos-7以上</h5><p>firewalld 防火墙（centos-7）运行命令,并重启：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<h5 id=\"centos-7以前\"><a href=\"#centos-7以前\" class=\"headerlink\" title=\"centos-7以前\"></a>centos-7以前</h5><p>iptables 防火墙（centos6.5及其以前）运行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>\n<p>在文件内添加下面命令行，然后重启</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service iptables restart</span><br></pre></td></tr></table></figure>\n"},{"title":"Java获取泛型类型","date":"2020-07-23T12:05:38.000Z","_content":"\n## 获取泛型class的通用方法\n\n```java\nType type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n\n```\n\n因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型\n\n## 无法获取到泛型类型\n\n```java\n// 1. \nclass SuperClass<T>{\n\n}\nSuperClass<String> object = SuperClass<String>()\n\n// 2.\nSubClass<T> extends SuperClass<T>{\n\n}\nSubClass<String> object = SubClass<Strng>()\n```\n\n## 可以获取到泛型类型\n\n```java\n// 1. 子类继承父类时, 明确了泛型类型\nSubClass extends SuperClass<String>{\n\n}\n// 2. 匿名内部类, 子类继承父类的特殊情况\nabstract class SuperClass<T>{\n\n}\nSuperClass<String> object = new SuperClass<String>(){\n    ...\n}\n```\n","source":"_posts/Java/Java获取泛型类型.md","raw":"---\ntitle: Java获取泛型类型\ndate: 2020-07-23 20:05:38\ncategories:\n- Java\ntags:\n- Java\n---\n\n## 获取泛型class的通用方法\n\n```java\nType type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n\n```\n\n因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型\n\n## 无法获取到泛型类型\n\n```java\n// 1. \nclass SuperClass<T>{\n\n}\nSuperClass<String> object = SuperClass<String>()\n\n// 2.\nSubClass<T> extends SuperClass<T>{\n\n}\nSubClass<String> object = SubClass<Strng>()\n```\n\n## 可以获取到泛型类型\n\n```java\n// 1. 子类继承父类时, 明确了泛型类型\nSubClass extends SuperClass<String>{\n\n}\n// 2. 匿名内部类, 子类继承父类的特殊情况\nabstract class SuperClass<T>{\n\n}\nSuperClass<String> object = new SuperClass<String>(){\n    ...\n}\n```\n","slug":"Java/Java获取泛型类型","published":1,"updated":"2020-07-23T13:06:45.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakri003o8mzmir4zw1q7","content":"<h2 id=\"获取泛型class的通用方法\"><a href=\"#获取泛型class的通用方法\" class=\"headerlink\" title=\"获取泛型class的通用方法\"></a>获取泛型class的通用方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<p>因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型</p>\n<h2 id=\"无法获取到泛型类型\"><a href=\"#无法获取到泛型类型\" class=\"headerlink\" title=\"无法获取到泛型类型\"></a>无法获取到泛型类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass&lt;String&gt; object = SuperClass&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.</span></span><br><span class=\"line\">SubClass&lt;T&gt; extends SuperClass&lt;T&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubClass&lt;String&gt; object = SubClass&lt;Strng&gt;()</span><br></pre></td></tr></table></figure>\n<h2 id=\"可以获取到泛型类型\"><a href=\"#可以获取到泛型类型\" class=\"headerlink\" title=\"可以获取到泛型类型\"></a>可以获取到泛型类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 子类继承父类时, 明确了泛型类型</span></span><br><span class=\"line\">SubClass extends SuperClass&lt;String&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2. 匿名内部类, 子类继承父类的特殊情况</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass&lt;String&gt; object = <span class=\"keyword\">new</span> SuperClass&lt;String&gt;()&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"获取泛型class的通用方法\"><a href=\"#获取泛型class的通用方法\" class=\"headerlink\" title=\"获取泛型class的通用方法\"></a>获取泛型class的通用方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>","more":"\n<p>因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型</p>\n<h2 id=\"无法获取到泛型类型\"><a href=\"#无法获取到泛型类型\" class=\"headerlink\" title=\"无法获取到泛型类型\"></a>无法获取到泛型类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass&lt;String&gt; object = SuperClass&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.</span></span><br><span class=\"line\">SubClass&lt;T&gt; extends SuperClass&lt;T&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubClass&lt;String&gt; object = SubClass&lt;Strng&gt;()</span><br></pre></td></tr></table></figure>\n<h2 id=\"可以获取到泛型类型\"><a href=\"#可以获取到泛型类型\" class=\"headerlink\" title=\"可以获取到泛型类型\"></a>可以获取到泛型类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 子类继承父类时, 明确了泛型类型</span></span><br><span class=\"line\">SubClass extends SuperClass&lt;String&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2. 匿名内部类, 子类继承父类的特殊情况</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass&lt;String&gt; object = <span class=\"keyword\">new</span> SuperClass&lt;String&gt;()&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"自动滚播TextView","date":"2019-12-31T06:49:08.000Z","_content":"\n要实现一个自动滚播的自定义View\n\n```java\npublic class AutoSwitchView extends AppCompatTextView {\n\n    private final int DEFAULT_IDLE_TIME = 3000;\n    private final int DEFAULT_SWITCH_TIME = 1000;\n\n    private int mIdleTime = DEFAULT_IDLE_TIME;\n    private int mSwitchTime = DEFAULT_SWITCH_TIME;\n    private Paint mPaint;\n    private String mCurStr;\n    private String mNextStr;\n    private List<String> mContentList;\n    private int mCurIndex = 0;\n    private float mCurValue;\n    private boolean mIsRunning = false;\n    private ValueAnimator mAnimator;\n    private Paint.FontMetrics mFontMetrics;\n    private Runnable mRunnable;\n\n    private int mWidth;\n    private int mPaddingLeft;\n    private int mPaddingRight;\n    private int mPaddingTop;\n    private int mPaddingBottom;\n    private int mHeight;\n    private float mTextBaseY;\n\n\n    public AutoSwitchView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public AutoSwitchView(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public AutoSwitchView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context);\n    }\n\n    private void init(Context context) {\n        mPaint = new Paint();\n        mPaint.setTextAlign(Paint.Align.CENTER);\n\n        mAnimator = ValueAnimator.ofFloat(0, 1);\n        mAnimator.setStartDelay(mIdleTime);\n        mAnimator.setDuration(mSwitchTime);\n        mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                mCurValue = (float) animation.getAnimatedValue();\n                // 必须要加这个判断, 不然会出现问题\n                if (mCurValue < 1.0) {\n                    invalidate();\n                }\n            }\n        });\n        mAnimator.addListener(new AnimatorListenerAdapter() {\n\n            @Override\n            public void onAnimationEnd(Animator animation, boolean isReverse) {\n                if (!mIsRunning) {\n                    return;\n                }\n                mCurIndex = (mCurIndex + 1) % mContentList.size();\n                mCurStr = mContentList.get(mCurIndex);\n                mNextStr = mContentList.get((mCurIndex + 1) % mContentList.size());\n                if (mRunnable == null) {\n                    mRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            mAnimator.start();\n                        }\n                    };\n                }\n                postDelayed(mRunnable, mIdleTime);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                mIsRunning = false;\n            }\n        });\n    }\n\n    public void start() {\n        if (mContentList == null || mContentList.size() == 0)\n            return;\n        if (mIsRunning) {\n            return;\n        }\n        if (mContentList.size() > 1) {\n            mCurStr = mContentList.get(0);\n            mNextStr = mContentList.get(1);\n        } else {\n            mCurStr = mContentList.get(0);\n            mNextStr = mContentList.get(0);\n        }\n        mCurIndex = 0;\n        mIsRunning = true;\n        mAnimator.start();\n        mAnimator.setStartDelay(mIdleTime);\n    }\n\n    public void stop() {\n        if (mRunnable != null) {\n            removeCallbacks(mRunnable);\n        }\n        mAnimator.cancel();\n        mIsRunning = false;\n        mCurIndex = 0;\n    }\n\n    public void setContentList(List<String> contentList) {\n        if (contentList == null || contentList.size() == 0)\n            return;\n        mContentList = contentList;\n        start();\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        mWidth = MeasureSpec.getSize(widthMeasureSpec);\n        mPaddingLeft = getPaddingLeft();\n        mPaddingRight = getPaddingRight();\n        mPaddingTop = getPaddingTop();\n        mPaddingBottom = getPaddingBottom();\n\n        mPaint.setTextSize(getTextSize());\n        mFontMetrics = mPaint.getFontMetrics();\n\n        mTextBaseY = -mFontMetrics.top + mPaddingTop;\n        mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom;\n\n        setMeasuredDimension(mWidth, mHeight);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        float curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / 2;\n        float nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / 2;\n\n        float baseY = 2 * mTextBaseY * (0.5f - mCurValue);\n        if (baseY > 0) {\n            canvas.drawText(mCurStr, curStartX, baseY, mPaint);\n        } else {\n            canvas.drawText(mNextStr, nextStartX, 2 * mTextBaseY + baseY, mPaint);\n        }\n    }\n}\n\n```","source":"_posts/Android/自动滚播TextView.md","raw":"---\ntitle: 自动滚播TextView\ndate: 2019-12-31 14:49:08\ntags:\n- View\ncategories:\n- Android\n- View\n---\n\n要实现一个自动滚播的自定义View\n\n```java\npublic class AutoSwitchView extends AppCompatTextView {\n\n    private final int DEFAULT_IDLE_TIME = 3000;\n    private final int DEFAULT_SWITCH_TIME = 1000;\n\n    private int mIdleTime = DEFAULT_IDLE_TIME;\n    private int mSwitchTime = DEFAULT_SWITCH_TIME;\n    private Paint mPaint;\n    private String mCurStr;\n    private String mNextStr;\n    private List<String> mContentList;\n    private int mCurIndex = 0;\n    private float mCurValue;\n    private boolean mIsRunning = false;\n    private ValueAnimator mAnimator;\n    private Paint.FontMetrics mFontMetrics;\n    private Runnable mRunnable;\n\n    private int mWidth;\n    private int mPaddingLeft;\n    private int mPaddingRight;\n    private int mPaddingTop;\n    private int mPaddingBottom;\n    private int mHeight;\n    private float mTextBaseY;\n\n\n    public AutoSwitchView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public AutoSwitchView(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public AutoSwitchView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context);\n    }\n\n    private void init(Context context) {\n        mPaint = new Paint();\n        mPaint.setTextAlign(Paint.Align.CENTER);\n\n        mAnimator = ValueAnimator.ofFloat(0, 1);\n        mAnimator.setStartDelay(mIdleTime);\n        mAnimator.setDuration(mSwitchTime);\n        mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                mCurValue = (float) animation.getAnimatedValue();\n                // 必须要加这个判断, 不然会出现问题\n                if (mCurValue < 1.0) {\n                    invalidate();\n                }\n            }\n        });\n        mAnimator.addListener(new AnimatorListenerAdapter() {\n\n            @Override\n            public void onAnimationEnd(Animator animation, boolean isReverse) {\n                if (!mIsRunning) {\n                    return;\n                }\n                mCurIndex = (mCurIndex + 1) % mContentList.size();\n                mCurStr = mContentList.get(mCurIndex);\n                mNextStr = mContentList.get((mCurIndex + 1) % mContentList.size());\n                if (mRunnable == null) {\n                    mRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            mAnimator.start();\n                        }\n                    };\n                }\n                postDelayed(mRunnable, mIdleTime);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                mIsRunning = false;\n            }\n        });\n    }\n\n    public void start() {\n        if (mContentList == null || mContentList.size() == 0)\n            return;\n        if (mIsRunning) {\n            return;\n        }\n        if (mContentList.size() > 1) {\n            mCurStr = mContentList.get(0);\n            mNextStr = mContentList.get(1);\n        } else {\n            mCurStr = mContentList.get(0);\n            mNextStr = mContentList.get(0);\n        }\n        mCurIndex = 0;\n        mIsRunning = true;\n        mAnimator.start();\n        mAnimator.setStartDelay(mIdleTime);\n    }\n\n    public void stop() {\n        if (mRunnable != null) {\n            removeCallbacks(mRunnable);\n        }\n        mAnimator.cancel();\n        mIsRunning = false;\n        mCurIndex = 0;\n    }\n\n    public void setContentList(List<String> contentList) {\n        if (contentList == null || contentList.size() == 0)\n            return;\n        mContentList = contentList;\n        start();\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        mWidth = MeasureSpec.getSize(widthMeasureSpec);\n        mPaddingLeft = getPaddingLeft();\n        mPaddingRight = getPaddingRight();\n        mPaddingTop = getPaddingTop();\n        mPaddingBottom = getPaddingBottom();\n\n        mPaint.setTextSize(getTextSize());\n        mFontMetrics = mPaint.getFontMetrics();\n\n        mTextBaseY = -mFontMetrics.top + mPaddingTop;\n        mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom;\n\n        setMeasuredDimension(mWidth, mHeight);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        float curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / 2;\n        float nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / 2;\n\n        float baseY = 2 * mTextBaseY * (0.5f - mCurValue);\n        if (baseY > 0) {\n            canvas.drawText(mCurStr, curStartX, baseY, mPaint);\n        } else {\n            canvas.drawText(mNextStr, nextStartX, 2 * mTextBaseY + baseY, mPaint);\n        }\n    }\n}\n\n```","slug":"Android/自动滚播TextView","published":1,"updated":"2019-12-31T07:28:48.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakrj003r8mzmogcw9h5r","content":"<p>要实现一个自动滚播的自定义View</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoSwitchView</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatTextView</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_IDLE_TIME = <span class=\"number\">3000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_SWITCH_TIME = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mIdleTime = DEFAULT_IDLE_TIME;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mSwitchTime = DEFAULT_SWITCH_TIME;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mCurStr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mNextStr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; mContentList;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mCurValue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueAnimator mAnimator;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint.FontMetrics mFontMetrics;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Runnable mRunnable;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWidth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingLeft;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingRight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingTop;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingBottom;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mHeight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mTextBaseY;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint();</span><br><span class=\"line\">        mPaint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\"></span><br><span class=\"line\">        mAnimator = ValueAnimator.ofFloat(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        mAnimator.setStartDelay(mIdleTime);</span><br><span class=\"line\">        mAnimator.setDuration(mSwitchTime);</span><br><span class=\"line\">        mAnimator.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</span><br><span class=\"line\">                mCurValue = (<span class=\"keyword\">float</span>) animation.getAnimatedValue();</span><br><span class=\"line\">                <span class=\"comment\">// 必须要加这个判断, 不然会出现问题</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mCurValue &lt; <span class=\"number\">1.0</span>) &#123;</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        mAnimator.addListener(<span class=\"keyword\">new</span> AnimatorListenerAdapter() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationEnd</span><span class=\"params\">(Animator animation, <span class=\"keyword\">boolean</span> isReverse)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!mIsRunning) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mCurIndex = (mCurIndex + <span class=\"number\">1</span>) % mContentList.size();</span><br><span class=\"line\">                mCurStr = mContentList.get(mCurIndex);</span><br><span class=\"line\">                mNextStr = mContentList.get((mCurIndex + <span class=\"number\">1</span>) % mContentList.size());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mRunnable == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            mAnimator.start();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                postDelayed(mRunnable, mIdleTime);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationCancel</span><span class=\"params\">(Animator animation)</span> </span>&#123;</span><br><span class=\"line\">                mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentList == <span class=\"keyword\">null</span> || mContentList.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mIsRunning) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentList.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            mCurStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            mNextStr = mContentList.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mCurStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            mNextStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        mIsRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        mAnimator.start();</span><br><span class=\"line\">        mAnimator.setStartDelay(mIdleTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRunnable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            removeCallbacks(mRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAnimator.cancel();</span><br><span class=\"line\">        mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentList</span><span class=\"params\">(List&lt;String&gt; contentList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (contentList == <span class=\"keyword\">null</span> || contentList.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        mContentList = contentList;</span><br><span class=\"line\">        start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        mWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">        mPaddingLeft = getPaddingLeft();</span><br><span class=\"line\">        mPaddingRight = getPaddingRight();</span><br><span class=\"line\">        mPaddingTop = getPaddingTop();</span><br><span class=\"line\">        mPaddingBottom = getPaddingBottom();</span><br><span class=\"line\"></span><br><span class=\"line\">        mPaint.setTextSize(getTextSize());</span><br><span class=\"line\">        mFontMetrics = mPaint.getFontMetrics();</span><br><span class=\"line\"></span><br><span class=\"line\">        mTextBaseY = -mFontMetrics.top + mPaddingTop;</span><br><span class=\"line\">        mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom;</span><br><span class=\"line\"></span><br><span class=\"line\">        setMeasuredDimension(mWidth, mHeight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDraw(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> baseY = <span class=\"number\">2</span> * mTextBaseY * (<span class=\"number\">0.5f</span> - mCurValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            canvas.drawText(mCurStr, curStartX, baseY, mPaint);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            canvas.drawText(mNextStr, nextStartX, <span class=\"number\">2</span> * mTextBaseY + baseY, mPaint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>要实现一个自动滚播的自定义View</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoSwitchView</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatTextView</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_IDLE_TIME = <span class=\"number\">3000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_SWITCH_TIME = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mIdleTime = DEFAULT_IDLE_TIME;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mSwitchTime = DEFAULT_SWITCH_TIME;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mCurStr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mNextStr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; mContentList;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mCurValue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueAnimator mAnimator;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint.FontMetrics mFontMetrics;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Runnable mRunnable;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWidth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingLeft;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingRight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingTop;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingBottom;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mHeight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mTextBaseY;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint();</span><br><span class=\"line\">        mPaint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\"></span><br><span class=\"line\">        mAnimator = ValueAnimator.ofFloat(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        mAnimator.setStartDelay(mIdleTime);</span><br><span class=\"line\">        mAnimator.setDuration(mSwitchTime);</span><br><span class=\"line\">        mAnimator.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</span><br><span class=\"line\">                mCurValue = (<span class=\"keyword\">float</span>) animation.getAnimatedValue();</span><br><span class=\"line\">                <span class=\"comment\">// 必须要加这个判断, 不然会出现问题</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mCurValue &lt; <span class=\"number\">1.0</span>) &#123;</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        mAnimator.addListener(<span class=\"keyword\">new</span> AnimatorListenerAdapter() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationEnd</span><span class=\"params\">(Animator animation, <span class=\"keyword\">boolean</span> isReverse)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!mIsRunning) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mCurIndex = (mCurIndex + <span class=\"number\">1</span>) % mContentList.size();</span><br><span class=\"line\">                mCurStr = mContentList.get(mCurIndex);</span><br><span class=\"line\">                mNextStr = mContentList.get((mCurIndex + <span class=\"number\">1</span>) % mContentList.size());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mRunnable == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            mAnimator.start();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                postDelayed(mRunnable, mIdleTime);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationCancel</span><span class=\"params\">(Animator animation)</span> </span>&#123;</span><br><span class=\"line\">                mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentList == <span class=\"keyword\">null</span> || mContentList.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mIsRunning) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentList.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            mCurStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            mNextStr = mContentList.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mCurStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            mNextStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        mIsRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        mAnimator.start();</span><br><span class=\"line\">        mAnimator.setStartDelay(mIdleTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRunnable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            removeCallbacks(mRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAnimator.cancel();</span><br><span class=\"line\">        mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentList</span><span class=\"params\">(List&lt;String&gt; contentList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (contentList == <span class=\"keyword\">null</span> || contentList.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        mContentList = contentList;</span><br><span class=\"line\">        start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        mWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">        mPaddingLeft = getPaddingLeft();</span><br><span class=\"line\">        mPaddingRight = getPaddingRight();</span><br><span class=\"line\">        mPaddingTop = getPaddingTop();</span><br><span class=\"line\">        mPaddingBottom = getPaddingBottom();</span><br><span class=\"line\"></span><br><span class=\"line\">        mPaint.setTextSize(getTextSize());</span><br><span class=\"line\">        mFontMetrics = mPaint.getFontMetrics();</span><br><span class=\"line\"></span><br><span class=\"line\">        mTextBaseY = -mFontMetrics.top + mPaddingTop;</span><br><span class=\"line\">        mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom;</span><br><span class=\"line\"></span><br><span class=\"line\">        setMeasuredDimension(mWidth, mHeight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDraw(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> baseY = <span class=\"number\">2</span> * mTextBaseY * (<span class=\"number\">0.5f</span> - mCurValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            canvas.drawText(mCurStr, curStartX, baseY, mPaint);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            canvas.drawText(mNextStr, nextStartX, <span class=\"number\">2</span> * mTextBaseY + baseY, mPaint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"flutter ui源码 初步","date":"2020-08-14T12:30:42.000Z","_content":"\n## Widget, Element, RanderObject 三者之间的关系\n\nWidget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。\n\n## Widget\n\nWidget类和Element类一一对应。Element是通过Widget生成的\nWidget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。\n\n**Widget.createElement()**\n\n创建Element对象\n\n**Widget.canUpdate(..)**\n```dart\nstatic bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n}\n```\n\n主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；\n通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。\n\n### State\n一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.\n\n**createState()**\n\n用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，**所以，本质上就是一个StatefulElement对应一个State实例。**\n\n**widget和context**\n- widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但**State实例只会在第一次插入到树中时被创建**，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 \n\n- context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext\n\n**State如何被Widget复用**\n只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(...)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。\n\n## Element\n\n最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。\n\n下面从Element的 **挂载、更新、卸载**过程来描述Element\n\n### mount\n\n**根Element的mount**\n\n```\n- main() \n    - runApp(..)\n    - WidgetsFlutterBinding.attachRootWidget(app)\n        - RenderObjectToWidgetAdapter<RenderBox>.attachToRenderTree(buildOwner, renderViewElement);\n            - createElement()\n            - BuildOwner.buildScope(element, () {\n                element.mount(null, null);\n            })\n```\n\n以上是根Element的mount过程，其中rederViewElement是根Elemet\n\n** Element的mount过程\n\n首先来看一下常用的StatelessElement，StatefulElement的继承关系\n\n```\nElement -> ComponentElement -> StatelessElement\n                            -> StatefulElement\n```\n\n```\n- mount()\n    - Element.updateInheritance()\n    - ComponentElement.firstBuild()\n        - Element.rebuild()\n        - ComponentElement.performRebuild()\n            - built = build()\n                -Widget.build()\n            - Element.updateChild(child, built, _)\n```\n\nElement.updateChild方法非常重要\n\n```dart\n@protected\nElement updateChild(Element child, Widget newWidget, dynamic newSlot) {\n    if (newWidget == null) {\n      if (child != null)\n        deactivateChild(child);\n      return null;\n    }\n    if (child != null) {\n      if (child.widget == newWidget) {\n        return child;\n      }\n      if (Widget.canUpdate(child.widget, newWidget)) {\n        child.update(newWidget);\n        return child;\n      }\n      deactivateChild(child);\n    }\n    return inflateWidget(newWidget, newSlot);\n}\n\nstatic bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n}\n```\n\n根据上面的代码，总结各种case\n\n* child != null && newWidget == null :\n    newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element\n* child == null && newWidget != null : \n    第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)\n* child != null && newWidget != null :\n    更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建\n* child == null && newWidget == null :\n    do nothing\n\n在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)\n\n```dart\n@protected\nElement inflateWidget(Widget newWidget, dynamic newSlot) {\n    ...\n\n    final Element newChild = newWidget.createElement();\n    newChild.mount(this, newSlot);\n    return newChild;\n}\n```\n\n```dart\nabstract class StatefulWidget extends Widget {\n  const StatefulWidget({ Key key }) : super(key: key);\n\n  @override\n  StatefulElement createElement() => StatefulElement(this);\n\n  State createState();\n}\n\nclass StatefulElement extends ComponentElement {\n\n  StatefulElement(StatefulWidget widget)\n      : _state = widget.createState(),\n        super(widget) {\n    _state._element = this;\n    _state._widget = widget;\n  }\n\n  @override\n  Widget build() => state.build(this);\n}\n```\nStatefulWidget，State，StatefulElement的调用关系： \nWidget.createElement() -> Element.build() -> State.build()\n\n### 更新Element\n\n```dart\nWidget.setState\n    - Element.markNeedsBuild()\n        - Element._dirty = true\n        - BuildOwner.scheduleBuildFor(this)\n            - BuildOwner._dirtyElements.add(element)\n```\n\n当调用statState之后，会将element标脏，并加入到_dirtyElements列表中\n\n```dart\n- WidgetsBinding.drawFrame()\n    - BuildOwner.buildScope(renderViewElement)\n        - BuildOwner._dirtyElements[index].rebuild()\n```\n\n每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。\n可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的\n\n### 卸载Element\n\n在Element的updateChild方法中，在 `child != null && newWidget == null` 时，会调用deactivateChild()\n\n```dart\n  @protected\n  void deactivateChild(Element child) {\n    child._parent = null;\n    child.detachRenderObject();\n    owner._inactiveElements.add(child); // this eventually calls child.deactivate()\n  }\n```\ndeactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。\n\n还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount\n\n```dart\nvoid finalizeTree() {\n    Timeline.startSync('Finalize tree', arguments: timelineWhitelistArguments);\n    try {\n      lockState(() {\n        _inactiveElements._unmountAll(); // this unregisters the GlobalKeys\n      });\n    }\n    ...\n}\n\nvoid _unmountAll() {\n    _locked = true;\n    final List<Element> elements = _elements.toList()..sort(Element._sort);\n    _elements.clear();\n    try {\n      elements.reversed.forEach(_unmount);\n    } finally {\n      _locked = false;\n    }\n}\n\nvoid _unmount(Element element) {\n    element.visitChildren((Element child) {\n      _unmount(child);\n    });\n    element.unmount();\n}\n```\n\n## RenderObject\n\n### RenderObjectElement\n\nRenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。**不是所有的Element都有对应的RenderObject**\n\nRenderObjectElement有三个常用的子类：\n\n* LeafRenderObjectElement：Leaf render objects, with no children\n* SingleChildRenderObjectElement：A single child\n* MultiChildRenderObjectElement：A linked list of children.\n\nRenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。\n\n### RenderObject的更新\n\n我们从render树的insert过程类分析RenderObject的更新\n从RenderObjectElement.insertChildRenderObject开始\n\n```dart\n  @override\n  void insertChildRenderObject(RenderObject child, Element slot) {\n    final ContainerRenderObjectMixin<RenderObject, ContainerParentDataMixin<RenderObject>> renderObject = this.renderObject;\n    renderObject.insert(child, after: slot?.renderObject);\n  }\n```\n\n这里调用了ContainerRenderObjectMixin的insert方法，\n\n```dart\n  void insert(ChildType child, { ChildType after }) {\n    adoptChild(child);\n    _insertIntoChildList(child, after: after);\n  }\n\n  @override\n  void adoptChild(RenderObject child) {\n    setupParentData(child);\n    markNeedsLayout();\n    markNeedsCompositingBitsUpdate();\n    markNeedsSemanticsUpdate();\n    super.adoptChild(child);\n  }\n\n  void markNeedsLayout() {\n    if (_relayoutBoundary != this) {\n      markParentNeedsLayout();\n    } else {\n      _needsLayout = true;\n      if (owner != null) {\n        owner._nodesNeedingLayout.add(this);\n        owner.requestVisualUpdate();\n      }\n    }\n  }\n\n  @protected\n  void markParentNeedsLayout() {\n    _needsLayout = true;\n    final RenderObject parent = this.parent;\n    if (!_doingThisLayoutWithCallback) {\n      parent.markNeedsLayout();\n    } else {\n      assert(parent._debugDoingThisLayout);\n    }\n  }\n```\n\nmarkNeedsLayout中判断如果不是_relayoutBoundary，对该节点标脏的同时会对parent进行向上标脏；否则，只对本节点标脏，触发`owner._nodesNeedingLayout.add( this )`与`owner.requestVisualUpdate()` 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner\n\nPiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。\n(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)\n来看一下PiplelineOwner.requestVisualUpdate\n\n```dart\n  void requestVisualUpdate() {\n    if (onNeedVisualUpdate != null)\n      onNeedVisualUpdate();\n  }\n```\nonNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里\n\n```dart\n  void initInstances() {\n    super.initInstances();\n    _instance = this;\n    _pipelineOwner = PipelineOwner(\n      onNeedVisualUpdate: ensureVisualUpdate,\n      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,\n      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,\n    );\n    window\n      ..onMetricsChanged = handleMetricsChanged\n      ..onTextScaleFactorChanged = handleTextScaleFactorChanged\n      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged\n      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged\n      ..onSemanticsAction = _handleSemanticsAction;\n    initRenderView();\n    _handleSemanticsEnabledChanged();\n    assert(renderView != null);\n    addPersistentFrameCallback(_handlePersistentFrameCallback);\n    initMouseTracker();\n  }\n\n  void _handlePersistentFrameCallback(Duration timeStamp) {\n    drawFrame();\n  }\n```\n\nensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制\n\n\n### layout、paint流程\n\n**RendererBinding.drawFrame**\n\n```dart\n  @protected\n  void drawFrame() {\n    ...\n    pipelineOwner.flushLayout();\n    pipelineOwner.flushCompositingBits();\n    pipelineOwner.flushPaint();\n    renderView.compositeFrame(); // this sends the bits to the GPU\n    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.\n  }\n```\n\n**pipelineOwner.flushLayout()**\n```dart\n  void flushLayout() {\n    try {\n      while (_nodesNeedingLayout.isNotEmpty) {\n        final List<RenderObject> dirtyNodes = _nodesNeedingLayout;\n        _nodesNeedingLayout = <RenderObject>[];\n        for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => a.depth - b.depth)) {\n          if (node._needsLayout && node.owner == this)\n            node._layoutWithoutResize();\n        }\n      }\n    } finally {\n      ...\n    }\n  }\n```\n\n***RendererObject._layoutWithoutResize**\n\n```dart\n  void _layoutWithoutResize() {\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, stack) {\n      _debugReportException('performLayout', e, stack);\n    }\n    _needsLayout = false;\n    markNeedsPaint();\n  }\n```\n\n这里调用performLayout()进行layout，并标记需要paint\n\n**flushPaint()的逻辑和flushLayout基本一致**\n\n\n\n\n\n\n","source":"_posts/Flutter/flutter-ui源码-初步.md","raw":"---\ntitle: flutter ui源码 初步\ndate: 2020-08-14 20:30:42\ntags:\n- Flutter\n---\n\n## Widget, Element, RanderObject 三者之间的关系\n\nWidget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。\n\n## Widget\n\nWidget类和Element类一一对应。Element是通过Widget生成的\nWidget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。\n\n**Widget.createElement()**\n\n创建Element对象\n\n**Widget.canUpdate(..)**\n```dart\nstatic bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n}\n```\n\n主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；\n通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。\n\n### State\n一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.\n\n**createState()**\n\n用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，**所以，本质上就是一个StatefulElement对应一个State实例。**\n\n**widget和context**\n- widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但**State实例只会在第一次插入到树中时被创建**，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 \n\n- context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext\n\n**State如何被Widget复用**\n只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(...)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。\n\n## Element\n\n最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。\n\n下面从Element的 **挂载、更新、卸载**过程来描述Element\n\n### mount\n\n**根Element的mount**\n\n```\n- main() \n    - runApp(..)\n    - WidgetsFlutterBinding.attachRootWidget(app)\n        - RenderObjectToWidgetAdapter<RenderBox>.attachToRenderTree(buildOwner, renderViewElement);\n            - createElement()\n            - BuildOwner.buildScope(element, () {\n                element.mount(null, null);\n            })\n```\n\n以上是根Element的mount过程，其中rederViewElement是根Elemet\n\n** Element的mount过程\n\n首先来看一下常用的StatelessElement，StatefulElement的继承关系\n\n```\nElement -> ComponentElement -> StatelessElement\n                            -> StatefulElement\n```\n\n```\n- mount()\n    - Element.updateInheritance()\n    - ComponentElement.firstBuild()\n        - Element.rebuild()\n        - ComponentElement.performRebuild()\n            - built = build()\n                -Widget.build()\n            - Element.updateChild(child, built, _)\n```\n\nElement.updateChild方法非常重要\n\n```dart\n@protected\nElement updateChild(Element child, Widget newWidget, dynamic newSlot) {\n    if (newWidget == null) {\n      if (child != null)\n        deactivateChild(child);\n      return null;\n    }\n    if (child != null) {\n      if (child.widget == newWidget) {\n        return child;\n      }\n      if (Widget.canUpdate(child.widget, newWidget)) {\n        child.update(newWidget);\n        return child;\n      }\n      deactivateChild(child);\n    }\n    return inflateWidget(newWidget, newSlot);\n}\n\nstatic bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n}\n```\n\n根据上面的代码，总结各种case\n\n* child != null && newWidget == null :\n    newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element\n* child == null && newWidget != null : \n    第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)\n* child != null && newWidget != null :\n    更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建\n* child == null && newWidget == null :\n    do nothing\n\n在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)\n\n```dart\n@protected\nElement inflateWidget(Widget newWidget, dynamic newSlot) {\n    ...\n\n    final Element newChild = newWidget.createElement();\n    newChild.mount(this, newSlot);\n    return newChild;\n}\n```\n\n```dart\nabstract class StatefulWidget extends Widget {\n  const StatefulWidget({ Key key }) : super(key: key);\n\n  @override\n  StatefulElement createElement() => StatefulElement(this);\n\n  State createState();\n}\n\nclass StatefulElement extends ComponentElement {\n\n  StatefulElement(StatefulWidget widget)\n      : _state = widget.createState(),\n        super(widget) {\n    _state._element = this;\n    _state._widget = widget;\n  }\n\n  @override\n  Widget build() => state.build(this);\n}\n```\nStatefulWidget，State，StatefulElement的调用关系： \nWidget.createElement() -> Element.build() -> State.build()\n\n### 更新Element\n\n```dart\nWidget.setState\n    - Element.markNeedsBuild()\n        - Element._dirty = true\n        - BuildOwner.scheduleBuildFor(this)\n            - BuildOwner._dirtyElements.add(element)\n```\n\n当调用statState之后，会将element标脏，并加入到_dirtyElements列表中\n\n```dart\n- WidgetsBinding.drawFrame()\n    - BuildOwner.buildScope(renderViewElement)\n        - BuildOwner._dirtyElements[index].rebuild()\n```\n\n每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。\n可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的\n\n### 卸载Element\n\n在Element的updateChild方法中，在 `child != null && newWidget == null` 时，会调用deactivateChild()\n\n```dart\n  @protected\n  void deactivateChild(Element child) {\n    child._parent = null;\n    child.detachRenderObject();\n    owner._inactiveElements.add(child); // this eventually calls child.deactivate()\n  }\n```\ndeactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。\n\n还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount\n\n```dart\nvoid finalizeTree() {\n    Timeline.startSync('Finalize tree', arguments: timelineWhitelistArguments);\n    try {\n      lockState(() {\n        _inactiveElements._unmountAll(); // this unregisters the GlobalKeys\n      });\n    }\n    ...\n}\n\nvoid _unmountAll() {\n    _locked = true;\n    final List<Element> elements = _elements.toList()..sort(Element._sort);\n    _elements.clear();\n    try {\n      elements.reversed.forEach(_unmount);\n    } finally {\n      _locked = false;\n    }\n}\n\nvoid _unmount(Element element) {\n    element.visitChildren((Element child) {\n      _unmount(child);\n    });\n    element.unmount();\n}\n```\n\n## RenderObject\n\n### RenderObjectElement\n\nRenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。**不是所有的Element都有对应的RenderObject**\n\nRenderObjectElement有三个常用的子类：\n\n* LeafRenderObjectElement：Leaf render objects, with no children\n* SingleChildRenderObjectElement：A single child\n* MultiChildRenderObjectElement：A linked list of children.\n\nRenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。\n\n### RenderObject的更新\n\n我们从render树的insert过程类分析RenderObject的更新\n从RenderObjectElement.insertChildRenderObject开始\n\n```dart\n  @override\n  void insertChildRenderObject(RenderObject child, Element slot) {\n    final ContainerRenderObjectMixin<RenderObject, ContainerParentDataMixin<RenderObject>> renderObject = this.renderObject;\n    renderObject.insert(child, after: slot?.renderObject);\n  }\n```\n\n这里调用了ContainerRenderObjectMixin的insert方法，\n\n```dart\n  void insert(ChildType child, { ChildType after }) {\n    adoptChild(child);\n    _insertIntoChildList(child, after: after);\n  }\n\n  @override\n  void adoptChild(RenderObject child) {\n    setupParentData(child);\n    markNeedsLayout();\n    markNeedsCompositingBitsUpdate();\n    markNeedsSemanticsUpdate();\n    super.adoptChild(child);\n  }\n\n  void markNeedsLayout() {\n    if (_relayoutBoundary != this) {\n      markParentNeedsLayout();\n    } else {\n      _needsLayout = true;\n      if (owner != null) {\n        owner._nodesNeedingLayout.add(this);\n        owner.requestVisualUpdate();\n      }\n    }\n  }\n\n  @protected\n  void markParentNeedsLayout() {\n    _needsLayout = true;\n    final RenderObject parent = this.parent;\n    if (!_doingThisLayoutWithCallback) {\n      parent.markNeedsLayout();\n    } else {\n      assert(parent._debugDoingThisLayout);\n    }\n  }\n```\n\nmarkNeedsLayout中判断如果不是_relayoutBoundary，对该节点标脏的同时会对parent进行向上标脏；否则，只对本节点标脏，触发`owner._nodesNeedingLayout.add( this )`与`owner.requestVisualUpdate()` 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner\n\nPiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。\n(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)\n来看一下PiplelineOwner.requestVisualUpdate\n\n```dart\n  void requestVisualUpdate() {\n    if (onNeedVisualUpdate != null)\n      onNeedVisualUpdate();\n  }\n```\nonNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里\n\n```dart\n  void initInstances() {\n    super.initInstances();\n    _instance = this;\n    _pipelineOwner = PipelineOwner(\n      onNeedVisualUpdate: ensureVisualUpdate,\n      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,\n      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,\n    );\n    window\n      ..onMetricsChanged = handleMetricsChanged\n      ..onTextScaleFactorChanged = handleTextScaleFactorChanged\n      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged\n      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged\n      ..onSemanticsAction = _handleSemanticsAction;\n    initRenderView();\n    _handleSemanticsEnabledChanged();\n    assert(renderView != null);\n    addPersistentFrameCallback(_handlePersistentFrameCallback);\n    initMouseTracker();\n  }\n\n  void _handlePersistentFrameCallback(Duration timeStamp) {\n    drawFrame();\n  }\n```\n\nensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制\n\n\n### layout、paint流程\n\n**RendererBinding.drawFrame**\n\n```dart\n  @protected\n  void drawFrame() {\n    ...\n    pipelineOwner.flushLayout();\n    pipelineOwner.flushCompositingBits();\n    pipelineOwner.flushPaint();\n    renderView.compositeFrame(); // this sends the bits to the GPU\n    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.\n  }\n```\n\n**pipelineOwner.flushLayout()**\n```dart\n  void flushLayout() {\n    try {\n      while (_nodesNeedingLayout.isNotEmpty) {\n        final List<RenderObject> dirtyNodes = _nodesNeedingLayout;\n        _nodesNeedingLayout = <RenderObject>[];\n        for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => a.depth - b.depth)) {\n          if (node._needsLayout && node.owner == this)\n            node._layoutWithoutResize();\n        }\n      }\n    } finally {\n      ...\n    }\n  }\n```\n\n***RendererObject._layoutWithoutResize**\n\n```dart\n  void _layoutWithoutResize() {\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, stack) {\n      _debugReportException('performLayout', e, stack);\n    }\n    _needsLayout = false;\n    markNeedsPaint();\n  }\n```\n\n这里调用performLayout()进行layout，并标记需要paint\n\n**flushPaint()的逻辑和flushLayout基本一致**\n\n\n\n\n\n\n","slug":"Flutter/flutter-ui源码-初步","published":1,"updated":"2020-09-22T08:29:30.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakrk003u8mzmbkx2l28n","content":"<h2 id=\"Widget-Element-RanderObject-三者之间的关系\"><a href=\"#Widget-Element-RanderObject-三者之间的关系\" class=\"headerlink\" title=\"Widget, Element, RanderObject 三者之间的关系\"></a>Widget, Element, RanderObject 三者之间的关系</h2><a id=\"more\"></a><p>Widget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。</p>\n<h2 id=\"Widget\"><a href=\"#Widget\" class=\"headerlink\" title=\"Widget\"></a>Widget</h2><p>Widget类和Element类一一对应。Element是通过Widget生成的<br>Widget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。</p>\n<p><strong>Widget.createElement()</strong></p>\n<p>创建Element对象</p>\n<p><strong>Widget.canUpdate(..)</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；<br>通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.</p>\n<p><strong>createState()</strong></p>\n<p>用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，<strong>所以，本质上就是一个StatefulElement对应一个State实例。</strong></p>\n<p><strong>widget和context</strong></p>\n<ul>\n<li><p>widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但<strong>State实例只会在第一次插入到树中时被创建</strong>，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 </p>\n</li>\n<li><p>context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext</p>\n</li>\n</ul>\n<p><strong>State如何被Widget复用</strong><br>只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(…)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。</p>\n<h2 id=\"Element\"><a href=\"#Element\" class=\"headerlink\" title=\"Element\"></a>Element</h2><p>最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。</p>\n<p>下面从Element的 <strong>挂载、更新、卸载</strong>过程来描述Element</p>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><p><strong>根Element的mount</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- main() </span><br><span class=\"line\">    - runApp(..)</span><br><span class=\"line\">    - WidgetsFlutterBinding.attachRootWidget(app)</span><br><span class=\"line\">        - RenderObjectToWidgetAdapter&lt;RenderBox&gt;.attachToRenderTree(buildOwner, renderViewElement);</span><br><span class=\"line\">            - createElement()</span><br><span class=\"line\">            - BuildOwner.buildScope(element, () &#123;</span><br><span class=\"line\">                element.mount(null, null);</span><br><span class=\"line\">            &#125;)</span><br></pre></td></tr></table></figure>\n<p>以上是根Element的mount过程，其中rederViewElement是根Elemet</p>\n<p>** Element的mount过程</p>\n<p>首先来看一下常用的StatelessElement，StatefulElement的继承关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element -&gt; ComponentElement -&gt; StatelessElement</span><br><span class=\"line\">                            -&gt; StatefulElement</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- mount()</span><br><span class=\"line\">    - Element.updateInheritance()</span><br><span class=\"line\">    - ComponentElement.firstBuild()</span><br><span class=\"line\">        - Element.rebuild()</span><br><span class=\"line\">        - ComponentElement.performRebuild()</span><br><span class=\"line\">            - built = build()</span><br><span class=\"line\">                -Widget.build()</span><br><span class=\"line\">            - Element.updateChild(child, built, _)</span><br></pre></td></tr></table></figure>\n<p>Element.updateChild方法非常重要</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> updateChild(<span class=\"built_in\">Element</span> child, Widget newWidget, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newWidget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        deactivateChild(child);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (child.widget == newWidget) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class=\"line\">        child.update(newWidget);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      deactivateChild(child);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inflateWidget(newWidget, newSlot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，总结各种case</p>\n<ul>\n<li>child != null &amp;&amp; newWidget == null :<br>  newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element</li>\n<li>child == null &amp;&amp; newWidget != null :<br>  第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)</li>\n<li>child != null &amp;&amp; newWidget != null :<br>  更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建</li>\n<li>child == null &amp;&amp; newWidget == null :<br>  do nothing</li>\n</ul>\n<p>在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> inflateWidget(Widget newWidget, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">Element</span> newChild = newWidget.createElement();</span><br><span class=\"line\">    newChild.mount(<span class=\"keyword\">this</span>, newSlot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newChild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulWidget</span> <span class=\"keyword\">extends</span> <span class=\"title\">Widget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> StatefulWidget(&#123; Key key &#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  StatefulElement createElement() =&gt; StatefulElement(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  State createState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComponentElement</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  StatefulElement(StatefulWidget widget)</span><br><span class=\"line\">      : _state = widget.createState(),</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(widget) &#123;</span><br><span class=\"line\">    _state._element = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    _state._widget = widget;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build() =&gt; state.build(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>StatefulWidget，State，StatefulElement的调用关系：<br>Widget.createElement() -&gt; Element.build() -&gt; State.build()</p>\n<h3 id=\"更新Element\"><a href=\"#更新Element\" class=\"headerlink\" title=\"更新Element\"></a>更新Element</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget.setState</span><br><span class=\"line\">    - <span class=\"built_in\">Element</span>.markNeedsBuild()</span><br><span class=\"line\">        - <span class=\"built_in\">Element</span>._dirty = <span class=\"keyword\">true</span></span><br><span class=\"line\">        - BuildOwner.scheduleBuildFor(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            - BuildOwner._dirtyElements.add(element)</span><br></pre></td></tr></table></figure>\n<p>当调用statState之后，会将element标脏，并加入到_dirtyElements列表中</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- WidgetsBinding.drawFrame()</span><br><span class=\"line\">    - BuildOwner.buildScope(renderViewElement)</span><br><span class=\"line\">        - BuildOwner._dirtyElements[index].rebuild()</span><br></pre></td></tr></table></figure>\n<p>每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。<br>可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的</p>\n<h3 id=\"卸载Element\"><a href=\"#卸载Element\" class=\"headerlink\" title=\"卸载Element\"></a>卸载Element</h3><p>在Element的updateChild方法中，在 <code>child != null &amp;&amp; newWidget == null</code> 时，会调用deactivateChild()</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> deactivateChild(<span class=\"built_in\">Element</span> child) &#123;</span><br><span class=\"line\">  child._parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  child.detachRenderObject();</span><br><span class=\"line\">  owner._inactiveElements.add(child); <span class=\"comment\">// this eventually calls child.deactivate()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>deactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。</p>\n<p>还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> finalizeTree() &#123;</span><br><span class=\"line\">    Timeline.startSync(<span class=\"string\">'Finalize tree'</span>, arguments: timelineWhitelistArguments);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      lockState(() &#123;</span><br><span class=\"line\">        _inactiveElements._unmountAll(); <span class=\"comment\">// this unregisters the GlobalKeys</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _unmountAll() &#123;</span><br><span class=\"line\">    _locked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">Element</span>&gt; elements = _elements.toList()..sort(<span class=\"built_in\">Element</span>._sort);</span><br><span class=\"line\">    _elements.clear();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      elements.reversed.forEach(_unmount);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      _locked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _unmount(<span class=\"built_in\">Element</span> element) &#123;</span><br><span class=\"line\">    element.visitChildren((<span class=\"built_in\">Element</span> child) &#123;</span><br><span class=\"line\">      _unmount(child);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    element.unmount();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RenderObject\"><a href=\"#RenderObject\" class=\"headerlink\" title=\"RenderObject\"></a>RenderObject</h2><h3 id=\"RenderObjectElement\"><a href=\"#RenderObjectElement\" class=\"headerlink\" title=\"RenderObjectElement\"></a>RenderObjectElement</h3><p>RenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。<strong>不是所有的Element都有对应的RenderObject</strong></p>\n<p>RenderObjectElement有三个常用的子类：</p>\n<ul>\n<li>LeafRenderObjectElement：Leaf render objects, with no children</li>\n<li>SingleChildRenderObjectElement：A single child</li>\n<li>MultiChildRenderObjectElement：A linked list of children.</li>\n</ul>\n<p>RenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。</p>\n<h3 id=\"RenderObject的更新\"><a href=\"#RenderObject的更新\" class=\"headerlink\" title=\"RenderObject的更新\"></a>RenderObject的更新</h3><p>我们从render树的insert过程类分析RenderObject的更新<br>从RenderObjectElement.insertChildRenderObject开始</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> insertChildRenderObject(RenderObject child, <span class=\"built_in\">Element</span> slot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt; renderObject = <span class=\"keyword\">this</span>.renderObject;</span><br><span class=\"line\">  renderObject.insert(child, after: slot?.renderObject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用了ContainerRenderObjectMixin的insert方法，</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> insert(ChildType child, &#123; ChildType after &#125;) &#123;</span><br><span class=\"line\">  adoptChild(child);</span><br><span class=\"line\">  _insertIntoChildList(child, after: after);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> adoptChild(RenderObject child) &#123;</span><br><span class=\"line\">  setupParentData(child);</span><br><span class=\"line\">  markNeedsLayout();</span><br><span class=\"line\">  markNeedsCompositingBitsUpdate();</span><br><span class=\"line\">  markNeedsSemanticsUpdate();</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.adoptChild(child);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> markNeedsLayout() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_relayoutBoundary != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    markParentNeedsLayout();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    _needsLayout = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      owner._nodesNeedingLayout.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      owner.requestVisualUpdate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> markParentNeedsLayout() &#123;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> RenderObject parent = <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_doingThisLayoutWithCallback) &#123;</span><br><span class=\"line\">    parent.markNeedsLayout();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(parent._debugDoingThisLayout);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>markNeedsLayout中判断如果不是_relayoutBoundary，对该节点标脏的同时会对parent进行向上标脏；否则，只对本节点标脏，触发<code>owner._nodesNeedingLayout.add( this )</code>与<code>owner.requestVisualUpdate()</code> 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner</p>\n<p>PiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。<br>(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)<br>来看一下PiplelineOwner.requestVisualUpdate</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> requestVisualUpdate() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (onNeedVisualUpdate != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    onNeedVisualUpdate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>onNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> initInstances() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.initInstances();</span><br><span class=\"line\">  _instance = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  _pipelineOwner = PipelineOwner(</span><br><span class=\"line\">    onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class=\"line\">    onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class=\"line\">    onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"built_in\">window</span></span><br><span class=\"line\">    ..onMetricsChanged = handleMetricsChanged</span><br><span class=\"line\">    ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class=\"line\">    ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class=\"line\">    ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class=\"line\">    ..onSemanticsAction = _handleSemanticsAction;</span><br><span class=\"line\">  initRenderView();</span><br><span class=\"line\">  _handleSemanticsEnabledChanged();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(renderView != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class=\"line\">  initMouseTracker();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _handlePersistentFrameCallback(<span class=\"built_in\">Duration</span> timeStamp) &#123;</span><br><span class=\"line\">  drawFrame();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制</p>\n<h3 id=\"layout、paint流程\"><a href=\"#layout、paint流程\" class=\"headerlink\" title=\"layout、paint流程\"></a>layout、paint流程</h3><p><strong>RendererBinding.drawFrame</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> drawFrame() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  pipelineOwner.flushLayout();</span><br><span class=\"line\">  pipelineOwner.flushCompositingBits();</span><br><span class=\"line\">  pipelineOwner.flushPaint();</span><br><span class=\"line\">  renderView.compositeFrame(); <span class=\"comment\">// this sends the bits to the GPU</span></span><br><span class=\"line\">  pipelineOwner.flushSemantics(); <span class=\"comment\">// this also sends the semantics to the OS.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>pipelineOwner.flushLayout()</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> flushLayout() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class=\"line\">      _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (RenderObject node <span class=\"keyword\">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node._needsLayout &amp;&amp; node.owner == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">          node._layoutWithoutResize();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>*RendererObject._layoutWithoutResize</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _layoutWithoutResize() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    performLayout();</span><br><span class=\"line\">    markNeedsSemanticsUpdate();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'performLayout'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  markNeedsPaint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用performLayout()进行layout，并标记需要paint</p>\n<p><strong>flushPaint()的逻辑和flushLayout基本一致</strong></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Widget-Element-RanderObject-三者之间的关系\"><a href=\"#Widget-Element-RanderObject-三者之间的关系\" class=\"headerlink\" title=\"Widget, Element, RanderObject 三者之间的关系\"></a>Widget, Element, RanderObject 三者之间的关系</h2>","more":"<p>Widget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。</p>\n<h2 id=\"Widget\"><a href=\"#Widget\" class=\"headerlink\" title=\"Widget\"></a>Widget</h2><p>Widget类和Element类一一对应。Element是通过Widget生成的<br>Widget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。</p>\n<p><strong>Widget.createElement()</strong></p>\n<p>创建Element对象</p>\n<p><strong>Widget.canUpdate(..)</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；<br>通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.</p>\n<p><strong>createState()</strong></p>\n<p>用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，<strong>所以，本质上就是一个StatefulElement对应一个State实例。</strong></p>\n<p><strong>widget和context</strong></p>\n<ul>\n<li><p>widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但<strong>State实例只会在第一次插入到树中时被创建</strong>，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 </p>\n</li>\n<li><p>context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext</p>\n</li>\n</ul>\n<p><strong>State如何被Widget复用</strong><br>只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(…)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。</p>\n<h2 id=\"Element\"><a href=\"#Element\" class=\"headerlink\" title=\"Element\"></a>Element</h2><p>最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。</p>\n<p>下面从Element的 <strong>挂载、更新、卸载</strong>过程来描述Element</p>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><p><strong>根Element的mount</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- main() </span><br><span class=\"line\">    - runApp(..)</span><br><span class=\"line\">    - WidgetsFlutterBinding.attachRootWidget(app)</span><br><span class=\"line\">        - RenderObjectToWidgetAdapter&lt;RenderBox&gt;.attachToRenderTree(buildOwner, renderViewElement);</span><br><span class=\"line\">            - createElement()</span><br><span class=\"line\">            - BuildOwner.buildScope(element, () &#123;</span><br><span class=\"line\">                element.mount(null, null);</span><br><span class=\"line\">            &#125;)</span><br></pre></td></tr></table></figure>\n<p>以上是根Element的mount过程，其中rederViewElement是根Elemet</p>\n<p>** Element的mount过程</p>\n<p>首先来看一下常用的StatelessElement，StatefulElement的继承关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element -&gt; ComponentElement -&gt; StatelessElement</span><br><span class=\"line\">                            -&gt; StatefulElement</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- mount()</span><br><span class=\"line\">    - Element.updateInheritance()</span><br><span class=\"line\">    - ComponentElement.firstBuild()</span><br><span class=\"line\">        - Element.rebuild()</span><br><span class=\"line\">        - ComponentElement.performRebuild()</span><br><span class=\"line\">            - built = build()</span><br><span class=\"line\">                -Widget.build()</span><br><span class=\"line\">            - Element.updateChild(child, built, _)</span><br></pre></td></tr></table></figure>\n<p>Element.updateChild方法非常重要</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> updateChild(<span class=\"built_in\">Element</span> child, Widget newWidget, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newWidget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        deactivateChild(child);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (child.widget == newWidget) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class=\"line\">        child.update(newWidget);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      deactivateChild(child);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inflateWidget(newWidget, newSlot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，总结各种case</p>\n<ul>\n<li>child != null &amp;&amp; newWidget == null :<br>  newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element</li>\n<li>child == null &amp;&amp; newWidget != null :<br>  第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)</li>\n<li>child != null &amp;&amp; newWidget != null :<br>  更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建</li>\n<li>child == null &amp;&amp; newWidget == null :<br>  do nothing</li>\n</ul>\n<p>在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> inflateWidget(Widget newWidget, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">Element</span> newChild = newWidget.createElement();</span><br><span class=\"line\">    newChild.mount(<span class=\"keyword\">this</span>, newSlot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newChild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulWidget</span> <span class=\"keyword\">extends</span> <span class=\"title\">Widget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> StatefulWidget(&#123; Key key &#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  StatefulElement createElement() =&gt; StatefulElement(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  State createState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComponentElement</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  StatefulElement(StatefulWidget widget)</span><br><span class=\"line\">      : _state = widget.createState(),</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(widget) &#123;</span><br><span class=\"line\">    _state._element = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    _state._widget = widget;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build() =&gt; state.build(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>StatefulWidget，State，StatefulElement的调用关系：<br>Widget.createElement() -&gt; Element.build() -&gt; State.build()</p>\n<h3 id=\"更新Element\"><a href=\"#更新Element\" class=\"headerlink\" title=\"更新Element\"></a>更新Element</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget.setState</span><br><span class=\"line\">    - <span class=\"built_in\">Element</span>.markNeedsBuild()</span><br><span class=\"line\">        - <span class=\"built_in\">Element</span>._dirty = <span class=\"keyword\">true</span></span><br><span class=\"line\">        - BuildOwner.scheduleBuildFor(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            - BuildOwner._dirtyElements.add(element)</span><br></pre></td></tr></table></figure>\n<p>当调用statState之后，会将element标脏，并加入到_dirtyElements列表中</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- WidgetsBinding.drawFrame()</span><br><span class=\"line\">    - BuildOwner.buildScope(renderViewElement)</span><br><span class=\"line\">        - BuildOwner._dirtyElements[index].rebuild()</span><br></pre></td></tr></table></figure>\n<p>每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。<br>可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的</p>\n<h3 id=\"卸载Element\"><a href=\"#卸载Element\" class=\"headerlink\" title=\"卸载Element\"></a>卸载Element</h3><p>在Element的updateChild方法中，在 <code>child != null &amp;&amp; newWidget == null</code> 时，会调用deactivateChild()</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> deactivateChild(<span class=\"built_in\">Element</span> child) &#123;</span><br><span class=\"line\">  child._parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  child.detachRenderObject();</span><br><span class=\"line\">  owner._inactiveElements.add(child); <span class=\"comment\">// this eventually calls child.deactivate()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>deactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。</p>\n<p>还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> finalizeTree() &#123;</span><br><span class=\"line\">    Timeline.startSync(<span class=\"string\">'Finalize tree'</span>, arguments: timelineWhitelistArguments);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      lockState(() &#123;</span><br><span class=\"line\">        _inactiveElements._unmountAll(); <span class=\"comment\">// this unregisters the GlobalKeys</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _unmountAll() &#123;</span><br><span class=\"line\">    _locked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">Element</span>&gt; elements = _elements.toList()..sort(<span class=\"built_in\">Element</span>._sort);</span><br><span class=\"line\">    _elements.clear();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      elements.reversed.forEach(_unmount);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      _locked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _unmount(<span class=\"built_in\">Element</span> element) &#123;</span><br><span class=\"line\">    element.visitChildren((<span class=\"built_in\">Element</span> child) &#123;</span><br><span class=\"line\">      _unmount(child);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    element.unmount();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RenderObject\"><a href=\"#RenderObject\" class=\"headerlink\" title=\"RenderObject\"></a>RenderObject</h2><h3 id=\"RenderObjectElement\"><a href=\"#RenderObjectElement\" class=\"headerlink\" title=\"RenderObjectElement\"></a>RenderObjectElement</h3><p>RenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。<strong>不是所有的Element都有对应的RenderObject</strong></p>\n<p>RenderObjectElement有三个常用的子类：</p>\n<ul>\n<li>LeafRenderObjectElement：Leaf render objects, with no children</li>\n<li>SingleChildRenderObjectElement：A single child</li>\n<li>MultiChildRenderObjectElement：A linked list of children.</li>\n</ul>\n<p>RenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。</p>\n<h3 id=\"RenderObject的更新\"><a href=\"#RenderObject的更新\" class=\"headerlink\" title=\"RenderObject的更新\"></a>RenderObject的更新</h3><p>我们从render树的insert过程类分析RenderObject的更新<br>从RenderObjectElement.insertChildRenderObject开始</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> insertChildRenderObject(RenderObject child, <span class=\"built_in\">Element</span> slot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt; renderObject = <span class=\"keyword\">this</span>.renderObject;</span><br><span class=\"line\">  renderObject.insert(child, after: slot?.renderObject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用了ContainerRenderObjectMixin的insert方法，</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> insert(ChildType child, &#123; ChildType after &#125;) &#123;</span><br><span class=\"line\">  adoptChild(child);</span><br><span class=\"line\">  _insertIntoChildList(child, after: after);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> adoptChild(RenderObject child) &#123;</span><br><span class=\"line\">  setupParentData(child);</span><br><span class=\"line\">  markNeedsLayout();</span><br><span class=\"line\">  markNeedsCompositingBitsUpdate();</span><br><span class=\"line\">  markNeedsSemanticsUpdate();</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.adoptChild(child);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> markNeedsLayout() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_relayoutBoundary != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    markParentNeedsLayout();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    _needsLayout = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      owner._nodesNeedingLayout.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      owner.requestVisualUpdate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> markParentNeedsLayout() &#123;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> RenderObject parent = <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_doingThisLayoutWithCallback) &#123;</span><br><span class=\"line\">    parent.markNeedsLayout();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(parent._debugDoingThisLayout);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>markNeedsLayout中判断如果不是_relayoutBoundary，对该节点标脏的同时会对parent进行向上标脏；否则，只对本节点标脏，触发<code>owner._nodesNeedingLayout.add( this )</code>与<code>owner.requestVisualUpdate()</code> 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner</p>\n<p>PiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。<br>(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)<br>来看一下PiplelineOwner.requestVisualUpdate</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> requestVisualUpdate() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (onNeedVisualUpdate != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    onNeedVisualUpdate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>onNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> initInstances() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.initInstances();</span><br><span class=\"line\">  _instance = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  _pipelineOwner = PipelineOwner(</span><br><span class=\"line\">    onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class=\"line\">    onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class=\"line\">    onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"built_in\">window</span></span><br><span class=\"line\">    ..onMetricsChanged = handleMetricsChanged</span><br><span class=\"line\">    ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class=\"line\">    ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class=\"line\">    ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class=\"line\">    ..onSemanticsAction = _handleSemanticsAction;</span><br><span class=\"line\">  initRenderView();</span><br><span class=\"line\">  _handleSemanticsEnabledChanged();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(renderView != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class=\"line\">  initMouseTracker();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _handlePersistentFrameCallback(<span class=\"built_in\">Duration</span> timeStamp) &#123;</span><br><span class=\"line\">  drawFrame();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制</p>\n<h3 id=\"layout、paint流程\"><a href=\"#layout、paint流程\" class=\"headerlink\" title=\"layout、paint流程\"></a>layout、paint流程</h3><p><strong>RendererBinding.drawFrame</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> drawFrame() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  pipelineOwner.flushLayout();</span><br><span class=\"line\">  pipelineOwner.flushCompositingBits();</span><br><span class=\"line\">  pipelineOwner.flushPaint();</span><br><span class=\"line\">  renderView.compositeFrame(); <span class=\"comment\">// this sends the bits to the GPU</span></span><br><span class=\"line\">  pipelineOwner.flushSemantics(); <span class=\"comment\">// this also sends the semantics to the OS.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>pipelineOwner.flushLayout()</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> flushLayout() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class=\"line\">      _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (RenderObject node <span class=\"keyword\">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node._needsLayout &amp;&amp; node.owner == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">          node._layoutWithoutResize();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>*RendererObject._layoutWithoutResize</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _layoutWithoutResize() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    performLayout();</span><br><span class=\"line\">    markNeedsSemanticsUpdate();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'performLayout'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  markNeedsPaint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用performLayout()进行layout，并标记需要paint</p>\n<p><strong>flushPaint()的逻辑和flushLayout基本一致</strong></p>\n"},{"title":"Glide源码-主要流程","date":"2019-11-17T18:00:05.000Z","_content":"\n## API调用\n\n```java\nGlide.with(fragment)\n    .load(myUrl)\n    .into(imageView);\n```\n\n## with过程\n\n### 主要工作\n\n将图片加载和对应的生命周期绑定(如activity, fragment等)\n绑定生命周期的优点:\n* 在activity, fragment等销毁的时候, 停止对应的图片加载. \n* 避免消耗资源\n* 防止空指针问题的出现\n\n### Glide\n```java\n    public static RequestManager with(Context context) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(context);\n    }\n\n    public static RequestManager with(Activity activity) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(activity);\n    }\n    \n    public static RequestManager with(FragmentActivity activity) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(activity);\n    }\n    \n    public static RequestManager with(android.app.Fragment fragment) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(fragment);\n    }\n    \n    public static RequestManager with(Fragment fragment) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(fragment);\n    }\n```\n\n### RequestManagerRetriever\n\n前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:\n默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了.\n\n```java\npublic RequestManager get(Context context) {\n    if (context == null) {\n        throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n    } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n        if (context instanceof FragmentActivity) {\n            return get((FragmentActivity) context);\n        } else if (context instanceof Activity) {\n            return get((Activity) context);\n        } else if (context instanceof ContextWrapper) {\n            return get(((ContextWrapper) context).getBaseContext());\n        }\n    }\n\n    return getApplicationManager(context);\n}\n\n// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定\nprivate RequestManager getApplicationManager(Context context) {\n    // Either an application context or we're on a background thread.\n    if (applicationManager == null) {\n        synchronized (this) {\n            if (applicationManager == null) {\n                // Normally pause/resume is taken care of by the fragment we add to the fragment or activity.\n                // However, in this case since the manager attached to the application will not receive lifecycle\n                // events, we must force the manager to start resumed using ApplicationLifecycle.\n\n                // 双校验锁 懒汉单例\n                // 将资源加载与整个APP的生命周期绑定\n                applicationManager = new RequestManager(context.getApplicationContext(),\n                        new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());\n            }\n        }\n    }\n\n    return applicationManager;\n}\n\n// 获取RequestManager\npublic RequestManager get(Activity activity) {\n    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n        return get(activity.getApplicationContext());\n    } else {\n        assertNotDestroyed(activity);\n        android.app.FragmentManager fm = activity.getFragmentManager();\n        return fragmentGet(activity, fm);\n    }\n}\n\n.... // 省略其他的重载方法\n\n// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定\nRequestManager fragmentGet(Context context, android.app.FragmentManager fm) {\n    RequestManagerFragment current = getRequestManagerFragment(fm);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());\n        current.setRequestManager(requestManager);\n    }\n    return requestManager;\n}\n\n// 创建并添加RequestManagerFragment\nRequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {\n    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n    if (current == null) {\n        // pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的\n        current = pendingRequestManagerFragments.get(fm);\n        if (current == null) {\n            // 使用FragmentManager添加fragment\n            current = new RequestManagerFragment();\n            pendingRequestManagerFragments.put(fm, current);\n            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();\n        }\n    }\n    return current;\n}\n\n```\n\n## load过程\n\n### RequestManager-load\n\n```java\npublic DrawableTypeRequest<String> load(String string) {\n    return (DrawableTypeRequest<String>) fromString().load(string);\n}\n```\n\n### GenericRequestBuilder\n\nRequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法. \n跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了\n\n```java    \n// ModelType是一个泛型通配符, model是加载的参数\npublic GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {\n    this.model = model;\n    isModelSet = true;\n    return this;\n}\n\n```\n\n## into过程\n\n### GenericRequestBuilder-into\n\n```java\npublic Target<TranscodeType> into(ImageView view) {\n    Util.assertMainThread();\n    if (view == null) {\n        throw new IllegalArgumentException(\"You must pass in a non null View\");\n    }\n\n    // ...省略代码\n\n    return into(glide.buildImageViewTarget(view, transcodeClass));\n}\n\npublic <Y extends Target<TranscodeType>> Y into(Y target) {\n    Util.assertMainThread();\n    \n    ... // 省略代码\n\n    Request previous = target.getRequest();\n\n    // 清楚target上旧的图片请求\n    if (previous != null) {\n        previous.clear();\n        requestTracker.removeRequest(previous);\n        previous.recycle();\n    }\n\n    Request request = buildRequest(target);\n    target.setRequest(request);\n    lifecycle.addListener(target);\n    // 开始请求图片\n    requestTracker.runRequest(request);\n\n    return target;\n}\n```\n\n**为什么要清楚target上旧的图片请求:**\n\n由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。\n\n在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象\n\n### GenericRequestBuilder-runRequest\n\n```java\npublic void runRequest(Request request) {\n    requests.add(request);\n    if (!isPaused) {\n        // 请求加载没有暂停, 则开始请求\n        request.begin();\n    } else {\n        // 请求加载暂停了, 则放入到等待队列中去\n        pendingRequests.add(request);\n    }\n}\n```\n\n```java\n@Override\npublic void begin() {\n    startTime = LogTime.getLogTime();\n    if (model == null) {\n        onException(null);\n        return;\n    }\n\n    status = Status.WAITING_FOR_SIZE;\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n        // 如果用户在调用API时配置了图片的大小, 直接下一步\n        // onSizeReady这个方法很重要\n        onSizeReady(overrideWidth, overrideHeight);\n    } else {\n        // 如果没有, 则获取ImageView的大小\n        // 这个方法最终也会走到onSizeReady方法\n        target.getSize(this);\n    }\n\n    if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {\n        target.onLoadStarted(getPlaceholderDrawable());\n    }\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime));\n    }\n}\n```\n\n```java\n@Override\npublic void onSizeReady(int width, int height) {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"Got onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n    if (status != Status.WAITING_FOR_SIZE) {\n        return;\n    }\n    status = Status.RUNNING;\n\n    width = Math.round(sizeMultiplier * width);\n    height = Math.round(sizeMultiplier * height);\n\n    ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();\n    final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);\n\n    if (dataFetcher == null) {\n        onException(new Exception(\"Failed to load model: \\'\" + model + \"\\'\"));\n        return;\n    }\n    ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished setup for calling load in \" + LogTime.getElapsedMillis(startTime));\n    }\n    loadedFromMemoryCache = true;\n    // 前面的代码都不知道在讲啥, 反正这个engine.load是重点\n    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,\n            priority, isMemoryCacheable, diskCacheStrategy, this);\n    loadedFromMemoryCache = resource != null;\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n}\n```\n\n### Engine-load\n\n获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. \n\n```java\npublic <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n        DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n\n    final String id = fetcher.getId();\n    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n            transcoder, loadProvider.getSourceEncoder());\n\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n        cb.onResourceReady(cached);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n        }\n        return null;\n    }\n\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n        cb.onResourceReady(active);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n        }\n        return null;\n    }\n\n    EngineJob current = jobs.get(key);\n    if (current != null) {\n        current.addCallback(cb);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Added to existing load\", startTime, key);\n        }\n        return new LoadStatus(cb, current);\n    }\n\n    // 前面的缓存策略, 只有再说\n\n    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n    DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n            transcoder, diskCacheProvider, diskCacheStrategy, priority);\n    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n    jobs.put(key, engineJob);\n    engineJob.addCallback(cb);\n    engineJob.start(runnable);\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Started new load\", startTime, key);\n    }\n    return new LoadStatus(cb, engineJob);\n}\n```\n\n### EngineRunnable\n\n获取网络图片, 并编解码\n\n```java\n@Override\npublic void run() {\n    if (isCancelled) {\n        return;\n    }\n\n    Exception exception = null;\n    Resource<?> resource = null;\n    try {\n        // decode()方法是重点\n        // decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等\n        // 这里就不分析了, 太麻烦\n        resource = decode();\n    } catch (OutOfMemoryError e) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Out Of Memory Error decoding\", e);\n        }\n        exception = new ErrorWrappingGlideException(e);\n    } catch (Exception e) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Exception decoding\", e);\n        }\n        exception = e;\n    }\n\n    if (isCancelled) {\n        if (resource != null) {\n            resource.recycle();\n        }\n        return;\n    }\n\n    if (resource == null) {\n        onLoadFailed(exception);\n    } else {\n        onLoadComplete(resource);\n    }\n}\n\nprivate void onLoadComplete(Resource resource) {\n    // manager是一个EngineJob对象\n    manager.onResourceReady(resource);\n}\n```\n\n### EngineJob\n\n```java\n@Override\npublic void onResourceReady(final Resource<?> resource) {\n    this.resource = resource;\n    // 这个handler最终会执行到handleResultOnMainThread方法\n    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();\n}\n\nprivate void handleResultOnMainThread() {\n    if (isCancelled) {\n        resource.recycle();\n        return;\n    } else if (cbs.isEmpty()) {\n        throw new IllegalStateException(\"Received a resource without any callbacks to notify\");\n    }\n    engineResource = engineResourceFactory.build(resource, isCacheable);\n    hasResource = true;\n\n    // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it\n    // synchronously released by one of the callbacks.\n    engineResource.acquire();\n    listener.onEngineJobComplete(key, engineResource);\n\n    for (ResourceCallback cb : cbs) {\n        if (!isInIgnoredCallbacks(cb)) {\n            engineResource.acquire();\n            cb.onResourceReady(engineResource);\n        }\n    }\n    // Our request is complete, so we can release the resource.\n    engineResource.release();\n}\n```\n\n就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了\n\n\n\n\n","source":"_posts/Android/源码解析/Glide源码-主要流程.md","raw":"---\ntitle: Glide源码-主要流程\ndate: 2019-11-18 02:00:05\ntags:\n- glide\n- 源码解析\ncategories:\n- Android\n---\n\n## API调用\n\n```java\nGlide.with(fragment)\n    .load(myUrl)\n    .into(imageView);\n```\n\n## with过程\n\n### 主要工作\n\n将图片加载和对应的生命周期绑定(如activity, fragment等)\n绑定生命周期的优点:\n* 在activity, fragment等销毁的时候, 停止对应的图片加载. \n* 避免消耗资源\n* 防止空指针问题的出现\n\n### Glide\n```java\n    public static RequestManager with(Context context) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(context);\n    }\n\n    public static RequestManager with(Activity activity) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(activity);\n    }\n    \n    public static RequestManager with(FragmentActivity activity) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(activity);\n    }\n    \n    public static RequestManager with(android.app.Fragment fragment) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(fragment);\n    }\n    \n    public static RequestManager with(Fragment fragment) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(fragment);\n    }\n```\n\n### RequestManagerRetriever\n\n前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:\n默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了.\n\n```java\npublic RequestManager get(Context context) {\n    if (context == null) {\n        throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n    } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n        if (context instanceof FragmentActivity) {\n            return get((FragmentActivity) context);\n        } else if (context instanceof Activity) {\n            return get((Activity) context);\n        } else if (context instanceof ContextWrapper) {\n            return get(((ContextWrapper) context).getBaseContext());\n        }\n    }\n\n    return getApplicationManager(context);\n}\n\n// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定\nprivate RequestManager getApplicationManager(Context context) {\n    // Either an application context or we're on a background thread.\n    if (applicationManager == null) {\n        synchronized (this) {\n            if (applicationManager == null) {\n                // Normally pause/resume is taken care of by the fragment we add to the fragment or activity.\n                // However, in this case since the manager attached to the application will not receive lifecycle\n                // events, we must force the manager to start resumed using ApplicationLifecycle.\n\n                // 双校验锁 懒汉单例\n                // 将资源加载与整个APP的生命周期绑定\n                applicationManager = new RequestManager(context.getApplicationContext(),\n                        new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());\n            }\n        }\n    }\n\n    return applicationManager;\n}\n\n// 获取RequestManager\npublic RequestManager get(Activity activity) {\n    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n        return get(activity.getApplicationContext());\n    } else {\n        assertNotDestroyed(activity);\n        android.app.FragmentManager fm = activity.getFragmentManager();\n        return fragmentGet(activity, fm);\n    }\n}\n\n.... // 省略其他的重载方法\n\n// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定\nRequestManager fragmentGet(Context context, android.app.FragmentManager fm) {\n    RequestManagerFragment current = getRequestManagerFragment(fm);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());\n        current.setRequestManager(requestManager);\n    }\n    return requestManager;\n}\n\n// 创建并添加RequestManagerFragment\nRequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {\n    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n    if (current == null) {\n        // pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的\n        current = pendingRequestManagerFragments.get(fm);\n        if (current == null) {\n            // 使用FragmentManager添加fragment\n            current = new RequestManagerFragment();\n            pendingRequestManagerFragments.put(fm, current);\n            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();\n        }\n    }\n    return current;\n}\n\n```\n\n## load过程\n\n### RequestManager-load\n\n```java\npublic DrawableTypeRequest<String> load(String string) {\n    return (DrawableTypeRequest<String>) fromString().load(string);\n}\n```\n\n### GenericRequestBuilder\n\nRequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法. \n跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了\n\n```java    \n// ModelType是一个泛型通配符, model是加载的参数\npublic GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {\n    this.model = model;\n    isModelSet = true;\n    return this;\n}\n\n```\n\n## into过程\n\n### GenericRequestBuilder-into\n\n```java\npublic Target<TranscodeType> into(ImageView view) {\n    Util.assertMainThread();\n    if (view == null) {\n        throw new IllegalArgumentException(\"You must pass in a non null View\");\n    }\n\n    // ...省略代码\n\n    return into(glide.buildImageViewTarget(view, transcodeClass));\n}\n\npublic <Y extends Target<TranscodeType>> Y into(Y target) {\n    Util.assertMainThread();\n    \n    ... // 省略代码\n\n    Request previous = target.getRequest();\n\n    // 清楚target上旧的图片请求\n    if (previous != null) {\n        previous.clear();\n        requestTracker.removeRequest(previous);\n        previous.recycle();\n    }\n\n    Request request = buildRequest(target);\n    target.setRequest(request);\n    lifecycle.addListener(target);\n    // 开始请求图片\n    requestTracker.runRequest(request);\n\n    return target;\n}\n```\n\n**为什么要清楚target上旧的图片请求:**\n\n由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。\n\n在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象\n\n### GenericRequestBuilder-runRequest\n\n```java\npublic void runRequest(Request request) {\n    requests.add(request);\n    if (!isPaused) {\n        // 请求加载没有暂停, 则开始请求\n        request.begin();\n    } else {\n        // 请求加载暂停了, 则放入到等待队列中去\n        pendingRequests.add(request);\n    }\n}\n```\n\n```java\n@Override\npublic void begin() {\n    startTime = LogTime.getLogTime();\n    if (model == null) {\n        onException(null);\n        return;\n    }\n\n    status = Status.WAITING_FOR_SIZE;\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n        // 如果用户在调用API时配置了图片的大小, 直接下一步\n        // onSizeReady这个方法很重要\n        onSizeReady(overrideWidth, overrideHeight);\n    } else {\n        // 如果没有, 则获取ImageView的大小\n        // 这个方法最终也会走到onSizeReady方法\n        target.getSize(this);\n    }\n\n    if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {\n        target.onLoadStarted(getPlaceholderDrawable());\n    }\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime));\n    }\n}\n```\n\n```java\n@Override\npublic void onSizeReady(int width, int height) {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"Got onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n    if (status != Status.WAITING_FOR_SIZE) {\n        return;\n    }\n    status = Status.RUNNING;\n\n    width = Math.round(sizeMultiplier * width);\n    height = Math.round(sizeMultiplier * height);\n\n    ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();\n    final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);\n\n    if (dataFetcher == null) {\n        onException(new Exception(\"Failed to load model: \\'\" + model + \"\\'\"));\n        return;\n    }\n    ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished setup for calling load in \" + LogTime.getElapsedMillis(startTime));\n    }\n    loadedFromMemoryCache = true;\n    // 前面的代码都不知道在讲啥, 反正这个engine.load是重点\n    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,\n            priority, isMemoryCacheable, diskCacheStrategy, this);\n    loadedFromMemoryCache = resource != null;\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n}\n```\n\n### Engine-load\n\n获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. \n\n```java\npublic <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n        DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n\n    final String id = fetcher.getId();\n    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n            transcoder, loadProvider.getSourceEncoder());\n\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n        cb.onResourceReady(cached);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n        }\n        return null;\n    }\n\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n        cb.onResourceReady(active);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n        }\n        return null;\n    }\n\n    EngineJob current = jobs.get(key);\n    if (current != null) {\n        current.addCallback(cb);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Added to existing load\", startTime, key);\n        }\n        return new LoadStatus(cb, current);\n    }\n\n    // 前面的缓存策略, 只有再说\n\n    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n    DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n            transcoder, diskCacheProvider, diskCacheStrategy, priority);\n    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n    jobs.put(key, engineJob);\n    engineJob.addCallback(cb);\n    engineJob.start(runnable);\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Started new load\", startTime, key);\n    }\n    return new LoadStatus(cb, engineJob);\n}\n```\n\n### EngineRunnable\n\n获取网络图片, 并编解码\n\n```java\n@Override\npublic void run() {\n    if (isCancelled) {\n        return;\n    }\n\n    Exception exception = null;\n    Resource<?> resource = null;\n    try {\n        // decode()方法是重点\n        // decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等\n        // 这里就不分析了, 太麻烦\n        resource = decode();\n    } catch (OutOfMemoryError e) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Out Of Memory Error decoding\", e);\n        }\n        exception = new ErrorWrappingGlideException(e);\n    } catch (Exception e) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Exception decoding\", e);\n        }\n        exception = e;\n    }\n\n    if (isCancelled) {\n        if (resource != null) {\n            resource.recycle();\n        }\n        return;\n    }\n\n    if (resource == null) {\n        onLoadFailed(exception);\n    } else {\n        onLoadComplete(resource);\n    }\n}\n\nprivate void onLoadComplete(Resource resource) {\n    // manager是一个EngineJob对象\n    manager.onResourceReady(resource);\n}\n```\n\n### EngineJob\n\n```java\n@Override\npublic void onResourceReady(final Resource<?> resource) {\n    this.resource = resource;\n    // 这个handler最终会执行到handleResultOnMainThread方法\n    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();\n}\n\nprivate void handleResultOnMainThread() {\n    if (isCancelled) {\n        resource.recycle();\n        return;\n    } else if (cbs.isEmpty()) {\n        throw new IllegalStateException(\"Received a resource without any callbacks to notify\");\n    }\n    engineResource = engineResourceFactory.build(resource, isCacheable);\n    hasResource = true;\n\n    // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it\n    // synchronously released by one of the callbacks.\n    engineResource.acquire();\n    listener.onEngineJobComplete(key, engineResource);\n\n    for (ResourceCallback cb : cbs) {\n        if (!isInIgnoredCallbacks(cb)) {\n            engineResource.acquire();\n            cb.onResourceReady(engineResource);\n        }\n    }\n    // Our request is complete, so we can release the resource.\n    engineResource.release();\n}\n```\n\n就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了\n\n\n\n\n","slug":"Android/源码解析/Glide源码-主要流程","published":1,"updated":"2019-12-21T12:16:41.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraks3004s8mzmg6wr6f0d","content":"<h2 id=\"API调用\"><a href=\"#API调用\" class=\"headerlink\" title=\"API调用\"></a>API调用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide.with(fragment)</span><br><span class=\"line\">    .load(myUrl)</span><br><span class=\"line\">    .into(imageView);</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<h2 id=\"with过程\"><a href=\"#with过程\" class=\"headerlink\" title=\"with过程\"></a>with过程</h2><h3 id=\"主要工作\"><a href=\"#主要工作\" class=\"headerlink\" title=\"主要工作\"></a>主要工作</h3><p>将图片加载和对应的生命周期绑定(如activity, fragment等)<br>绑定生命周期的优点:</p>\n<ul>\n<li>在activity, fragment等销毁的时候, 停止对应的图片加载. </li>\n<li>避免消耗资源</li>\n<li>防止空指针问题的出现</li>\n</ul>\n<h3 id=\"Glide\"><a href=\"#Glide\" class=\"headerlink\" title=\"Glide\"></a>Glide</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(activity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(activity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(android.app.Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(fragment);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(fragment);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RequestManagerRetriever\"><a href=\"#RequestManagerRetriever\" class=\"headerlink\" title=\"RequestManagerRetriever\"></a>RequestManagerRetriever</h3><p>前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:<br>默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You cannot start a load on a null Context\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class=\"keyword\">instanceof</span> Application)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> FragmentActivity) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get((FragmentActivity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get((Activity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> ContextWrapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getApplicationManager(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">getApplicationManager</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Either an application context or we're on a background thread.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Normally pause/resume is taken care of by the fragment we add to the fragment or activity.</span></span><br><span class=\"line\">                <span class=\"comment\">// However, in this case since the manager attached to the application will not receive lifecycle</span></span><br><span class=\"line\">                <span class=\"comment\">// events, we must force the manager to start resumed using ApplicationLifecycle.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 双校验锁 懒汉单例</span></span><br><span class=\"line\">                <span class=\"comment\">// 将资源加载与整个APP的生命周期绑定</span></span><br><span class=\"line\">                applicationManager = <span class=\"keyword\">new</span> RequestManager(context.getApplicationContext(),</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> ApplicationLifecycle(), <span class=\"keyword\">new</span> EmptyRequestManagerTreeNode());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> applicationManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取RequestManager</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get(activity.getApplicationContext());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        assertNotDestroyed(activity);</span><br><span class=\"line\">        android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fragmentGet(activity, fm);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.... <span class=\"comment\">// 省略其他的重载方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定</span></span><br><span class=\"line\"><span class=\"function\">RequestManager <span class=\"title\">fragmentGet</span><span class=\"params\">(Context context, android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerFragment current = getRequestManagerFragment(fm);</span><br><span class=\"line\">    RequestManager requestManager = current.getRequestManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        requestManager = <span class=\"keyword\">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class=\"line\">        current.setRequestManager(requestManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并添加RequestManagerFragment</span></span><br><span class=\"line\"><span class=\"function\">RequestManagerFragment <span class=\"title\">getRequestManagerFragment</span><span class=\"params\">(<span class=\"keyword\">final</span> android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的</span></span><br><span class=\"line\">        current = pendingRequestManagerFragments.get(fm);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用FragmentManager添加fragment</span></span><br><span class=\"line\">            current = <span class=\"keyword\">new</span> RequestManagerFragment();</span><br><span class=\"line\">            pendingRequestManagerFragments.put(fm, current);</span><br><span class=\"line\">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class=\"line\">            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"load过程\"><a href=\"#load过程\" class=\"headerlink\" title=\"load过程\"></a>load过程</h2><h3 id=\"RequestManager-load\"><a href=\"#RequestManager-load\" class=\"headerlink\" title=\"RequestManager-load\"></a>RequestManager-load</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;String&gt; <span class=\"title\">load</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GenericRequestBuilder\"><a href=\"#GenericRequestBuilder\" class=\"headerlink\" title=\"GenericRequestBuilder\"></a>GenericRequestBuilder</h3><p>RequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法.<br>跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ModelType是一个泛型通配符, model是加载的参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; <span class=\"title\">load</span><span class=\"params\">(ModelType model)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.model = model;</span><br><span class=\"line\">    isModelSet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"into过程\"><a href=\"#into过程\" class=\"headerlink\" title=\"into过程\"></a>into过程</h2><h3 id=\"GenericRequestBuilder-into\"><a href=\"#GenericRequestBuilder-into\" class=\"headerlink\" title=\"GenericRequestBuilder-into\"></a>GenericRequestBuilder-into</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Target&lt;TranscodeType&gt; <span class=\"title\">into</span><span class=\"params\">(ImageView view)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must pass in a non null View\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(Y target)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    </span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清楚target上旧的图片请求</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        previous.clear();</span><br><span class=\"line\">        requestTracker.removeRequest(previous);</span><br><span class=\"line\">        previous.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Request request = buildRequest(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    lifecycle.addListener(target);</span><br><span class=\"line\">    <span class=\"comment\">// 开始请求图片</span></span><br><span class=\"line\">    requestTracker.runRequest(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>为什么要清楚target上旧的图片请求:</strong></p>\n<p>由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。</p>\n<p>在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象</p>\n<h3 id=\"GenericRequestBuilder-runRequest\"><a href=\"#GenericRequestBuilder-runRequest\" class=\"headerlink\" title=\"GenericRequestBuilder-runRequest\"></a>GenericRequestBuilder-runRequest</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runRequest</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    requests.add(request);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPaused) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求加载没有暂停, 则开始请求</span></span><br><span class=\"line\">        request.begin();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求加载暂停了, 则放入到等待队列中去</span></span><br><span class=\"line\">        pendingRequests.add(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (model == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onException(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    status = Status.WAITING_FOR_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果用户在调用API时配置了图片的大小, 直接下一步</span></span><br><span class=\"line\">        <span class=\"comment\">// onSizeReady这个方法很重要</span></span><br><span class=\"line\">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有, 则获取ImageView的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 这个方法最终也会走到onSizeReady方法</span></span><br><span class=\"line\">        target.getSize(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class=\"line\">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished run method in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeReady</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"Got onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    status = Status.RUNNING;</span><br><span class=\"line\"></span><br><span class=\"line\">    width = Math.round(sizeMultiplier * width);</span><br><span class=\"line\">    height = Math.round(sizeMultiplier * height);</span><br><span class=\"line\"></span><br><span class=\"line\">    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dataFetcher == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onException(<span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Failed to load model: \\'\"</span> + model + <span class=\"string\">\"\\'\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished setup for calling load in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    loadedFromMemoryCache = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 前面的代码都不知道在讲啥, 反正这个engine.load是重点</span></span><br><span class=\"line\">    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</span><br><span class=\"line\">            priority, isMemoryCacheable, diskCacheStrategy, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    loadedFromMemoryCache = resource != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Engine-load\"><a href=\"#Engine-load\" class=\"headerlink\" title=\"Engine-load\"></a>Engine-load</h3><p>获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();</span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class=\"line\">            transcoder, loadProvider.getSourceEncoder());</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(cached);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(active);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob current = jobs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        current.addCallback(cb);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前面的缓存策略, 只有再说</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EngineRunnable\"><a href=\"#EngineRunnable\" class=\"headerlink\" title=\"EngineRunnable\"></a>EngineRunnable</h3><p>获取网络图片, 并编解码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Exception exception = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Resource&lt;?&gt; resource = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// decode()方法是重点</span></span><br><span class=\"line\">        <span class=\"comment\">// decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里就不分析了, 太麻烦</span></span><br><span class=\"line\">        resource = decode();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">\"Out Of Memory Error decoding\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exception = <span class=\"keyword\">new</span> ErrorWrappingGlideException(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">\"Exception decoding\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exception = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resource != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            resource.recycle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resource == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onLoadFailed(exception);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        onLoadComplete(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoadComplete</span><span class=\"params\">(Resource resource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// manager是一个EngineJob对象</span></span><br><span class=\"line\">    manager.onResourceReady(resource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EngineJob\"><a href=\"#EngineJob\" class=\"headerlink\" title=\"EngineJob\"></a>EngineJob</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(<span class=\"keyword\">final</span> Resource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resource = resource;</span><br><span class=\"line\">    <span class=\"comment\">// 这个handler最终会执行到handleResultOnMainThread方法</span></span><br><span class=\"line\">    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, <span class=\"keyword\">this</span>).sendToTarget();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResultOnMainThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        resource.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cbs.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Received a resource without any callbacks to notify\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    engineResource = engineResourceFactory.build(resource, isCacheable);</span><br><span class=\"line\">    hasResource = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it</span></span><br><span class=\"line\">    <span class=\"comment\">// synchronously released by one of the callbacks.</span></span><br><span class=\"line\">    engineResource.acquire();</span><br><span class=\"line\">    listener.onEngineJobComplete(key, engineResource);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceCallback cb : cbs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isInIgnoredCallbacks(cb)) &#123;</span><br><span class=\"line\">            engineResource.acquire();</span><br><span class=\"line\">            cb.onResourceReady(engineResource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Our request is complete, so we can release the resource.</span></span><br><span class=\"line\">    engineResource.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"API调用\"><a href=\"#API调用\" class=\"headerlink\" title=\"API调用\"></a>API调用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide.with(fragment)</span><br><span class=\"line\">    .load(myUrl)</span><br><span class=\"line\">    .into(imageView);</span><br></pre></td></tr></table></figure>","more":"\n<h2 id=\"with过程\"><a href=\"#with过程\" class=\"headerlink\" title=\"with过程\"></a>with过程</h2><h3 id=\"主要工作\"><a href=\"#主要工作\" class=\"headerlink\" title=\"主要工作\"></a>主要工作</h3><p>将图片加载和对应的生命周期绑定(如activity, fragment等)<br>绑定生命周期的优点:</p>\n<ul>\n<li>在activity, fragment等销毁的时候, 停止对应的图片加载. </li>\n<li>避免消耗资源</li>\n<li>防止空指针问题的出现</li>\n</ul>\n<h3 id=\"Glide\"><a href=\"#Glide\" class=\"headerlink\" title=\"Glide\"></a>Glide</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(activity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(activity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(android.app.Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(fragment);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(fragment);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RequestManagerRetriever\"><a href=\"#RequestManagerRetriever\" class=\"headerlink\" title=\"RequestManagerRetriever\"></a>RequestManagerRetriever</h3><p>前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:<br>默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You cannot start a load on a null Context\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class=\"keyword\">instanceof</span> Application)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> FragmentActivity) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get((FragmentActivity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get((Activity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> ContextWrapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getApplicationManager(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">getApplicationManager</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Either an application context or we're on a background thread.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Normally pause/resume is taken care of by the fragment we add to the fragment or activity.</span></span><br><span class=\"line\">                <span class=\"comment\">// However, in this case since the manager attached to the application will not receive lifecycle</span></span><br><span class=\"line\">                <span class=\"comment\">// events, we must force the manager to start resumed using ApplicationLifecycle.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 双校验锁 懒汉单例</span></span><br><span class=\"line\">                <span class=\"comment\">// 将资源加载与整个APP的生命周期绑定</span></span><br><span class=\"line\">                applicationManager = <span class=\"keyword\">new</span> RequestManager(context.getApplicationContext(),</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> ApplicationLifecycle(), <span class=\"keyword\">new</span> EmptyRequestManagerTreeNode());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> applicationManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取RequestManager</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get(activity.getApplicationContext());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        assertNotDestroyed(activity);</span><br><span class=\"line\">        android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fragmentGet(activity, fm);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.... <span class=\"comment\">// 省略其他的重载方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定</span></span><br><span class=\"line\"><span class=\"function\">RequestManager <span class=\"title\">fragmentGet</span><span class=\"params\">(Context context, android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerFragment current = getRequestManagerFragment(fm);</span><br><span class=\"line\">    RequestManager requestManager = current.getRequestManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        requestManager = <span class=\"keyword\">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class=\"line\">        current.setRequestManager(requestManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并添加RequestManagerFragment</span></span><br><span class=\"line\"><span class=\"function\">RequestManagerFragment <span class=\"title\">getRequestManagerFragment</span><span class=\"params\">(<span class=\"keyword\">final</span> android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的</span></span><br><span class=\"line\">        current = pendingRequestManagerFragments.get(fm);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用FragmentManager添加fragment</span></span><br><span class=\"line\">            current = <span class=\"keyword\">new</span> RequestManagerFragment();</span><br><span class=\"line\">            pendingRequestManagerFragments.put(fm, current);</span><br><span class=\"line\">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class=\"line\">            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"load过程\"><a href=\"#load过程\" class=\"headerlink\" title=\"load过程\"></a>load过程</h2><h3 id=\"RequestManager-load\"><a href=\"#RequestManager-load\" class=\"headerlink\" title=\"RequestManager-load\"></a>RequestManager-load</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;String&gt; <span class=\"title\">load</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GenericRequestBuilder\"><a href=\"#GenericRequestBuilder\" class=\"headerlink\" title=\"GenericRequestBuilder\"></a>GenericRequestBuilder</h3><p>RequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法.<br>跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ModelType是一个泛型通配符, model是加载的参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; <span class=\"title\">load</span><span class=\"params\">(ModelType model)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.model = model;</span><br><span class=\"line\">    isModelSet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"into过程\"><a href=\"#into过程\" class=\"headerlink\" title=\"into过程\"></a>into过程</h2><h3 id=\"GenericRequestBuilder-into\"><a href=\"#GenericRequestBuilder-into\" class=\"headerlink\" title=\"GenericRequestBuilder-into\"></a>GenericRequestBuilder-into</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Target&lt;TranscodeType&gt; <span class=\"title\">into</span><span class=\"params\">(ImageView view)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must pass in a non null View\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(Y target)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    </span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清楚target上旧的图片请求</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        previous.clear();</span><br><span class=\"line\">        requestTracker.removeRequest(previous);</span><br><span class=\"line\">        previous.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Request request = buildRequest(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    lifecycle.addListener(target);</span><br><span class=\"line\">    <span class=\"comment\">// 开始请求图片</span></span><br><span class=\"line\">    requestTracker.runRequest(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>为什么要清楚target上旧的图片请求:</strong></p>\n<p>由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。</p>\n<p>在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象</p>\n<h3 id=\"GenericRequestBuilder-runRequest\"><a href=\"#GenericRequestBuilder-runRequest\" class=\"headerlink\" title=\"GenericRequestBuilder-runRequest\"></a>GenericRequestBuilder-runRequest</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runRequest</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    requests.add(request);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPaused) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求加载没有暂停, 则开始请求</span></span><br><span class=\"line\">        request.begin();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求加载暂停了, 则放入到等待队列中去</span></span><br><span class=\"line\">        pendingRequests.add(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (model == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onException(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    status = Status.WAITING_FOR_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果用户在调用API时配置了图片的大小, 直接下一步</span></span><br><span class=\"line\">        <span class=\"comment\">// onSizeReady这个方法很重要</span></span><br><span class=\"line\">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有, 则获取ImageView的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 这个方法最终也会走到onSizeReady方法</span></span><br><span class=\"line\">        target.getSize(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class=\"line\">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished run method in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeReady</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"Got onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    status = Status.RUNNING;</span><br><span class=\"line\"></span><br><span class=\"line\">    width = Math.round(sizeMultiplier * width);</span><br><span class=\"line\">    height = Math.round(sizeMultiplier * height);</span><br><span class=\"line\"></span><br><span class=\"line\">    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dataFetcher == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onException(<span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Failed to load model: \\'\"</span> + model + <span class=\"string\">\"\\'\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished setup for calling load in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    loadedFromMemoryCache = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 前面的代码都不知道在讲啥, 反正这个engine.load是重点</span></span><br><span class=\"line\">    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</span><br><span class=\"line\">            priority, isMemoryCacheable, diskCacheStrategy, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    loadedFromMemoryCache = resource != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Engine-load\"><a href=\"#Engine-load\" class=\"headerlink\" title=\"Engine-load\"></a>Engine-load</h3><p>获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();</span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class=\"line\">            transcoder, loadProvider.getSourceEncoder());</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(cached);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(active);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob current = jobs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        current.addCallback(cb);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前面的缓存策略, 只有再说</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EngineRunnable\"><a href=\"#EngineRunnable\" class=\"headerlink\" title=\"EngineRunnable\"></a>EngineRunnable</h3><p>获取网络图片, 并编解码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Exception exception = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Resource&lt;?&gt; resource = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// decode()方法是重点</span></span><br><span class=\"line\">        <span class=\"comment\">// decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里就不分析了, 太麻烦</span></span><br><span class=\"line\">        resource = decode();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">\"Out Of Memory Error decoding\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exception = <span class=\"keyword\">new</span> ErrorWrappingGlideException(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">\"Exception decoding\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exception = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resource != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            resource.recycle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resource == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onLoadFailed(exception);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        onLoadComplete(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoadComplete</span><span class=\"params\">(Resource resource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// manager是一个EngineJob对象</span></span><br><span class=\"line\">    manager.onResourceReady(resource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EngineJob\"><a href=\"#EngineJob\" class=\"headerlink\" title=\"EngineJob\"></a>EngineJob</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(<span class=\"keyword\">final</span> Resource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resource = resource;</span><br><span class=\"line\">    <span class=\"comment\">// 这个handler最终会执行到handleResultOnMainThread方法</span></span><br><span class=\"line\">    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, <span class=\"keyword\">this</span>).sendToTarget();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResultOnMainThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        resource.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cbs.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Received a resource without any callbacks to notify\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    engineResource = engineResourceFactory.build(resource, isCacheable);</span><br><span class=\"line\">    hasResource = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it</span></span><br><span class=\"line\">    <span class=\"comment\">// synchronously released by one of the callbacks.</span></span><br><span class=\"line\">    engineResource.acquire();</span><br><span class=\"line\">    listener.onEngineJobComplete(key, engineResource);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceCallback cb : cbs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isInIgnoredCallbacks(cb)) &#123;</span><br><span class=\"line\">            engineResource.acquire();</span><br><span class=\"line\">            cb.onResourceReady(engineResource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Our request is complete, so we can release the resource.</span></span><br><span class=\"line\">    engineResource.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了</p>\n"},{"title":"Glide源码-缓存机制","date":"2019-11-18T08:52:17.000Z","_content":"\n## Glide的配置\n\n在实例化Glide的时候, 对很多重要的部分做了初始化.\n\n```java\n\n// 起始入口\npublic DrawableTypeRequest<String> load(String string) {\n    return (DrawableTypeRequest<String>) fromString().load(string);\n}\n\n... // 省略中间步骤\n```\n\n一直向下追溯, 可以找到Glide类的这个方法\n\n```java\nGlide createGlide() {\n    if (sourceService == null) {\n        // 初始化加载网络图片的线程池\n        final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());\n        sourceService = new FifoPriorityThreadPoolExecutor(cores);\n    }\n    if (diskCacheService == null) {\n        // 初始化加载磁盘缓存的线程池\n        diskCacheService = new FifoPriorityThreadPoolExecutor(1);\n    }\n\n    // 初始化内存缓存池, 可以看到, 是一个lrucache\n    MemorySizeCalculator calculator = new MemorySizeCalculator(context);\n    if (bitmapPool == null) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n            int size = calculator.getBitmapPoolSize();\n            bitmapPool = new LruBitmapPool(size);\n        } else {\n            bitmapPool = new BitmapPoolAdapter();\n        }\n    }\n\n    if (memoryCache == null) {\n        memoryCache = new LruResourceCache(calculator.getMemoryCacheSize());\n    }\n\n    if (diskCacheFactory == null) {\n        diskCacheFactory = new InternalCacheDiskCacheFactory(context);\n    }\n\n    if (engine == null) {\n        // 实例化Glide Engine\n        engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);\n    }\n\n    if (decodeFormat == null) {\n        decodeFormat = DecodeFormat.DEFAULT;\n    }\n\n    return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);\n}\n```\n\n## 内存缓存\n\n### Engine-load\n\n```java\nprivate final Map<Key, WeakReference<EngineResource<?>>> activeResources;\n\n...\n\npublic <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n        DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n\n    // 组装key\n    final String id = fetcher.getId();\n    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n            transcoder, loadProvider.getSourceEncoder());\n\n    // 先从内存cache中获取\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n        cb.onResourceReady(cached);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n        }\n        return null;\n    }\n\n    // 从ActiveResources获取\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n        cb.onResourceReady(active);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n        }\n        return null;\n    }\n\n    // 后面的内容暂时和内存缓存无关\n\n    EngineJob current = jobs.get(key);\n    if (current != null) {\n        // 当已经存在相同的图片加载job, 直接添加新的callback即可\n        current.addCallback(cb);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Added to existing load\", startTime, key);\n        }\n        return new LoadStatus(cb, current);\n    }\n\n    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n    DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n            transcoder, diskCacheProvider, diskCacheStrategy, priority);\n    // 具体的图片请求工作在这个runnable中\n    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n    jobs.put(key, engineJob);\n    engineJob.addCallback(cb);\n    engineJob.start(runnable);\n    \n    return new LoadStatus(cb, engineJob);\n}\n```\n\n可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取. \nActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合:\n* 为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:\n使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。\n* 存储的正在使用的图片资源的**弱引用**: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用\n\n来看看对lrucache和ActiveResources的操作\n\n### 内存cache的获取\n\n```java\n// 从cache中获取\nprivate EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {\n    // 检查内存缓存是否被禁用\n    if (!isMemoryCacheable) {\n        return null;\n    }\n\n    EngineResource<?> cached = getEngineResourceFromCache(key);\n    if (cached != null) {\n        // cache命中, 从lrucache中取出后放入ActiveResources\n        cached.acquire();\n        activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));\n    }\n    return cached;\n}\n// 从cache中获取资源\nprivate EngineResource<?> getEngineResourceFromCache(Key key) {\n    // 注意这里是直接remove的\n    Resource<?> cached = cache.remove(key);\n\n    final EngineResource result;\n    if (cached == null) {\n        result = null;\n    } else if (cached instanceof EngineResource) {\n        // Save an object allocation if we've cached an EngineResource (the typical case).\n        result = (EngineResource) cached;\n    } else {\n        result = new EngineResource(cached, true /*isCacheable*/);\n    }\n    return result;\n}\n\nprivate EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {\n    // 检查内存cache是否被禁用\n    if (!isMemoryCacheable) {\n        return null;\n    }\n\n    EngineResource<?> active = null;\n    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);\n    if (activeRef != null) {\n        active = activeRef.get();\n        if (active != null) {\n            // ActiveResource命中\n            active.acquire();\n        } else {\n            // 弱引用的对象被释放了, 直接remove\n            activeResources.remove(key);\n        }\n    }\n\n    return active;\n}\n```\n\n### 内存cache的释放\n\n先来看看resource中如何表示图片需要被释放\n```java\nclass EngineResource<Z> implements Resource<Z> {\n    private int acquired;\n    ...\n\n    void acquire() {\n        ... // 省略异常处理\n        ++acquired;\n    }\n\n    void release() {\n        ... // 省略异常处理\n        if (--acquired == 0) {\n            // 当acquired为0的使用, 表示当前图片没有被引用\n            listener.onResourceReleased(key, this);\n        }\n    }\n}\n```\n\nresource中listener的回调是在EngineJob类中实现的\n\n```java\n// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache\n@Override\npublic void onResourceReleased(Key cacheKey, EngineResource resource) {\n    Util.assertMainThread();\n    activeResources.remove(cacheKey);\n    if (resource.isCacheable()) {\n        cache.put(cacheKey, resource);\n    } else {\n        resourceRecycler.recycle(resource);\n    }\n}\n```\n\n## 磁盘缓存\n\n首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理.\n\n### 入口\n\n内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中\n\n```java\nprivate Resource<?> decode() throws Exception {\n    if (isDecodingFromCache()) {\n        return decodeFromCache();\n    } else {\n        return decodeFromSource();\n    }\n}\n\n// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片\nprivate Resource<?> decodeFromCache() throws Exception {\n    Resource<?> result = null;\n    try {\n        result = decodeJob.decodeResultFromCache();\n    } catch (Exception e) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Exception decoding result from cache: \" + e);\n        }\n    }\n\n    if (result == null) {\n        result = decodeJob.decodeSourceFromCache();\n    }\n    return result;\n    }\n```\n\n### 磁盘cache读取\n\n```java\npublic Resource<Z> decodeResultFromCache() throws Exception {\n    if (!diskCacheStrategy.cacheResult()) {\n        return null;\n    }\n    long startTime = LogTime.getLogTime();\n    Resource<T> transformed = loadFromCache(resultKey);\n    startTime = LogTime.getLogTime();\n    Resource<Z> result = transcode(transformed);\n    return result;\n}\n\npublic Resource<Z> decodeSourceFromCache() throws Exception {\n    if (!diskCacheStrategy.cacheSource()) {\n        return null;\n    }\n    long startTime = LogTime.getLogTime();\n    Resource<T> decoded = loadFromCache(resultKey.getOriginalKey());\n    return transformEncodeAndTranscode(decoded);\n}\n\nprivate Resource<T> loadFromCache(Key key) throws IOException {\n    File cacheFile = diskCacheProvider.getDiskCache().get(key);\n    if (cacheFile == null) {\n        return null;\n    }\n    Resource<T> result = null;\n    try {\n        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);\n    } finally {\n        if (result == null) {\n            diskCacheProvider.getDiskCache().delete(key);\n        }\n    }\n    return result;\n}\n```\n\n磁盘缓存读取这里挺好懂的\n\n### 磁盘cache写入\n\n#### 缓存原始图片\n\n直接贴调用过程吧\n\nEngineRunnable.decodeFromSource()\n-> EngineRunnable.decodeFromSource()\n-> DecodeJob.decodeFromSource()\n-> DecodeJob.decodeSource()\n-> DecodeJob.decodeFromSourceData()\n-> DecodeJob.cacheAndDecodeSourceData\n\n```java\nprivate Resource<T> decodeSource() throws Exception {\n    Resource<T> decoded = null;\n    try {\n        long startTime = LogTime.getLogTime();\n        // 从网络获取图片\n        final A data = fetcher.loadData(priority);\n        if (isCancelled) {\n            return null;\n        }\n        decoded = decodeFromSourceData(data);\n    } finally {\n        fetcher.cleanup();\n    }\n    return decoded;\n}\n\nprivate Resource<T> cacheAndDecodeSourceData(A data) throws IOException {\n    long startTime = LogTime.getLogTime();\n    SourceWriter<A> writer = new SourceWriter<A>(loadProvider.getSourceEncoder(), data);\n    diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);\n\n    startTime = LogTime.getLogTime();\n    // ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个?\n    Resource<T> result = loadFromCache(resultKey.getOriginalKey());\n    return result;\n}\n```\n\n#### 缓存处理过后的图片\n\nEngineRunnable.decodeFromSource()\n-> EngineRunnable.decodeFromSource()\n-> DecodeJob.decodeFromSource()\n-> DecodeJob.transformEncodeAndTranscode\n-> DecodeJob.writeTransformedToCache\n\n```java\nprivate Resource<Z> transformEncodeAndTranscode(Resource<T> decoded) {\n    long startTime = LogTime.getLogTime();\n    // 先转换图片\n    Resource<T> transformed = transform(decoded);\n    // 写入磁盘\n    writeTransformedToCache(transformed);\n\n    startTime = LogTime.getLogTime();\n    // 转码\n    Resource<Z> result = transcode(transformed);\n\n    return result;\n}\n\nprivate void writeTransformedToCache(Resource<T> transformed) {\n    if (transformed == null || !diskCacheStrategy.cacheResult()) {\n        return;\n    }\n    long startTime = LogTime.getLogTime();\n    SourceWriter<Resource<T>> writer = new SourceWriter<Resource<T>>(loadProvider.getEncoder(), transformed);\n    diskCacheProvider.getDiskCache().put(resultKey, writer);\n}\n```\n","source":"_posts/Android/源码解析/Glide源码-缓存机制.md","raw":"---\ntitle: Glide源码-缓存机制\ndate: 2019-11-18 16:52:17\ntags:\n- glide\n- 源码解析\ncategories:\n- Android\n---\n\n## Glide的配置\n\n在实例化Glide的时候, 对很多重要的部分做了初始化.\n\n```java\n\n// 起始入口\npublic DrawableTypeRequest<String> load(String string) {\n    return (DrawableTypeRequest<String>) fromString().load(string);\n}\n\n... // 省略中间步骤\n```\n\n一直向下追溯, 可以找到Glide类的这个方法\n\n```java\nGlide createGlide() {\n    if (sourceService == null) {\n        // 初始化加载网络图片的线程池\n        final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());\n        sourceService = new FifoPriorityThreadPoolExecutor(cores);\n    }\n    if (diskCacheService == null) {\n        // 初始化加载磁盘缓存的线程池\n        diskCacheService = new FifoPriorityThreadPoolExecutor(1);\n    }\n\n    // 初始化内存缓存池, 可以看到, 是一个lrucache\n    MemorySizeCalculator calculator = new MemorySizeCalculator(context);\n    if (bitmapPool == null) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n            int size = calculator.getBitmapPoolSize();\n            bitmapPool = new LruBitmapPool(size);\n        } else {\n            bitmapPool = new BitmapPoolAdapter();\n        }\n    }\n\n    if (memoryCache == null) {\n        memoryCache = new LruResourceCache(calculator.getMemoryCacheSize());\n    }\n\n    if (diskCacheFactory == null) {\n        diskCacheFactory = new InternalCacheDiskCacheFactory(context);\n    }\n\n    if (engine == null) {\n        // 实例化Glide Engine\n        engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);\n    }\n\n    if (decodeFormat == null) {\n        decodeFormat = DecodeFormat.DEFAULT;\n    }\n\n    return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);\n}\n```\n\n## 内存缓存\n\n### Engine-load\n\n```java\nprivate final Map<Key, WeakReference<EngineResource<?>>> activeResources;\n\n...\n\npublic <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n        DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n\n    // 组装key\n    final String id = fetcher.getId();\n    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n            transcoder, loadProvider.getSourceEncoder());\n\n    // 先从内存cache中获取\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n        cb.onResourceReady(cached);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n        }\n        return null;\n    }\n\n    // 从ActiveResources获取\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n        cb.onResourceReady(active);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n        }\n        return null;\n    }\n\n    // 后面的内容暂时和内存缓存无关\n\n    EngineJob current = jobs.get(key);\n    if (current != null) {\n        // 当已经存在相同的图片加载job, 直接添加新的callback即可\n        current.addCallback(cb);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Added to existing load\", startTime, key);\n        }\n        return new LoadStatus(cb, current);\n    }\n\n    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n    DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n            transcoder, diskCacheProvider, diskCacheStrategy, priority);\n    // 具体的图片请求工作在这个runnable中\n    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n    jobs.put(key, engineJob);\n    engineJob.addCallback(cb);\n    engineJob.start(runnable);\n    \n    return new LoadStatus(cb, engineJob);\n}\n```\n\n可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取. \nActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合:\n* 为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:\n使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。\n* 存储的正在使用的图片资源的**弱引用**: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用\n\n来看看对lrucache和ActiveResources的操作\n\n### 内存cache的获取\n\n```java\n// 从cache中获取\nprivate EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {\n    // 检查内存缓存是否被禁用\n    if (!isMemoryCacheable) {\n        return null;\n    }\n\n    EngineResource<?> cached = getEngineResourceFromCache(key);\n    if (cached != null) {\n        // cache命中, 从lrucache中取出后放入ActiveResources\n        cached.acquire();\n        activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));\n    }\n    return cached;\n}\n// 从cache中获取资源\nprivate EngineResource<?> getEngineResourceFromCache(Key key) {\n    // 注意这里是直接remove的\n    Resource<?> cached = cache.remove(key);\n\n    final EngineResource result;\n    if (cached == null) {\n        result = null;\n    } else if (cached instanceof EngineResource) {\n        // Save an object allocation if we've cached an EngineResource (the typical case).\n        result = (EngineResource) cached;\n    } else {\n        result = new EngineResource(cached, true /*isCacheable*/);\n    }\n    return result;\n}\n\nprivate EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {\n    // 检查内存cache是否被禁用\n    if (!isMemoryCacheable) {\n        return null;\n    }\n\n    EngineResource<?> active = null;\n    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);\n    if (activeRef != null) {\n        active = activeRef.get();\n        if (active != null) {\n            // ActiveResource命中\n            active.acquire();\n        } else {\n            // 弱引用的对象被释放了, 直接remove\n            activeResources.remove(key);\n        }\n    }\n\n    return active;\n}\n```\n\n### 内存cache的释放\n\n先来看看resource中如何表示图片需要被释放\n```java\nclass EngineResource<Z> implements Resource<Z> {\n    private int acquired;\n    ...\n\n    void acquire() {\n        ... // 省略异常处理\n        ++acquired;\n    }\n\n    void release() {\n        ... // 省略异常处理\n        if (--acquired == 0) {\n            // 当acquired为0的使用, 表示当前图片没有被引用\n            listener.onResourceReleased(key, this);\n        }\n    }\n}\n```\n\nresource中listener的回调是在EngineJob类中实现的\n\n```java\n// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache\n@Override\npublic void onResourceReleased(Key cacheKey, EngineResource resource) {\n    Util.assertMainThread();\n    activeResources.remove(cacheKey);\n    if (resource.isCacheable()) {\n        cache.put(cacheKey, resource);\n    } else {\n        resourceRecycler.recycle(resource);\n    }\n}\n```\n\n## 磁盘缓存\n\n首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理.\n\n### 入口\n\n内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中\n\n```java\nprivate Resource<?> decode() throws Exception {\n    if (isDecodingFromCache()) {\n        return decodeFromCache();\n    } else {\n        return decodeFromSource();\n    }\n}\n\n// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片\nprivate Resource<?> decodeFromCache() throws Exception {\n    Resource<?> result = null;\n    try {\n        result = decodeJob.decodeResultFromCache();\n    } catch (Exception e) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Exception decoding result from cache: \" + e);\n        }\n    }\n\n    if (result == null) {\n        result = decodeJob.decodeSourceFromCache();\n    }\n    return result;\n    }\n```\n\n### 磁盘cache读取\n\n```java\npublic Resource<Z> decodeResultFromCache() throws Exception {\n    if (!diskCacheStrategy.cacheResult()) {\n        return null;\n    }\n    long startTime = LogTime.getLogTime();\n    Resource<T> transformed = loadFromCache(resultKey);\n    startTime = LogTime.getLogTime();\n    Resource<Z> result = transcode(transformed);\n    return result;\n}\n\npublic Resource<Z> decodeSourceFromCache() throws Exception {\n    if (!diskCacheStrategy.cacheSource()) {\n        return null;\n    }\n    long startTime = LogTime.getLogTime();\n    Resource<T> decoded = loadFromCache(resultKey.getOriginalKey());\n    return transformEncodeAndTranscode(decoded);\n}\n\nprivate Resource<T> loadFromCache(Key key) throws IOException {\n    File cacheFile = diskCacheProvider.getDiskCache().get(key);\n    if (cacheFile == null) {\n        return null;\n    }\n    Resource<T> result = null;\n    try {\n        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);\n    } finally {\n        if (result == null) {\n            diskCacheProvider.getDiskCache().delete(key);\n        }\n    }\n    return result;\n}\n```\n\n磁盘缓存读取这里挺好懂的\n\n### 磁盘cache写入\n\n#### 缓存原始图片\n\n直接贴调用过程吧\n\nEngineRunnable.decodeFromSource()\n-> EngineRunnable.decodeFromSource()\n-> DecodeJob.decodeFromSource()\n-> DecodeJob.decodeSource()\n-> DecodeJob.decodeFromSourceData()\n-> DecodeJob.cacheAndDecodeSourceData\n\n```java\nprivate Resource<T> decodeSource() throws Exception {\n    Resource<T> decoded = null;\n    try {\n        long startTime = LogTime.getLogTime();\n        // 从网络获取图片\n        final A data = fetcher.loadData(priority);\n        if (isCancelled) {\n            return null;\n        }\n        decoded = decodeFromSourceData(data);\n    } finally {\n        fetcher.cleanup();\n    }\n    return decoded;\n}\n\nprivate Resource<T> cacheAndDecodeSourceData(A data) throws IOException {\n    long startTime = LogTime.getLogTime();\n    SourceWriter<A> writer = new SourceWriter<A>(loadProvider.getSourceEncoder(), data);\n    diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);\n\n    startTime = LogTime.getLogTime();\n    // ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个?\n    Resource<T> result = loadFromCache(resultKey.getOriginalKey());\n    return result;\n}\n```\n\n#### 缓存处理过后的图片\n\nEngineRunnable.decodeFromSource()\n-> EngineRunnable.decodeFromSource()\n-> DecodeJob.decodeFromSource()\n-> DecodeJob.transformEncodeAndTranscode\n-> DecodeJob.writeTransformedToCache\n\n```java\nprivate Resource<Z> transformEncodeAndTranscode(Resource<T> decoded) {\n    long startTime = LogTime.getLogTime();\n    // 先转换图片\n    Resource<T> transformed = transform(decoded);\n    // 写入磁盘\n    writeTransformedToCache(transformed);\n\n    startTime = LogTime.getLogTime();\n    // 转码\n    Resource<Z> result = transcode(transformed);\n\n    return result;\n}\n\nprivate void writeTransformedToCache(Resource<T> transformed) {\n    if (transformed == null || !diskCacheStrategy.cacheResult()) {\n        return;\n    }\n    long startTime = LogTime.getLogTime();\n    SourceWriter<Resource<T>> writer = new SourceWriter<Resource<T>>(loadProvider.getEncoder(), transformed);\n    diskCacheProvider.getDiskCache().put(resultKey, writer);\n}\n```\n","slug":"Android/源码解析/Glide源码-缓存机制","published":1,"updated":"2019-12-21T12:16:41.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraks5004t8mzmx9v5kof4","content":"<h2 id=\"Glide的配置\"><a href=\"#Glide的配置\" class=\"headerlink\" title=\"Glide的配置\"></a>Glide的配置</h2><p>在实例化Glide的时候, 对很多重要的部分做了初始化.</p><a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 起始入口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;String&gt; <span class=\"title\">load</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 省略中间步骤</span></span><br></pre></td></tr></table></figure>\n<p>一直向下追溯, 可以找到Glide类的这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Glide <span class=\"title\">createGlide</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化加载网络图片的线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cores = Math.max(<span class=\"number\">1</span>, Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">        sourceService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(cores);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diskCacheService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化加载磁盘缓存的线程池</span></span><br><span class=\"line\">        diskCacheService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化内存缓存池, 可以看到, 是一个lrucache</span></span><br><span class=\"line\">    MemorySizeCalculator calculator = <span class=\"keyword\">new</span> MemorySizeCalculator(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bitmapPool == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = calculator.getBitmapPoolSize();</span><br><span class=\"line\">            bitmapPool = <span class=\"keyword\">new</span> LruBitmapPool(size);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            bitmapPool = <span class=\"keyword\">new</span> BitmapPoolAdapter();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memoryCache == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        memoryCache = <span class=\"keyword\">new</span> LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diskCacheFactory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        diskCacheFactory = <span class=\"keyword\">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (engine == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化Glide Engine</span></span><br><span class=\"line\">        engine = <span class=\"keyword\">new</span> Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (decodeFormat == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        decodeFormat = DecodeFormat.DEFAULT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Glide(engine, memoryCache, bitmapPool, context, decodeFormat);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h2><h3 id=\"Engine-load\"><a href=\"#Engine-load\" class=\"headerlink\" title=\"Engine-load\"></a>Engine-load</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 组装key</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();</span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class=\"line\">            transcoder, loadProvider.getSourceEncoder());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 先从内存cache中获取</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(cached);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从ActiveResources获取</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(active);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后面的内容暂时和内存缓存无关</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob current = jobs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当已经存在相同的图片加载job, 直接添加新的callback即可</span></span><br><span class=\"line\">        current.addCallback(cb);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class=\"line\">    <span class=\"comment\">// 具体的图片请求工作在这个runnable中</span></span><br><span class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(runnable);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取.<br>ActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合:</p>\n<ul>\n<li>为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:<br>使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。</li>\n<li>存储的正在使用的图片资源的<strong>弱引用</strong>: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用</li>\n</ul>\n<p>来看看对lrucache和ActiveResources的操作</p>\n<h3 id=\"内存cache的获取\"><a href=\"#内存cache的获取\" class=\"headerlink\" title=\"内存cache的获取\"></a>内存cache的获取</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从cache中获取</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class=\"keyword\">boolean</span> isMemoryCacheable) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查内存缓存是否被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMemoryCacheable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cache命中, 从lrucache中取出后放入ActiveResources</span></span><br><span class=\"line\">        cached.acquire();</span><br><span class=\"line\">        activeResources.put(key, <span class=\"keyword\">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cached;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从cache中获取资源</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意这里是直接remove的</span></span><br><span class=\"line\">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> EngineResource result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cached <span class=\"keyword\">instanceof</span> EngineResource) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class=\"line\">        result = (EngineResource) cached;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> EngineResource(cached, <span class=\"keyword\">true</span> <span class=\"comment\">/*isCacheable*/</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class=\"keyword\">boolean</span> isMemoryCacheable) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查内存cache是否被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMemoryCacheable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activeRef != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        active = activeRef.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ActiveResource命中</span></span><br><span class=\"line\">            active.acquire();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 弱引用的对象被释放了, 直接remove</span></span><br><span class=\"line\">            activeResources.remove(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> active;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内存cache的释放\"><a href=\"#内存cache的释放\" class=\"headerlink\" title=\"内存cache的释放\"></a>内存cache的释放</h3><p>先来看看resource中如何表示图片需要被释放<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineResource</span>&lt;<span class=\"title\">Z</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Resource</span>&lt;<span class=\"title\">Z</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> acquired;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ... <span class=\"comment\">// 省略异常处理</span></span><br><span class=\"line\">        ++acquired;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ... <span class=\"comment\">// 省略异常处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (--acquired == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当acquired为0的使用, 表示当前图片没有被引用</span></span><br><span class=\"line\">            listener.onResourceReleased(key, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>resource中listener的回调是在EngineJob类中实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReleased</span><span class=\"params\">(Key cacheKey, EngineResource resource)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    activeResources.remove(cacheKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resource.isCacheable()) &#123;</span><br><span class=\"line\">        cache.put(cacheKey, resource);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resourceRecycler.recycle(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"磁盘缓存\"><a href=\"#磁盘缓存\" class=\"headerlink\" title=\"磁盘缓存\"></a>磁盘缓存</h2><p>首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理.</p>\n<h3 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h3><p>内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Resource&lt;?&gt; decode() <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDecodingFromCache()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decodeFromCache();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decodeFromSource();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Resource&lt;?&gt; decodeFromCache() <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    Resource&lt;?&gt; result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        result = decodeJob.decodeResultFromCache();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class=\"line\">            Log.d(TAG, <span class=\"string\">\"Exception decoding result from cache: \"</span> + e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = decodeJob.decodeSourceFromCache();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"磁盘cache读取\"><a href=\"#磁盘cache读取\" class=\"headerlink\" title=\"磁盘cache读取\"></a>磁盘cache读取</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Z&gt; <span class=\"title\">decodeResultFromCache</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!diskCacheStrategy.cacheResult()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;T&gt; transformed = loadFromCache(resultKey);</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Z&gt; <span class=\"title\">decodeSourceFromCache</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!diskCacheStrategy.cacheSource()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformEncodeAndTranscode(decoded);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">loadFromCache</span><span class=\"params\">(Key key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    File cacheFile = diskCacheProvider.getDiskCache().get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheFile == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Resource&lt;T&gt; result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            diskCacheProvider.getDiskCache().delete(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>磁盘缓存读取这里挺好懂的</p>\n<h3 id=\"磁盘cache写入\"><a href=\"#磁盘cache写入\" class=\"headerlink\" title=\"磁盘cache写入\"></a>磁盘cache写入</h3><h4 id=\"缓存原始图片\"><a href=\"#缓存原始图片\" class=\"headerlink\" title=\"缓存原始图片\"></a>缓存原始图片</h4><p>直接贴调用过程吧</p>\n<p>EngineRunnable.decodeFromSource()<br>-&gt; EngineRunnable.decodeFromSource()<br>-&gt; DecodeJob.decodeFromSource()<br>-&gt; DecodeJob.decodeSource()<br>-&gt; DecodeJob.decodeFromSourceData()<br>-&gt; DecodeJob.cacheAndDecodeSourceData</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">decodeSource</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Resource&lt;T&gt; decoded = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">        <span class=\"comment\">// 从网络获取图片</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> A data = fetcher.loadData(priority);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        decoded = decodeFromSourceData(data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        fetcher.cleanup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decoded;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">cacheAndDecodeSourceData</span><span class=\"params\">(A data)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    SourceWriter&lt;A&gt; writer = <span class=\"keyword\">new</span> SourceWriter&lt;A&gt;(loadProvider.getSourceEncoder(), data);</span><br><span class=\"line\">    diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);</span><br><span class=\"line\"></span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个?</span></span><br><span class=\"line\">    Resource&lt;T&gt; result = loadFromCache(resultKey.getOriginalKey());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"缓存处理过后的图片\"><a href=\"#缓存处理过后的图片\" class=\"headerlink\" title=\"缓存处理过后的图片\"></a>缓存处理过后的图片</h4><p>EngineRunnable.decodeFromSource()<br>-&gt; EngineRunnable.decodeFromSource()<br>-&gt; DecodeJob.decodeFromSource()<br>-&gt; DecodeJob.transformEncodeAndTranscode<br>-&gt; DecodeJob.writeTransformedToCache</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;Z&gt; <span class=\"title\">transformEncodeAndTranscode</span><span class=\"params\">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 先转换图片</span></span><br><span class=\"line\">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class=\"line\">    <span class=\"comment\">// 写入磁盘</span></span><br><span class=\"line\">    writeTransformedToCache(transformed);</span><br><span class=\"line\"></span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 转码</span></span><br><span class=\"line\">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeTransformedToCache</span><span class=\"params\">(Resource&lt;T&gt; transformed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transformed == <span class=\"keyword\">null</span> || !diskCacheStrategy.cacheResult()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    SourceWriter&lt;Resource&lt;T&gt;&gt; writer = <span class=\"keyword\">new</span> SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed);</span><br><span class=\"line\">    diskCacheProvider.getDiskCache().put(resultKey, writer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Glide的配置\"><a href=\"#Glide的配置\" class=\"headerlink\" title=\"Glide的配置\"></a>Glide的配置</h2><p>在实例化Glide的时候, 对很多重要的部分做了初始化.</p>","more":"\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 起始入口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;String&gt; <span class=\"title\">load</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 省略中间步骤</span></span><br></pre></td></tr></table></figure>\n<p>一直向下追溯, 可以找到Glide类的这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Glide <span class=\"title\">createGlide</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化加载网络图片的线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cores = Math.max(<span class=\"number\">1</span>, Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">        sourceService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(cores);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diskCacheService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化加载磁盘缓存的线程池</span></span><br><span class=\"line\">        diskCacheService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化内存缓存池, 可以看到, 是一个lrucache</span></span><br><span class=\"line\">    MemorySizeCalculator calculator = <span class=\"keyword\">new</span> MemorySizeCalculator(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bitmapPool == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = calculator.getBitmapPoolSize();</span><br><span class=\"line\">            bitmapPool = <span class=\"keyword\">new</span> LruBitmapPool(size);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            bitmapPool = <span class=\"keyword\">new</span> BitmapPoolAdapter();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memoryCache == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        memoryCache = <span class=\"keyword\">new</span> LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diskCacheFactory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        diskCacheFactory = <span class=\"keyword\">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (engine == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化Glide Engine</span></span><br><span class=\"line\">        engine = <span class=\"keyword\">new</span> Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (decodeFormat == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        decodeFormat = DecodeFormat.DEFAULT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Glide(engine, memoryCache, bitmapPool, context, decodeFormat);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h2><h3 id=\"Engine-load\"><a href=\"#Engine-load\" class=\"headerlink\" title=\"Engine-load\"></a>Engine-load</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 组装key</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();</span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class=\"line\">            transcoder, loadProvider.getSourceEncoder());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 先从内存cache中获取</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(cached);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从ActiveResources获取</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(active);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后面的内容暂时和内存缓存无关</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob current = jobs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当已经存在相同的图片加载job, 直接添加新的callback即可</span></span><br><span class=\"line\">        current.addCallback(cb);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class=\"line\">    <span class=\"comment\">// 具体的图片请求工作在这个runnable中</span></span><br><span class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(runnable);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取.<br>ActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合:</p>\n<ul>\n<li>为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:<br>使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。</li>\n<li>存储的正在使用的图片资源的<strong>弱引用</strong>: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用</li>\n</ul>\n<p>来看看对lrucache和ActiveResources的操作</p>\n<h3 id=\"内存cache的获取\"><a href=\"#内存cache的获取\" class=\"headerlink\" title=\"内存cache的获取\"></a>内存cache的获取</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从cache中获取</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class=\"keyword\">boolean</span> isMemoryCacheable) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查内存缓存是否被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMemoryCacheable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cache命中, 从lrucache中取出后放入ActiveResources</span></span><br><span class=\"line\">        cached.acquire();</span><br><span class=\"line\">        activeResources.put(key, <span class=\"keyword\">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cached;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从cache中获取资源</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意这里是直接remove的</span></span><br><span class=\"line\">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> EngineResource result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cached <span class=\"keyword\">instanceof</span> EngineResource) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class=\"line\">        result = (EngineResource) cached;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> EngineResource(cached, <span class=\"keyword\">true</span> <span class=\"comment\">/*isCacheable*/</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class=\"keyword\">boolean</span> isMemoryCacheable) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查内存cache是否被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMemoryCacheable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activeRef != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        active = activeRef.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ActiveResource命中</span></span><br><span class=\"line\">            active.acquire();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 弱引用的对象被释放了, 直接remove</span></span><br><span class=\"line\">            activeResources.remove(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> active;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内存cache的释放\"><a href=\"#内存cache的释放\" class=\"headerlink\" title=\"内存cache的释放\"></a>内存cache的释放</h3><p>先来看看resource中如何表示图片需要被释放<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineResource</span>&lt;<span class=\"title\">Z</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Resource</span>&lt;<span class=\"title\">Z</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> acquired;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ... <span class=\"comment\">// 省略异常处理</span></span><br><span class=\"line\">        ++acquired;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ... <span class=\"comment\">// 省略异常处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (--acquired == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当acquired为0的使用, 表示当前图片没有被引用</span></span><br><span class=\"line\">            listener.onResourceReleased(key, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>resource中listener的回调是在EngineJob类中实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReleased</span><span class=\"params\">(Key cacheKey, EngineResource resource)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    activeResources.remove(cacheKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resource.isCacheable()) &#123;</span><br><span class=\"line\">        cache.put(cacheKey, resource);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resourceRecycler.recycle(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"磁盘缓存\"><a href=\"#磁盘缓存\" class=\"headerlink\" title=\"磁盘缓存\"></a>磁盘缓存</h2><p>首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理.</p>\n<h3 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h3><p>内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Resource&lt;?&gt; decode() <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDecodingFromCache()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decodeFromCache();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decodeFromSource();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Resource&lt;?&gt; decodeFromCache() <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    Resource&lt;?&gt; result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        result = decodeJob.decodeResultFromCache();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class=\"line\">            Log.d(TAG, <span class=\"string\">\"Exception decoding result from cache: \"</span> + e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = decodeJob.decodeSourceFromCache();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"磁盘cache读取\"><a href=\"#磁盘cache读取\" class=\"headerlink\" title=\"磁盘cache读取\"></a>磁盘cache读取</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Z&gt; <span class=\"title\">decodeResultFromCache</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!diskCacheStrategy.cacheResult()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;T&gt; transformed = loadFromCache(resultKey);</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Z&gt; <span class=\"title\">decodeSourceFromCache</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!diskCacheStrategy.cacheSource()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformEncodeAndTranscode(decoded);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">loadFromCache</span><span class=\"params\">(Key key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    File cacheFile = diskCacheProvider.getDiskCache().get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheFile == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Resource&lt;T&gt; result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            diskCacheProvider.getDiskCache().delete(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>磁盘缓存读取这里挺好懂的</p>\n<h3 id=\"磁盘cache写入\"><a href=\"#磁盘cache写入\" class=\"headerlink\" title=\"磁盘cache写入\"></a>磁盘cache写入</h3><h4 id=\"缓存原始图片\"><a href=\"#缓存原始图片\" class=\"headerlink\" title=\"缓存原始图片\"></a>缓存原始图片</h4><p>直接贴调用过程吧</p>\n<p>EngineRunnable.decodeFromSource()<br>-&gt; EngineRunnable.decodeFromSource()<br>-&gt; DecodeJob.decodeFromSource()<br>-&gt; DecodeJob.decodeSource()<br>-&gt; DecodeJob.decodeFromSourceData()<br>-&gt; DecodeJob.cacheAndDecodeSourceData</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">decodeSource</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Resource&lt;T&gt; decoded = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">        <span class=\"comment\">// 从网络获取图片</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> A data = fetcher.loadData(priority);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        decoded = decodeFromSourceData(data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        fetcher.cleanup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decoded;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">cacheAndDecodeSourceData</span><span class=\"params\">(A data)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    SourceWriter&lt;A&gt; writer = <span class=\"keyword\">new</span> SourceWriter&lt;A&gt;(loadProvider.getSourceEncoder(), data);</span><br><span class=\"line\">    diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);</span><br><span class=\"line\"></span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个?</span></span><br><span class=\"line\">    Resource&lt;T&gt; result = loadFromCache(resultKey.getOriginalKey());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"缓存处理过后的图片\"><a href=\"#缓存处理过后的图片\" class=\"headerlink\" title=\"缓存处理过后的图片\"></a>缓存处理过后的图片</h4><p>EngineRunnable.decodeFromSource()<br>-&gt; EngineRunnable.decodeFromSource()<br>-&gt; DecodeJob.decodeFromSource()<br>-&gt; DecodeJob.transformEncodeAndTranscode<br>-&gt; DecodeJob.writeTransformedToCache</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;Z&gt; <span class=\"title\">transformEncodeAndTranscode</span><span class=\"params\">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 先转换图片</span></span><br><span class=\"line\">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class=\"line\">    <span class=\"comment\">// 写入磁盘</span></span><br><span class=\"line\">    writeTransformedToCache(transformed);</span><br><span class=\"line\"></span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 转码</span></span><br><span class=\"line\">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeTransformedToCache</span><span class=\"params\">(Resource&lt;T&gt; transformed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transformed == <span class=\"keyword\">null</span> || !diskCacheStrategy.cacheResult()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    SourceWriter&lt;Resource&lt;T&gt;&gt; writer = <span class=\"keyword\">new</span> SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed);</span><br><span class=\"line\">    diskCacheProvider.getDiskCache().put(resultKey, writer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"OkHttp3源码-CallServerInterceptor","date":"2019-11-16T17:10:03.000Z","_content":"\nCallServerInterceptor主要负责具体的访问服务端\n\n```java\n/** This is the last interceptor in the chain. It makes a network call to the server. */\n\n  @Override \n  public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    HttpCodec httpCodec = realChain.httpStream();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n    RealConnection connection = (RealConnection) realChain.connection();\n    Request request = realChain.request();\n\n    long sentRequestMillis = System.currentTimeMillis();\n\n    realChain.eventListener().requestHeadersStart(realChain.call());\n    // HttpCodec相当于流, 将请求header写入流\n    httpCodec.writeRequestHeaders(request);\n    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n    Response.Builder responseBuilder = null;\n    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n      // Continue\" response before transmitting the request body. If we don't get that, return\n      // what we did get (such as a 4xx response) without ever transmitting the request body.\n      // 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流.\n      // \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体\n      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n        // 发送请求头\n        httpCodec.flushRequest();\n        realChain.eventListener().responseHeadersStart(realChain.call());\n        // 读取response\n        responseBuilder = httpCodec.readResponseHeaders(true);\n      }\n\n      // 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, \n      // 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体\n      if (responseBuilder == null) {\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        // 将请求体写入流\n        realChain.eventListener().requestBodyStart(realChain.call());\n        long contentLength = request.body().contentLength();\n        CountingSink requestBodyOut =\n            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\n        request.body().writeTo(bufferedRequestBody);\n        bufferedRequestBody.close();\n        realChain.eventListener()\n            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n      } else if (!connection.isMultiplexed()) {\n        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n        // from being reused. Otherwise we're still obligated to transmit the request body to\n        // leave the connection in a consistent state.\n\n        // 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接)\n        streamAllocation.noNewStreams();\n      }\n    }\n\n    // 结束发送请求\n    httpCodec.finishRequest();\n\n    if (responseBuilder == null) {\n      realChain.eventListener().responseHeadersStart(realChain.call());\n      // 读取response的头\n      responseBuilder = httpCodec.readResponseHeaders(false);\n    }\n\n    // 构建带响应头的响应体\n    Response response = responseBuilder\n        .request(request)\n        .handshake(streamAllocation.connection().handshake())\n        .sentRequestAtMillis(sentRequestMillis)\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build();\n\n    int code = response.code();\n    if (code == 100) {\n      // server sent a 100-continue even though we did not request one.\n      // try again to read the actual response\n      responseBuilder = httpCodec.readResponseHeaders(false);\n\n      response = responseBuilder\n              .request(request)\n              .handshake(streamAllocation.connection().handshake())\n              .sentRequestAtMillis(sentRequestMillis)\n              .receivedResponseAtMillis(System.currentTimeMillis())\n              .build();\n\n      code = response.code();\n    }\n\n    realChain.eventListener()\n            .responseHeadersEnd(realChain.call(), response);\n\n    if (forWebSocket && code == 101) {\n      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n      response = response.newBuilder()\n          .body(Util.EMPTY_RESPONSE)\n          .build();\n    } else {\n      // 构建响应体\n      response = response.newBuilder()\n          .body(httpCodec.openResponseBody(response))\n          .build();\n    }\n\n    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n\n    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n      throw new ProtocolException(\n          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n    }\n\n    return response;\n  }\n```","source":"_posts/Android/源码解析/OkHttp3源码-CallServerInterceptor.md","raw":"---\ntitle: OkHttp3源码-CallServerInterceptor\ndate: 2019-11-17 01:10:03\ntags:\n- okhttp3\n- 源码解析\ncategories:\n- Android\n---\n\nCallServerInterceptor主要负责具体的访问服务端\n\n```java\n/** This is the last interceptor in the chain. It makes a network call to the server. */\n\n  @Override \n  public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    HttpCodec httpCodec = realChain.httpStream();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n    RealConnection connection = (RealConnection) realChain.connection();\n    Request request = realChain.request();\n\n    long sentRequestMillis = System.currentTimeMillis();\n\n    realChain.eventListener().requestHeadersStart(realChain.call());\n    // HttpCodec相当于流, 将请求header写入流\n    httpCodec.writeRequestHeaders(request);\n    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n    Response.Builder responseBuilder = null;\n    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n      // Continue\" response before transmitting the request body. If we don't get that, return\n      // what we did get (such as a 4xx response) without ever transmitting the request body.\n      // 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流.\n      // \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体\n      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n        // 发送请求头\n        httpCodec.flushRequest();\n        realChain.eventListener().responseHeadersStart(realChain.call());\n        // 读取response\n        responseBuilder = httpCodec.readResponseHeaders(true);\n      }\n\n      // 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, \n      // 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体\n      if (responseBuilder == null) {\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        // 将请求体写入流\n        realChain.eventListener().requestBodyStart(realChain.call());\n        long contentLength = request.body().contentLength();\n        CountingSink requestBodyOut =\n            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\n        request.body().writeTo(bufferedRequestBody);\n        bufferedRequestBody.close();\n        realChain.eventListener()\n            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n      } else if (!connection.isMultiplexed()) {\n        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n        // from being reused. Otherwise we're still obligated to transmit the request body to\n        // leave the connection in a consistent state.\n\n        // 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接)\n        streamAllocation.noNewStreams();\n      }\n    }\n\n    // 结束发送请求\n    httpCodec.finishRequest();\n\n    if (responseBuilder == null) {\n      realChain.eventListener().responseHeadersStart(realChain.call());\n      // 读取response的头\n      responseBuilder = httpCodec.readResponseHeaders(false);\n    }\n\n    // 构建带响应头的响应体\n    Response response = responseBuilder\n        .request(request)\n        .handshake(streamAllocation.connection().handshake())\n        .sentRequestAtMillis(sentRequestMillis)\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build();\n\n    int code = response.code();\n    if (code == 100) {\n      // server sent a 100-continue even though we did not request one.\n      // try again to read the actual response\n      responseBuilder = httpCodec.readResponseHeaders(false);\n\n      response = responseBuilder\n              .request(request)\n              .handshake(streamAllocation.connection().handshake())\n              .sentRequestAtMillis(sentRequestMillis)\n              .receivedResponseAtMillis(System.currentTimeMillis())\n              .build();\n\n      code = response.code();\n    }\n\n    realChain.eventListener()\n            .responseHeadersEnd(realChain.call(), response);\n\n    if (forWebSocket && code == 101) {\n      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n      response = response.newBuilder()\n          .body(Util.EMPTY_RESPONSE)\n          .build();\n    } else {\n      // 构建响应体\n      response = response.newBuilder()\n          .body(httpCodec.openResponseBody(response))\n          .build();\n    }\n\n    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n\n    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n      throw new ProtocolException(\n          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n    }\n\n    return response;\n  }\n```","slug":"Android/源码解析/OkHttp3源码-CallServerInterceptor","published":1,"updated":"2019-12-21T12:16:41.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraks6004v8mzmo4b2h1dk","content":"<p>CallServerInterceptor主要负责具体的访问服务端</p><a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** This is the last interceptor in the chain. It makes a network call to the server. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class=\"line\">    <span class=\"comment\">// HttpCodec相当于流, 将请求header写入流</span></span><br><span class=\"line\">    httpCodec.writeRequestHeaders(request);</span><br><span class=\"line\">    realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class=\"line\"></span><br><span class=\"line\">    Response.Builder responseBuilder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100</span></span><br><span class=\"line\">      <span class=\"comment\">// Continue\" response before transmitting the request body. If we don't get that, return</span></span><br><span class=\"line\">      <span class=\"comment\">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class=\"line\">      <span class=\"comment\">// 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流.</span></span><br><span class=\"line\">      <span class=\"comment\">// \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发送请求头</span></span><br><span class=\"line\">        httpCodec.flushRequest();</span><br><span class=\"line\">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">        <span class=\"comment\">// 读取response</span></span><br><span class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, </span></span><br><span class=\"line\">      <span class=\"comment\">// 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write the request body if the \"Expect: 100-continue\" expectation was met.</span></span><br><span class=\"line\">        <span class=\"comment\">// 将请求体写入流</span></span><br><span class=\"line\">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> contentLength = request.body().contentLength();</span><br><span class=\"line\">        CountingSink requestBodyOut =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class=\"line\">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class=\"line\"></span><br><span class=\"line\">        request.body().writeTo(bufferedRequestBody);</span><br><span class=\"line\">        bufferedRequestBody.close();</span><br><span class=\"line\">        realChain.eventListener()</span><br><span class=\"line\">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class=\"line\">        <span class=\"comment\">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class=\"line\">        <span class=\"comment\">// leave the connection in a consistent state.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接)</span></span><br><span class=\"line\">        streamAllocation.noNewStreams();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 结束发送请求</span></span><br><span class=\"line\">    httpCodec.finishRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">      <span class=\"comment\">// 读取response的头</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建带响应头的响应体</span></span><br><span class=\"line\">    Response response = responseBuilder</span><br><span class=\"line\">        .request(request)</span><br><span class=\"line\">        .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> code = response.code();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// server sent a 100-continue even though we did not request one.</span></span><br><span class=\"line\">      <span class=\"comment\">// try again to read the actual response</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      response = responseBuilder</span><br><span class=\"line\">              .request(request)</span><br><span class=\"line\">              .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">              .build();</span><br><span class=\"line\"></span><br><span class=\"line\">      code = response.code();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener()</span><br><span class=\"line\">            .responseHeadersEnd(realChain.call(), response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forWebSocket &amp;&amp; code == <span class=\"number\">101</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 构建响应体</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(httpCodec.openResponseBody(response))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.request().header(<span class=\"string\">\"Connection\"</span>))</span><br><span class=\"line\">        || <span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.header(<span class=\"string\">\"Connection\"</span>))) &#123;</span><br><span class=\"line\">      streamAllocation.noNewStreams();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(</span><br><span class=\"line\">          <span class=\"string\">\"HTTP \"</span> + code + <span class=\"string\">\" had non-zero Content-Length: \"</span> + response.body().contentLength());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>CallServerInterceptor主要负责具体的访问服务端</p>","more":"\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** This is the last interceptor in the chain. It makes a network call to the server. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class=\"line\">    <span class=\"comment\">// HttpCodec相当于流, 将请求header写入流</span></span><br><span class=\"line\">    httpCodec.writeRequestHeaders(request);</span><br><span class=\"line\">    realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class=\"line\"></span><br><span class=\"line\">    Response.Builder responseBuilder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100</span></span><br><span class=\"line\">      <span class=\"comment\">// Continue\" response before transmitting the request body. If we don't get that, return</span></span><br><span class=\"line\">      <span class=\"comment\">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class=\"line\">      <span class=\"comment\">// 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流.</span></span><br><span class=\"line\">      <span class=\"comment\">// \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发送请求头</span></span><br><span class=\"line\">        httpCodec.flushRequest();</span><br><span class=\"line\">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">        <span class=\"comment\">// 读取response</span></span><br><span class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, </span></span><br><span class=\"line\">      <span class=\"comment\">// 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write the request body if the \"Expect: 100-continue\" expectation was met.</span></span><br><span class=\"line\">        <span class=\"comment\">// 将请求体写入流</span></span><br><span class=\"line\">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> contentLength = request.body().contentLength();</span><br><span class=\"line\">        CountingSink requestBodyOut =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class=\"line\">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class=\"line\"></span><br><span class=\"line\">        request.body().writeTo(bufferedRequestBody);</span><br><span class=\"line\">        bufferedRequestBody.close();</span><br><span class=\"line\">        realChain.eventListener()</span><br><span class=\"line\">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class=\"line\">        <span class=\"comment\">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class=\"line\">        <span class=\"comment\">// leave the connection in a consistent state.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接)</span></span><br><span class=\"line\">        streamAllocation.noNewStreams();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 结束发送请求</span></span><br><span class=\"line\">    httpCodec.finishRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">      <span class=\"comment\">// 读取response的头</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建带响应头的响应体</span></span><br><span class=\"line\">    Response response = responseBuilder</span><br><span class=\"line\">        .request(request)</span><br><span class=\"line\">        .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> code = response.code();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// server sent a 100-continue even though we did not request one.</span></span><br><span class=\"line\">      <span class=\"comment\">// try again to read the actual response</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      response = responseBuilder</span><br><span class=\"line\">              .request(request)</span><br><span class=\"line\">              .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">              .build();</span><br><span class=\"line\"></span><br><span class=\"line\">      code = response.code();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener()</span><br><span class=\"line\">            .responseHeadersEnd(realChain.call(), response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forWebSocket &amp;&amp; code == <span class=\"number\">101</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 构建响应体</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(httpCodec.openResponseBody(response))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.request().header(<span class=\"string\">\"Connection\"</span>))</span><br><span class=\"line\">        || <span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.header(<span class=\"string\">\"Connection\"</span>))) &#123;</span><br><span class=\"line\">      streamAllocation.noNewStreams();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(</span><br><span class=\"line\">          <span class=\"string\">\"HTTP \"</span> + code + <span class=\"string\">\" had non-zero Content-Length: \"</span> + response.body().contentLength());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>"},{"title":"OkHttp3源码-RetryAndInterceptor和BridgeInterceptor","date":"2019-11-14T08:54:17.000Z","_content":"\n# OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor\n\n## RetryAndInterceptor\n\n**主要功能:**\n失败重连, 重定向\n\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Call call = realChain.call();\n    EventListener eventListener = realChain.eventListener();\n\n    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),\n        createAddress(request.url()), call, eventListener, callStackTrace);\n    this.streamAllocation = streamAllocation;\n\n    int followUpCount = 0;\n    // priorResponse表示在重定向时, 上一次request的response\n    Response priorResponse = null;\n    // while死循环, 在请求失败或者重定向之后重新发起请求\n    while (true) {\n        if (canceled) {\n            streamAllocation.release();\n            throw new IOException(\"Canceled\");\n        }\n\n        Response response;\n        boolean releaseConnection = true;\n        try {\n            // 进入责任链的下一个结点\n            response = realChain.proceed(request, streamAllocation, null, null);\n            releaseConnection = false;\n        } catch (RouteException e) {\n            // The attempt to connect via a route failed. The request will not have been sent.\n            // recover方法判断这个request是否可以失败重连\n            // 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false\n            if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {\n                throw e.getFirstConnectException();\n            }\n            releaseConnection = false;\n            // 进入下一个while迭代, 开始失败重连\n            continue;\n        } catch (IOException e) {\n            // An attempt to communicate with a server failed. The request may have been sent.\n            boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n            if (!recover(e, streamAllocation, requestSendStarted, request))\n                throw e;\n            releaseConnection = false;\n            continue;\n        } finally {\n            // We're throwing an unchecked exception. Release any resources.\n            if (releaseConnection) {\n                streamAllocation.streamFailed(null);\n                streamAllocation.release();\n            }\n        }\n\n        // Attach the prior response if it exists. Such responses never have a body.\n        // 如果priorResponse不为null, 将其加入到当前response中\n        if (priorResponse != null) {\n            response = response.newBuilder()\n                .priorResponse(priorResponse.newBuilder()\n                        .body(null)\n                        .build())\n                .build();\n        }\n\n        // followUp意思是重定向\n        Request followUp;\n        try {\n            // followUpRequest方法: 重定向时根据response构建新的request\n            followUp = followUpRequest(response, streamAllocation.route());\n        } catch (IOException e) {\n            streamAllocation.release();\n            throw e;\n        }\n\n        // followUp为空, 表示没有重定向了, 当前response为最终结果, return\n        if (followUp == null) {\n            streamAllocation.release();\n            return response;\n        }\n\n        // 有重定向, 关闭响应流\n        closeQuietly(response.body());\n\n        // 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常\n        if (++followUpCount > MAX_FOLLOW_UPS) {\n            streamAllocation.release();\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n\n        // 判断是否是不可重定向的类型\n        if (followUp.body() instanceof UnrepeatableRequestBody) {\n            streamAllocation.release();\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n        }\n\n        if (!sameConnection(response, followUp.url())) {\n            streamAllocation.release();\n            streamAllocation = new StreamAllocation(client.connectionPool(),\n                createAddress(followUp.url()), call, eventListener, callStackTrace);\n            this.streamAllocation = streamAllocation;\n        } else if (streamAllocation.codec() != null) {\n            throw new IllegalStateException(\"Closing the body of \" + response\n                + \" didn't close its backing stream. Bad interceptor?\");\n        }\n\n        // 更新request 和 priorResponse\n        request = followUp;\n        priorResponse = response;\n    }\n}\n```\n\n## RetryAndInterceptor伪代码\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    Response response;\n    Request request = chain.request;\n    StreamAllocation streamAllocation = new StreamAllocation();\n\n    int followUpCount = 0;\n    while(true){\n        try{\n            response = realChain.proceed(request, streamAllocation, null, null);\n        }catch(OkhttpException e){\n            if (!recover())\n                throw e;\n            continue;\n        }catch(OtherException e){\n            throw e;\n        }\n\n        Request followUp;\n        try {\n            followUp = followUpRequest(response, streamAllocation.route());\n        } catch (IOException e) {\n            throw e;\n        }\n\n        if(followUp == null)\n            return response;\n        \n        if (++followUpCount > MAX_FOLLOW_UPS) {\n            throw new Exception(\"Too many follow-up requests: \" + followUpCount);\n        }\n\n        request = followUp;\n    }\n}\n```\n\n## BridgeInterceptor\n\n这个拦截器比较简单, 提一下源代码上的注释吧\n\n```java\n/**\n* Bridges from application code to network code. First it builds a network request from a user\n* request. Then it proceeds to call the network. Finally it builds a user response from the network\n* response.\n*/\n\n/**\n* 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求\n* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。\n*/\n```\n","source":"_posts/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor.md","raw":"---\ntitle: OkHttp3源码-RetryAndInterceptor和BridgeInterceptor\ndate: 2019-11-14 16:54:17\ntags:\n  - okhttp3\n  - 源码解析\ncategories:\n  - Android\n---\n\n# OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor\n\n## RetryAndInterceptor\n\n**主要功能:**\n失败重连, 重定向\n\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Call call = realChain.call();\n    EventListener eventListener = realChain.eventListener();\n\n    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),\n        createAddress(request.url()), call, eventListener, callStackTrace);\n    this.streamAllocation = streamAllocation;\n\n    int followUpCount = 0;\n    // priorResponse表示在重定向时, 上一次request的response\n    Response priorResponse = null;\n    // while死循环, 在请求失败或者重定向之后重新发起请求\n    while (true) {\n        if (canceled) {\n            streamAllocation.release();\n            throw new IOException(\"Canceled\");\n        }\n\n        Response response;\n        boolean releaseConnection = true;\n        try {\n            // 进入责任链的下一个结点\n            response = realChain.proceed(request, streamAllocation, null, null);\n            releaseConnection = false;\n        } catch (RouteException e) {\n            // The attempt to connect via a route failed. The request will not have been sent.\n            // recover方法判断这个request是否可以失败重连\n            // 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false\n            if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {\n                throw e.getFirstConnectException();\n            }\n            releaseConnection = false;\n            // 进入下一个while迭代, 开始失败重连\n            continue;\n        } catch (IOException e) {\n            // An attempt to communicate with a server failed. The request may have been sent.\n            boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n            if (!recover(e, streamAllocation, requestSendStarted, request))\n                throw e;\n            releaseConnection = false;\n            continue;\n        } finally {\n            // We're throwing an unchecked exception. Release any resources.\n            if (releaseConnection) {\n                streamAllocation.streamFailed(null);\n                streamAllocation.release();\n            }\n        }\n\n        // Attach the prior response if it exists. Such responses never have a body.\n        // 如果priorResponse不为null, 将其加入到当前response中\n        if (priorResponse != null) {\n            response = response.newBuilder()\n                .priorResponse(priorResponse.newBuilder()\n                        .body(null)\n                        .build())\n                .build();\n        }\n\n        // followUp意思是重定向\n        Request followUp;\n        try {\n            // followUpRequest方法: 重定向时根据response构建新的request\n            followUp = followUpRequest(response, streamAllocation.route());\n        } catch (IOException e) {\n            streamAllocation.release();\n            throw e;\n        }\n\n        // followUp为空, 表示没有重定向了, 当前response为最终结果, return\n        if (followUp == null) {\n            streamAllocation.release();\n            return response;\n        }\n\n        // 有重定向, 关闭响应流\n        closeQuietly(response.body());\n\n        // 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常\n        if (++followUpCount > MAX_FOLLOW_UPS) {\n            streamAllocation.release();\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n\n        // 判断是否是不可重定向的类型\n        if (followUp.body() instanceof UnrepeatableRequestBody) {\n            streamAllocation.release();\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n        }\n\n        if (!sameConnection(response, followUp.url())) {\n            streamAllocation.release();\n            streamAllocation = new StreamAllocation(client.connectionPool(),\n                createAddress(followUp.url()), call, eventListener, callStackTrace);\n            this.streamAllocation = streamAllocation;\n        } else if (streamAllocation.codec() != null) {\n            throw new IllegalStateException(\"Closing the body of \" + response\n                + \" didn't close its backing stream. Bad interceptor?\");\n        }\n\n        // 更新request 和 priorResponse\n        request = followUp;\n        priorResponse = response;\n    }\n}\n```\n\n## RetryAndInterceptor伪代码\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    Response response;\n    Request request = chain.request;\n    StreamAllocation streamAllocation = new StreamAllocation();\n\n    int followUpCount = 0;\n    while(true){\n        try{\n            response = realChain.proceed(request, streamAllocation, null, null);\n        }catch(OkhttpException e){\n            if (!recover())\n                throw e;\n            continue;\n        }catch(OtherException e){\n            throw e;\n        }\n\n        Request followUp;\n        try {\n            followUp = followUpRequest(response, streamAllocation.route());\n        } catch (IOException e) {\n            throw e;\n        }\n\n        if(followUp == null)\n            return response;\n        \n        if (++followUpCount > MAX_FOLLOW_UPS) {\n            throw new Exception(\"Too many follow-up requests: \" + followUpCount);\n        }\n\n        request = followUp;\n    }\n}\n```\n\n## BridgeInterceptor\n\n这个拦截器比较简单, 提一下源代码上的注释吧\n\n```java\n/**\n* Bridges from application code to network code. First it builds a network request from a user\n* request. Then it proceeds to call the network. Finally it builds a user response from the network\n* response.\n*/\n\n/**\n* 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求\n* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。\n*/\n```\n","slug":"Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor","published":1,"updated":"2019-12-21T12:16:41.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraks7004w8mzmgpsfdk7y","content":"<h1 id=\"OkHttp3-源码-RetryAndInterceptor-和-BridgeInterceptor\"><a href=\"#OkHttp3-源码-RetryAndInterceptor-和-BridgeInterceptor\" class=\"headerlink\" title=\"OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor\"></a>OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor</h1><a id=\"more\"></a><h2 id=\"RetryAndInterceptor\"><a href=\"#RetryAndInterceptor\" class=\"headerlink\" title=\"RetryAndInterceptor\"></a>RetryAndInterceptor</h2><p><strong>主要功能:</strong><br>失败重连, 重定向</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Call call = realChain.call();</span><br><span class=\"line\">    EventListener eventListener = realChain.eventListener();</span><br><span class=\"line\"></span><br><span class=\"line\">    StreamAllocation streamAllocation = <span class=\"keyword\">new</span> StreamAllocation(client.connectionPool(),</span><br><span class=\"line\">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.streamAllocation = streamAllocation;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> followUpCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// priorResponse表示在重定向时, 上一次request的response</span></span><br><span class=\"line\">    Response priorResponse = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// while死循环, 在请求失败或者重定向之后重新发起请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canceled) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Response response;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> releaseConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 进入责任链的下一个结点</span></span><br><span class=\"line\">            response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RouteException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class=\"line\">            <span class=\"comment\">// recover方法判断这个request是否可以失败重连</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class=\"keyword\">false</span>, request)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e.getFirstConnectException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 进入下一个while迭代, 开始失败重连</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> requestSendStarted = !(e <span class=\"keyword\">instanceof</span> ConnectionShutdownException);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover(e, streamAllocation, requestSendStarted, request))</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (releaseConnection) &#123;</span><br><span class=\"line\">                streamAllocation.streamFailed(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                streamAllocation.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果priorResponse不为null, 将其加入到当前response中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (priorResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            response = response.newBuilder()</span><br><span class=\"line\">                .priorResponse(priorResponse.newBuilder()</span><br><span class=\"line\">                        .body(<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        .build())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// followUp意思是重定向</span></span><br><span class=\"line\">        Request followUp;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// followUpRequest方法: 重定向时根据response构建新的request</span></span><br><span class=\"line\">            followUp = followUpRequest(response, streamAllocation.route());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// followUp为空, 表示没有重定向了, 当前response为最终结果, return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (followUp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 有重定向, 关闭响应流</span></span><br><span class=\"line\">        closeQuietly(response.body());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(<span class=\"string\">\"Too many follow-up requests: \"</span> + followUpCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是不可重定向的类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (followUp.body() <span class=\"keyword\">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HttpRetryException(<span class=\"string\">\"Cannot retry streamed HTTP body\"</span>, response.code());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            streamAllocation = <span class=\"keyword\">new</span> StreamAllocation(client.connectionPool(),</span><br><span class=\"line\">                createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.streamAllocation = streamAllocation;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (streamAllocation.codec() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Closing the body of \"</span> + response</span><br><span class=\"line\">                + <span class=\"string\">\" didn't close its backing stream. Bad interceptor?\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新request 和 priorResponse</span></span><br><span class=\"line\">        request = followUp;</span><br><span class=\"line\">        priorResponse = response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RetryAndInterceptor伪代码\"><a href=\"#RetryAndInterceptor伪代码\" class=\"headerlink\" title=\"RetryAndInterceptor伪代码\"></a>RetryAndInterceptor伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Response response;</span><br><span class=\"line\">    Request request = chain.request;</span><br><span class=\"line\">    StreamAllocation streamAllocation = <span class=\"keyword\">new</span> StreamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> followUpCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(OkhttpException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(OtherException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Request followUp;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            followUp = followUpRequest(response, streamAllocation.route());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(followUp == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Too many follow-up requests: \"</span> + followUpCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        request = followUp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"BridgeInterceptor\"><a href=\"#BridgeInterceptor\" class=\"headerlink\" title=\"BridgeInterceptor\"></a>BridgeInterceptor</h2><p>这个拦截器比较简单, 提一下源代码上的注释吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Bridges from application code to network code. First it builds a network request from a user</span></span><br><span class=\"line\"><span class=\"comment\">* request. Then it proceeds to call the network. Finally it builds a user response from the network</span></span><br><span class=\"line\"><span class=\"comment\">* response.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求</span></span><br><span class=\"line\"><span class=\"comment\">* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"OkHttp3-源码-RetryAndInterceptor-和-BridgeInterceptor\"><a href=\"#OkHttp3-源码-RetryAndInterceptor-和-BridgeInterceptor\" class=\"headerlink\" title=\"OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor\"></a>OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor</h1>","more":"<h2 id=\"RetryAndInterceptor\"><a href=\"#RetryAndInterceptor\" class=\"headerlink\" title=\"RetryAndInterceptor\"></a>RetryAndInterceptor</h2><p><strong>主要功能:</strong><br>失败重连, 重定向</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Call call = realChain.call();</span><br><span class=\"line\">    EventListener eventListener = realChain.eventListener();</span><br><span class=\"line\"></span><br><span class=\"line\">    StreamAllocation streamAllocation = <span class=\"keyword\">new</span> StreamAllocation(client.connectionPool(),</span><br><span class=\"line\">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.streamAllocation = streamAllocation;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> followUpCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// priorResponse表示在重定向时, 上一次request的response</span></span><br><span class=\"line\">    Response priorResponse = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// while死循环, 在请求失败或者重定向之后重新发起请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canceled) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Response response;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> releaseConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 进入责任链的下一个结点</span></span><br><span class=\"line\">            response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RouteException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class=\"line\">            <span class=\"comment\">// recover方法判断这个request是否可以失败重连</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class=\"keyword\">false</span>, request)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e.getFirstConnectException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 进入下一个while迭代, 开始失败重连</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> requestSendStarted = !(e <span class=\"keyword\">instanceof</span> ConnectionShutdownException);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover(e, streamAllocation, requestSendStarted, request))</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (releaseConnection) &#123;</span><br><span class=\"line\">                streamAllocation.streamFailed(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                streamAllocation.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果priorResponse不为null, 将其加入到当前response中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (priorResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            response = response.newBuilder()</span><br><span class=\"line\">                .priorResponse(priorResponse.newBuilder()</span><br><span class=\"line\">                        .body(<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        .build())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// followUp意思是重定向</span></span><br><span class=\"line\">        Request followUp;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// followUpRequest方法: 重定向时根据response构建新的request</span></span><br><span class=\"line\">            followUp = followUpRequest(response, streamAllocation.route());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// followUp为空, 表示没有重定向了, 当前response为最终结果, return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (followUp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 有重定向, 关闭响应流</span></span><br><span class=\"line\">        closeQuietly(response.body());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(<span class=\"string\">\"Too many follow-up requests: \"</span> + followUpCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是不可重定向的类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (followUp.body() <span class=\"keyword\">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HttpRetryException(<span class=\"string\">\"Cannot retry streamed HTTP body\"</span>, response.code());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            streamAllocation = <span class=\"keyword\">new</span> StreamAllocation(client.connectionPool(),</span><br><span class=\"line\">                createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.streamAllocation = streamAllocation;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (streamAllocation.codec() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Closing the body of \"</span> + response</span><br><span class=\"line\">                + <span class=\"string\">\" didn't close its backing stream. Bad interceptor?\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新request 和 priorResponse</span></span><br><span class=\"line\">        request = followUp;</span><br><span class=\"line\">        priorResponse = response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RetryAndInterceptor伪代码\"><a href=\"#RetryAndInterceptor伪代码\" class=\"headerlink\" title=\"RetryAndInterceptor伪代码\"></a>RetryAndInterceptor伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Response response;</span><br><span class=\"line\">    Request request = chain.request;</span><br><span class=\"line\">    StreamAllocation streamAllocation = <span class=\"keyword\">new</span> StreamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> followUpCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(OkhttpException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(OtherException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Request followUp;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            followUp = followUpRequest(response, streamAllocation.route());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(followUp == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Too many follow-up requests: \"</span> + followUpCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        request = followUp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"BridgeInterceptor\"><a href=\"#BridgeInterceptor\" class=\"headerlink\" title=\"BridgeInterceptor\"></a>BridgeInterceptor</h2><p>这个拦截器比较简单, 提一下源代码上的注释吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Bridges from application code to network code. First it builds a network request from a user</span></span><br><span class=\"line\"><span class=\"comment\">* request. Then it proceeds to call the network. Finally it builds a user response from the network</span></span><br><span class=\"line\"><span class=\"comment\">* response.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求</span></span><br><span class=\"line\"><span class=\"comment\">* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n"},{"title":"OkHttp3源码-责任链的分析","date":"2019-11-14T07:52:46.000Z","_content":"\n# okhttp3源码-责任链的分析\n\nokhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程\n\n## getResponseWithInterceptorChain()\n\n```java\nResponse getResponseWithInterceptorChain() throws IOException {\n    // Build a full stack of interceptors.\n    List<Interceptor> interceptors = new ArrayList<>();\n    interceptors.addAll(client.interceptors());\n    interceptors.add(retryAndFollowUpInterceptor);\n    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n    interceptors.add(new CacheInterceptor(client.internalCache()));\n    interceptors.add(new ConnectInterceptor(client));\n    if (!forWebSocket) {\n      interceptors.addAll(client.networkInterceptors());\n    }\n    interceptors.add(new CallServerInterceptor(forWebSocket));\n\n    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n        originalRequest, this, eventListener, client.connectTimeoutMillis(),\n        client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n    Response response = chain.proceed(originalRequest);\n    if (retryAndFollowUpInterceptor.isCanceled()) {\n      closeQuietly(response);\n      throw new IOException(\"Canceled\");\n    }\n    return response;\n  }\n}\n```\n\n### 每个拦截器的简单说明:\n* 1. 用户拦截器：通过Builder的addInterceptor方法添加的拦截器。\n* 2. RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。\n* 3. BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。\n* 4. CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程\n* 5. ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。\n* 6. CallServerInterceptor：和服务器通信，完成Http请求。\n所以我们可以总结出网络请求的调用流程：\n\nChain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类\n\n### RealInterceptorChian\n\n```java\n@Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n}\n\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n    RealConnection connection) throws IOException {\n    if (index >= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    ... // 省略一些异常处理的代码\n\n    // Call the next interceptor in the chain.\n    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n        writeTimeout);\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n        throw new IllegalStateException(\"network interceptor \" + interceptor\n            + \" must call proceed() exactly once\");\n    }\n\n    // Confirm that the intercepted response isn't null.\n    if (response == null) {\n        throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n    }\n\n    if (response.body() == null) {\n        throw new IllegalStateException(\n            \"interceptor \" + interceptor + \" returned a response with no body\");\n    }\n\n    return response;\n}\n```\n\n### interceptor.intercept(chain)\n\n**伪代码**\n```java\n@Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Call call = realChain.call();\n\n    ... // 处理request\n\n    Response response;\n    try {\n        // 继续责任链的下一个结点\n        response = realChain.proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n    } catch (Exception e) {\n        ... //\n    }\n\n    ... // 处理response\n}\n```\n\n梳理一下这个责任链模式的流程: (' -> '表示调用关系)\n-> getResponseWithInterceptorChain()\n-> chain.process(request)\n-> interceptor.intercept(nextChain)\n-> chain.process(request)\n-> interceptor.intercept(nextChain)\n-> ... // 循环直至责任链最后一个结点\n\n\n\n\n","source":"_posts/Android/源码解析/OkHttp3源码-责任链的分析.md","raw":"---\ntitle: OkHttp3源码-责任链的分析\ndate: 2019-11-14 15:52:46\ntags:\n- okhttp3\n- 源码分析\ncategories:\n- Android\n---\n\n# okhttp3源码-责任链的分析\n\nokhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程\n\n## getResponseWithInterceptorChain()\n\n```java\nResponse getResponseWithInterceptorChain() throws IOException {\n    // Build a full stack of interceptors.\n    List<Interceptor> interceptors = new ArrayList<>();\n    interceptors.addAll(client.interceptors());\n    interceptors.add(retryAndFollowUpInterceptor);\n    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n    interceptors.add(new CacheInterceptor(client.internalCache()));\n    interceptors.add(new ConnectInterceptor(client));\n    if (!forWebSocket) {\n      interceptors.addAll(client.networkInterceptors());\n    }\n    interceptors.add(new CallServerInterceptor(forWebSocket));\n\n    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n        originalRequest, this, eventListener, client.connectTimeoutMillis(),\n        client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n    Response response = chain.proceed(originalRequest);\n    if (retryAndFollowUpInterceptor.isCanceled()) {\n      closeQuietly(response);\n      throw new IOException(\"Canceled\");\n    }\n    return response;\n  }\n}\n```\n\n### 每个拦截器的简单说明:\n* 1. 用户拦截器：通过Builder的addInterceptor方法添加的拦截器。\n* 2. RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。\n* 3. BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。\n* 4. CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程\n* 5. ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。\n* 6. CallServerInterceptor：和服务器通信，完成Http请求。\n所以我们可以总结出网络请求的调用流程：\n\nChain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类\n\n### RealInterceptorChian\n\n```java\n@Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n}\n\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n    RealConnection connection) throws IOException {\n    if (index >= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    ... // 省略一些异常处理的代码\n\n    // Call the next interceptor in the chain.\n    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n        writeTimeout);\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n        throw new IllegalStateException(\"network interceptor \" + interceptor\n            + \" must call proceed() exactly once\");\n    }\n\n    // Confirm that the intercepted response isn't null.\n    if (response == null) {\n        throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n    }\n\n    if (response.body() == null) {\n        throw new IllegalStateException(\n            \"interceptor \" + interceptor + \" returned a response with no body\");\n    }\n\n    return response;\n}\n```\n\n### interceptor.intercept(chain)\n\n**伪代码**\n```java\n@Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Call call = realChain.call();\n\n    ... // 处理request\n\n    Response response;\n    try {\n        // 继续责任链的下一个结点\n        response = realChain.proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n    } catch (Exception e) {\n        ... //\n    }\n\n    ... // 处理response\n}\n```\n\n梳理一下这个责任链模式的流程: (' -> '表示调用关系)\n-> getResponseWithInterceptorChain()\n-> chain.process(request)\n-> interceptor.intercept(nextChain)\n-> chain.process(request)\n-> interceptor.intercept(nextChain)\n-> ... // 循环直至责任链最后一个结点\n\n\n\n\n","slug":"Android/源码解析/OkHttp3源码-责任链的分析","published":1,"updated":"2019-12-21T12:16:41.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraks8004y8mzmtbcgugo1","content":"<h1 id=\"okhttp3源码-责任链的分析\"><a href=\"#okhttp3源码-责任链的分析\" class=\"headerlink\" title=\"okhttp3源码-责任链的分析\"></a>okhttp3源码-责任链的分析</h1><p>okhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程</p><a id=\"more\"></a>\n<h2 id=\"getResponseWithInterceptorChain\"><a href=\"#getResponseWithInterceptorChain\" class=\"headerlink\" title=\"getResponseWithInterceptorChain()\"></a>getResponseWithInterceptorChain()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Response <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Build a full stack of interceptors.</span></span><br><span class=\"line\">    List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    interceptors.addAll(client.interceptors());</span><br><span class=\"line\">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CacheInterceptor(client.internalCache()));</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> ConnectInterceptor(client));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!forWebSocket) &#123;</span><br><span class=\"line\">      interceptors.addAll(client.networkInterceptors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CallServerInterceptor(forWebSocket));</span><br><span class=\"line\"></span><br><span class=\"line\">    Interceptor.Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        originalRequest, <span class=\"keyword\">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class=\"line\">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = chain.proceed(originalRequest);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class=\"line\">      closeQuietly(response);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"每个拦截器的简单说明\"><a href=\"#每个拦截器的简单说明\" class=\"headerlink\" title=\"每个拦截器的简单说明:\"></a>每个拦截器的简单说明:</h3><ul>\n<li><ol>\n<li>用户拦截器：通过Builder的addInterceptor方法添加的拦截器。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>CallServerInterceptor：和服务器通信，完成Http请求。<br>所以我们可以总结出网络请求的调用流程：</li>\n</ol>\n</li>\n</ul>\n<p>Chain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类</p>\n<h3 id=\"RealInterceptorChian\"><a href=\"#RealInterceptorChian\" class=\"headerlink\" title=\"RealInterceptorChian\"></a>RealInterceptorChian</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    RealConnection connection)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= interceptors.size()) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\"></span><br><span class=\"line\">    calls++;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略一些异常处理的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call the next interceptor in the chain.</span></span><br><span class=\"line\">    RealInterceptorChain next = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class=\"line\">        connection, index + <span class=\"number\">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout);</span><br><span class=\"line\">    Interceptor interceptor = interceptors.get(index);</span><br><span class=\"line\">    Response response = interceptor.intercept(next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpCodec != <span class=\"keyword\">null</span> &amp;&amp; index + <span class=\"number\">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptor</span><br><span class=\"line\">            + <span class=\"string\">\" must call proceed() exactly once\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Confirm that the intercepted response isn't null.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.body() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">            <span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned a response with no body\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"interceptor-intercept-chain\"><a href=\"#interceptor-intercept-chain\" class=\"headerlink\" title=\"interceptor.intercept(chain)\"></a>interceptor.intercept(chain)</h3><p><strong>伪代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Call call = realChain.call();</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 处理request</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Response response;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 继续责任链的下一个结点</span></span><br><span class=\"line\">        response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ... <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 处理response</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>梳理一下这个责任链模式的流程: (‘ -&gt; ‘表示调用关系)<br>-&gt; getResponseWithInterceptorChain()<br>-&gt; chain.process(request)<br>-&gt; interceptor.intercept(nextChain)<br>-&gt; chain.process(request)<br>-&gt; interceptor.intercept(nextChain)<br>-&gt; … // 循环直至责任链最后一个结点</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"okhttp3源码-责任链的分析\"><a href=\"#okhttp3源码-责任链的分析\" class=\"headerlink\" title=\"okhttp3源码-责任链的分析\"></a>okhttp3源码-责任链的分析</h1><p>okhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程</p>","more":"\n<h2 id=\"getResponseWithInterceptorChain\"><a href=\"#getResponseWithInterceptorChain\" class=\"headerlink\" title=\"getResponseWithInterceptorChain()\"></a>getResponseWithInterceptorChain()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Response <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Build a full stack of interceptors.</span></span><br><span class=\"line\">    List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    interceptors.addAll(client.interceptors());</span><br><span class=\"line\">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CacheInterceptor(client.internalCache()));</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> ConnectInterceptor(client));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!forWebSocket) &#123;</span><br><span class=\"line\">      interceptors.addAll(client.networkInterceptors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CallServerInterceptor(forWebSocket));</span><br><span class=\"line\"></span><br><span class=\"line\">    Interceptor.Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        originalRequest, <span class=\"keyword\">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class=\"line\">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = chain.proceed(originalRequest);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class=\"line\">      closeQuietly(response);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"每个拦截器的简单说明\"><a href=\"#每个拦截器的简单说明\" class=\"headerlink\" title=\"每个拦截器的简单说明:\"></a>每个拦截器的简单说明:</h3><ul>\n<li><ol>\n<li>用户拦截器：通过Builder的addInterceptor方法添加的拦截器。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>CallServerInterceptor：和服务器通信，完成Http请求。<br>所以我们可以总结出网络请求的调用流程：</li>\n</ol>\n</li>\n</ul>\n<p>Chain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类</p>\n<h3 id=\"RealInterceptorChian\"><a href=\"#RealInterceptorChian\" class=\"headerlink\" title=\"RealInterceptorChian\"></a>RealInterceptorChian</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    RealConnection connection)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= interceptors.size()) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\"></span><br><span class=\"line\">    calls++;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略一些异常处理的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call the next interceptor in the chain.</span></span><br><span class=\"line\">    RealInterceptorChain next = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class=\"line\">        connection, index + <span class=\"number\">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout);</span><br><span class=\"line\">    Interceptor interceptor = interceptors.get(index);</span><br><span class=\"line\">    Response response = interceptor.intercept(next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpCodec != <span class=\"keyword\">null</span> &amp;&amp; index + <span class=\"number\">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptor</span><br><span class=\"line\">            + <span class=\"string\">\" must call proceed() exactly once\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Confirm that the intercepted response isn't null.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.body() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">            <span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned a response with no body\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"interceptor-intercept-chain\"><a href=\"#interceptor-intercept-chain\" class=\"headerlink\" title=\"interceptor.intercept(chain)\"></a>interceptor.intercept(chain)</h3><p><strong>伪代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Call call = realChain.call();</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 处理request</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Response response;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 继续责任链的下一个结点</span></span><br><span class=\"line\">        response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ... <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 处理response</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>梳理一下这个责任链模式的流程: (‘ -&gt; ‘表示调用关系)<br>-&gt; getResponseWithInterceptorChain()<br>-&gt; chain.process(request)<br>-&gt; interceptor.intercept(nextChain)<br>-&gt; chain.process(request)<br>-&gt; interceptor.intercept(nextChain)<br>-&gt; … // 循环直至责任链最后一个结点</p>\n"},{"title":"OkHttp3源码-CacheInterceptor","date":"2019-11-14T12:17:52.000Z","_content":"\n# OkHttp3源码-CacheInterceptor\n\nokhttp3的cache管理部分比较复杂, 我一上来是一脸懵逼的, 结合网上的博客, 先上个伪代码吧..\n\n## 伪代码\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    // 1. 从Interceptor类的成员变量cache中尝试获取cache\n    // 这里的cache是OkHttpClient在build用户手动添加的, 默认为null\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    // 从请求策略中获取缓存的 网络请求 和 response\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    //2 如果缓存策略禁止使用网络请求并且缓存的response为null, 则返回一个504的response\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response(504);\n    }\n\n    //3 如果缓存策略禁止使用网络请求但是缓存的response不为null, 返回cache\n    if (networkRequest == null) {\n      return cacheResponse;\n    }\n\n    //4 到达这里表示没有可用的缓存, 继续责任链的下一个结点, 继续请求网络\n    networkResponse = chain.proceed(networkRequest);\n\n    //5 如果cache不为null, 并且服务器返回的response.code为HTTP_NOT_MODIFIED, 则返回cache中的response\n    // (304: 客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户端缓存可以使用)\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        Response response = cacheResponse.newBuilder()\n        return response;\n      } \n    }\n\n    //6 决定使用网络获取的response\n    Response response = networkResponse;\n\n    //7 将response装入cache中, 这里是用户添加的那个cache\n    cache.put(response);\n\n    return response;\n}\n```\n\n## interceptor的详细过程\n\n看过伪代码, 现在来看详细过程, 就好多了\n\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    //默认cache为null,可以配置cache,不为空尝试获取缓存中的response\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    long now = System.currentTimeMillis();\n    //根据response,time,request创建一个缓存策略，用于判断怎样使用缓存\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    if (cache != null) {\n      cache.trackResponse(strategy);\n    }\n\n    if (cacheCandidate != null && cacheResponse == null) {\n      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\n    }\n\n    // If we're forbidden from using the network and the cache is insufficient, fail.\n    //如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response.Builder()\n          .request(chain.request())\n          .protocol(Protocol.HTTP_1_1)\n          .code(504)\n          .message(\"Unsatisfiable Request (only-if-cached)\")\n          .body(Util.EMPTY_RESPONSE)\n          .sentRequestAtMillis(-1L)\n          .receivedResponseAtMillis(System.currentTimeMillis())\n          .build();\n    }\n\n    // If we don't need the network, we're done.\n    //不使用网络，但是有缓存，直接返回缓存\n    if (networkRequest == null) {\n      return cacheResponse.newBuilder()\n          .cacheResponse(stripBody(cacheResponse))\n          .build();\n    }\n\n    Response networkResponse = null;\n    try {\n      //直接走后续拦截器\n      networkResponse = chain.proceed(networkRequest);\n    } finally {\n      // If we're crashing on I/O or otherwise, don't leak the cache body.\n      if (networkResponse == null && cacheCandidate != null) {\n        closeQuietly(cacheCandidate.body());\n      }\n    }\n\n    // If we have a cache response too, then we're doing a conditional get.\n    // 当缓存响应和网络响应同时存在的时候，选择用哪个\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        // 如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求\n        // (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).\n        // 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应\n        Response response = cacheResponse.newBuilder()\n            .headers(combine(cacheResponse.headers(), networkResponse.headers()))\n            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n            .cacheResponse(stripBody(cacheResponse))\n            .networkResponse(stripBody(networkResponse))\n            .build();\n        networkResponse.body().close();\n\n        // Update the cache after combining headers but before stripping the\n        // Content-Encoding header (as performed by initContentStream()).\n        cache.trackConditionalCacheHit();\n        cache.update(cacheResponse, response);\n        return response;\n      } else {\n        closeQuietly(cacheResponse.body());\n      }\n    }\n    //使用网络响应\n    Response response = networkResponse.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n\n    //所以默认创建的OkHttpClient是没有缓存的\n    if (cache != null) {\n      // 缓存response\n      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {\n        // Offer this request to the cache.\n        // 缓存Resposne的Header信息\n        CacheRequest cacheRequest = cache.put(response);\n        // 缓存body\n        return cacheWritingResponse(cacheRequest, response);\n      }\n      // 只能okhttp3只能缓存GET请求....不然从cache中移除request\n      // 很奇怪, 为什么要在这里加一个判断\n      if (HttpMethod.invalidatesCache(networkRequest.method())) {\n        try {\n          cache.remove(networkRequest);\n        } catch (IOException ignored) {\n          // The cache cannot be written.\n        }\n      }\n    }\n\n    return response;\n}\n```\n\n## Cache\n\n**OkHttpClient创建时添加cache:**\n```java\nOkHttpClient.Builder builder = new OkHttpClient.Builder()\n    .connectTimeout(15, TimeUnit.SECONDS)\n    .writeTimeout(20, TimeUnit.SECONDS)\n    .readTimeout(20, TimeUnit.SECONDS)\n    .cache(new Cache(context.getExternalCacheDir(), 10*1024*1024));\n```\n\n**InternalCache和Cache:**\n\nInternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量\n\n**实现原理:**\n\n封装了对DiskLruCach的操作\n\n**注意点:**\n**Cache类只能缓存get请求.** 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低.\n\n## CacheStrategy\n\n**构造方法**\n```java\nCacheStrategy(Request networkRequest, Response cacheResponse)\n```\n生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。\n\n**CacheStrategy.Factory**\n```java\npublic Factory(long nowMillis, Request request, Response cacheResponse) \n```\n\n这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy\n\nrequest参数中附带有用户对缓存策略的配置: ( .cacheControl)\n\n类如:\n```java\nRequest request = new Request.Builder()\n       .cacheControl(new CacheControl.Builder().noCache().build())\n       .url(\"http://publicobject.com/helloworld.txt\")\n       .build();\n```\n\n\n\n\n\n\n\n\n","source":"_posts/Android/源码解析/OkHttp3源码-CacheInterceptor.md","raw":"---\ntitle: OkHttp3源码-CacheInterceptor\ndate: 2019-11-14 20:17:52\ntags:\n- okhttp3\n- 源码解析\ncategories:\n- Android\n---\n\n# OkHttp3源码-CacheInterceptor\n\nokhttp3的cache管理部分比较复杂, 我一上来是一脸懵逼的, 结合网上的博客, 先上个伪代码吧..\n\n## 伪代码\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    // 1. 从Interceptor类的成员变量cache中尝试获取cache\n    // 这里的cache是OkHttpClient在build用户手动添加的, 默认为null\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    // 从请求策略中获取缓存的 网络请求 和 response\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    //2 如果缓存策略禁止使用网络请求并且缓存的response为null, 则返回一个504的response\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response(504);\n    }\n\n    //3 如果缓存策略禁止使用网络请求但是缓存的response不为null, 返回cache\n    if (networkRequest == null) {\n      return cacheResponse;\n    }\n\n    //4 到达这里表示没有可用的缓存, 继续责任链的下一个结点, 继续请求网络\n    networkResponse = chain.proceed(networkRequest);\n\n    //5 如果cache不为null, 并且服务器返回的response.code为HTTP_NOT_MODIFIED, 则返回cache中的response\n    // (304: 客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户端缓存可以使用)\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        Response response = cacheResponse.newBuilder()\n        return response;\n      } \n    }\n\n    //6 决定使用网络获取的response\n    Response response = networkResponse;\n\n    //7 将response装入cache中, 这里是用户添加的那个cache\n    cache.put(response);\n\n    return response;\n}\n```\n\n## interceptor的详细过程\n\n看过伪代码, 现在来看详细过程, 就好多了\n\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    //默认cache为null,可以配置cache,不为空尝试获取缓存中的response\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    long now = System.currentTimeMillis();\n    //根据response,time,request创建一个缓存策略，用于判断怎样使用缓存\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    if (cache != null) {\n      cache.trackResponse(strategy);\n    }\n\n    if (cacheCandidate != null && cacheResponse == null) {\n      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\n    }\n\n    // If we're forbidden from using the network and the cache is insufficient, fail.\n    //如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response.Builder()\n          .request(chain.request())\n          .protocol(Protocol.HTTP_1_1)\n          .code(504)\n          .message(\"Unsatisfiable Request (only-if-cached)\")\n          .body(Util.EMPTY_RESPONSE)\n          .sentRequestAtMillis(-1L)\n          .receivedResponseAtMillis(System.currentTimeMillis())\n          .build();\n    }\n\n    // If we don't need the network, we're done.\n    //不使用网络，但是有缓存，直接返回缓存\n    if (networkRequest == null) {\n      return cacheResponse.newBuilder()\n          .cacheResponse(stripBody(cacheResponse))\n          .build();\n    }\n\n    Response networkResponse = null;\n    try {\n      //直接走后续拦截器\n      networkResponse = chain.proceed(networkRequest);\n    } finally {\n      // If we're crashing on I/O or otherwise, don't leak the cache body.\n      if (networkResponse == null && cacheCandidate != null) {\n        closeQuietly(cacheCandidate.body());\n      }\n    }\n\n    // If we have a cache response too, then we're doing a conditional get.\n    // 当缓存响应和网络响应同时存在的时候，选择用哪个\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        // 如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求\n        // (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).\n        // 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应\n        Response response = cacheResponse.newBuilder()\n            .headers(combine(cacheResponse.headers(), networkResponse.headers()))\n            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n            .cacheResponse(stripBody(cacheResponse))\n            .networkResponse(stripBody(networkResponse))\n            .build();\n        networkResponse.body().close();\n\n        // Update the cache after combining headers but before stripping the\n        // Content-Encoding header (as performed by initContentStream()).\n        cache.trackConditionalCacheHit();\n        cache.update(cacheResponse, response);\n        return response;\n      } else {\n        closeQuietly(cacheResponse.body());\n      }\n    }\n    //使用网络响应\n    Response response = networkResponse.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n\n    //所以默认创建的OkHttpClient是没有缓存的\n    if (cache != null) {\n      // 缓存response\n      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {\n        // Offer this request to the cache.\n        // 缓存Resposne的Header信息\n        CacheRequest cacheRequest = cache.put(response);\n        // 缓存body\n        return cacheWritingResponse(cacheRequest, response);\n      }\n      // 只能okhttp3只能缓存GET请求....不然从cache中移除request\n      // 很奇怪, 为什么要在这里加一个判断\n      if (HttpMethod.invalidatesCache(networkRequest.method())) {\n        try {\n          cache.remove(networkRequest);\n        } catch (IOException ignored) {\n          // The cache cannot be written.\n        }\n      }\n    }\n\n    return response;\n}\n```\n\n## Cache\n\n**OkHttpClient创建时添加cache:**\n```java\nOkHttpClient.Builder builder = new OkHttpClient.Builder()\n    .connectTimeout(15, TimeUnit.SECONDS)\n    .writeTimeout(20, TimeUnit.SECONDS)\n    .readTimeout(20, TimeUnit.SECONDS)\n    .cache(new Cache(context.getExternalCacheDir(), 10*1024*1024));\n```\n\n**InternalCache和Cache:**\n\nInternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量\n\n**实现原理:**\n\n封装了对DiskLruCach的操作\n\n**注意点:**\n**Cache类只能缓存get请求.** 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低.\n\n## CacheStrategy\n\n**构造方法**\n```java\nCacheStrategy(Request networkRequest, Response cacheResponse)\n```\n生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。\n\n**CacheStrategy.Factory**\n```java\npublic Factory(long nowMillis, Request request, Response cacheResponse) \n```\n\n这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy\n\nrequest参数中附带有用户对缓存策略的配置: ( .cacheControl)\n\n类如:\n```java\nRequest request = new Request.Builder()\n       .cacheControl(new CacheControl.Builder().noCache().build())\n       .url(\"http://publicobject.com/helloworld.txt\")\n       .build();\n```\n\n\n\n\n\n\n\n\n","slug":"Android/源码解析/OkHttp3源码-CacheInterceptor","published":1,"updated":"2019-12-21T12:16:41.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraks900518mzmavos1qva","content":"<h1 id=\"OkHttp3源码-CacheInterceptor\"><a href=\"#OkHttp3源码-CacheInterceptor\" class=\"headerlink\" title=\"OkHttp3源码-CacheInterceptor\"></a>OkHttp3源码-CacheInterceptor</h1><a id=\"more\"></a><p>okhttp3的cache管理部分比较复杂, 我一上来是一脸懵逼的, 结合网上的博客, 先上个伪代码吧..</p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 从Interceptor类的成员变量cache中尝试获取cache</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里的cache是OkHttpClient在build用户手动添加的, 默认为null</span></span><br><span class=\"line\">    Response cacheCandidate = cache != <span class=\"keyword\">null</span></span><br><span class=\"line\">        ? cache.get(chain.request())</span><br><span class=\"line\">        : <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从请求策略中获取缓存的 网络请求 和 response</span></span><br><span class=\"line\">    CacheStrategy strategy = <span class=\"keyword\">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class=\"line\">    Request networkRequest = strategy.networkRequest;</span><br><span class=\"line\">    Response cacheResponse = strategy.cacheResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2 如果缓存策略禁止使用网络请求并且缓存的response为null, 则返回一个504的response</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response(<span class=\"number\">504</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3 如果缓存策略禁止使用网络请求但是缓存的response不为null, 返回cache</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cacheResponse;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//4 到达这里表示没有可用的缓存, 继续责任链的下一个结点, 继续请求网络</span></span><br><span class=\"line\">    networkResponse = chain.proceed(networkRequest);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//5 如果cache不为null, 并且服务器返回的response.code为HTTP_NOT_MODIFIED, 则返回cache中的response</span></span><br><span class=\"line\">    <span class=\"comment\">// (304: 客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户端缓存可以使用)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class=\"line\">        Response response = cacheResponse.newBuilder()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//6 决定使用网络获取的response</span></span><br><span class=\"line\">    Response response = networkResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//7 将response装入cache中, 这里是用户添加的那个cache</span></span><br><span class=\"line\">    cache.put(response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"interceptor的详细过程\"><a href=\"#interceptor的详细过程\" class=\"headerlink\" title=\"interceptor的详细过程\"></a>interceptor的详细过程</h2><p>看过伪代码, 现在来看详细过程, 就好多了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//默认cache为null,可以配置cache,不为空尝试获取缓存中的response</span></span><br><span class=\"line\">    Response cacheCandidate = cache != <span class=\"keyword\">null</span></span><br><span class=\"line\">        ? cache.get(chain.request())</span><br><span class=\"line\">        : <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">//根据response,time,request创建一个缓存策略，用于判断怎样使用缓存</span></span><br><span class=\"line\">    CacheStrategy strategy = <span class=\"keyword\">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class=\"line\">    Request networkRequest = strategy.networkRequest;</span><br><span class=\"line\">    Response cacheResponse = strategy.cacheResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      cache.trackResponse(strategy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheCandidate != <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      closeQuietly(cacheCandidate.body()); <span class=\"comment\">// The cache candidate wasn't applicable. Close it.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response.Builder()</span><br><span class=\"line\">          .request(chain.request())</span><br><span class=\"line\">          .protocol(Protocol.HTTP_1_1)</span><br><span class=\"line\">          .code(<span class=\"number\">504</span>)</span><br><span class=\"line\">          .message(<span class=\"string\">\"Unsatisfiable Request (only-if-cached)\"</span>)</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .sentRequestAtMillis(-<span class=\"number\">1L</span>)</span><br><span class=\"line\">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we don't need the network, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">//不使用网络，但是有缓存，直接返回缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cacheResponse.newBuilder()</span><br><span class=\"line\">          .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Response networkResponse = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//直接走后续拦截器</span></span><br><span class=\"line\">      networkResponse = chain.proceed(networkRequest);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse == <span class=\"keyword\">null</span> &amp;&amp; cacheCandidate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        closeQuietly(cacheCandidate.body());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class=\"line\">    <span class=\"comment\">// 当缓存响应和网络响应同时存在的时候，选择用哪个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求</span></span><br><span class=\"line\">        <span class=\"comment\">// (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).</span></span><br><span class=\"line\">        <span class=\"comment\">// 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应</span></span><br><span class=\"line\">        Response response = cacheResponse.newBuilder()</span><br><span class=\"line\">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class=\"line\">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class=\"line\">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class=\"line\">            .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">            .networkResponse(stripBody(networkResponse))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">        networkResponse.body().close();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Update the cache after combining headers but before stripping the</span></span><br><span class=\"line\">        <span class=\"comment\">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class=\"line\">        cache.trackConditionalCacheHit();</span><br><span class=\"line\">        cache.update(cacheResponse, response);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        closeQuietly(cacheResponse.body());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//使用网络响应</span></span><br><span class=\"line\">    Response response = networkResponse.newBuilder()</span><br><span class=\"line\">        .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">        .networkResponse(stripBody(networkResponse))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所以默认创建的OkHttpClient是没有缓存的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 缓存response</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Offer this request to the cache.</span></span><br><span class=\"line\">        <span class=\"comment\">// 缓存Resposne的Header信息</span></span><br><span class=\"line\">        CacheRequest cacheRequest = cache.put(response);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存body</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 只能okhttp3只能缓存GET请求....不然从cache中移除request</span></span><br><span class=\"line\">      <span class=\"comment\">// 很奇怪, 为什么要在这里加一个判断</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          cache.remove(networkRequest);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// The cache cannot be written.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache\"></a>Cache</h2><p><strong>OkHttpClient创建时添加cache:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient.Builder builder = <span class=\"keyword\">new</span> OkHttpClient.Builder()</span><br><span class=\"line\">    .connectTimeout(<span class=\"number\">15</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .writeTimeout(<span class=\"number\">20</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .readTimeout(<span class=\"number\">20</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .cache(<span class=\"keyword\">new</span> Cache(context.getExternalCacheDir(), <span class=\"number\">10</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>));</span><br></pre></td></tr></table></figure></p>\n<p><strong>InternalCache和Cache:</strong></p>\n<p>InternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量</p>\n<p><strong>实现原理:</strong></p>\n<p>封装了对DiskLruCach的操作</p>\n<p><strong>注意点:</strong><br><strong>Cache类只能缓存get请求.</strong> 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低.</p>\n<h2 id=\"CacheStrategy\"><a href=\"#CacheStrategy\" class=\"headerlink\" title=\"CacheStrategy\"></a>CacheStrategy</h2><p><strong>构造方法</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CacheStrategy(Request networkRequest, Response cacheResponse)</span><br></pre></td></tr></table></figure></p>\n<p>生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。</p>\n<p><strong>CacheStrategy.Factory</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Factory</span><span class=\"params\">(<span class=\"keyword\">long</span> nowMillis, Request request, Response cacheResponse)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy</p>\n<p>request参数中附带有用户对缓存策略的配置: ( .cacheControl)</p>\n<p>类如:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request request = <span class=\"keyword\">new</span> Request.Builder()</span><br><span class=\"line\">       .cacheControl(<span class=\"keyword\">new</span> CacheControl.Builder().noCache().build())</span><br><span class=\"line\">       .url(<span class=\"string\">\"http://publicobject.com/helloworld.txt\"</span>)</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"OkHttp3源码-CacheInterceptor\"><a href=\"#OkHttp3源码-CacheInterceptor\" class=\"headerlink\" title=\"OkHttp3源码-CacheInterceptor\"></a>OkHttp3源码-CacheInterceptor</h1>","more":"<p>okhttp3的cache管理部分比较复杂, 我一上来是一脸懵逼的, 结合网上的博客, 先上个伪代码吧..</p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 从Interceptor类的成员变量cache中尝试获取cache</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里的cache是OkHttpClient在build用户手动添加的, 默认为null</span></span><br><span class=\"line\">    Response cacheCandidate = cache != <span class=\"keyword\">null</span></span><br><span class=\"line\">        ? cache.get(chain.request())</span><br><span class=\"line\">        : <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从请求策略中获取缓存的 网络请求 和 response</span></span><br><span class=\"line\">    CacheStrategy strategy = <span class=\"keyword\">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class=\"line\">    Request networkRequest = strategy.networkRequest;</span><br><span class=\"line\">    Response cacheResponse = strategy.cacheResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2 如果缓存策略禁止使用网络请求并且缓存的response为null, 则返回一个504的response</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response(<span class=\"number\">504</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3 如果缓存策略禁止使用网络请求但是缓存的response不为null, 返回cache</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cacheResponse;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//4 到达这里表示没有可用的缓存, 继续责任链的下一个结点, 继续请求网络</span></span><br><span class=\"line\">    networkResponse = chain.proceed(networkRequest);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//5 如果cache不为null, 并且服务器返回的response.code为HTTP_NOT_MODIFIED, 则返回cache中的response</span></span><br><span class=\"line\">    <span class=\"comment\">// (304: 客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户端缓存可以使用)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class=\"line\">        Response response = cacheResponse.newBuilder()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//6 决定使用网络获取的response</span></span><br><span class=\"line\">    Response response = networkResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//7 将response装入cache中, 这里是用户添加的那个cache</span></span><br><span class=\"line\">    cache.put(response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"interceptor的详细过程\"><a href=\"#interceptor的详细过程\" class=\"headerlink\" title=\"interceptor的详细过程\"></a>interceptor的详细过程</h2><p>看过伪代码, 现在来看详细过程, 就好多了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//默认cache为null,可以配置cache,不为空尝试获取缓存中的response</span></span><br><span class=\"line\">    Response cacheCandidate = cache != <span class=\"keyword\">null</span></span><br><span class=\"line\">        ? cache.get(chain.request())</span><br><span class=\"line\">        : <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">//根据response,time,request创建一个缓存策略，用于判断怎样使用缓存</span></span><br><span class=\"line\">    CacheStrategy strategy = <span class=\"keyword\">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class=\"line\">    Request networkRequest = strategy.networkRequest;</span><br><span class=\"line\">    Response cacheResponse = strategy.cacheResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      cache.trackResponse(strategy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheCandidate != <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      closeQuietly(cacheCandidate.body()); <span class=\"comment\">// The cache candidate wasn't applicable. Close it.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response.Builder()</span><br><span class=\"line\">          .request(chain.request())</span><br><span class=\"line\">          .protocol(Protocol.HTTP_1_1)</span><br><span class=\"line\">          .code(<span class=\"number\">504</span>)</span><br><span class=\"line\">          .message(<span class=\"string\">\"Unsatisfiable Request (only-if-cached)\"</span>)</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .sentRequestAtMillis(-<span class=\"number\">1L</span>)</span><br><span class=\"line\">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we don't need the network, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">//不使用网络，但是有缓存，直接返回缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cacheResponse.newBuilder()</span><br><span class=\"line\">          .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Response networkResponse = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//直接走后续拦截器</span></span><br><span class=\"line\">      networkResponse = chain.proceed(networkRequest);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse == <span class=\"keyword\">null</span> &amp;&amp; cacheCandidate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        closeQuietly(cacheCandidate.body());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class=\"line\">    <span class=\"comment\">// 当缓存响应和网络响应同时存在的时候，选择用哪个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求</span></span><br><span class=\"line\">        <span class=\"comment\">// (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).</span></span><br><span class=\"line\">        <span class=\"comment\">// 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应</span></span><br><span class=\"line\">        Response response = cacheResponse.newBuilder()</span><br><span class=\"line\">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class=\"line\">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class=\"line\">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class=\"line\">            .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">            .networkResponse(stripBody(networkResponse))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">        networkResponse.body().close();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Update the cache after combining headers but before stripping the</span></span><br><span class=\"line\">        <span class=\"comment\">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class=\"line\">        cache.trackConditionalCacheHit();</span><br><span class=\"line\">        cache.update(cacheResponse, response);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        closeQuietly(cacheResponse.body());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//使用网络响应</span></span><br><span class=\"line\">    Response response = networkResponse.newBuilder()</span><br><span class=\"line\">        .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">        .networkResponse(stripBody(networkResponse))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所以默认创建的OkHttpClient是没有缓存的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 缓存response</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Offer this request to the cache.</span></span><br><span class=\"line\">        <span class=\"comment\">// 缓存Resposne的Header信息</span></span><br><span class=\"line\">        CacheRequest cacheRequest = cache.put(response);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存body</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 只能okhttp3只能缓存GET请求....不然从cache中移除request</span></span><br><span class=\"line\">      <span class=\"comment\">// 很奇怪, 为什么要在这里加一个判断</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          cache.remove(networkRequest);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// The cache cannot be written.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache\"></a>Cache</h2><p><strong>OkHttpClient创建时添加cache:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient.Builder builder = <span class=\"keyword\">new</span> OkHttpClient.Builder()</span><br><span class=\"line\">    .connectTimeout(<span class=\"number\">15</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .writeTimeout(<span class=\"number\">20</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .readTimeout(<span class=\"number\">20</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .cache(<span class=\"keyword\">new</span> Cache(context.getExternalCacheDir(), <span class=\"number\">10</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>));</span><br></pre></td></tr></table></figure></p>\n<p><strong>InternalCache和Cache:</strong></p>\n<p>InternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量</p>\n<p><strong>实现原理:</strong></p>\n<p>封装了对DiskLruCach的操作</p>\n<p><strong>注意点:</strong><br><strong>Cache类只能缓存get请求.</strong> 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低.</p>\n<h2 id=\"CacheStrategy\"><a href=\"#CacheStrategy\" class=\"headerlink\" title=\"CacheStrategy\"></a>CacheStrategy</h2><p><strong>构造方法</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CacheStrategy(Request networkRequest, Response cacheResponse)</span><br></pre></td></tr></table></figure></p>\n<p>生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。</p>\n<p><strong>CacheStrategy.Factory</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Factory</span><span class=\"params\">(<span class=\"keyword\">long</span> nowMillis, Request request, Response cacheResponse)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy</p>\n<p>request参数中附带有用户对缓存策略的配置: ( .cacheControl)</p>\n<p>类如:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request request = <span class=\"keyword\">new</span> Request.Builder()</span><br><span class=\"line\">       .cacheControl(<span class=\"keyword\">new</span> CacheControl.Builder().noCache().build())</span><br><span class=\"line\">       .url(<span class=\"string\">\"http://publicobject.com/helloworld.txt\"</span>)</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure></p>\n"},{"title":"OkHttp3源码-ConnectInterceptor","date":"2019-11-15T15:45:15.000Z","_content":"\nConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.\n\n## 参考链接:\n[https://www.jianshu.com/p/4bf4c796db6f](okhttp源码分析（四）-ConnectInterceptor过滤器)\n[https://juejin.im/post/5b73abe55188256142142d89](OkHttp3源码解析(三)——连接池复用)\n\n## intercept\n\n```java\n@Override public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Request request = realChain.request();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n\n    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);\n    RealConnection connection = streamAllocation.connection();\n\n    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n}\n```\n\nConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单.\n\n## StreamAllocation\n\n### 流, 连接, 请求\nHTTP通信执行网络\"请求\"需要在\"连接\"上建立一个新的\"流\". StreamAllocation称之流的桥梁，它负责为一次\"请求\"寻找\"连接\"并建立\"流\"\n来看看StreamAllocation源代码上的官方注释:\n```java\n/**\n * <ul>\n *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are\n *         potentially slow to establish so it is necessary to be able to cancel a connection\n *         currently being connected.\n *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on\n *         connections. Each connection has its own allocation limit, which defines how many\n *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream\n *         at a time, HTTP/2 typically carry multiple.\n *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and\n *         its follow up requests. We prefer to keep all streams of a single call on the same\n *         connection for better behavior and locality.\n * </ul>\n */\n```\n**翻译:**\n* Connection:\n    到远端服务器的物理连接. Socket连接的具体工作者\n* Stream:\n    在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个.\n    在okhttp3的流是HttpCodec表示\n* Call: \n    对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中\n\n### newStream, findHealthyConnection\n\n#### newStream\n\n获取合适的连接, 从连接中获取流\n```java\n  public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n    int connectTimeout = client.connectTimeoutMillis();\n    int readTimeout = client.readTimeoutMillis();\n    int writeTimeout = client.writeTimeoutMillis();\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n      //获取一个连接\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n      //实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec\n      HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  }\n```\n\n#### findHealthyConnecton\n\n不断循环, 直到获取一个healthy?的连接\n健康的连接, 大概意思是socket能正常使用的意思吧\n\n```java\n  /**\n   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated\n   * until a healthy connection is found.\n   */\n  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n      throws IOException {\n    while (true) {\n      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n          connectionRetryEnabled);\n\n      // If this is a brand new connection, we can skip the extensive health checks.\n      synchronized (connectionPool) {\n        if (candidate.successCount == 0) {\n          return candidate;\n        }\n      }\n\n      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n      // isn't, take it out of the pool and start again.\n      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n        // 如果这个连接不健康, \n        // 禁用这条连接, 重复寻找可用的连接\n        noNewStreams();\n        continue;\n      }\n\n      return candidate;\n    }\n  }\n```\n\n### findConnection-重点\n\n```java\n /**\n   * Returns a connection to host a new stream. This prefers the existing connection if it exists,\n   * then the pool, finally building a new connection.\n   */\n /**\n   * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接\n   */\nprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled) throws IOException {\n    boolean foundPooledConnection = false;\n    RealConnection result = null;\n    Route selectedRoute = null;\n    Connection releasedConnection;\n    Socket toClose;\n    synchronized (connectionPool) {\n      ... // 省略代码\n\n      // Attempt to use an already-allocated connection. We need to be careful here because our\n      // already-allocated connection may have been restricted from creating new streams.\n      releasedConnection = this.connection;\n      toClose = releaseIfNoNewStreams();\n      if (this.connection != null) {\n        //如果当前connection不为空可以直接使用\n        // We had an already-allocated connection and it's good.\n        result = this.connection;\n        releasedConnection = null;\n      }\n      if (!reportedAcquired) {\n        // If the connection was never reported acquired, don't report it as released!\n        releasedConnection = null;\n      }\n\n      //当前这个connection不能使用，尝试从连接池里面获取一个请求\n      if (result == null) {\n        // Attempt to get a connection from the pool.\n        // Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法\n        Internal.instance.get(connectionPool, address, this, null);\n        if (connection != null) {\n          foundPooledConnection = true;\n          result = connection;\n        } else {\n          selectedRoute = route;\n        }\n      }\n    }\n    closeQuietly(toClose);\n\n    ... // 省略代码\n\n    if (result != null) {\n      // 找到一条可复用的连接\n      // If we found an already-allocated or pooled connection, we're done.\n      return result;\n    }\n\n    // 到达这里表示没有找到\n    // 切换路由再在连接池里面找下，如果有则返回\n\n    // If we need a route selection, make one. This is a blocking operation.\n    boolean newRouteSelection = false;\n    // 检查是否有其他路由\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\n      newRouteSelection = true;\n      routeSelection = routeSelector.next();\n    }\n\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(\"Canceled\");\n\n      if (newRouteSelection) {\n        // Now that we have a set of IP addresses, make another attempt at getting a connection from\n        // the pool. This could match due to connection coalescing.\n        // 有其他路由, 遍历RooteSelector\n        List<Route> routes = routeSelection.getAll();\n        for (int i = 0, size = routes.size(); i < size; i++) {\n          Route route = routes.get(i);\n          Internal.instance.get(connectionPool, address, this, route);\n          if (connection != null) {\n            foundPooledConnection = true;\n            result = connection;\n            this.route = route;\n            break;\n          }\n        }\n      }\n\n      if (!foundPooledConnection) {\n        //没找到则创建一条\n        if (selectedRoute == null) {\n          selectedRoute = routeSelection.next();\n        }\n\n        // Create a connection and assign it to this allocation immediately. This makes it possible\n        // for an asynchronous cancel() to interrupt the handshake we're about to do.\n        route = selectedRoute;\n        refusedStreamCount = 0;\n        result = new RealConnection(connectionPool, selectedRoute);\n        //往连接中增加流\n        acquire(result, false);\n      }\n    }\n\n    // If we found a pooled connection on the 2nd time around, we're done.\n    //如果第二次找到了可以复用的，则返回\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n      return result;\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    // 建立连接,开始握手\n    result.connect(\n        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);\n    // 将这条路由从错误缓存中清除\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      reportedAcquired = true;\n\n      // Pool the connection.\n      //将这个请求加入连接池\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      // 如果是多路复用，则合并\n      if (result.isMultiplexed()) {\n        // 返回的是一个重复的socket\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    // 关闭重复的socket\n    closeQuietly(socket);\n\n    eventListener.connectionAcquired(call, result);\n    return result;\n  }\n```\n\n## CollectionPool\n\n### 主要成员变量\n\n```java\n/**\n* Background threads are used to cleanup expired connections. There will be at most a single\n* thread running per connection pool. The thread pool executor permits the pool itself to be\n* garbage collected.\n*/\n/**\n被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). \n*/\nprivate static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,\n    Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,\n    new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp ConnectionPool\", true));\n\n/** The maximum number of idle connections for each address. */\n// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5\nprivate final int maxIdleConnections;\n// 允许的线程空闲的最大时间, 默认为5分钟\nprivate final long keepAliveDurationNs;\n// 清理的task\nprivate final Runnable cleanupRunnable = new Runnable() {\n    @Override public void run() {\n        while (true) {\n            long waitNanos = cleanup(System.nanoTime());\n            if (waitNanos == -1) return;\n            if (waitNanos > 0) {\n                long waitMillis = waitNanos / 1000000L;\n                waitNanos -= (waitMillis * 1000000L);\n                synchronized (ConnectionPool.this) {\n                    try {\n                        ConnectionPool.this.wait(waitMillis, (int) waitNanos);\n                    } catch (InterruptedException ignored) {\n                    }\n                }\n            }\n        }\n    }\n};\n// 连接池中的连接集合\nprivate final Deque<RealConnection> connections = new ArrayDeque<>();\n// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...\nfinal RouteDatabase routeDatabase = new RouteDatabase();\n// 标记清理线程是否在运行\nboolean cleanupRunning;\n```\n\n**ConnectionPool创建的位置:**\nConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs)\n\n\n### cleanUpRunnable\n\n会被放入线程池的清理任务\n\n```java\nprivate final Runnable cleanupRunnable = new Runnable() {\n    @Override public void run() {\n        while (true) {\n            // cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间\n            long waitNanos = cleanup(System.nanoTime());\n            if (waitNanos == -1) return;\n            if (waitNanos > 0) {\n                long waitMillis = waitNanos / 1000000L;\n                waitNanos -= (waitMillis * 1000000L);\n                synchronized (ConnectionPool.this) {\n                    try {\n                        // 挂起清理线程\n                        ConnectionPool.this.wait(waitMillis, (int) waitNanos);\n                    } catch (InterruptedException ignored) {\n                    }\n                }\n            }\n        }\n    }\n};\n```\n\n### cleanUp\n\n找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间.\n\n```java\n/**\n* Performs maintenance on this pool, evicting the connection that has been idle the longest if\n* either it has exceeded the keep alive limit or the idle connections limit.\n*\n* <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns\n* -1 if no further cleanups are required.\n*/\n\nlong cleanup(long now) {\n    int inUseConnectionCount = 0;\n    int idleConnectionCount = 0;\n    RealConnection longestIdleConnection = null;\n    long longestIdleDurationNs = Long.MIN_VALUE;\n\n    // Find either a connection to evict, or the time that the next eviction is due.\n    // 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection\n    synchronized (this) {\n      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {\n        RealConnection connection = i.next();\n\n        // If the connection is in use, keep searching.\n        // pruneAndGetAllocationCount方法判断当前connection是否正在使用中\n        if (pruneAndGetAllocationCount(connection, now) > 0) {\n          inUseConnectionCount++;\n          continue;\n        }\n\n        idleConnectionCount++;\n\n        // If the connection is ready to be evicted, we're done.\n        long idleDurationNs = now - connection.idleAtNanos;\n        // 记录空闲最长的那个connection, 并且记录空闲的最长时间\n        if (idleDurationNs > longestIdleDurationNs) {\n          longestIdleDurationNs = idleDurationNs;\n          longestIdleConnection = connection;\n        }\n      }\n\n      if (longestIdleDurationNs >= this.keepAliveDurationNs\n          || idleConnectionCount > this.maxIdleConnections) {\n        // We've found a connection to evict. Remove it from the list, then close it below (outside\n        // of the synchronized block).\n        \n        // 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制\n        // 从connections集合中remove掉该connection\n        connections.remove(longestIdleConnection);\n      } else if (idleConnectionCount > 0) {\n        // A connection will be ready to evict soon.\n        // 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间\n        return keepAliveDurationNs - longestIdleDurationNs;\n      } else if (inUseConnectionCount > 0) {\n        // All connections are in use. It'll be at least the keep alive duration 'til we run again.\n        // 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理\n        return keepAliveDurationNs;\n      } else {\n        // No connections, idle or in use.\n        // 根本没有connection, 返回-1, 直接终止清理任务\n        cleanupRunning = false;\n        return -1;\n      }\n    }\n\n    closeQuietly(longestIdleConnection.socket());\n\n    // Cleanup again immediately.\n    return 0;\n}\n```\n\n### pruneAndGetAllocationCount\n\n判断该连接是否是空闲的\n\n```java\nprivate int pruneAndGetAllocationCount(RealConnection connection, long now) {\n    List<Reference<StreamAllocation>> references = connection.allocations;\n    for (int i = 0; i < references.size(); ) {\n        Reference<StreamAllocation> reference = references.get(i);\n    \n        //如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation\n        if (reference.get() != null) {\n            i++;\n            continue;\n        }\n\n        ... // 省略代码\n        \n        //如果没有引用，就移除\n        references.remove(i);\n        connection.noNewStreams = true;\n\n        //如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接\n        if (references.isEmpty()) {\n            connection.idleAtNanos = now - keepAliveDurationNs;\n            return 0;\n        }\n    }\n    //遍历结束后，返回引用的数量，说明当前连接是活跃连接\n    return references.size();\n}\n```\n\n**判断连接是否空闲过程:**\nRealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用...), 若集合为空, 则该连接时空闲的. \n\n### get和put\n\n**get:**\n```java\nRealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      //判断这个连接是否符合address和route, 判断过程很麻烦\n      if (connection.isEligible(address, route)) {\n        // 将streamAllocation和这个connection绑定\n        streamAllocation.acquire(connection, true);\n        return connection;\n      }\n    }\n    return null;\n}\n```\n\n**put:**\n```java\n  void put(RealConnection connection) {\n    assert (Thread.holdsLock(this));\n    if (!cleanupRunning) {\n      // 当清理任务没有工作的时候, 将任务放入线程池中运行\n      // 因为当connections集合为空时, 清理任务会终止\n      // ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ???\n      cleanupRunning = true;\n      executor.execute(cleanupRunnable);\n    }\n    connections.add(connection);\n  }\n```\n\n","source":"_posts/Android/源码解析/OkHttp3源码-ConnectInterceptor.md","raw":"---\ntitle: OkHttp3源码-ConnectInterceptor\ndate: 2019-11-15 23:45:15\ntags:\n- okhttp3\n- 源码解析\ncategories:\n- Android\n---\n\nConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.\n\n## 参考链接:\n[https://www.jianshu.com/p/4bf4c796db6f](okhttp源码分析（四）-ConnectInterceptor过滤器)\n[https://juejin.im/post/5b73abe55188256142142d89](OkHttp3源码解析(三)——连接池复用)\n\n## intercept\n\n```java\n@Override public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Request request = realChain.request();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n\n    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);\n    RealConnection connection = streamAllocation.connection();\n\n    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n}\n```\n\nConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单.\n\n## StreamAllocation\n\n### 流, 连接, 请求\nHTTP通信执行网络\"请求\"需要在\"连接\"上建立一个新的\"流\". StreamAllocation称之流的桥梁，它负责为一次\"请求\"寻找\"连接\"并建立\"流\"\n来看看StreamAllocation源代码上的官方注释:\n```java\n/**\n * <ul>\n *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are\n *         potentially slow to establish so it is necessary to be able to cancel a connection\n *         currently being connected.\n *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on\n *         connections. Each connection has its own allocation limit, which defines how many\n *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream\n *         at a time, HTTP/2 typically carry multiple.\n *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and\n *         its follow up requests. We prefer to keep all streams of a single call on the same\n *         connection for better behavior and locality.\n * </ul>\n */\n```\n**翻译:**\n* Connection:\n    到远端服务器的物理连接. Socket连接的具体工作者\n* Stream:\n    在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个.\n    在okhttp3的流是HttpCodec表示\n* Call: \n    对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中\n\n### newStream, findHealthyConnection\n\n#### newStream\n\n获取合适的连接, 从连接中获取流\n```java\n  public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n    int connectTimeout = client.connectTimeoutMillis();\n    int readTimeout = client.readTimeoutMillis();\n    int writeTimeout = client.writeTimeoutMillis();\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n      //获取一个连接\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n      //实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec\n      HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  }\n```\n\n#### findHealthyConnecton\n\n不断循环, 直到获取一个healthy?的连接\n健康的连接, 大概意思是socket能正常使用的意思吧\n\n```java\n  /**\n   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated\n   * until a healthy connection is found.\n   */\n  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n      throws IOException {\n    while (true) {\n      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n          connectionRetryEnabled);\n\n      // If this is a brand new connection, we can skip the extensive health checks.\n      synchronized (connectionPool) {\n        if (candidate.successCount == 0) {\n          return candidate;\n        }\n      }\n\n      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n      // isn't, take it out of the pool and start again.\n      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n        // 如果这个连接不健康, \n        // 禁用这条连接, 重复寻找可用的连接\n        noNewStreams();\n        continue;\n      }\n\n      return candidate;\n    }\n  }\n```\n\n### findConnection-重点\n\n```java\n /**\n   * Returns a connection to host a new stream. This prefers the existing connection if it exists,\n   * then the pool, finally building a new connection.\n   */\n /**\n   * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接\n   */\nprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled) throws IOException {\n    boolean foundPooledConnection = false;\n    RealConnection result = null;\n    Route selectedRoute = null;\n    Connection releasedConnection;\n    Socket toClose;\n    synchronized (connectionPool) {\n      ... // 省略代码\n\n      // Attempt to use an already-allocated connection. We need to be careful here because our\n      // already-allocated connection may have been restricted from creating new streams.\n      releasedConnection = this.connection;\n      toClose = releaseIfNoNewStreams();\n      if (this.connection != null) {\n        //如果当前connection不为空可以直接使用\n        // We had an already-allocated connection and it's good.\n        result = this.connection;\n        releasedConnection = null;\n      }\n      if (!reportedAcquired) {\n        // If the connection was never reported acquired, don't report it as released!\n        releasedConnection = null;\n      }\n\n      //当前这个connection不能使用，尝试从连接池里面获取一个请求\n      if (result == null) {\n        // Attempt to get a connection from the pool.\n        // Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法\n        Internal.instance.get(connectionPool, address, this, null);\n        if (connection != null) {\n          foundPooledConnection = true;\n          result = connection;\n        } else {\n          selectedRoute = route;\n        }\n      }\n    }\n    closeQuietly(toClose);\n\n    ... // 省略代码\n\n    if (result != null) {\n      // 找到一条可复用的连接\n      // If we found an already-allocated or pooled connection, we're done.\n      return result;\n    }\n\n    // 到达这里表示没有找到\n    // 切换路由再在连接池里面找下，如果有则返回\n\n    // If we need a route selection, make one. This is a blocking operation.\n    boolean newRouteSelection = false;\n    // 检查是否有其他路由\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\n      newRouteSelection = true;\n      routeSelection = routeSelector.next();\n    }\n\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(\"Canceled\");\n\n      if (newRouteSelection) {\n        // Now that we have a set of IP addresses, make another attempt at getting a connection from\n        // the pool. This could match due to connection coalescing.\n        // 有其他路由, 遍历RooteSelector\n        List<Route> routes = routeSelection.getAll();\n        for (int i = 0, size = routes.size(); i < size; i++) {\n          Route route = routes.get(i);\n          Internal.instance.get(connectionPool, address, this, route);\n          if (connection != null) {\n            foundPooledConnection = true;\n            result = connection;\n            this.route = route;\n            break;\n          }\n        }\n      }\n\n      if (!foundPooledConnection) {\n        //没找到则创建一条\n        if (selectedRoute == null) {\n          selectedRoute = routeSelection.next();\n        }\n\n        // Create a connection and assign it to this allocation immediately. This makes it possible\n        // for an asynchronous cancel() to interrupt the handshake we're about to do.\n        route = selectedRoute;\n        refusedStreamCount = 0;\n        result = new RealConnection(connectionPool, selectedRoute);\n        //往连接中增加流\n        acquire(result, false);\n      }\n    }\n\n    // If we found a pooled connection on the 2nd time around, we're done.\n    //如果第二次找到了可以复用的，则返回\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n      return result;\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    // 建立连接,开始握手\n    result.connect(\n        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);\n    // 将这条路由从错误缓存中清除\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      reportedAcquired = true;\n\n      // Pool the connection.\n      //将这个请求加入连接池\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      // 如果是多路复用，则合并\n      if (result.isMultiplexed()) {\n        // 返回的是一个重复的socket\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    // 关闭重复的socket\n    closeQuietly(socket);\n\n    eventListener.connectionAcquired(call, result);\n    return result;\n  }\n```\n\n## CollectionPool\n\n### 主要成员变量\n\n```java\n/**\n* Background threads are used to cleanup expired connections. There will be at most a single\n* thread running per connection pool. The thread pool executor permits the pool itself to be\n* garbage collected.\n*/\n/**\n被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). \n*/\nprivate static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,\n    Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,\n    new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp ConnectionPool\", true));\n\n/** The maximum number of idle connections for each address. */\n// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5\nprivate final int maxIdleConnections;\n// 允许的线程空闲的最大时间, 默认为5分钟\nprivate final long keepAliveDurationNs;\n// 清理的task\nprivate final Runnable cleanupRunnable = new Runnable() {\n    @Override public void run() {\n        while (true) {\n            long waitNanos = cleanup(System.nanoTime());\n            if (waitNanos == -1) return;\n            if (waitNanos > 0) {\n                long waitMillis = waitNanos / 1000000L;\n                waitNanos -= (waitMillis * 1000000L);\n                synchronized (ConnectionPool.this) {\n                    try {\n                        ConnectionPool.this.wait(waitMillis, (int) waitNanos);\n                    } catch (InterruptedException ignored) {\n                    }\n                }\n            }\n        }\n    }\n};\n// 连接池中的连接集合\nprivate final Deque<RealConnection> connections = new ArrayDeque<>();\n// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...\nfinal RouteDatabase routeDatabase = new RouteDatabase();\n// 标记清理线程是否在运行\nboolean cleanupRunning;\n```\n\n**ConnectionPool创建的位置:**\nConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs)\n\n\n### cleanUpRunnable\n\n会被放入线程池的清理任务\n\n```java\nprivate final Runnable cleanupRunnable = new Runnable() {\n    @Override public void run() {\n        while (true) {\n            // cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间\n            long waitNanos = cleanup(System.nanoTime());\n            if (waitNanos == -1) return;\n            if (waitNanos > 0) {\n                long waitMillis = waitNanos / 1000000L;\n                waitNanos -= (waitMillis * 1000000L);\n                synchronized (ConnectionPool.this) {\n                    try {\n                        // 挂起清理线程\n                        ConnectionPool.this.wait(waitMillis, (int) waitNanos);\n                    } catch (InterruptedException ignored) {\n                    }\n                }\n            }\n        }\n    }\n};\n```\n\n### cleanUp\n\n找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间.\n\n```java\n/**\n* Performs maintenance on this pool, evicting the connection that has been idle the longest if\n* either it has exceeded the keep alive limit or the idle connections limit.\n*\n* <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns\n* -1 if no further cleanups are required.\n*/\n\nlong cleanup(long now) {\n    int inUseConnectionCount = 0;\n    int idleConnectionCount = 0;\n    RealConnection longestIdleConnection = null;\n    long longestIdleDurationNs = Long.MIN_VALUE;\n\n    // Find either a connection to evict, or the time that the next eviction is due.\n    // 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection\n    synchronized (this) {\n      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {\n        RealConnection connection = i.next();\n\n        // If the connection is in use, keep searching.\n        // pruneAndGetAllocationCount方法判断当前connection是否正在使用中\n        if (pruneAndGetAllocationCount(connection, now) > 0) {\n          inUseConnectionCount++;\n          continue;\n        }\n\n        idleConnectionCount++;\n\n        // If the connection is ready to be evicted, we're done.\n        long idleDurationNs = now - connection.idleAtNanos;\n        // 记录空闲最长的那个connection, 并且记录空闲的最长时间\n        if (idleDurationNs > longestIdleDurationNs) {\n          longestIdleDurationNs = idleDurationNs;\n          longestIdleConnection = connection;\n        }\n      }\n\n      if (longestIdleDurationNs >= this.keepAliveDurationNs\n          || idleConnectionCount > this.maxIdleConnections) {\n        // We've found a connection to evict. Remove it from the list, then close it below (outside\n        // of the synchronized block).\n        \n        // 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制\n        // 从connections集合中remove掉该connection\n        connections.remove(longestIdleConnection);\n      } else if (idleConnectionCount > 0) {\n        // A connection will be ready to evict soon.\n        // 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间\n        return keepAliveDurationNs - longestIdleDurationNs;\n      } else if (inUseConnectionCount > 0) {\n        // All connections are in use. It'll be at least the keep alive duration 'til we run again.\n        // 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理\n        return keepAliveDurationNs;\n      } else {\n        // No connections, idle or in use.\n        // 根本没有connection, 返回-1, 直接终止清理任务\n        cleanupRunning = false;\n        return -1;\n      }\n    }\n\n    closeQuietly(longestIdleConnection.socket());\n\n    // Cleanup again immediately.\n    return 0;\n}\n```\n\n### pruneAndGetAllocationCount\n\n判断该连接是否是空闲的\n\n```java\nprivate int pruneAndGetAllocationCount(RealConnection connection, long now) {\n    List<Reference<StreamAllocation>> references = connection.allocations;\n    for (int i = 0; i < references.size(); ) {\n        Reference<StreamAllocation> reference = references.get(i);\n    \n        //如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation\n        if (reference.get() != null) {\n            i++;\n            continue;\n        }\n\n        ... // 省略代码\n        \n        //如果没有引用，就移除\n        references.remove(i);\n        connection.noNewStreams = true;\n\n        //如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接\n        if (references.isEmpty()) {\n            connection.idleAtNanos = now - keepAliveDurationNs;\n            return 0;\n        }\n    }\n    //遍历结束后，返回引用的数量，说明当前连接是活跃连接\n    return references.size();\n}\n```\n\n**判断连接是否空闲过程:**\nRealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用...), 若集合为空, 则该连接时空闲的. \n\n### get和put\n\n**get:**\n```java\nRealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      //判断这个连接是否符合address和route, 判断过程很麻烦\n      if (connection.isEligible(address, route)) {\n        // 将streamAllocation和这个connection绑定\n        streamAllocation.acquire(connection, true);\n        return connection;\n      }\n    }\n    return null;\n}\n```\n\n**put:**\n```java\n  void put(RealConnection connection) {\n    assert (Thread.holdsLock(this));\n    if (!cleanupRunning) {\n      // 当清理任务没有工作的时候, 将任务放入线程池中运行\n      // 因为当connections集合为空时, 清理任务会终止\n      // ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ???\n      cleanupRunning = true;\n      executor.execute(cleanupRunnable);\n    }\n    connections.add(connection);\n  }\n```\n\n","slug":"Android/源码解析/OkHttp3源码-ConnectInterceptor","published":1,"updated":"2019-12-21T12:16:41.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraksa00538mzmj6pom8qz","content":"<p>ConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.</p><a id=\"more\"></a>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接:\"></a>参考链接:</h2><p><a href=\"okhttp源码分析（四）-ConnectInterceptor过滤器\">https://www.jianshu.com/p/4bf4c796db6f</a><br><a href=\"OkHttp3源码解析(三\">https://juejin.im/post/5b73abe55188256142142d89</a>——连接池复用)</p>\n<h2 id=\"intercept\"><a href=\"#intercept\" class=\"headerlink\" title=\"intercept\"></a>intercept</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class=\"line\">    RealConnection connection = streamAllocation.connection();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单.</p>\n<h2 id=\"StreamAllocation\"><a href=\"#StreamAllocation\" class=\"headerlink\" title=\"StreamAllocation\"></a>StreamAllocation</h2><h3 id=\"流-连接-请求\"><a href=\"#流-连接-请求\" class=\"headerlink\" title=\"流, 连接, 请求\"></a>流, 连接, 请求</h3><p>HTTP通信执行网络”请求”需要在”连接”上建立一个新的”流”. StreamAllocation称之流的桥梁，它负责为一次”请求”寻找”连接”并建立”流”<br>来看看StreamAllocation源代码上的官方注释:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Connections:&lt;/strong&gt; physical socket connections to remote servers. These are</span></span><br><span class=\"line\"><span class=\"comment\"> *         potentially slow to establish so it is necessary to be able to cancel a connection</span></span><br><span class=\"line\"><span class=\"comment\"> *         currently being connected.</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Streams:&lt;/strong&gt; logical HTTP request/response pairs that are layered on</span></span><br><span class=\"line\"><span class=\"comment\"> *         connections. Each connection has its own allocation limit, which defines how many</span></span><br><span class=\"line\"><span class=\"comment\"> *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream</span></span><br><span class=\"line\"><span class=\"comment\"> *         at a time, HTTP/2 typically carry multiple.</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Calls:&lt;/strong&gt; a logical sequence of streams, typically an initial request and</span></span><br><span class=\"line\"><span class=\"comment\"> *         its follow up requests. We prefer to keep all streams of a single call on the same</span></span><br><span class=\"line\"><span class=\"comment\"> *         connection for better behavior and locality.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>翻译:</strong></p>\n<ul>\n<li>Connection:<br>  到远端服务器的物理连接. Socket连接的具体工作者</li>\n<li>Stream:<br>  在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个.<br>  在okhttp3的流是HttpCodec表示</li>\n<li>Call:<br>  对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中</li>\n</ul>\n<h3 id=\"newStream-findHealthyConnection\"><a href=\"#newStream-findHealthyConnection\" class=\"headerlink\" title=\"newStream, findHealthyConnection\"></a>newStream, findHealthyConnection</h3><h4 id=\"newStream\"><a href=\"#newStream\" class=\"headerlink\" title=\"newStream\"></a>newStream</h4><p>获取合适的连接, 从连接中获取流<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HttpCodec <span class=\"title\">newStream</span><span class=\"params\">(OkHttpClient client, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> connectTimeout = client.connectTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> readTimeout = client.readTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> writeTimeout = client.writeTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取一个连接</span></span><br><span class=\"line\">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class=\"line\">    <span class=\"comment\">//实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec</span></span><br><span class=\"line\">    HttpCodec resultCodec = resultConnection.newCodec(client, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      codec = resultCodec;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resultCodec;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RouteException(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"findHealthyConnecton\"><a href=\"#findHealthyConnecton\" class=\"headerlink\" title=\"findHealthyConnecton\"></a>findHealthyConnecton</h4><p>不断循环, 直到获取一个healthy?的连接<br>健康的连接, 大概意思是socket能正常使用的意思吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</span></span><br><span class=\"line\"><span class=\"comment\"> * until a healthy connection is found.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findHealthyConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">int</span> writeTimeout, <span class=\"keyword\">boolean</span> connectionRetryEnabled, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class=\"line\">        connectionRetryEnabled);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (candidate.successCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class=\"line\">    <span class=\"comment\">// isn't, take it out of the pool and start again.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果这个连接不健康, </span></span><br><span class=\"line\">      <span class=\"comment\">// 禁用这条连接, 重复寻找可用的连接</span></span><br><span class=\"line\">      noNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"findConnection-重点\"><a href=\"#findConnection-重点\" class=\"headerlink\" title=\"findConnection-重点\"></a>findConnection-重点</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span></span><br><span class=\"line\"><span class=\"comment\">   * then the pool, finally building a new connection.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout, <span class=\"keyword\">int</span> writeTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> connectionRetryEnabled)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> foundPooledConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    RealConnection result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Route selectedRoute = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Connection releasedConnection;</span><br><span class=\"line\">    Socket toClose;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Attempt to use an already-allocated connection. We need to be careful here because our</span></span><br><span class=\"line\">      <span class=\"comment\">// already-allocated connection may have been restricted from creating new streams.</span></span><br><span class=\"line\">      releasedConnection = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">      toClose = releaseIfNoNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前connection不为空可以直接使用</span></span><br><span class=\"line\">        <span class=\"comment\">// We had an already-allocated connection and it's good.</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!reportedAcquired) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the connection was never reported acquired, don't report it as released!</span></span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//当前这个connection不能使用，尝试从连接池里面获取一个请求</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Attempt to get a connection from the pool.</span></span><br><span class=\"line\">        <span class=\"comment\">// Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法</span></span><br><span class=\"line\">        Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          result = connection;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          selectedRoute = route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeQuietly(toClose);</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找到一条可复用的连接</span></span><br><span class=\"line\">      <span class=\"comment\">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 到达这里表示没有找到</span></span><br><span class=\"line\">    <span class=\"comment\">// 切换路由再在连接池里面找下，如果有则返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> newRouteSelection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 检查是否有其他路由</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span> &amp;&amp; (routeSelection == <span class=\"keyword\">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class=\"line\">      newRouteSelection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      routeSelection = routeSelector.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newRouteSelection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class=\"line\">        <span class=\"comment\">// the pool. This could match due to connection coalescing.</span></span><br><span class=\"line\">        <span class=\"comment\">// 有其他路由, 遍历RooteSelector</span></span><br><span class=\"line\">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">          Route route = routes.get(i);</span><br><span class=\"line\">          Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, route);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            result = connection;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.route = route;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!foundPooledConnection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//没找到则创建一条</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          selectedRoute = routeSelection.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class=\"line\">        <span class=\"comment\">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class=\"line\">        route = selectedRoute;</span><br><span class=\"line\">        refusedStreamCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class=\"line\">        <span class=\"comment\">//往连接中增加流</span></span><br><span class=\"line\">        acquire(result, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果第二次找到了可以复用的，则返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"comment\">// 建立连接,开始握手</span></span><br><span class=\"line\">    result.connect(</span><br><span class=\"line\">        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);</span><br><span class=\"line\">    <span class=\"comment\">// 将这条路由从错误缓存中清除</span></span><br><span class=\"line\">    routeDatabase().connected(result.route());</span><br><span class=\"line\"></span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      reportedAcquired = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Pool the connection.</span></span><br><span class=\"line\">      <span class=\"comment\">//将这个请求加入连接池</span></span><br><span class=\"line\">      Internal.instance.put(connectionPool, result);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class=\"line\">      <span class=\"comment\">// release this connection and acquire that one.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果是多路复用，则合并</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回的是一个重复的socket</span></span><br><span class=\"line\">        socket = Internal.instance.deduplicate(connectionPool, address, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        result = connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭重复的socket</span></span><br><span class=\"line\">    closeQuietly(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CollectionPool\"><a href=\"#CollectionPool\" class=\"headerlink\" title=\"CollectionPool\"></a>CollectionPool</h2><h3 id=\"主要成员变量\"><a href=\"#主要成员变量\" class=\"headerlink\" title=\"主要成员变量\"></a>主要成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Background threads are used to cleanup expired connections. There will be at most a single</span></span><br><span class=\"line\"><span class=\"comment\">* thread running per connection pool. The thread pool executor permits the pool itself to be</span></span><br><span class=\"line\"><span class=\"comment\">* garbage collected.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor executor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span> <span class=\"comment\">/* corePoolSize */</span>,</span><br><span class=\"line\">    Integer.MAX_VALUE <span class=\"comment\">/* maximumPoolSize */</span>, <span class=\"number\">60L</span> <span class=\"comment\">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class=\"string\">\"OkHttp ConnectionPool\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** The maximum number of idle connections for each address. */</span></span><br><span class=\"line\"><span class=\"comment\">// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxIdleConnections;</span><br><span class=\"line\"><span class=\"comment\">// 允许的线程空闲的最大时间, 默认为5分钟</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> keepAliveDurationNs;</span><br><span class=\"line\"><span class=\"comment\">// 清理的task</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable cleanupRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> waitMillis = waitNanos / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">                waitNanos -= (waitMillis * <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ConnectionPool.<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        ConnectionPool.<span class=\"keyword\">this</span>.wait(waitMillis, (<span class=\"keyword\">int</span>) waitNanos);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 连接池中的连接集合</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;RealConnection&gt; connections = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> RouteDatabase routeDatabase = <span class=\"keyword\">new</span> RouteDatabase();</span><br><span class=\"line\"><span class=\"comment\">// 标记清理线程是否在运行</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> cleanupRunning;</span><br></pre></td></tr></table></figure>\n<p><strong>ConnectionPool创建的位置:</strong><br>ConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs)</p>\n<h3 id=\"cleanUpRunnable\"><a href=\"#cleanUpRunnable\" class=\"headerlink\" title=\"cleanUpRunnable\"></a>cleanUpRunnable</h3><p>会被放入线程池的清理任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable cleanupRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> waitMillis = waitNanos / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">                waitNanos -= (waitMillis * <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ConnectionPool.<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 挂起清理线程</span></span><br><span class=\"line\">                        ConnectionPool.<span class=\"keyword\">this</span>.wait(waitMillis, (<span class=\"keyword\">int</span>) waitNanos);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cleanUp\"><a href=\"#cleanUp\" class=\"headerlink\" title=\"cleanUp\"></a>cleanUp</h3><p>找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Performs maintenance on this pool, evicting the connection that has been idle the longest if</span></span><br><span class=\"line\"><span class=\"comment\">* either it has exceeded the keep alive limit or the idle connections limit.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;p&gt;Returns the duration in nanos to sleep until the next scheduled call to this method. Returns</span></span><br><span class=\"line\"><span class=\"comment\">* -1 if no further cleanups are required.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">cleanup</span><span class=\"params\">(<span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> inUseConnectionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idleConnectionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    RealConnection longestIdleConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class=\"line\">    <span class=\"comment\">// 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">        RealConnection connection = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the connection is in use, keep searching.</span></span><br><span class=\"line\">        <span class=\"comment\">// pruneAndGetAllocationCount方法判断当前connection是否正在使用中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          inUseConnectionCount++;</span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        idleConnectionCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the connection is ready to be evicted, we're done.</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class=\"line\">        <span class=\"comment\">// 记录空闲最长的那个connection, 并且记录空闲的最长时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class=\"line\">          longestIdleDurationNs = idleDurationNs;</span><br><span class=\"line\">          longestIdleConnection = connection;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (longestIdleDurationNs &gt;= <span class=\"keyword\">this</span>.keepAliveDurationNs</span><br><span class=\"line\">          || idleConnectionCount &gt; <span class=\"keyword\">this</span>.maxIdleConnections) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We've found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class=\"line\">        <span class=\"comment\">// of the synchronized block).</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制</span></span><br><span class=\"line\">        <span class=\"comment\">// 从connections集合中remove掉该connection</span></span><br><span class=\"line\">        connections.remove(longestIdleConnection);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (idleConnectionCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// A connection will be ready to evict soon.</span></span><br><span class=\"line\">        <span class=\"comment\">// 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inUseConnectionCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span></span><br><span class=\"line\">        <span class=\"comment\">// 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keepAliveDurationNs;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// No connections, idle or in use.</span></span><br><span class=\"line\">        <span class=\"comment\">// 根本没有connection, 返回-1, 直接终止清理任务</span></span><br><span class=\"line\">        cleanupRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    closeQuietly(longestIdleConnection.socket());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Cleanup again immediately.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pruneAndGetAllocationCount\"><a href=\"#pruneAndGetAllocationCount\" class=\"headerlink\" title=\"pruneAndGetAllocationCount\"></a>pruneAndGetAllocationCount</h3><p>判断该连接是否是空闲的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">pruneAndGetAllocationCount</span><span class=\"params\">(RealConnection connection, <span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; references.size(); ) &#123;</span><br><span class=\"line\">        Reference&lt;StreamAllocation&gt; reference = references.get(i);</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reference.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//如果没有引用，就移除</span></span><br><span class=\"line\">        references.remove(i);</span><br><span class=\"line\">        connection.noNewStreams = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (references.isEmpty()) &#123;</span><br><span class=\"line\">            connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遍历结束后，返回引用的数量，说明当前连接是活跃连接</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> references.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>判断连接是否空闲过程:</strong><br>RealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用…), 若集合为空, 则该连接时空闲的. </p>\n<h3 id=\"get和put\"><a href=\"#get和put\" class=\"headerlink\" title=\"get和put\"></a>get和put</h3><p><strong>get:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">RealConnection <span class=\"title\">get</span><span class=\"params\">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RealConnection connection : connections) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//判断这个连接是否符合address和route, 判断过程很麻烦</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将streamAllocation和这个connection绑定</span></span><br><span class=\"line\">        streamAllocation.acquire(connection, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>put:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(RealConnection connection)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!cleanupRunning) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当清理任务没有工作的时候, 将任务放入线程池中运行</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为当connections集合为空时, 清理任务会终止</span></span><br><span class=\"line\">    <span class=\"comment\">// ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ???</span></span><br><span class=\"line\">    cleanupRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    executor.execute(cleanupRunnable);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  connections.add(connection);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>ConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.</p>","more":"\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接:\"></a>参考链接:</h2><p><a href=\"okhttp源码分析（四）-ConnectInterceptor过滤器\">https://www.jianshu.com/p/4bf4c796db6f</a><br><a href=\"OkHttp3源码解析(三\">https://juejin.im/post/5b73abe55188256142142d89</a>——连接池复用)</p>\n<h2 id=\"intercept\"><a href=\"#intercept\" class=\"headerlink\" title=\"intercept\"></a>intercept</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class=\"line\">    RealConnection connection = streamAllocation.connection();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单.</p>\n<h2 id=\"StreamAllocation\"><a href=\"#StreamAllocation\" class=\"headerlink\" title=\"StreamAllocation\"></a>StreamAllocation</h2><h3 id=\"流-连接-请求\"><a href=\"#流-连接-请求\" class=\"headerlink\" title=\"流, 连接, 请求\"></a>流, 连接, 请求</h3><p>HTTP通信执行网络”请求”需要在”连接”上建立一个新的”流”. StreamAllocation称之流的桥梁，它负责为一次”请求”寻找”连接”并建立”流”<br>来看看StreamAllocation源代码上的官方注释:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Connections:&lt;/strong&gt; physical socket connections to remote servers. These are</span></span><br><span class=\"line\"><span class=\"comment\"> *         potentially slow to establish so it is necessary to be able to cancel a connection</span></span><br><span class=\"line\"><span class=\"comment\"> *         currently being connected.</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Streams:&lt;/strong&gt; logical HTTP request/response pairs that are layered on</span></span><br><span class=\"line\"><span class=\"comment\"> *         connections. Each connection has its own allocation limit, which defines how many</span></span><br><span class=\"line\"><span class=\"comment\"> *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream</span></span><br><span class=\"line\"><span class=\"comment\"> *         at a time, HTTP/2 typically carry multiple.</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Calls:&lt;/strong&gt; a logical sequence of streams, typically an initial request and</span></span><br><span class=\"line\"><span class=\"comment\"> *         its follow up requests. We prefer to keep all streams of a single call on the same</span></span><br><span class=\"line\"><span class=\"comment\"> *         connection for better behavior and locality.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>翻译:</strong></p>\n<ul>\n<li>Connection:<br>  到远端服务器的物理连接. Socket连接的具体工作者</li>\n<li>Stream:<br>  在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个.<br>  在okhttp3的流是HttpCodec表示</li>\n<li>Call:<br>  对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中</li>\n</ul>\n<h3 id=\"newStream-findHealthyConnection\"><a href=\"#newStream-findHealthyConnection\" class=\"headerlink\" title=\"newStream, findHealthyConnection\"></a>newStream, findHealthyConnection</h3><h4 id=\"newStream\"><a href=\"#newStream\" class=\"headerlink\" title=\"newStream\"></a>newStream</h4><p>获取合适的连接, 从连接中获取流<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HttpCodec <span class=\"title\">newStream</span><span class=\"params\">(OkHttpClient client, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> connectTimeout = client.connectTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> readTimeout = client.readTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> writeTimeout = client.writeTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取一个连接</span></span><br><span class=\"line\">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class=\"line\">    <span class=\"comment\">//实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec</span></span><br><span class=\"line\">    HttpCodec resultCodec = resultConnection.newCodec(client, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      codec = resultCodec;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resultCodec;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RouteException(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"findHealthyConnecton\"><a href=\"#findHealthyConnecton\" class=\"headerlink\" title=\"findHealthyConnecton\"></a>findHealthyConnecton</h4><p>不断循环, 直到获取一个healthy?的连接<br>健康的连接, 大概意思是socket能正常使用的意思吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</span></span><br><span class=\"line\"><span class=\"comment\"> * until a healthy connection is found.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findHealthyConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">int</span> writeTimeout, <span class=\"keyword\">boolean</span> connectionRetryEnabled, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class=\"line\">        connectionRetryEnabled);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (candidate.successCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class=\"line\">    <span class=\"comment\">// isn't, take it out of the pool and start again.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果这个连接不健康, </span></span><br><span class=\"line\">      <span class=\"comment\">// 禁用这条连接, 重复寻找可用的连接</span></span><br><span class=\"line\">      noNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"findConnection-重点\"><a href=\"#findConnection-重点\" class=\"headerlink\" title=\"findConnection-重点\"></a>findConnection-重点</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span></span><br><span class=\"line\"><span class=\"comment\">   * then the pool, finally building a new connection.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout, <span class=\"keyword\">int</span> writeTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> connectionRetryEnabled)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> foundPooledConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    RealConnection result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Route selectedRoute = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Connection releasedConnection;</span><br><span class=\"line\">    Socket toClose;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Attempt to use an already-allocated connection. We need to be careful here because our</span></span><br><span class=\"line\">      <span class=\"comment\">// already-allocated connection may have been restricted from creating new streams.</span></span><br><span class=\"line\">      releasedConnection = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">      toClose = releaseIfNoNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前connection不为空可以直接使用</span></span><br><span class=\"line\">        <span class=\"comment\">// We had an already-allocated connection and it's good.</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!reportedAcquired) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the connection was never reported acquired, don't report it as released!</span></span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//当前这个connection不能使用，尝试从连接池里面获取一个请求</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Attempt to get a connection from the pool.</span></span><br><span class=\"line\">        <span class=\"comment\">// Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法</span></span><br><span class=\"line\">        Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          result = connection;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          selectedRoute = route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeQuietly(toClose);</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找到一条可复用的连接</span></span><br><span class=\"line\">      <span class=\"comment\">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 到达这里表示没有找到</span></span><br><span class=\"line\">    <span class=\"comment\">// 切换路由再在连接池里面找下，如果有则返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> newRouteSelection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 检查是否有其他路由</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span> &amp;&amp; (routeSelection == <span class=\"keyword\">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class=\"line\">      newRouteSelection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      routeSelection = routeSelector.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newRouteSelection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class=\"line\">        <span class=\"comment\">// the pool. This could match due to connection coalescing.</span></span><br><span class=\"line\">        <span class=\"comment\">// 有其他路由, 遍历RooteSelector</span></span><br><span class=\"line\">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">          Route route = routes.get(i);</span><br><span class=\"line\">          Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, route);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            result = connection;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.route = route;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!foundPooledConnection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//没找到则创建一条</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          selectedRoute = routeSelection.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class=\"line\">        <span class=\"comment\">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class=\"line\">        route = selectedRoute;</span><br><span class=\"line\">        refusedStreamCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class=\"line\">        <span class=\"comment\">//往连接中增加流</span></span><br><span class=\"line\">        acquire(result, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果第二次找到了可以复用的，则返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"comment\">// 建立连接,开始握手</span></span><br><span class=\"line\">    result.connect(</span><br><span class=\"line\">        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);</span><br><span class=\"line\">    <span class=\"comment\">// 将这条路由从错误缓存中清除</span></span><br><span class=\"line\">    routeDatabase().connected(result.route());</span><br><span class=\"line\"></span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      reportedAcquired = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Pool the connection.</span></span><br><span class=\"line\">      <span class=\"comment\">//将这个请求加入连接池</span></span><br><span class=\"line\">      Internal.instance.put(connectionPool, result);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class=\"line\">      <span class=\"comment\">// release this connection and acquire that one.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果是多路复用，则合并</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回的是一个重复的socket</span></span><br><span class=\"line\">        socket = Internal.instance.deduplicate(connectionPool, address, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        result = connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭重复的socket</span></span><br><span class=\"line\">    closeQuietly(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CollectionPool\"><a href=\"#CollectionPool\" class=\"headerlink\" title=\"CollectionPool\"></a>CollectionPool</h2><h3 id=\"主要成员变量\"><a href=\"#主要成员变量\" class=\"headerlink\" title=\"主要成员变量\"></a>主要成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Background threads are used to cleanup expired connections. There will be at most a single</span></span><br><span class=\"line\"><span class=\"comment\">* thread running per connection pool. The thread pool executor permits the pool itself to be</span></span><br><span class=\"line\"><span class=\"comment\">* garbage collected.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor executor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span> <span class=\"comment\">/* corePoolSize */</span>,</span><br><span class=\"line\">    Integer.MAX_VALUE <span class=\"comment\">/* maximumPoolSize */</span>, <span class=\"number\">60L</span> <span class=\"comment\">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class=\"string\">\"OkHttp ConnectionPool\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** The maximum number of idle connections for each address. */</span></span><br><span class=\"line\"><span class=\"comment\">// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxIdleConnections;</span><br><span class=\"line\"><span class=\"comment\">// 允许的线程空闲的最大时间, 默认为5分钟</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> keepAliveDurationNs;</span><br><span class=\"line\"><span class=\"comment\">// 清理的task</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable cleanupRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> waitMillis = waitNanos / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">                waitNanos -= (waitMillis * <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ConnectionPool.<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        ConnectionPool.<span class=\"keyword\">this</span>.wait(waitMillis, (<span class=\"keyword\">int</span>) waitNanos);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 连接池中的连接集合</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;RealConnection&gt; connections = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> RouteDatabase routeDatabase = <span class=\"keyword\">new</span> RouteDatabase();</span><br><span class=\"line\"><span class=\"comment\">// 标记清理线程是否在运行</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> cleanupRunning;</span><br></pre></td></tr></table></figure>\n<p><strong>ConnectionPool创建的位置:</strong><br>ConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs)</p>\n<h3 id=\"cleanUpRunnable\"><a href=\"#cleanUpRunnable\" class=\"headerlink\" title=\"cleanUpRunnable\"></a>cleanUpRunnable</h3><p>会被放入线程池的清理任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable cleanupRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> waitMillis = waitNanos / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">                waitNanos -= (waitMillis * <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ConnectionPool.<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 挂起清理线程</span></span><br><span class=\"line\">                        ConnectionPool.<span class=\"keyword\">this</span>.wait(waitMillis, (<span class=\"keyword\">int</span>) waitNanos);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cleanUp\"><a href=\"#cleanUp\" class=\"headerlink\" title=\"cleanUp\"></a>cleanUp</h3><p>找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Performs maintenance on this pool, evicting the connection that has been idle the longest if</span></span><br><span class=\"line\"><span class=\"comment\">* either it has exceeded the keep alive limit or the idle connections limit.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;p&gt;Returns the duration in nanos to sleep until the next scheduled call to this method. Returns</span></span><br><span class=\"line\"><span class=\"comment\">* -1 if no further cleanups are required.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">cleanup</span><span class=\"params\">(<span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> inUseConnectionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idleConnectionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    RealConnection longestIdleConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class=\"line\">    <span class=\"comment\">// 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">        RealConnection connection = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the connection is in use, keep searching.</span></span><br><span class=\"line\">        <span class=\"comment\">// pruneAndGetAllocationCount方法判断当前connection是否正在使用中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          inUseConnectionCount++;</span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        idleConnectionCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the connection is ready to be evicted, we're done.</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class=\"line\">        <span class=\"comment\">// 记录空闲最长的那个connection, 并且记录空闲的最长时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class=\"line\">          longestIdleDurationNs = idleDurationNs;</span><br><span class=\"line\">          longestIdleConnection = connection;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (longestIdleDurationNs &gt;= <span class=\"keyword\">this</span>.keepAliveDurationNs</span><br><span class=\"line\">          || idleConnectionCount &gt; <span class=\"keyword\">this</span>.maxIdleConnections) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We've found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class=\"line\">        <span class=\"comment\">// of the synchronized block).</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制</span></span><br><span class=\"line\">        <span class=\"comment\">// 从connections集合中remove掉该connection</span></span><br><span class=\"line\">        connections.remove(longestIdleConnection);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (idleConnectionCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// A connection will be ready to evict soon.</span></span><br><span class=\"line\">        <span class=\"comment\">// 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inUseConnectionCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span></span><br><span class=\"line\">        <span class=\"comment\">// 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keepAliveDurationNs;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// No connections, idle or in use.</span></span><br><span class=\"line\">        <span class=\"comment\">// 根本没有connection, 返回-1, 直接终止清理任务</span></span><br><span class=\"line\">        cleanupRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    closeQuietly(longestIdleConnection.socket());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Cleanup again immediately.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pruneAndGetAllocationCount\"><a href=\"#pruneAndGetAllocationCount\" class=\"headerlink\" title=\"pruneAndGetAllocationCount\"></a>pruneAndGetAllocationCount</h3><p>判断该连接是否是空闲的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">pruneAndGetAllocationCount</span><span class=\"params\">(RealConnection connection, <span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; references.size(); ) &#123;</span><br><span class=\"line\">        Reference&lt;StreamAllocation&gt; reference = references.get(i);</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reference.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//如果没有引用，就移除</span></span><br><span class=\"line\">        references.remove(i);</span><br><span class=\"line\">        connection.noNewStreams = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (references.isEmpty()) &#123;</span><br><span class=\"line\">            connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遍历结束后，返回引用的数量，说明当前连接是活跃连接</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> references.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>判断连接是否空闲过程:</strong><br>RealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用…), 若集合为空, 则该连接时空闲的. </p>\n<h3 id=\"get和put\"><a href=\"#get和put\" class=\"headerlink\" title=\"get和put\"></a>get和put</h3><p><strong>get:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">RealConnection <span class=\"title\">get</span><span class=\"params\">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RealConnection connection : connections) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//判断这个连接是否符合address和route, 判断过程很麻烦</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将streamAllocation和这个connection绑定</span></span><br><span class=\"line\">        streamAllocation.acquire(connection, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>put:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(RealConnection connection)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!cleanupRunning) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当清理任务没有工作的时候, 将任务放入线程池中运行</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为当connections集合为空时, 清理任务会终止</span></span><br><span class=\"line\">    <span class=\"comment\">// ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ???</span></span><br><span class=\"line\">    cleanupRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    executor.execute(cleanupRunnable);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  connections.add(connection);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"handler机制源码解析","date":"2019-11-09T05:59:20.000Z","_content":"\n# Handler机制源码解析\n\n因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。\n\n## 1. Looper\n主要是loop()方法\n```java\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    for (;;) {\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            // 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中.\n            // 只有调用quit方法时,next()方法再能真正的返回null\n            return;\n        }\n        try {\n            // msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方\n            msg.target.dispatchMessage(msg);\n        } finally {\n            ... // 省略代码 \n        }\n        msg.recycleUnchecked();\n    }\n}\n```\n\n## 2. MessageQueue\n\n### 关键成员变量\n\n```java\n// mPtr是native的MessageQueue的指针\nprivate long mPtr; // used by native code\n// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个message\nMessage mMessages;\n\n\n// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作\nprivate final ArrayList<IdleHandler> mIdleHandlers = new ArrayList<IdleHandler>();\nprivate IdleHandler[] mPendingIdleHandlers;\n\nprivate SparseArray<FileDescriptorRecord> mFileDescriptorRecords;\nprivate boolean mQuitting;\n\n// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.\nprivate boolean mBlocked;\n\n// The next barrier token.\n// Barriers are indicated by messages with a null target whose arg1 field carries the token.\nprivate int mNextBarrierToken;\n```\n\n### 构造方法\n```java\nMessageQueue(boolean quitAllowed) {\n    mQuitAllowed = quitAllowed;\n    mPtr = nativeInit();\n}\n```\n\n### next()方法\n\n```java\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        // 调用native层的方法,使用epoll机制,挂起当前线程. \n        // nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            // 获取链表的头结点,即第一个message\n            Message msg = mMessages;\n            // 判断msg是否为同步栅栏\n            // 表示同步栅栏的msg, 其msg.target为null\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                // 寻找队列中第一个异步message\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                if (now < msg.when) {\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // 因为上面一旦找到msg,直接return,所以执行到这里已经msg一定为null\n            // msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到\n\n            // Process the quit message now that all pending messages have been handled.\n            // 判断是否需要结束循环\n            if (mQuitting) {\n                // dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0\n                // 只有在这里next()方法才会返回null\n                dispose();\n                return null;\n            }\n\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            // 当获取到的message为空, 或者message的执行时间没有到\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                // 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis\n                mBlocked = true;\n                continue;\n            }\n\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        // 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(TAG, \"IdleHandler threw exception\", t);\n            }\n\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n\n#### 1. nativePollOnce(ptr, nextPollTimeoutMillis);\n这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间. \n**特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.** \nnextPollTimeoutMillis = -1 出现的时机两种情况:\n* 消息队列为空\n* 遇到了同步barrier, 并且之后没有遇到异步的msg\n\n#### 2. IdleHandler:\n```java\npublic static interface IdleHandler {\n    /**\n        * Called when the message queue has run out of messages and will now\n        * wait for more.  Return true to keep your idle handler active, false\n        * to have it removed.  This may be called if there are still messages\n        * pending in the queue, but they are all scheduled to be dispatched\n        * after the current time.\n        */\n        // queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次\n    boolean queueIdle();\n}\n```\nMessageQueue中有两个IdleHandler的集合, IdleHandler是一个接, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到)\n\n#### 3. 同步栅栏 Barrier\n\n* 定义: target为null的msg为同步栅栏\n* 作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg\n* 意义: 相当于为msg添加了一个优先级\n\n### quit()\n\n```java\nvoid quit(boolean safe) {\n    synchronized (this) {\n        if (mQuitting) {\n            return;\n        }\n        mQuitting = true;\n\n        if (safe) {\n            // 这个方法会去除所有的msg.when > now 的msg\n            removeAllFutureMessagesLocked();\n        } else {\n            // 没有任何判断, 直接去除所有的msg\n            removeAllMessagesLocked();\n        }\n\n        // We can assume mPtr != 0 because mQuitting was previously false.\n        // 因为在next()方法中才会调用dispose()方法销毁消息队\n        // 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法\n        nativeWake(mPtr);\n    }\n}\n```\n\n### enqueueMessage\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    ... // 省略代码\n\n    synchronized (this) {\n        if (mQuitting) {\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            // New head, wake up the event queue if blocked.\n            // 添加到队列头部, 有可能是需要wake的\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // Inserted within the middle of the queue.  Usually we don't have to wake\n            // up the event queue unless there is a barrier at the head of the queue\n            // and the message is the earliest asynchronous message in the queue.\n            // 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n\n```\n\n#### **1. 插入顺序:**\n之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序\n\n#### **2. needWake**\n判断是否需要唤醒线程. \n在以下情况下, needWake会为true:\n* 消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1\n* 消息队列不为空, 并且当前线程是blocked的, 新插入msg.when < 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg\n* 消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1\n\n","source":"_posts/Android/源码解析/handler机制源码解析.md","raw":"---\ntitle: handler机制源码解析\ndate: 2019-11-09 13:59:20\ntags:\n- Handler\n- 源码解析\ncategories: \n- Android\n---\n\n# Handler机制源码解析\n\n因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。\n\n## 1. Looper\n主要是loop()方法\n```java\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    for (;;) {\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            // 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中.\n            // 只有调用quit方法时,next()方法再能真正的返回null\n            return;\n        }\n        try {\n            // msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方\n            msg.target.dispatchMessage(msg);\n        } finally {\n            ... // 省略代码 \n        }\n        msg.recycleUnchecked();\n    }\n}\n```\n\n## 2. MessageQueue\n\n### 关键成员变量\n\n```java\n// mPtr是native的MessageQueue的指针\nprivate long mPtr; // used by native code\n// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个message\nMessage mMessages;\n\n\n// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作\nprivate final ArrayList<IdleHandler> mIdleHandlers = new ArrayList<IdleHandler>();\nprivate IdleHandler[] mPendingIdleHandlers;\n\nprivate SparseArray<FileDescriptorRecord> mFileDescriptorRecords;\nprivate boolean mQuitting;\n\n// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.\nprivate boolean mBlocked;\n\n// The next barrier token.\n// Barriers are indicated by messages with a null target whose arg1 field carries the token.\nprivate int mNextBarrierToken;\n```\n\n### 构造方法\n```java\nMessageQueue(boolean quitAllowed) {\n    mQuitAllowed = quitAllowed;\n    mPtr = nativeInit();\n}\n```\n\n### next()方法\n\n```java\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        // 调用native层的方法,使用epoll机制,挂起当前线程. \n        // nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            // 获取链表的头结点,即第一个message\n            Message msg = mMessages;\n            // 判断msg是否为同步栅栏\n            // 表示同步栅栏的msg, 其msg.target为null\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                // 寻找队列中第一个异步message\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                if (now < msg.when) {\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // 因为上面一旦找到msg,直接return,所以执行到这里已经msg一定为null\n            // msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到\n\n            // Process the quit message now that all pending messages have been handled.\n            // 判断是否需要结束循环\n            if (mQuitting) {\n                // dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0\n                // 只有在这里next()方法才会返回null\n                dispose();\n                return null;\n            }\n\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            // 当获取到的message为空, 或者message的执行时间没有到\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                // 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis\n                mBlocked = true;\n                continue;\n            }\n\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        // 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(TAG, \"IdleHandler threw exception\", t);\n            }\n\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n\n#### 1. nativePollOnce(ptr, nextPollTimeoutMillis);\n这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间. \n**特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.** \nnextPollTimeoutMillis = -1 出现的时机两种情况:\n* 消息队列为空\n* 遇到了同步barrier, 并且之后没有遇到异步的msg\n\n#### 2. IdleHandler:\n```java\npublic static interface IdleHandler {\n    /**\n        * Called when the message queue has run out of messages and will now\n        * wait for more.  Return true to keep your idle handler active, false\n        * to have it removed.  This may be called if there are still messages\n        * pending in the queue, but they are all scheduled to be dispatched\n        * after the current time.\n        */\n        // queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次\n    boolean queueIdle();\n}\n```\nMessageQueue中有两个IdleHandler的集合, IdleHandler是一个接, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到)\n\n#### 3. 同步栅栏 Barrier\n\n* 定义: target为null的msg为同步栅栏\n* 作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg\n* 意义: 相当于为msg添加了一个优先级\n\n### quit()\n\n```java\nvoid quit(boolean safe) {\n    synchronized (this) {\n        if (mQuitting) {\n            return;\n        }\n        mQuitting = true;\n\n        if (safe) {\n            // 这个方法会去除所有的msg.when > now 的msg\n            removeAllFutureMessagesLocked();\n        } else {\n            // 没有任何判断, 直接去除所有的msg\n            removeAllMessagesLocked();\n        }\n\n        // We can assume mPtr != 0 because mQuitting was previously false.\n        // 因为在next()方法中才会调用dispose()方法销毁消息队\n        // 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法\n        nativeWake(mPtr);\n    }\n}\n```\n\n### enqueueMessage\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    ... // 省略代码\n\n    synchronized (this) {\n        if (mQuitting) {\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            // New head, wake up the event queue if blocked.\n            // 添加到队列头部, 有可能是需要wake的\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // Inserted within the middle of the queue.  Usually we don't have to wake\n            // up the event queue unless there is a barrier at the head of the queue\n            // and the message is the earliest asynchronous message in the queue.\n            // 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n\n```\n\n#### **1. 插入顺序:**\n之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序\n\n#### **2. needWake**\n判断是否需要唤醒线程. \n在以下情况下, needWake会为true:\n* 消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1\n* 消息队列不为空, 并且当前线程是blocked的, 新插入msg.when < 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg\n* 消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1\n\n","slug":"Android/源码解析/handler机制源码解析","published":1,"updated":"2019-12-21T12:16:41.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraksc00568mzmvd69htc3","content":"<h1 id=\"Handler机制源码解析\"><a href=\"#Handler机制源码解析\" class=\"headerlink\" title=\"Handler机制源码解析\"></a>Handler机制源码解析</h1><p>因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。</p><a id=\"more\"></a>\n<h2 id=\"1-Looper\"><a href=\"#1-Looper\" class=\"headerlink\" title=\"1. Looper\"></a>1. Looper</h2><p>主要是loop()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></span><br><span class=\"line\">            <span class=\"comment\">// 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中.</span></span><br><span class=\"line\">            <span class=\"comment\">// 只有调用quit方法时,next()方法再能真正的返回null</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            ... <span class=\"comment\">// 省略代码 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-MessageQueue\"><a href=\"#2-MessageQueue\" class=\"headerlink\" title=\"2. MessageQueue\"></a>2. MessageQueue</h2><h3 id=\"关键成员变量\"><a href=\"#关键成员变量\" class=\"headerlink\" title=\"关键成员变量\"></a>关键成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mPtr是native的MessageQueue的指针</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mPtr; <span class=\"comment\">// used by native code</span></span><br><span class=\"line\"><span class=\"comment\">// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个message</span></span><br><span class=\"line\">Message mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class=\"keyword\">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mQuitting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mBlocked;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The next barrier token.</span></span><br><span class=\"line\"><span class=\"comment\">// Barriers are indicated by messages with a null target whose arg1 field carries the token.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mNextBarrierToken;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123;</span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    mPtr = nativeInit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"next-方法\"><a href=\"#next-方法\" class=\"headerlink\" title=\"next()方法\"></a>next()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Return here if the message loop has already quit and been disposed.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can happen if the application tries to restart a looper after quit</span></span><br><span class=\"line\">    <span class=\"comment\">// which is not supported.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用native层的方法,使用epoll机制,挂起当前线程. </span></span><br><span class=\"line\">        <span class=\"comment\">// nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 获取链表的头结点,即第一个message</span></span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\">            <span class=\"comment\">// 判断msg是否为同步栅栏</span></span><br><span class=\"line\">            <span class=\"comment\">// 表示同步栅栏的msg, 其msg.target为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\">                <span class=\"comment\">// 寻找队列中第一个异步message</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 因为上面一旦找到msg,直接return,所以执行到这里已经msg一定为null</span></span><br><span class=\"line\">            <span class=\"comment\">// msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">            <span class=\"comment\">// 判断是否需要结束循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0</span></span><br><span class=\"line\">                <span class=\"comment\">// 只有在这里next()方法才会返回null</span></span><br><span class=\"line\">                dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If first time idle, then get the number of idlers to run.</span></span><br><span class=\"line\">            <span class=\"comment\">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class=\"line\">            <span class=\"comment\">// 当获取到的message为空, 或者message的执行时间没有到</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">                <span class=\"comment\">// 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis</span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.</span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration.</span></span><br><span class=\"line\">        <span class=\"comment\">// 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>; <span class=\"comment\">// release the reference to the handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                keep = idler.queueIdle();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// While calling an idle handler, a new message could have been delivered</span></span><br><span class=\"line\">        <span class=\"comment\">// so go back and look again for a pending message without waiting.</span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-nativePollOnce-ptr-nextPollTimeoutMillis\"><a href=\"#1-nativePollOnce-ptr-nextPollTimeoutMillis\" class=\"headerlink\" title=\"1. nativePollOnce(ptr, nextPollTimeoutMillis);\"></a>1. nativePollOnce(ptr, nextPollTimeoutMillis);</h4><p>这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间.<br><strong>特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.</strong><br>nextPollTimeoutMillis = -1 出现的时机两种情况:</p>\n<ul>\n<li>消息队列为空</li>\n<li>遇到了同步barrier, 并且之后没有遇到异步的msg</li>\n</ul>\n<h4 id=\"2-IdleHandler\"><a href=\"#2-IdleHandler\" class=\"headerlink\" title=\"2. IdleHandler:\"></a>2. IdleHandler:</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IdleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Called when the message queue has run out of messages and will now</span></span><br><span class=\"line\"><span class=\"comment\">        * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class=\"line\"><span class=\"comment\">        * to have it removed.  This may be called if there are still messages</span></span><br><span class=\"line\"><span class=\"comment\">        * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class=\"line\"><span class=\"comment\">        * after the current time.</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"comment\">// queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue中有两个IdleHandler的集合, IdleHandler是一个接, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到)</p>\n<h4 id=\"3-同步栅栏-Barrier\"><a href=\"#3-同步栅栏-Barrier\" class=\"headerlink\" title=\"3. 同步栅栏 Barrier\"></a>3. 同步栅栏 Barrier</h4><ul>\n<li>定义: target为null的msg为同步栅栏</li>\n<li>作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg</li>\n<li>意义: 相当于为msg添加了一个优先级</li>\n</ul>\n<h3 id=\"quit\"><a href=\"#quit\" class=\"headerlink\" title=\"quit()\"></a>quit()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">(<span class=\"keyword\">boolean</span> safe)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mQuitting = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (safe) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个方法会去除所有的msg.when &gt; now 的msg</span></span><br><span class=\"line\">            removeAllFutureMessagesLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有任何判断, 直接去除所有的msg</span></span><br><span class=\"line\">            removeAllMessagesLocked();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为在next()方法中才会调用dispose()方法销毁消息队</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法</span></span><br><span class=\"line\">        nativeWake(mPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"enqueueMessage\"><a href=\"#enqueueMessage\" class=\"headerlink\" title=\"enqueueMessage\"></a>enqueueMessage</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// New head, wake up the event queue if blocked.</span></span><br><span class=\"line\">            <span class=\"comment\">// 添加到队列头部, 有可能是需要wake的</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class=\"line\">            <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class=\"line\">            <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class=\"line\">            <span class=\"comment\">// 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-插入顺序\"><a href=\"#1-插入顺序\" class=\"headerlink\" title=\"1. 插入顺序:\"></a><strong>1. 插入顺序:</strong></h4><p>之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序</p>\n<h4 id=\"2-needWake\"><a href=\"#2-needWake\" class=\"headerlink\" title=\"2. needWake\"></a><strong>2. needWake</strong></h4><p>判断是否需要唤醒线程.<br>在以下情况下, needWake会为true:</p>\n<ul>\n<li>消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1</li>\n<li>消息队列不为空, 并且当前线程是blocked的, 新插入msg.when &lt; 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg</li>\n<li>消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Handler机制源码解析\"><a href=\"#Handler机制源码解析\" class=\"headerlink\" title=\"Handler机制源码解析\"></a>Handler机制源码解析</h1><p>因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。</p>","more":"\n<h2 id=\"1-Looper\"><a href=\"#1-Looper\" class=\"headerlink\" title=\"1. Looper\"></a>1. Looper</h2><p>主要是loop()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></span><br><span class=\"line\">            <span class=\"comment\">// 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中.</span></span><br><span class=\"line\">            <span class=\"comment\">// 只有调用quit方法时,next()方法再能真正的返回null</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            ... <span class=\"comment\">// 省略代码 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-MessageQueue\"><a href=\"#2-MessageQueue\" class=\"headerlink\" title=\"2. MessageQueue\"></a>2. MessageQueue</h2><h3 id=\"关键成员变量\"><a href=\"#关键成员变量\" class=\"headerlink\" title=\"关键成员变量\"></a>关键成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mPtr是native的MessageQueue的指针</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mPtr; <span class=\"comment\">// used by native code</span></span><br><span class=\"line\"><span class=\"comment\">// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个message</span></span><br><span class=\"line\">Message mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class=\"keyword\">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mQuitting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mBlocked;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The next barrier token.</span></span><br><span class=\"line\"><span class=\"comment\">// Barriers are indicated by messages with a null target whose arg1 field carries the token.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mNextBarrierToken;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123;</span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    mPtr = nativeInit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"next-方法\"><a href=\"#next-方法\" class=\"headerlink\" title=\"next()方法\"></a>next()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Return here if the message loop has already quit and been disposed.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can happen if the application tries to restart a looper after quit</span></span><br><span class=\"line\">    <span class=\"comment\">// which is not supported.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用native层的方法,使用epoll机制,挂起当前线程. </span></span><br><span class=\"line\">        <span class=\"comment\">// nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 获取链表的头结点,即第一个message</span></span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\">            <span class=\"comment\">// 判断msg是否为同步栅栏</span></span><br><span class=\"line\">            <span class=\"comment\">// 表示同步栅栏的msg, 其msg.target为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\">                <span class=\"comment\">// 寻找队列中第一个异步message</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 因为上面一旦找到msg,直接return,所以执行到这里已经msg一定为null</span></span><br><span class=\"line\">            <span class=\"comment\">// msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">            <span class=\"comment\">// 判断是否需要结束循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0</span></span><br><span class=\"line\">                <span class=\"comment\">// 只有在这里next()方法才会返回null</span></span><br><span class=\"line\">                dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If first time idle, then get the number of idlers to run.</span></span><br><span class=\"line\">            <span class=\"comment\">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class=\"line\">            <span class=\"comment\">// 当获取到的message为空, 或者message的执行时间没有到</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">                <span class=\"comment\">// 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis</span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.</span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration.</span></span><br><span class=\"line\">        <span class=\"comment\">// 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>; <span class=\"comment\">// release the reference to the handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                keep = idler.queueIdle();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// While calling an idle handler, a new message could have been delivered</span></span><br><span class=\"line\">        <span class=\"comment\">// so go back and look again for a pending message without waiting.</span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-nativePollOnce-ptr-nextPollTimeoutMillis\"><a href=\"#1-nativePollOnce-ptr-nextPollTimeoutMillis\" class=\"headerlink\" title=\"1. nativePollOnce(ptr, nextPollTimeoutMillis);\"></a>1. nativePollOnce(ptr, nextPollTimeoutMillis);</h4><p>这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间.<br><strong>特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.</strong><br>nextPollTimeoutMillis = -1 出现的时机两种情况:</p>\n<ul>\n<li>消息队列为空</li>\n<li>遇到了同步barrier, 并且之后没有遇到异步的msg</li>\n</ul>\n<h4 id=\"2-IdleHandler\"><a href=\"#2-IdleHandler\" class=\"headerlink\" title=\"2. IdleHandler:\"></a>2. IdleHandler:</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IdleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Called when the message queue has run out of messages and will now</span></span><br><span class=\"line\"><span class=\"comment\">        * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class=\"line\"><span class=\"comment\">        * to have it removed.  This may be called if there are still messages</span></span><br><span class=\"line\"><span class=\"comment\">        * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class=\"line\"><span class=\"comment\">        * after the current time.</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"comment\">// queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue中有两个IdleHandler的集合, IdleHandler是一个接, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到)</p>\n<h4 id=\"3-同步栅栏-Barrier\"><a href=\"#3-同步栅栏-Barrier\" class=\"headerlink\" title=\"3. 同步栅栏 Barrier\"></a>3. 同步栅栏 Barrier</h4><ul>\n<li>定义: target为null的msg为同步栅栏</li>\n<li>作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg</li>\n<li>意义: 相当于为msg添加了一个优先级</li>\n</ul>\n<h3 id=\"quit\"><a href=\"#quit\" class=\"headerlink\" title=\"quit()\"></a>quit()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">(<span class=\"keyword\">boolean</span> safe)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mQuitting = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (safe) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个方法会去除所有的msg.when &gt; now 的msg</span></span><br><span class=\"line\">            removeAllFutureMessagesLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有任何判断, 直接去除所有的msg</span></span><br><span class=\"line\">            removeAllMessagesLocked();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为在next()方法中才会调用dispose()方法销毁消息队</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法</span></span><br><span class=\"line\">        nativeWake(mPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"enqueueMessage\"><a href=\"#enqueueMessage\" class=\"headerlink\" title=\"enqueueMessage\"></a>enqueueMessage</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// New head, wake up the event queue if blocked.</span></span><br><span class=\"line\">            <span class=\"comment\">// 添加到队列头部, 有可能是需要wake的</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class=\"line\">            <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class=\"line\">            <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class=\"line\">            <span class=\"comment\">// 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-插入顺序\"><a href=\"#1-插入顺序\" class=\"headerlink\" title=\"1. 插入顺序:\"></a><strong>1. 插入顺序:</strong></h4><p>之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序</p>\n<h4 id=\"2-needWake\"><a href=\"#2-needWake\" class=\"headerlink\" title=\"2. needWake\"></a><strong>2. needWake</strong></h4><p>判断是否需要唤醒线程.<br>在以下情况下, needWake会为true:</p>\n<ul>\n<li>消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1</li>\n<li>消息队列不为空, 并且当前线程是blocked的, 新插入msg.when &lt; 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg</li>\n<li>消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1</li>\n</ul>\n"},{"title":"OkHttp3源码-发起请求的主要流程","date":"2019-11-13T13:21:04.000Z","_content":"\n# OkHttp3源码解析-发起请求的主要流程\n\n结合网上的博客和自己看的源码, 写的简单理解.\n\n## 主要的类:\n* OkHttpClient:\n    用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等\n* Request:\n    用户对单次请求的数据进行配置, uur, 数据参数等. \n* Call:\n    在框架内部表示对请求的封装\n* Dispatcher:\n    在框架内部对请求进行分发\n\n## OkHttpClient:\n\n主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用.\n\n```java\n/**\n* Prepares the {@code request} to be executed at some point in the future.\n*/\n@Override public Call newCall(Request request) {\n    return RealCall.newRealCall(this, request, false /* for web socket */);\n}\n```\n\n## Call:\n\n### 构造方法\n```java\n  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    this.client = client;\n    this.originalRequest = originalRequest;\n    this.forWebSocket = forWebSocket;\n    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);\n    this.timeout = new AsyncTimeout() {\n      @Override protected void timedOut() {\n        cancel();\n      }\n    };\n    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);\n  }\n\n  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    // Safely publish the Call instance to the EventListener.\n    RealCall call = new RealCall(client, originalRequest, forWebSocket);\n    call.eventListener = client.eventListenerFactory().create(call);\n    return call;\n  }\n```\n\n### 同步执行一个call\n\n在RealCall中有一个execute方法, 这里发起一个同步请求\n```java\n  @Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    timeout.enter();\n    eventListener.callStart(this);\n    try {\n      client.dispatcher().executed(this);\n      // getResponseWithInterceptorChain()是具体的请求的操作过程\n      Response result = getResponseWithInterceptorChain();\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } catch (IOException e) {\n      e = timeoutExit(e);\n      eventListener.callFailed(this, e);\n      throw e;\n    } finally {\n      client.dispatcher().finished(this);\n    }\n  }\n```\n\n**getResponseWithInterceptorChain()方法是请求发出的最终执行方法.** 也就是说RealCall中调用execute()就已经直接同步开始了请求操作.\n\n但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? \n\n详细的内容可以看Dispatcher的源码解析.\n\n### 异步执行一个call\n\nRealCall中的enqueue方法, 发起一个异步请求\n```java\n  @Override public void enqueue(Callback responseCallback) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    eventListener.callStart(this);\n    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n```\n可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类\n\n**AsyncCall中的executeOn, execute**\n```java\n/**\n* Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up\n* if the executor has been shut down by reporting the call as failed.\n*/\nvoid executeOn(ExecutorService executorService) {\n      assert (!Thread.holdsLock(client.dispatcher()));\n      boolean success = false;\n      try {\n        executorService.execute(this);\n        success = true;\n      } catch (RejectedExecutionException e) {\n        InterruptedIOException ioException = new InterruptedIOException(\"executor rejected\");\n        ioException.initCause(e);\n        eventListener.callFailed(RealCall.this, ioException);\n        responseCallback.onFailure(RealCall.this, ioException);\n      } finally {\n        if (!success) {\n          client.dispatcher().finished(this); // This call is no longer running!\n        }\n      }\n    }\n\n@Override protected void execute() {\n  boolean signalledCallback = false;\n  timeout.enter();\n  try {\n    Response response = getResponseWithInterceptorChain();\n    signalledCallback = true;\n    responseCallback.onResponse(RealCall.this, response);\n  } catch (IOException e) {\n    e = timeoutExit(e);\n    if (signalledCallback) {\n      // Do not signal the callback twice!\n      Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n    } else {\n      eventListener.callFailed(RealCall.this, e);\n      responseCallback.onFailure(RealCall.this, e);\n    }\n  } finally {\n    client.dispatcher().finished(this);\n  }\n}\n```\n再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行.\n\n\n## Dispatcher\n\n### 重要的成员变量\n\n```java\n  private int maxRequests = 64;\n  private int maxRequestsPerHost = 5;\n  private @Nullable Runnable idleCallback;\n\n  /** Executes calls. Created lazily. */\n  // 这是一个线程池, 并且实现了懒加载\n  private @Nullable ExecutorService executorService;\n\n  /** Ready async calls in the order they'll be run. */\n  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n\n  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\n  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n```\n\n**为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:**\n答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列.\n\n### ExcutorService\n\n```java\npublic synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n    }\n    return executorService;\n}\n```\n\n这个线程池其实是一个CacheThreadPool. 他的特点是: \n* 底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)\n* 通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。\n* 适用：执行很多短期异步的小程序或者负载较轻的服务器\n\n检查调用executorService()方法的地方, 是一个promoteAndExecute()方法\n\n### enqueue(AsyncCall call)\n\n```java\nvoid enqueue(AsyncCall call) {\n    synchronized (this) {\n      readyAsyncCalls.add(call);\n    }\n    promoteAndExecute();\n}\n```\n上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步\n\n### promoteAndExecute()\n\n```java\n\n  /**\n   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs\n   * them on the executor service. Must not be called with synchronization because executing calls\n   * can call into user code.\n   *\n   * @return true if the dispatcher is currently running calls.\n   */\n  // 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call\n  // 如果成功执行上面的操作, 返回true\n  private boolean promoteAndExecute() {\n    assert (!Thread.holdsLock(this));\n\n    List<AsyncCall> executableCalls = new ArrayList<>();\n    boolean isRunning;\n    synchronized (this) {\n      // 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去\n      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n        AsyncCall asyncCall = i.next();\n\n        // 到达了max限制, break\n        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.\n        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.\n\n        i.remove();\n        executableCalls.add(asyncCall);\n        runningAsyncCalls.add(asyncCall);\n      }\n      isRunning = runningCallsCount() > 0;\n    }\n\n\n    for (int i = 0, size = executableCalls.size(); i < size; i++) {\n      AsyncCall asyncCall = executableCalls.get(i);\n      // 在线程池中执行这个call\n      asyncCall.executeOn(executorService());\n    }\n\n    return isRunning;\n  }\n```\n\npromoteAndExecute()方法的解析直接看上面源码的注释. \n\n结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行. \n想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢? \n想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法\n\n### finished(Deque<T> calls, T call)\n\n```java\nprivate <T> void finished(Deque<T> calls, T call) {\n    Runnable idleCallback;\n    synchronized (this) {\n        if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\");\n        idleCallback = this.idleCallback;\n    }\n\n    boolean isRunning = promoteAndExecute();\n\n    if (!isRunning && idleCallback != null) {\n        idleCallback.run();\n    }\n}\n```\n在RealCall和AsyncCall代码中, 能看到同样调用了despatcher.finished方法\n\n### 同步的call\n\n```java\n/** Used by {@code Call#execute} to signal it is in-flight. */\nsynchronized void executed(RealCall call) {\n    runningSyncCalls.add(call);\n}\n```\n\n同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已. \n\n\n\n\n\n\n\n","source":"_posts/Android/源码解析/OkHttp3源码-发起请求的主要流程.md","raw":"---\ntitle: OkHttp3源码-发起请求的主要流程\ndate: 2019-11-13 21:21:04\ntags:\n- Okhttp3\n- 源码解析\ncategories:\n- Android\n---\n\n# OkHttp3源码解析-发起请求的主要流程\n\n结合网上的博客和自己看的源码, 写的简单理解.\n\n## 主要的类:\n* OkHttpClient:\n    用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等\n* Request:\n    用户对单次请求的数据进行配置, uur, 数据参数等. \n* Call:\n    在框架内部表示对请求的封装\n* Dispatcher:\n    在框架内部对请求进行分发\n\n## OkHttpClient:\n\n主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用.\n\n```java\n/**\n* Prepares the {@code request} to be executed at some point in the future.\n*/\n@Override public Call newCall(Request request) {\n    return RealCall.newRealCall(this, request, false /* for web socket */);\n}\n```\n\n## Call:\n\n### 构造方法\n```java\n  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    this.client = client;\n    this.originalRequest = originalRequest;\n    this.forWebSocket = forWebSocket;\n    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);\n    this.timeout = new AsyncTimeout() {\n      @Override protected void timedOut() {\n        cancel();\n      }\n    };\n    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);\n  }\n\n  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    // Safely publish the Call instance to the EventListener.\n    RealCall call = new RealCall(client, originalRequest, forWebSocket);\n    call.eventListener = client.eventListenerFactory().create(call);\n    return call;\n  }\n```\n\n### 同步执行一个call\n\n在RealCall中有一个execute方法, 这里发起一个同步请求\n```java\n  @Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    timeout.enter();\n    eventListener.callStart(this);\n    try {\n      client.dispatcher().executed(this);\n      // getResponseWithInterceptorChain()是具体的请求的操作过程\n      Response result = getResponseWithInterceptorChain();\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } catch (IOException e) {\n      e = timeoutExit(e);\n      eventListener.callFailed(this, e);\n      throw e;\n    } finally {\n      client.dispatcher().finished(this);\n    }\n  }\n```\n\n**getResponseWithInterceptorChain()方法是请求发出的最终执行方法.** 也就是说RealCall中调用execute()就已经直接同步开始了请求操作.\n\n但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? \n\n详细的内容可以看Dispatcher的源码解析.\n\n### 异步执行一个call\n\nRealCall中的enqueue方法, 发起一个异步请求\n```java\n  @Override public void enqueue(Callback responseCallback) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    eventListener.callStart(this);\n    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n```\n可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类\n\n**AsyncCall中的executeOn, execute**\n```java\n/**\n* Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up\n* if the executor has been shut down by reporting the call as failed.\n*/\nvoid executeOn(ExecutorService executorService) {\n      assert (!Thread.holdsLock(client.dispatcher()));\n      boolean success = false;\n      try {\n        executorService.execute(this);\n        success = true;\n      } catch (RejectedExecutionException e) {\n        InterruptedIOException ioException = new InterruptedIOException(\"executor rejected\");\n        ioException.initCause(e);\n        eventListener.callFailed(RealCall.this, ioException);\n        responseCallback.onFailure(RealCall.this, ioException);\n      } finally {\n        if (!success) {\n          client.dispatcher().finished(this); // This call is no longer running!\n        }\n      }\n    }\n\n@Override protected void execute() {\n  boolean signalledCallback = false;\n  timeout.enter();\n  try {\n    Response response = getResponseWithInterceptorChain();\n    signalledCallback = true;\n    responseCallback.onResponse(RealCall.this, response);\n  } catch (IOException e) {\n    e = timeoutExit(e);\n    if (signalledCallback) {\n      // Do not signal the callback twice!\n      Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n    } else {\n      eventListener.callFailed(RealCall.this, e);\n      responseCallback.onFailure(RealCall.this, e);\n    }\n  } finally {\n    client.dispatcher().finished(this);\n  }\n}\n```\n再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行.\n\n\n## Dispatcher\n\n### 重要的成员变量\n\n```java\n  private int maxRequests = 64;\n  private int maxRequestsPerHost = 5;\n  private @Nullable Runnable idleCallback;\n\n  /** Executes calls. Created lazily. */\n  // 这是一个线程池, 并且实现了懒加载\n  private @Nullable ExecutorService executorService;\n\n  /** Ready async calls in the order they'll be run. */\n  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n\n  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\n  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n```\n\n**为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:**\n答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列.\n\n### ExcutorService\n\n```java\npublic synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n    }\n    return executorService;\n}\n```\n\n这个线程池其实是一个CacheThreadPool. 他的特点是: \n* 底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)\n* 通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。\n* 适用：执行很多短期异步的小程序或者负载较轻的服务器\n\n检查调用executorService()方法的地方, 是一个promoteAndExecute()方法\n\n### enqueue(AsyncCall call)\n\n```java\nvoid enqueue(AsyncCall call) {\n    synchronized (this) {\n      readyAsyncCalls.add(call);\n    }\n    promoteAndExecute();\n}\n```\n上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步\n\n### promoteAndExecute()\n\n```java\n\n  /**\n   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs\n   * them on the executor service. Must not be called with synchronization because executing calls\n   * can call into user code.\n   *\n   * @return true if the dispatcher is currently running calls.\n   */\n  // 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call\n  // 如果成功执行上面的操作, 返回true\n  private boolean promoteAndExecute() {\n    assert (!Thread.holdsLock(this));\n\n    List<AsyncCall> executableCalls = new ArrayList<>();\n    boolean isRunning;\n    synchronized (this) {\n      // 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去\n      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n        AsyncCall asyncCall = i.next();\n\n        // 到达了max限制, break\n        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.\n        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.\n\n        i.remove();\n        executableCalls.add(asyncCall);\n        runningAsyncCalls.add(asyncCall);\n      }\n      isRunning = runningCallsCount() > 0;\n    }\n\n\n    for (int i = 0, size = executableCalls.size(); i < size; i++) {\n      AsyncCall asyncCall = executableCalls.get(i);\n      // 在线程池中执行这个call\n      asyncCall.executeOn(executorService());\n    }\n\n    return isRunning;\n  }\n```\n\npromoteAndExecute()方法的解析直接看上面源码的注释. \n\n结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行. \n想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢? \n想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法\n\n### finished(Deque<T> calls, T call)\n\n```java\nprivate <T> void finished(Deque<T> calls, T call) {\n    Runnable idleCallback;\n    synchronized (this) {\n        if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\");\n        idleCallback = this.idleCallback;\n    }\n\n    boolean isRunning = promoteAndExecute();\n\n    if (!isRunning && idleCallback != null) {\n        idleCallback.run();\n    }\n}\n```\n在RealCall和AsyncCall代码中, 能看到同样调用了despatcher.finished方法\n\n### 同步的call\n\n```java\n/** Used by {@code Call#execute} to signal it is in-flight. */\nsynchronized void executed(RealCall call) {\n    runningSyncCalls.add(call);\n}\n```\n\n同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已. \n\n\n\n\n\n\n\n","slug":"Android/源码解析/OkHttp3源码-发起请求的主要流程","published":1,"updated":"2019-12-21T12:16:41.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraksd00598mzm7r3qz8t7","content":"<h1 id=\"OkHttp3源码解析-发起请求的主要流程\"><a href=\"#OkHttp3源码解析-发起请求的主要流程\" class=\"headerlink\" title=\"OkHttp3源码解析-发起请求的主要流程\"></a>OkHttp3源码解析-发起请求的主要流程</h1><a id=\"more\"></a><p>结合网上的博客和自己看的源码, 写的简单理解.</p>\n<h2 id=\"主要的类\"><a href=\"#主要的类\" class=\"headerlink\" title=\"主要的类:\"></a>主要的类:</h2><ul>\n<li>OkHttpClient:<br>  用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等</li>\n<li>Request:<br>  用户对单次请求的数据进行配置, uur, 数据参数等. </li>\n<li>Call:<br>  在框架内部表示对请求的封装</li>\n<li>Dispatcher:<br>  在框架内部对请求进行分发</li>\n</ul>\n<h2 id=\"OkHttpClient\"><a href=\"#OkHttpClient\" class=\"headerlink\" title=\"OkHttpClient:\"></a>OkHttpClient:</h2><p>主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Prepares the &#123;<span class=\"doctag\">@code</span> request&#125; to be executed at some point in the future.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call <span class=\"title\">newCall</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RealCall.newRealCall(<span class=\"keyword\">this</span>, request, <span class=\"keyword\">false</span> <span class=\"comment\">/* for web socket */</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Call\"><a href=\"#Call\" class=\"headerlink\" title=\"Call:\"></a>Call:</h2><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">RealCall</span><span class=\"params\">(OkHttpClient client, Request originalRequest, <span class=\"keyword\">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.originalRequest = originalRequest;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.forWebSocket = forWebSocket;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.retryAndFollowUpInterceptor = <span class=\"keyword\">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout = <span class=\"keyword\">new</span> AsyncTimeout() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">timedOut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> RealCall <span class=\"title\">newRealCall</span><span class=\"params\">(OkHttpClient client, Request originalRequest, <span class=\"keyword\">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Safely publish the Call instance to the EventListener.</span></span><br><span class=\"line\">  RealCall call = <span class=\"keyword\">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class=\"line\">  call.eventListener = client.eventListenerFactory().create(call);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> call;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步执行一个call\"><a href=\"#同步执行一个call\" class=\"headerlink\" title=\"同步执行一个call\"></a>同步执行一个call</h3><p>在RealCall中有一个execute方法, 这里发起一个同步请求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">    executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  captureCallStackTrace();</span><br><span class=\"line\">  timeout.enter();</span><br><span class=\"line\">  eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    client.dispatcher().executed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">// getResponseWithInterceptorChain()是具体的请求的操作过程</span></span><br><span class=\"line\">    Response result = getResponseWithInterceptorChain();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e = timeoutExit(e);</span><br><span class=\"line\">    eventListener.callFailed(<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>getResponseWithInterceptorChain()方法是请求发出的最终执行方法.</strong> 也就是说RealCall中调用execute()就已经直接同步开始了请求操作.</p>\n<p>但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? </p>\n<p>详细的内容可以看Dispatcher的源码解析.</p>\n<h3 id=\"异步执行一个call\"><a href=\"#异步执行一个call\" class=\"headerlink\" title=\"异步执行一个call\"></a>异步执行一个call</h3><p>RealCall中的enqueue方法, 发起一个异步请求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Callback responseCallback)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">    executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  captureCallStackTrace();</span><br><span class=\"line\">  eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  client.dispatcher().enqueue(<span class=\"keyword\">new</span> AsyncCall(responseCallback));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类</p>\n<p><strong>AsyncCall中的executeOn, execute</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Attempt to enqueue this async call on &#123;<span class=\"doctag\">@code</span> executorService&#125;. This will attempt to clean up</span></span><br><span class=\"line\"><span class=\"comment\">* if the executor has been shut down by reporting the call as failed.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executeOn</span><span class=\"params\">(ExecutorService executorService)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        executorService.execute(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        success = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</span><br><span class=\"line\">        InterruptedIOException ioException = <span class=\"keyword\">new</span> InterruptedIOException(<span class=\"string\">\"executor rejected\"</span>);</span><br><span class=\"line\">        ioException.initCause(e);</span><br><span class=\"line\">        eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, ioException);</span><br><span class=\"line\">        responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, ioException);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">          client.dispatcher().finished(<span class=\"keyword\">this</span>); <span class=\"comment\">// This call is no longer running!</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> signalledCallback = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  timeout.enter();</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Response response = getResponseWithInterceptorChain();</span><br><span class=\"line\">    signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    responseCallback.onResponse(RealCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e = timeoutExit(e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (signalledCallback) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Do not signal the callback twice!</span></span><br><span class=\"line\">      Platform.get().log(INFO, <span class=\"string\">\"Callback failure for \"</span> + toLoggableString(), e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">      responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行.</p>\n<h2 id=\"Dispatcher\"><a href=\"#Dispatcher\" class=\"headerlink\" title=\"Dispatcher\"></a>Dispatcher</h2><h3 id=\"重要的成员变量\"><a href=\"#重要的成员变量\" class=\"headerlink\" title=\"重要的成员变量\"></a>重要的成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequests = <span class=\"number\">64</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequestsPerHost = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> Runnable idleCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Executes calls. Created lazily. */</span></span><br><span class=\"line\"><span class=\"comment\">// 这是一个线程池, 并且实现了懒加载</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> ExecutorService executorService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Ready async calls in the order they'll be run. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p><strong>为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:</strong><br>答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列.</p>\n<h3 id=\"ExcutorService\"><a href=\"#ExcutorService\" class=\"headerlink\" title=\"ExcutorService\"></a>ExcutorService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> ExecutorService <span class=\"title\">executorService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executorService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      executorService = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE, <span class=\"number\">60</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">          <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class=\"string\">\"OkHttp Dispatcher\"</span>, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executorService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个线程池其实是一个CacheThreadPool. 他的特点是: </p>\n<ul>\n<li>底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</li>\n<li>通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</li>\n<li>适用：执行很多短期异步的小程序或者负载较轻的服务器</li>\n</ul>\n<p>检查调用executorService()方法的地方, 是一个promoteAndExecute()方法</p>\n<h3 id=\"enqueue-AsyncCall-call\"><a href=\"#enqueue-AsyncCall-call\" class=\"headerlink\" title=\"enqueue(AsyncCall call)\"></a>enqueue(AsyncCall call)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(AsyncCall call)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      readyAsyncCalls.add(call);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    promoteAndExecute();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步</p>\n<h3 id=\"promoteAndExecute\"><a href=\"#promoteAndExecute\" class=\"headerlink\" title=\"promoteAndExecute()\"></a>promoteAndExecute()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Promotes eligible calls from &#123;<span class=\"doctag\">@link</span> #readyAsyncCalls&#125; to &#123;<span class=\"doctag\">@link</span> #runningAsyncCalls&#125; and runs</span></span><br><span class=\"line\"><span class=\"comment\"> * them on the executor service. Must not be called with synchronization because executing calls</span></span><br><span class=\"line\"><span class=\"comment\"> * can call into user code.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if the dispatcher is currently running calls.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call</span></span><br><span class=\"line\"><span class=\"comment\">// 如果成功执行上面的操作, 返回true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">promoteAndExecute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (!Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  List&lt;AsyncCall&gt; executableCalls = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> isRunning;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">      AsyncCall asyncCall = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 到达了max限制, break</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class=\"keyword\">break</span>; <span class=\"comment\">// Max capacity.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class=\"keyword\">continue</span>; <span class=\"comment\">// Host max capacity.</span></span><br><span class=\"line\"></span><br><span class=\"line\">      i.remove();</span><br><span class=\"line\">      executableCalls.add(asyncCall);</span><br><span class=\"line\">      runningAsyncCalls.add(asyncCall);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    isRunning = runningCallsCount() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">    AsyncCall asyncCall = executableCalls.get(i);</span><br><span class=\"line\">    <span class=\"comment\">// 在线程池中执行这个call</span></span><br><span class=\"line\">    asyncCall.executeOn(executorService());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> isRunning;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>promoteAndExecute()方法的解析直接看上面源码的注释. </p>\n<p>结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行.<br>想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢?<br>想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法</p>\n<h3 id=\"finished-Deque-calls-T-call\"><a href=\"#finished-Deque-calls-T-call\" class=\"headerlink\" title=\"finished(Deque calls, T call)\"></a>finished(Deque<t> calls, T call)</t></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class=\"line\">    Runnable idleCallback;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!calls.remove(call)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Call wasn't in-flight!\"</span>);</span><br><span class=\"line\">        idleCallback = <span class=\"keyword\">this</span>.idleCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isRunning = promoteAndExecute();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isRunning &amp;&amp; idleCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        idleCallback.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在RealCall和AsyncCall代码中, 能看到同样调用了despatcher.finished方法</p>\n<h3 id=\"同步的call\"><a href=\"#同步的call\" class=\"headerlink\" title=\"同步的call\"></a>同步的call</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Used by &#123;<span class=\"doctag\">@code</span> Call#execute&#125; to signal it is in-flight. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">executed</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    runningSyncCalls.add(call);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已. </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"OkHttp3源码解析-发起请求的主要流程\"><a href=\"#OkHttp3源码解析-发起请求的主要流程\" class=\"headerlink\" title=\"OkHttp3源码解析-发起请求的主要流程\"></a>OkHttp3源码解析-发起请求的主要流程</h1>","more":"<p>结合网上的博客和自己看的源码, 写的简单理解.</p>\n<h2 id=\"主要的类\"><a href=\"#主要的类\" class=\"headerlink\" title=\"主要的类:\"></a>主要的类:</h2><ul>\n<li>OkHttpClient:<br>  用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等</li>\n<li>Request:<br>  用户对单次请求的数据进行配置, uur, 数据参数等. </li>\n<li>Call:<br>  在框架内部表示对请求的封装</li>\n<li>Dispatcher:<br>  在框架内部对请求进行分发</li>\n</ul>\n<h2 id=\"OkHttpClient\"><a href=\"#OkHttpClient\" class=\"headerlink\" title=\"OkHttpClient:\"></a>OkHttpClient:</h2><p>主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Prepares the &#123;<span class=\"doctag\">@code</span> request&#125; to be executed at some point in the future.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call <span class=\"title\">newCall</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RealCall.newRealCall(<span class=\"keyword\">this</span>, request, <span class=\"keyword\">false</span> <span class=\"comment\">/* for web socket */</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Call\"><a href=\"#Call\" class=\"headerlink\" title=\"Call:\"></a>Call:</h2><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">RealCall</span><span class=\"params\">(OkHttpClient client, Request originalRequest, <span class=\"keyword\">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.originalRequest = originalRequest;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.forWebSocket = forWebSocket;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.retryAndFollowUpInterceptor = <span class=\"keyword\">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout = <span class=\"keyword\">new</span> AsyncTimeout() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">timedOut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> RealCall <span class=\"title\">newRealCall</span><span class=\"params\">(OkHttpClient client, Request originalRequest, <span class=\"keyword\">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Safely publish the Call instance to the EventListener.</span></span><br><span class=\"line\">  RealCall call = <span class=\"keyword\">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class=\"line\">  call.eventListener = client.eventListenerFactory().create(call);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> call;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步执行一个call\"><a href=\"#同步执行一个call\" class=\"headerlink\" title=\"同步执行一个call\"></a>同步执行一个call</h3><p>在RealCall中有一个execute方法, 这里发起一个同步请求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">    executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  captureCallStackTrace();</span><br><span class=\"line\">  timeout.enter();</span><br><span class=\"line\">  eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    client.dispatcher().executed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">// getResponseWithInterceptorChain()是具体的请求的操作过程</span></span><br><span class=\"line\">    Response result = getResponseWithInterceptorChain();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e = timeoutExit(e);</span><br><span class=\"line\">    eventListener.callFailed(<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>getResponseWithInterceptorChain()方法是请求发出的最终执行方法.</strong> 也就是说RealCall中调用execute()就已经直接同步开始了请求操作.</p>\n<p>但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? </p>\n<p>详细的内容可以看Dispatcher的源码解析.</p>\n<h3 id=\"异步执行一个call\"><a href=\"#异步执行一个call\" class=\"headerlink\" title=\"异步执行一个call\"></a>异步执行一个call</h3><p>RealCall中的enqueue方法, 发起一个异步请求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Callback responseCallback)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">    executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  captureCallStackTrace();</span><br><span class=\"line\">  eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  client.dispatcher().enqueue(<span class=\"keyword\">new</span> AsyncCall(responseCallback));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类</p>\n<p><strong>AsyncCall中的executeOn, execute</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Attempt to enqueue this async call on &#123;<span class=\"doctag\">@code</span> executorService&#125;. This will attempt to clean up</span></span><br><span class=\"line\"><span class=\"comment\">* if the executor has been shut down by reporting the call as failed.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executeOn</span><span class=\"params\">(ExecutorService executorService)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        executorService.execute(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        success = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</span><br><span class=\"line\">        InterruptedIOException ioException = <span class=\"keyword\">new</span> InterruptedIOException(<span class=\"string\">\"executor rejected\"</span>);</span><br><span class=\"line\">        ioException.initCause(e);</span><br><span class=\"line\">        eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, ioException);</span><br><span class=\"line\">        responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, ioException);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">          client.dispatcher().finished(<span class=\"keyword\">this</span>); <span class=\"comment\">// This call is no longer running!</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> signalledCallback = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  timeout.enter();</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Response response = getResponseWithInterceptorChain();</span><br><span class=\"line\">    signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    responseCallback.onResponse(RealCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e = timeoutExit(e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (signalledCallback) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Do not signal the callback twice!</span></span><br><span class=\"line\">      Platform.get().log(INFO, <span class=\"string\">\"Callback failure for \"</span> + toLoggableString(), e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">      responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行.</p>\n<h2 id=\"Dispatcher\"><a href=\"#Dispatcher\" class=\"headerlink\" title=\"Dispatcher\"></a>Dispatcher</h2><h3 id=\"重要的成员变量\"><a href=\"#重要的成员变量\" class=\"headerlink\" title=\"重要的成员变量\"></a>重要的成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequests = <span class=\"number\">64</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequestsPerHost = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> Runnable idleCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Executes calls. Created lazily. */</span></span><br><span class=\"line\"><span class=\"comment\">// 这是一个线程池, 并且实现了懒加载</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> ExecutorService executorService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Ready async calls in the order they'll be run. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p><strong>为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:</strong><br>答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列.</p>\n<h3 id=\"ExcutorService\"><a href=\"#ExcutorService\" class=\"headerlink\" title=\"ExcutorService\"></a>ExcutorService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> ExecutorService <span class=\"title\">executorService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executorService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      executorService = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE, <span class=\"number\">60</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">          <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class=\"string\">\"OkHttp Dispatcher\"</span>, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executorService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个线程池其实是一个CacheThreadPool. 他的特点是: </p>\n<ul>\n<li>底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</li>\n<li>通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</li>\n<li>适用：执行很多短期异步的小程序或者负载较轻的服务器</li>\n</ul>\n<p>检查调用executorService()方法的地方, 是一个promoteAndExecute()方法</p>\n<h3 id=\"enqueue-AsyncCall-call\"><a href=\"#enqueue-AsyncCall-call\" class=\"headerlink\" title=\"enqueue(AsyncCall call)\"></a>enqueue(AsyncCall call)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(AsyncCall call)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      readyAsyncCalls.add(call);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    promoteAndExecute();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步</p>\n<h3 id=\"promoteAndExecute\"><a href=\"#promoteAndExecute\" class=\"headerlink\" title=\"promoteAndExecute()\"></a>promoteAndExecute()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Promotes eligible calls from &#123;<span class=\"doctag\">@link</span> #readyAsyncCalls&#125; to &#123;<span class=\"doctag\">@link</span> #runningAsyncCalls&#125; and runs</span></span><br><span class=\"line\"><span class=\"comment\"> * them on the executor service. Must not be called with synchronization because executing calls</span></span><br><span class=\"line\"><span class=\"comment\"> * can call into user code.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if the dispatcher is currently running calls.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call</span></span><br><span class=\"line\"><span class=\"comment\">// 如果成功执行上面的操作, 返回true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">promoteAndExecute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (!Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  List&lt;AsyncCall&gt; executableCalls = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> isRunning;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">      AsyncCall asyncCall = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 到达了max限制, break</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class=\"keyword\">break</span>; <span class=\"comment\">// Max capacity.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class=\"keyword\">continue</span>; <span class=\"comment\">// Host max capacity.</span></span><br><span class=\"line\"></span><br><span class=\"line\">      i.remove();</span><br><span class=\"line\">      executableCalls.add(asyncCall);</span><br><span class=\"line\">      runningAsyncCalls.add(asyncCall);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    isRunning = runningCallsCount() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">    AsyncCall asyncCall = executableCalls.get(i);</span><br><span class=\"line\">    <span class=\"comment\">// 在线程池中执行这个call</span></span><br><span class=\"line\">    asyncCall.executeOn(executorService());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> isRunning;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>promoteAndExecute()方法的解析直接看上面源码的注释. </p>\n<p>结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行.<br>想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢?<br>想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法</p>\n<h3 id=\"finished-Deque-calls-T-call\"><a href=\"#finished-Deque-calls-T-call\" class=\"headerlink\" title=\"finished(Deque calls, T call)\"></a>finished(Deque<t> calls, T call)</t></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class=\"line\">    Runnable idleCallback;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!calls.remove(call)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Call wasn't in-flight!\"</span>);</span><br><span class=\"line\">        idleCallback = <span class=\"keyword\">this</span>.idleCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isRunning = promoteAndExecute();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isRunning &amp;&amp; idleCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        idleCallback.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在RealCall和AsyncCall代码中, 能看到同样调用了despatcher.finished方法</p>\n<h3 id=\"同步的call\"><a href=\"#同步的call\" class=\"headerlink\" title=\"同步的call\"></a>同步的call</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Used by &#123;<span class=\"doctag\">@code</span> Call#execute&#125; to signal it is in-flight. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">executed</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    runningSyncCalls.add(call);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已. </p>\n"},{"title":"事件分发机制","date":"2019-08-13T13:12:59.000Z","_content":"\n# 事件分发机制\n\n## dispatchTouchEvent\n\n### ViewGroup 的 dispatchTouchEvent 方法\n\n#### 伪代码\n\n```java\npublic boolean dispatchTouchEvent(){\n    boolean consume = false;\n    if (onInterceptTouchEvent(ev)){\n        consume = super.dispatchTouchEvent();\n    }else{\n        consume = child.dispatchTouchEvent(ev);\n        if (!consume)\n            consume = super.dispatchTouchEvent(ev)\n    }\n    return consume;\n}\n```\n\n解释：\n在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理\n\n#### 源代码\n\n##### dispatchTouchEvent\n\n```java\n// Handle an initial down.\nif (actionMasked == MotionEvent.ACTION_DOWN) {\n    // Throw away all previous state when starting a new touch gesture.\n    // The framework may have dropped the up or cancel event for the previous gesture\n    // due to an app switch, ANR, or some other state change.\n    // 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null\n    cancelAndClearTouchTargets(ev);\n    resetTouchState();\n}\n\n// Check for interception.\nfinal boolean intercepted;\n// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素\n// mFirstTouchTarget赋值在addTouchTarget方法中\nif (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {\n    final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n    if (!disallowIntercept) {\n        intercepted = onInterceptTouchEvent(ev);\n        ev.setAction(action); // restore action in case it was changed\n    } else {\n        intercepted = false;\n    }\n} else {\n    // mFirstTouchTarget == null, 并且这不是一个down事件, 说明\n    // down事件没有被ViewGroup拦击, down事件也没有被子view消费, \n    // 后续的事件也没有被子View消费, 所以后续的事件交给ViewGroup\n    intercepted = true;\n}\n\n.... //省略代码\n\n// Check for cancelation.\nfinal boolean canceled = resetCancelNextUpFlag(this)\n        || actionMasked == MotionEvent.ACTION_CANCEL;\n// Update list of touch targets for pointer down, if needed.\nfinal boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\nTouchTarget newTouchTarget = null;\nboolean alreadyDispatchedToNewTouchTarget = false;\n\nif (!canceled && !intercepted) {\n    ... //省略部分代码\n    for (int i = childrenCount - 1; i >= 0; i--) {\n\n        ... //省略部分代码\n\n        newTouchTarget = getTouchTarget(child);\n        if (newTouchTarget != null) {\n            // Child is already receiving touch within its bounds.\n            // Give it the new pointer in addition to the ones it is handling.\n            newTouchTarget.pointerIdBits |= idBitsToAssign;\n            break;\n        }\n\n        ... // 省略部分代码\n\n        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n            // Child wants to receive touch within its bounds.\n            // 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环\n\n            .... // 省略部分代码\n            newTouchTarget = addTouchTarget(child, idBitsToAssign);\n            alreadyDispatchedToNewTouchTarget = true;\n            break;\n        }\n\n        ... //省略代码\n    }\n    ... // 省略部分代码\n}\n\n... // 省略部分代码\n\n// Dispatch to touch targets.\nif (mFirstTouchTarget == null) {\n    // No touch targets so treat this as an ordinary view.\n    // 说明没有子view消费掉这个事件，所以交给父类处理\n    handled = dispatchTransformedTouchEvent(ev, canceled, null,\n            TouchTarget.ALL_POINTER_IDS);\n} else {\n\n    ... // 省略代码\n}\n```\n\n##### dispatchTransformedTouchEvent\n\n```java\nprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n    final boolean handled;\n\n    // 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理\n    final int oldAction = event.getAction();\n    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n        event.setAction(MotionEvent.ACTION_CANCEL);\n        if (child == null) {\n            handled = super.dispatchTouchEvent(event);\n        } else {\n            handled = child.dispatchTouchEvent(event);\n        }\n        event.setAction(oldAction);\n        return handled;\n    }\n\n    ... // 省略代码\n}\n```\n\n##### addTouchTarget\n\n**mFirstTarget 赋值的地方**\n\n```java\nprivate TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {\n    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);\n    target.next = mFirstTouchTarget;\n    mFirstTouchTarget = target;\n    return target;\n}\n```\n\n#### 需要注意的点\n\n##### ActionDown\n\n- ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理\n- ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位\n\n##### ActionMove、ActionUp 等其他事件\n\n- 若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截\n- 若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理\n\n(以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到)\n\n##### requestDisallowInterceptTouchEvent(true)\n\n- 子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。\n- 但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位\n\n## View 的 dispatchTouchEvent 方法\n\n如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent event) {\n    ... // 省略代码\n\n    ListenerInfo li = mListenerInfo;\n    if (li != null && li.mOnTouchListener != null\n            && (mViewFlags & ENABLED_MASK) == ENABLED\n            && li.mOnTouchListener.onTouch(this, event)) {\n        result = true;\n    }\n\n    if (!result && onTouchEvent(event)) {\n        result = true;\n    }\n\n    ... // 省略代码\n\n    return result;\n}\n```\n","source":"_posts/Android/源码解析/事件分发机制.md","raw":"---\ntitle: 事件分发机制\ndate: 2019-08-13 21:12:59\ntags:\n- View\n- 源码解析\ncategories:\n- Android\n- View\n---\n\n# 事件分发机制\n\n## dispatchTouchEvent\n\n### ViewGroup 的 dispatchTouchEvent 方法\n\n#### 伪代码\n\n```java\npublic boolean dispatchTouchEvent(){\n    boolean consume = false;\n    if (onInterceptTouchEvent(ev)){\n        consume = super.dispatchTouchEvent();\n    }else{\n        consume = child.dispatchTouchEvent(ev);\n        if (!consume)\n            consume = super.dispatchTouchEvent(ev)\n    }\n    return consume;\n}\n```\n\n解释：\n在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理\n\n#### 源代码\n\n##### dispatchTouchEvent\n\n```java\n// Handle an initial down.\nif (actionMasked == MotionEvent.ACTION_DOWN) {\n    // Throw away all previous state when starting a new touch gesture.\n    // The framework may have dropped the up or cancel event for the previous gesture\n    // due to an app switch, ANR, or some other state change.\n    // 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null\n    cancelAndClearTouchTargets(ev);\n    resetTouchState();\n}\n\n// Check for interception.\nfinal boolean intercepted;\n// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素\n// mFirstTouchTarget赋值在addTouchTarget方法中\nif (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {\n    final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n    if (!disallowIntercept) {\n        intercepted = onInterceptTouchEvent(ev);\n        ev.setAction(action); // restore action in case it was changed\n    } else {\n        intercepted = false;\n    }\n} else {\n    // mFirstTouchTarget == null, 并且这不是一个down事件, 说明\n    // down事件没有被ViewGroup拦击, down事件也没有被子view消费, \n    // 后续的事件也没有被子View消费, 所以后续的事件交给ViewGroup\n    intercepted = true;\n}\n\n.... //省略代码\n\n// Check for cancelation.\nfinal boolean canceled = resetCancelNextUpFlag(this)\n        || actionMasked == MotionEvent.ACTION_CANCEL;\n// Update list of touch targets for pointer down, if needed.\nfinal boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\nTouchTarget newTouchTarget = null;\nboolean alreadyDispatchedToNewTouchTarget = false;\n\nif (!canceled && !intercepted) {\n    ... //省略部分代码\n    for (int i = childrenCount - 1; i >= 0; i--) {\n\n        ... //省略部分代码\n\n        newTouchTarget = getTouchTarget(child);\n        if (newTouchTarget != null) {\n            // Child is already receiving touch within its bounds.\n            // Give it the new pointer in addition to the ones it is handling.\n            newTouchTarget.pointerIdBits |= idBitsToAssign;\n            break;\n        }\n\n        ... // 省略部分代码\n\n        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n            // Child wants to receive touch within its bounds.\n            // 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环\n\n            .... // 省略部分代码\n            newTouchTarget = addTouchTarget(child, idBitsToAssign);\n            alreadyDispatchedToNewTouchTarget = true;\n            break;\n        }\n\n        ... //省略代码\n    }\n    ... // 省略部分代码\n}\n\n... // 省略部分代码\n\n// Dispatch to touch targets.\nif (mFirstTouchTarget == null) {\n    // No touch targets so treat this as an ordinary view.\n    // 说明没有子view消费掉这个事件，所以交给父类处理\n    handled = dispatchTransformedTouchEvent(ev, canceled, null,\n            TouchTarget.ALL_POINTER_IDS);\n} else {\n\n    ... // 省略代码\n}\n```\n\n##### dispatchTransformedTouchEvent\n\n```java\nprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n    final boolean handled;\n\n    // 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理\n    final int oldAction = event.getAction();\n    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n        event.setAction(MotionEvent.ACTION_CANCEL);\n        if (child == null) {\n            handled = super.dispatchTouchEvent(event);\n        } else {\n            handled = child.dispatchTouchEvent(event);\n        }\n        event.setAction(oldAction);\n        return handled;\n    }\n\n    ... // 省略代码\n}\n```\n\n##### addTouchTarget\n\n**mFirstTarget 赋值的地方**\n\n```java\nprivate TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {\n    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);\n    target.next = mFirstTouchTarget;\n    mFirstTouchTarget = target;\n    return target;\n}\n```\n\n#### 需要注意的点\n\n##### ActionDown\n\n- ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理\n- ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位\n\n##### ActionMove、ActionUp 等其他事件\n\n- 若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截\n- 若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理\n\n(以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到)\n\n##### requestDisallowInterceptTouchEvent(true)\n\n- 子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。\n- 但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位\n\n## View 的 dispatchTouchEvent 方法\n\n如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent event) {\n    ... // 省略代码\n\n    ListenerInfo li = mListenerInfo;\n    if (li != null && li.mOnTouchListener != null\n            && (mViewFlags & ENABLED_MASK) == ENABLED\n            && li.mOnTouchListener.onTouch(this, event)) {\n        result = true;\n    }\n\n    if (!result && onTouchEvent(event)) {\n        result = true;\n    }\n\n    ... // 省略代码\n\n    return result;\n}\n```\n","slug":"Android/源码解析/事件分发机制","published":1,"updated":"2020-03-24T14:47:18.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdrakse005d8mzm1ijjqkzb","content":"<h1 id=\"事件分发机制\"><a href=\"#事件分发机制\" class=\"headerlink\" title=\"事件分发机制\"></a>事件分发机制</h1><h2 id=\"dispatchTouchEvent\"><a href=\"#dispatchTouchEvent\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h2><a id=\"more\"></a><h3 id=\"ViewGroup-的-dispatchTouchEvent-方法\"><a href=\"#ViewGroup-的-dispatchTouchEvent-方法\" class=\"headerlink\" title=\"ViewGroup 的 dispatchTouchEvent 方法\"></a>ViewGroup 的 dispatchTouchEvent 方法</h3><h4 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> consume = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (onInterceptTouchEvent(ev))&#123;</span><br><span class=\"line\">        consume = <span class=\"keyword\">super</span>.dispatchTouchEvent();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        consume = child.dispatchTouchEvent(ev);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!consume)</span><br><span class=\"line\">            consume = <span class=\"keyword\">super</span>.dispatchTouchEvent(ev)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> consume;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：<br>在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><h5 id=\"dispatchTouchEvent-1\"><a href=\"#dispatchTouchEvent-1\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Handle an initial down.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class=\"line\">    <span class=\"comment\">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class=\"line\">    <span class=\"comment\">// due to an app switch, ANR, or some other state change.</span></span><br><span class=\"line\">    <span class=\"comment\">// 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null</span></span><br><span class=\"line\">    cancelAndClearTouchTargets(ev);</span><br><span class=\"line\">    resetTouchState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for interception.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> intercepted;</span><br><span class=\"line\"><span class=\"comment\">// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素</span></span><br><span class=\"line\"><span class=\"comment\">// mFirstTouchTarget赋值在addTouchTarget方法中</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!disallowIntercept) &#123;</span><br><span class=\"line\">        intercepted = onInterceptTouchEvent(ev);</span><br><span class=\"line\">        ev.setAction(action); <span class=\"comment\">// restore action in case it was changed</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        intercepted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// mFirstTouchTarget == null, 并且这不是一个down事件, 说明</span></span><br><span class=\"line\">    <span class=\"comment\">// down事件没有被ViewGroup拦击, down事件也没有被子view消费, </span></span><br><span class=\"line\">    <span class=\"comment\">// 后续的事件也没有被子View消费, 所以后续的事件交给ViewGroup</span></span><br><span class=\"line\">    intercepted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.... <span class=\"comment\">//省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for cancelation.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> canceled = resetCancelNextUpFlag(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class=\"line\"><span class=\"comment\">// Update list of touch targets for pointer down, if needed.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class=\"number\">0</span>;</span><br><span class=\"line\">TouchTarget newTouchTarget = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">    ... <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">        newTouchTarget = getTouchTarget(child);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Child is already receiving touch within its bounds.</span></span><br><span class=\"line\">            <span class=\"comment\">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class=\"line\">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, <span class=\"keyword\">false</span>, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Child wants to receive touch within its bounds.</span></span><br><span class=\"line\">            <span class=\"comment\">// 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">            .... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class=\"line\">            alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">//省略代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dispatch to touch targets.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// No touch targets so treat this as an ordinary view.</span></span><br><span class=\"line\">    <span class=\"comment\">// 说明没有子view消费掉这个事件，所以交给父类处理</span></span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"dispatchTransformedTouchEvent\"><a href=\"#dispatchTransformedTouchEvent\" class=\"headerlink\" title=\"dispatchTransformedTouchEvent\"></a>dispatchTransformedTouchEvent</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTransformedTouchEvent</span><span class=\"params\">(MotionEvent event, <span class=\"keyword\">boolean</span> cancel,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            View child, <span class=\"keyword\">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> handled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldAction = event.getAction();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class=\"line\">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            handled = <span class=\"keyword\">super</span>.dispatchTouchEvent(event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        event.setAction(oldAction);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"addTouchTarget\"><a href=\"#addTouchTarget\" class=\"headerlink\" title=\"addTouchTarget\"></a>addTouchTarget</h5><p><strong>mFirstTarget 赋值的地方</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> TouchTarget <span class=\"title\">addTouchTarget</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class=\"line\">    target.next = mFirstTouchTarget;</span><br><span class=\"line\">    mFirstTouchTarget = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h4><h5 id=\"ActionDown\"><a href=\"#ActionDown\" class=\"headerlink\" title=\"ActionDown\"></a>ActionDown</h5><ul>\n<li>ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理</li>\n<li>ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位</li>\n</ul>\n<h5 id=\"ActionMove、ActionUp-等其他事件\"><a href=\"#ActionMove、ActionUp-等其他事件\" class=\"headerlink\" title=\"ActionMove、ActionUp 等其他事件\"></a>ActionMove、ActionUp 等其他事件</h5><ul>\n<li>若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截</li>\n<li>若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理</li>\n</ul>\n<p>(以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到)</p>\n<h5 id=\"requestDisallowInterceptTouchEvent-true\"><a href=\"#requestDisallowInterceptTouchEvent-true\" class=\"headerlink\" title=\"requestDisallowInterceptTouchEvent(true)\"></a>requestDisallowInterceptTouchEvent(true)</h5><ul>\n<li>子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。</li>\n<li>但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位</li>\n</ul>\n<h2 id=\"View-的-dispatchTouchEvent-方法\"><a href=\"#View-的-dispatchTouchEvent-方法\" class=\"headerlink\" title=\"View 的 dispatchTouchEvent 方法\"></a>View 的 dispatchTouchEvent 方法</h2><p>如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnTouchListener != <span class=\"keyword\">null</span></span><br><span class=\"line\">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class=\"line\">            &amp;&amp; li.mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"事件分发机制\"><a href=\"#事件分发机制\" class=\"headerlink\" title=\"事件分发机制\"></a>事件分发机制</h1><h2 id=\"dispatchTouchEvent\"><a href=\"#dispatchTouchEvent\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h2>","more":"<h3 id=\"ViewGroup-的-dispatchTouchEvent-方法\"><a href=\"#ViewGroup-的-dispatchTouchEvent-方法\" class=\"headerlink\" title=\"ViewGroup 的 dispatchTouchEvent 方法\"></a>ViewGroup 的 dispatchTouchEvent 方法</h3><h4 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> consume = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (onInterceptTouchEvent(ev))&#123;</span><br><span class=\"line\">        consume = <span class=\"keyword\">super</span>.dispatchTouchEvent();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        consume = child.dispatchTouchEvent(ev);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!consume)</span><br><span class=\"line\">            consume = <span class=\"keyword\">super</span>.dispatchTouchEvent(ev)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> consume;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：<br>在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><h5 id=\"dispatchTouchEvent-1\"><a href=\"#dispatchTouchEvent-1\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Handle an initial down.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class=\"line\">    <span class=\"comment\">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class=\"line\">    <span class=\"comment\">// due to an app switch, ANR, or some other state change.</span></span><br><span class=\"line\">    <span class=\"comment\">// 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null</span></span><br><span class=\"line\">    cancelAndClearTouchTargets(ev);</span><br><span class=\"line\">    resetTouchState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for interception.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> intercepted;</span><br><span class=\"line\"><span class=\"comment\">// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素</span></span><br><span class=\"line\"><span class=\"comment\">// mFirstTouchTarget赋值在addTouchTarget方法中</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!disallowIntercept) &#123;</span><br><span class=\"line\">        intercepted = onInterceptTouchEvent(ev);</span><br><span class=\"line\">        ev.setAction(action); <span class=\"comment\">// restore action in case it was changed</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        intercepted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// mFirstTouchTarget == null, 并且这不是一个down事件, 说明</span></span><br><span class=\"line\">    <span class=\"comment\">// down事件没有被ViewGroup拦击, down事件也没有被子view消费, </span></span><br><span class=\"line\">    <span class=\"comment\">// 后续的事件也没有被子View消费, 所以后续的事件交给ViewGroup</span></span><br><span class=\"line\">    intercepted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.... <span class=\"comment\">//省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for cancelation.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> canceled = resetCancelNextUpFlag(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class=\"line\"><span class=\"comment\">// Update list of touch targets for pointer down, if needed.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class=\"number\">0</span>;</span><br><span class=\"line\">TouchTarget newTouchTarget = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">    ... <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">        newTouchTarget = getTouchTarget(child);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Child is already receiving touch within its bounds.</span></span><br><span class=\"line\">            <span class=\"comment\">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class=\"line\">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, <span class=\"keyword\">false</span>, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Child wants to receive touch within its bounds.</span></span><br><span class=\"line\">            <span class=\"comment\">// 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">            .... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class=\"line\">            alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">//省略代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dispatch to touch targets.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// No touch targets so treat this as an ordinary view.</span></span><br><span class=\"line\">    <span class=\"comment\">// 说明没有子view消费掉这个事件，所以交给父类处理</span></span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"dispatchTransformedTouchEvent\"><a href=\"#dispatchTransformedTouchEvent\" class=\"headerlink\" title=\"dispatchTransformedTouchEvent\"></a>dispatchTransformedTouchEvent</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTransformedTouchEvent</span><span class=\"params\">(MotionEvent event, <span class=\"keyword\">boolean</span> cancel,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            View child, <span class=\"keyword\">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> handled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldAction = event.getAction();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class=\"line\">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            handled = <span class=\"keyword\">super</span>.dispatchTouchEvent(event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        event.setAction(oldAction);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"addTouchTarget\"><a href=\"#addTouchTarget\" class=\"headerlink\" title=\"addTouchTarget\"></a>addTouchTarget</h5><p><strong>mFirstTarget 赋值的地方</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> TouchTarget <span class=\"title\">addTouchTarget</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class=\"line\">    target.next = mFirstTouchTarget;</span><br><span class=\"line\">    mFirstTouchTarget = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h4><h5 id=\"ActionDown\"><a href=\"#ActionDown\" class=\"headerlink\" title=\"ActionDown\"></a>ActionDown</h5><ul>\n<li>ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理</li>\n<li>ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位</li>\n</ul>\n<h5 id=\"ActionMove、ActionUp-等其他事件\"><a href=\"#ActionMove、ActionUp-等其他事件\" class=\"headerlink\" title=\"ActionMove、ActionUp 等其他事件\"></a>ActionMove、ActionUp 等其他事件</h5><ul>\n<li>若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截</li>\n<li>若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理</li>\n</ul>\n<p>(以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到)</p>\n<h5 id=\"requestDisallowInterceptTouchEvent-true\"><a href=\"#requestDisallowInterceptTouchEvent-true\" class=\"headerlink\" title=\"requestDisallowInterceptTouchEvent(true)\"></a>requestDisallowInterceptTouchEvent(true)</h5><ul>\n<li>子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。</li>\n<li>但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位</li>\n</ul>\n<h2 id=\"View-的-dispatchTouchEvent-方法\"><a href=\"#View-的-dispatchTouchEvent-方法\" class=\"headerlink\" title=\"View 的 dispatchTouchEvent 方法\"></a>View 的 dispatchTouchEvent 方法</h2><p>如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnTouchListener != <span class=\"keyword\">null</span></span><br><span class=\"line\">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class=\"line\">            &amp;&amp; li.mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Fresco源码解析","date":"2020-03-20T07:24:32.000Z","_content":"\n## 1. 介绍：\nfresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。\n* 支持加载网络，本地存储和资源图片；\n* 提供三级缓存（二级memory和一级internal storage）；\n* 支持JPEGs，PNGs，GIFs，WEBPs等，还支持Progressive JPEG，优秀的动画支持；\n* 图片圆角，scale，自定义背景，overlays等等；\n* 优秀的内存管理, 在安卓低版本中会将缓存保存至特殊区域, 而不是java heap, 从而避免oom；\n\n## 2. 主要组成部分\n\n![fresco基本结构](/images/fresco基本结构.jpg)\n\n* DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由ViewHolder负责。\n* DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。\n* DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。\n* DraweeHolder：统筹管理Hierarchy与DraweeController。\n* ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。\n* Producer/Consumer：Producer也有很多种，是完成具体工作的类. 它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。\n* IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。\n\n## 3. 发起图片请求的主要流程\n### 3.1 流程图\n![fresco发起请求的主要流程](/images/fresco发起请求的流程.jpg)\n\n### 3.2 源码分析\n\n#### 3.2.1 DraweeView\n我们常用的类是SimpleDraweeView, 继承关系如下\nSimpleDraweeView -> GenericDraweeView -> DraweeView -> ImageView\n**注意: 虽然上述的类都是继承于ImageView的, 但是使用时最好不要调用ImageView本身的任何属性和方法, 不然的话使用不了Fresco的功能**\n\n* DraweeView: 持有ViewHolder, ViewHolder管理DraweeController和DraweeHierarchy\n* GenericDraweeView: 解析xml属性, 创建DraweeHierarchy\n* SimpleDraweeView: 我们一般使用的类, 接受请求, 创建爱你DraweeController\n\n**SimpleDraweeView.setImageURI**\n```java\n/**\n* Displays an image given by the uri.\n*\n* @param uri uri of the image\n* @param callerContext caller context\n*/\npublic void setImageURI(Uri uri, @Nullable Object callerContext) {\nDraweeController controller =\n    mControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\nsetController(controller);\n}\n```\nmControllerBuilder在setUri方法中创建了ImageRequest, 在build的过程中构建好了请求, cache, 编码, 解码等流程. 最后setController启动请求流程\n\n#### 3.2.2 DraweeControllerBuilder.build\n\n在DraweeControllerBuilder.build方法中创建了DataSource. DataSource类似于Java里的Futures，代表数据的来源\n\n```\n-> AbstractDraweeControllerBuilder.build\n--> AbstractDraweeControllerBuilder.buildController\n----> PipelineDraweeControllerBuilder.obtainController // 创建controller并return\n-----> AbstractDraweeControllerBuilder.obtainDataSourceSupplier\n------> AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest // 创建了Supplier<DataSource<IMAGE>>, 调用supplier.get方法就会创建Data\nSource\n```\n\n#### 3.2.3 setController\n\n```\n-> DraweeView.setController\n--> DraweeHolder.setController\n----> DraweeController.setHierarchy\n----> DraweeHolder.attachController\n-----> AbstractDraweeController.onAttach\n------> AbstractDraweeController.submitRequest\n```\n\n```java\nprotected void submitRequest() {\n    ...\n    final T closeableImage = getCachedImage(); // DataSource还没有start,已经开始获取缓存了\n    if (closeableImage != null) {\n      ...\n      return;\n    }\n    ...\n    mDataSource = getDataSource(); // 获取DataSource\n    final String id = mId;\n    final boolean wasImmediate = mDataSource.hasResult();\n    // 注册并处理结果\n    final DataSubscriber<T> dataSubscriber =\n        new BaseDataSubscriber<T>() {\n          @Override\n          public void onNewResultImpl(DataSource<T> dataSource) {\n            boolean isFinished = dataSource.isFinished();\n            boolean hasMultipleResults = dataSource.hasMultipleResults();\n            float progress = dataSource.getProgress();\n            T image = dataSource.getResult();\n            if (image != null) {\n              onNewResultInternal(\n                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);\n            } else if (isFinished) {\n              onFailureInternal(id, dataSource, new NullPointerException(), /* isFinished */ true);\n            }\n          }\n\n          @Override\n          public void onFailureImpl(DataSource<T> dataSource) {\n            ...\n          }\n\n          @Override\n          public void onProgressUpdate(DataSource<T> dataSource) {\n            ...\n          }\n        };\n    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);\n}\n\n@Override\nprotected DataSource<CloseableReference<CloseableImage>> getDataSource() {\n    // 这里的mDataSouceSupplier是controller在创建时有构造方法传入\n    DataSource<CloseableReference<CloseableImage>> result = mDataSourceSupplier.get();\n    return result;\n}\n```\n\n还有一个问题, DataSource是什么时候启动的? 我们在DraweeController.build创建过程中发现创建了Supplier<DataSource<>>,  controller的getDataSource实际上就是从Supplier获取的DataSource\n\n\n```\n-------> PipelineDraweeControllerBuilder.getDataSourceForRequest\n--------> ImagePipeline.fetchDecodedImage // 在这个方法中创建了producerSequence\n---------> ImagePipeline.submitFetchRequest\n----------> CloseableProducerToDataSourceAdapter<T>.craete\n-----------> new CloseableProducerToDataSourceAdapter\n```\n**featchDecodeImage**\n```java\npublic DataSource<CloseableReference<CloseableImage>> fetchDecodedImage(\n      ImageRequest imageRequest,\n      Object callerContext,\n      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,\n      @Nullable RequestListener requestListener) {\n    try {\n      // 创建Producer序列\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext,\n          requestListener);\n    } catch (Exception exception) {\n      return DataSources.immediateFailedDataSource(exception);\n    }\n}\n```\n\n**CloseableProducerToDataSourceAdapter的构造方法**\n这个构造方法只是简单的调用父类的构造方法\n```java\nprotected AbstractProducerToDataSourceAdapter(\n      Producer<T> producer,\n      SettableProducerContext settableProducerContext,\n      RequestListener requestListener) {\n    \n    mSettableProducerContext = settableProducerContext;\n    mRequestListener = requestListener;\n\n    mRequestListener.onRequestStart(\n        settableProducerContext.getImageRequest(),\n        mSettableProducerContext.getCallerContext(),\n        mSettableProducerContext.getId(),\n        mSettableProducerContext.isPrefetch());\n    if (FrescoSystrace.isTracing()) {\n      FrescoSystrace.endSection();\n    }\n\n    // procuder序列启动\n    producer.produceResults(createConsumer(), settableProducerContext);\n}\n```\n**原来DataSource一创建就会启动produer的工作流程**\n\n## 3. Producer序列的工作流程\n### 3.1 Producer/Consumer的基本概念\n**模板代码**\n```java\npublic class XXXXProducer implements Producer{\n\n    private final Producer mInputProducer;\n\n    public BitmapMemoryCacheProducer(Producer inputProducer) {\n        mInputProducer = inputProducer;\n    }\n\n    @Override\n    public void produceResults(\n        final Consumer consumer,\n        final ProducerContext producerContext) {\n\n        ... 尝试直接得到结果\n        if(已经获取到结果){\n            consumer.onNewResult(result, status);\n            return ;\n        }\n\n        Consumer newConsumer = new DelegatingConsumer(consumer){\n            @Override\n            public void onNewResultImpl(newResult, int status) {\n                ... 处理上一阶段返回的结果\n                if(isLast){\n                    // 将自己处理完成的数据交给上一层producer\n                    // 这里的getConsumer是构造方法传入的consumer, 也就是上一层producer创建的DelegatingConsumer\n                    getConsumer().onNewResult();\n                }\n            }\n        }\n        // 进行下一阶段\n        mInputProducer.produceResults(newConsumer, producerContext);\n    }\n}\n```\n\n**Consumer的onNewResult方法**\nonNewResult会直接调用自己的onNewResultImpl方法\n```java\n@Override\npublic synchronized void onNewResult(@Nullable T newResult, @Status int status) {\n    if (mIsFinished) {\n      return;\n    }\n    mIsFinished = isLast(status);\n    try {\n      onNewResultImpl(newResult, status);\n    } catch (Exception e) {\n      onUnhandledException(e);\n    }\n}\n```\n\n按照这样类似责任链的设计模式, 实际上, 往后加入的producer越晚执行\n\n### 3.2 主要的producer内容梳理\n\n* BitmapMemoryCacheGetProducer\n从内存中获取已解码的图片, 因为是直接从内存中获取可以用的, 所以是即时的, 在UI线程中就可以做\n* BackgroundThreadHandoffProducer\n将任务移交给子线程, 这里仅仅是转移线程而已, 具体的工作在具体的线程中完成\n* BitmapMemoryCacheKeyMultiplexProducer\n将多个拥有相同已解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据\n* BitmapMemoryCacheProducer\n又一次获取内存缓存? 我觉得主要是将下一阶段获取的已解码图片存储到缓存中\n* DecodeProducer\n解码\n* ResizeAndRotateProducer\n旋转, 缩放\n* AddImageTransformMetaProducer\n添加MetaData\n* EncodeCacheKeyMutiplexProducer\n将多个拥有相同未解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据；\n* EncodedMemoryCacheProducer\n查找未解码的图片缓存, 将下一步得到的未解码图片保存到缓存中\n* DiskCacheReadProducer\n读磁盘缓存, 有分MainCache和SmallCache, SmallCache存储小图片, 避免大图片被挤出缓存. 启动task并扔进线程池\n* DiskCacheWriteProducer\n存入磁盘缓存, 同样是在线程池中操作\n* newNetworkFetchProducer\n从网络中获取图片\n\n","source":"_posts/Android/源码解析/Fresco源码解析.md","raw":"---\ntitle: Fresco源码解析\ndate: 2020-03-20 15:24:32\ntags: \n- Fresco\n- 源码解析\ncategories:\n- Android\n---\n\n## 1. 介绍：\nfresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。\n* 支持加载网络，本地存储和资源图片；\n* 提供三级缓存（二级memory和一级internal storage）；\n* 支持JPEGs，PNGs，GIFs，WEBPs等，还支持Progressive JPEG，优秀的动画支持；\n* 图片圆角，scale，自定义背景，overlays等等；\n* 优秀的内存管理, 在安卓低版本中会将缓存保存至特殊区域, 而不是java heap, 从而避免oom；\n\n## 2. 主要组成部分\n\n![fresco基本结构](/images/fresco基本结构.jpg)\n\n* DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由ViewHolder负责。\n* DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。\n* DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。\n* DraweeHolder：统筹管理Hierarchy与DraweeController。\n* ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。\n* Producer/Consumer：Producer也有很多种，是完成具体工作的类. 它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。\n* IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。\n\n## 3. 发起图片请求的主要流程\n### 3.1 流程图\n![fresco发起请求的主要流程](/images/fresco发起请求的流程.jpg)\n\n### 3.2 源码分析\n\n#### 3.2.1 DraweeView\n我们常用的类是SimpleDraweeView, 继承关系如下\nSimpleDraweeView -> GenericDraweeView -> DraweeView -> ImageView\n**注意: 虽然上述的类都是继承于ImageView的, 但是使用时最好不要调用ImageView本身的任何属性和方法, 不然的话使用不了Fresco的功能**\n\n* DraweeView: 持有ViewHolder, ViewHolder管理DraweeController和DraweeHierarchy\n* GenericDraweeView: 解析xml属性, 创建DraweeHierarchy\n* SimpleDraweeView: 我们一般使用的类, 接受请求, 创建爱你DraweeController\n\n**SimpleDraweeView.setImageURI**\n```java\n/**\n* Displays an image given by the uri.\n*\n* @param uri uri of the image\n* @param callerContext caller context\n*/\npublic void setImageURI(Uri uri, @Nullable Object callerContext) {\nDraweeController controller =\n    mControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\nsetController(controller);\n}\n```\nmControllerBuilder在setUri方法中创建了ImageRequest, 在build的过程中构建好了请求, cache, 编码, 解码等流程. 最后setController启动请求流程\n\n#### 3.2.2 DraweeControllerBuilder.build\n\n在DraweeControllerBuilder.build方法中创建了DataSource. DataSource类似于Java里的Futures，代表数据的来源\n\n```\n-> AbstractDraweeControllerBuilder.build\n--> AbstractDraweeControllerBuilder.buildController\n----> PipelineDraweeControllerBuilder.obtainController // 创建controller并return\n-----> AbstractDraweeControllerBuilder.obtainDataSourceSupplier\n------> AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest // 创建了Supplier<DataSource<IMAGE>>, 调用supplier.get方法就会创建Data\nSource\n```\n\n#### 3.2.3 setController\n\n```\n-> DraweeView.setController\n--> DraweeHolder.setController\n----> DraweeController.setHierarchy\n----> DraweeHolder.attachController\n-----> AbstractDraweeController.onAttach\n------> AbstractDraweeController.submitRequest\n```\n\n```java\nprotected void submitRequest() {\n    ...\n    final T closeableImage = getCachedImage(); // DataSource还没有start,已经开始获取缓存了\n    if (closeableImage != null) {\n      ...\n      return;\n    }\n    ...\n    mDataSource = getDataSource(); // 获取DataSource\n    final String id = mId;\n    final boolean wasImmediate = mDataSource.hasResult();\n    // 注册并处理结果\n    final DataSubscriber<T> dataSubscriber =\n        new BaseDataSubscriber<T>() {\n          @Override\n          public void onNewResultImpl(DataSource<T> dataSource) {\n            boolean isFinished = dataSource.isFinished();\n            boolean hasMultipleResults = dataSource.hasMultipleResults();\n            float progress = dataSource.getProgress();\n            T image = dataSource.getResult();\n            if (image != null) {\n              onNewResultInternal(\n                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);\n            } else if (isFinished) {\n              onFailureInternal(id, dataSource, new NullPointerException(), /* isFinished */ true);\n            }\n          }\n\n          @Override\n          public void onFailureImpl(DataSource<T> dataSource) {\n            ...\n          }\n\n          @Override\n          public void onProgressUpdate(DataSource<T> dataSource) {\n            ...\n          }\n        };\n    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);\n}\n\n@Override\nprotected DataSource<CloseableReference<CloseableImage>> getDataSource() {\n    // 这里的mDataSouceSupplier是controller在创建时有构造方法传入\n    DataSource<CloseableReference<CloseableImage>> result = mDataSourceSupplier.get();\n    return result;\n}\n```\n\n还有一个问题, DataSource是什么时候启动的? 我们在DraweeController.build创建过程中发现创建了Supplier<DataSource<>>,  controller的getDataSource实际上就是从Supplier获取的DataSource\n\n\n```\n-------> PipelineDraweeControllerBuilder.getDataSourceForRequest\n--------> ImagePipeline.fetchDecodedImage // 在这个方法中创建了producerSequence\n---------> ImagePipeline.submitFetchRequest\n----------> CloseableProducerToDataSourceAdapter<T>.craete\n-----------> new CloseableProducerToDataSourceAdapter\n```\n**featchDecodeImage**\n```java\npublic DataSource<CloseableReference<CloseableImage>> fetchDecodedImage(\n      ImageRequest imageRequest,\n      Object callerContext,\n      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,\n      @Nullable RequestListener requestListener) {\n    try {\n      // 创建Producer序列\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext,\n          requestListener);\n    } catch (Exception exception) {\n      return DataSources.immediateFailedDataSource(exception);\n    }\n}\n```\n\n**CloseableProducerToDataSourceAdapter的构造方法**\n这个构造方法只是简单的调用父类的构造方法\n```java\nprotected AbstractProducerToDataSourceAdapter(\n      Producer<T> producer,\n      SettableProducerContext settableProducerContext,\n      RequestListener requestListener) {\n    \n    mSettableProducerContext = settableProducerContext;\n    mRequestListener = requestListener;\n\n    mRequestListener.onRequestStart(\n        settableProducerContext.getImageRequest(),\n        mSettableProducerContext.getCallerContext(),\n        mSettableProducerContext.getId(),\n        mSettableProducerContext.isPrefetch());\n    if (FrescoSystrace.isTracing()) {\n      FrescoSystrace.endSection();\n    }\n\n    // procuder序列启动\n    producer.produceResults(createConsumer(), settableProducerContext);\n}\n```\n**原来DataSource一创建就会启动produer的工作流程**\n\n## 3. Producer序列的工作流程\n### 3.1 Producer/Consumer的基本概念\n**模板代码**\n```java\npublic class XXXXProducer implements Producer{\n\n    private final Producer mInputProducer;\n\n    public BitmapMemoryCacheProducer(Producer inputProducer) {\n        mInputProducer = inputProducer;\n    }\n\n    @Override\n    public void produceResults(\n        final Consumer consumer,\n        final ProducerContext producerContext) {\n\n        ... 尝试直接得到结果\n        if(已经获取到结果){\n            consumer.onNewResult(result, status);\n            return ;\n        }\n\n        Consumer newConsumer = new DelegatingConsumer(consumer){\n            @Override\n            public void onNewResultImpl(newResult, int status) {\n                ... 处理上一阶段返回的结果\n                if(isLast){\n                    // 将自己处理完成的数据交给上一层producer\n                    // 这里的getConsumer是构造方法传入的consumer, 也就是上一层producer创建的DelegatingConsumer\n                    getConsumer().onNewResult();\n                }\n            }\n        }\n        // 进行下一阶段\n        mInputProducer.produceResults(newConsumer, producerContext);\n    }\n}\n```\n\n**Consumer的onNewResult方法**\nonNewResult会直接调用自己的onNewResultImpl方法\n```java\n@Override\npublic synchronized void onNewResult(@Nullable T newResult, @Status int status) {\n    if (mIsFinished) {\n      return;\n    }\n    mIsFinished = isLast(status);\n    try {\n      onNewResultImpl(newResult, status);\n    } catch (Exception e) {\n      onUnhandledException(e);\n    }\n}\n```\n\n按照这样类似责任链的设计模式, 实际上, 往后加入的producer越晚执行\n\n### 3.2 主要的producer内容梳理\n\n* BitmapMemoryCacheGetProducer\n从内存中获取已解码的图片, 因为是直接从内存中获取可以用的, 所以是即时的, 在UI线程中就可以做\n* BackgroundThreadHandoffProducer\n将任务移交给子线程, 这里仅仅是转移线程而已, 具体的工作在具体的线程中完成\n* BitmapMemoryCacheKeyMultiplexProducer\n将多个拥有相同已解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据\n* BitmapMemoryCacheProducer\n又一次获取内存缓存? 我觉得主要是将下一阶段获取的已解码图片存储到缓存中\n* DecodeProducer\n解码\n* ResizeAndRotateProducer\n旋转, 缩放\n* AddImageTransformMetaProducer\n添加MetaData\n* EncodeCacheKeyMutiplexProducer\n将多个拥有相同未解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据；\n* EncodedMemoryCacheProducer\n查找未解码的图片缓存, 将下一步得到的未解码图片保存到缓存中\n* DiskCacheReadProducer\n读磁盘缓存, 有分MainCache和SmallCache, SmallCache存储小图片, 避免大图片被挤出缓存. 启动task并扔进线程池\n* DiskCacheWriteProducer\n存入磁盘缓存, 同样是在线程池中操作\n* newNetworkFetchProducer\n从网络中获取图片\n\n","slug":"Android/源码解析/Fresco源码解析","published":1,"updated":"2020-03-21T08:38:19.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfdraksf005g8mzmej1qzzro","content":"<h2 id=\"1-介绍：\"><a href=\"#1-介绍：\" class=\"headerlink\" title=\"1. 介绍：\"></a>1. 介绍：</h2><p>fresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。</p><a id=\"more\"></a>\n<ul>\n<li>支持加载网络，本地存储和资源图片；</li>\n<li>提供三级缓存（二级memory和一级internal storage）；</li>\n<li>支持JPEGs，PNGs，GIFs，WEBPs等，还支持Progressive JPEG，优秀的动画支持；</li>\n<li>图片圆角，scale，自定义背景，overlays等等；</li>\n<li>优秀的内存管理, 在安卓低版本中会将缓存保存至特殊区域, 而不是java heap, 从而避免oom；</li>\n</ul>\n<h2 id=\"2-主要组成部分\"><a href=\"#2-主要组成部分\" class=\"headerlink\" title=\"2. 主要组成部分\"></a>2. 主要组成部分</h2><p><img src=\"/images/fresco基本结构.jpg\" alt=\"fresco基本结构\"></p>\n<ul>\n<li>DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由ViewHolder负责。</li>\n<li>DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。</li>\n<li>DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。</li>\n<li>DraweeHolder：统筹管理Hierarchy与DraweeController。</li>\n<li>ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。</li>\n<li>Producer/Consumer：Producer也有很多种，是完成具体工作的类. 它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。</li>\n<li>IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。</li>\n</ul>\n<h2 id=\"3-发起图片请求的主要流程\"><a href=\"#3-发起图片请求的主要流程\" class=\"headerlink\" title=\"3. 发起图片请求的主要流程\"></a>3. 发起图片请求的主要流程</h2><h3 id=\"3-1-流程图\"><a href=\"#3-1-流程图\" class=\"headerlink\" title=\"3.1 流程图\"></a>3.1 流程图</h3><p><img src=\"/images/fresco发起请求的流程.jpg\" alt=\"fresco发起请求的主要流程\"></p>\n<h3 id=\"3-2-源码分析\"><a href=\"#3-2-源码分析\" class=\"headerlink\" title=\"3.2 源码分析\"></a>3.2 源码分析</h3><h4 id=\"3-2-1-DraweeView\"><a href=\"#3-2-1-DraweeView\" class=\"headerlink\" title=\"3.2.1 DraweeView\"></a>3.2.1 DraweeView</h4><p>我们常用的类是SimpleDraweeView, 继承关系如下<br>SimpleDraweeView -&gt; GenericDraweeView -&gt; DraweeView -&gt; ImageView<br><strong>注意: 虽然上述的类都是继承于ImageView的, 但是使用时最好不要调用ImageView本身的任何属性和方法, 不然的话使用不了Fresco的功能</strong></p>\n<ul>\n<li>DraweeView: 持有ViewHolder, ViewHolder管理DraweeController和DraweeHierarchy</li>\n<li>GenericDraweeView: 解析xml属性, 创建DraweeHierarchy</li>\n<li>SimpleDraweeView: 我们一般使用的类, 接受请求, 创建爱你DraweeController</li>\n</ul>\n<p><strong>SimpleDraweeView.setImageURI</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Displays an image given by the uri.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> uri uri of the image</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> callerContext caller context</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageURI</span><span class=\"params\">(Uri uri, @Nullable Object callerContext)</span> </span>&#123;</span><br><span class=\"line\">DraweeController controller =</span><br><span class=\"line\">    mControllerBuilder</span><br><span class=\"line\">        .setCallerContext(callerContext)</span><br><span class=\"line\">        .setUri(uri)</span><br><span class=\"line\">        .setOldController(getController())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">setController(controller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mControllerBuilder在setUri方法中创建了ImageRequest, 在build的过程中构建好了请求, cache, 编码, 解码等流程. 最后setController启动请求流程</p>\n<h4 id=\"3-2-2-DraweeControllerBuilder-build\"><a href=\"#3-2-2-DraweeControllerBuilder-build\" class=\"headerlink\" title=\"3.2.2 DraweeControllerBuilder.build\"></a>3.2.2 DraweeControllerBuilder.build</h4><p>在DraweeControllerBuilder.build方法中创建了DataSource. DataSource类似于Java里的Futures，代表数据的来源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; AbstractDraweeControllerBuilder.build</span><br><span class=\"line\">--&gt; AbstractDraweeControllerBuilder.buildController</span><br><span class=\"line\">----&gt; PipelineDraweeControllerBuilder.obtainController // 创建controller并return</span><br><span class=\"line\">-----&gt; AbstractDraweeControllerBuilder.obtainDataSourceSupplier</span><br><span class=\"line\">------&gt; AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest // 创建了Supplier&lt;DataSource&lt;IMAGE&gt;&gt;, 调用supplier.get方法就会创建Data</span><br><span class=\"line\">Source</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-setController\"><a href=\"#3-2-3-setController\" class=\"headerlink\" title=\"3.2.3 setController\"></a>3.2.3 setController</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; DraweeView.setController</span><br><span class=\"line\">--&gt; DraweeHolder.setController</span><br><span class=\"line\">----&gt; DraweeController.setHierarchy</span><br><span class=\"line\">----&gt; DraweeHolder.attachController</span><br><span class=\"line\">-----&gt; AbstractDraweeController.onAttach</span><br><span class=\"line\">------&gt; AbstractDraweeController.submitRequest</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">submitRequest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T closeableImage = getCachedImage(); <span class=\"comment\">// DataSource还没有start,已经开始获取缓存了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closeableImage != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mDataSource = getDataSource(); <span class=\"comment\">// 获取DataSource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = mId;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> wasImmediate = mDataSource.hasResult();</span><br><span class=\"line\">    <span class=\"comment\">// 注册并处理结果</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> DataSubscriber&lt;T&gt; dataSubscriber =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> BaseDataSubscriber&lt;T&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResultImpl</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isFinished = dataSource.isFinished();</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> hasMultipleResults = dataSource.hasMultipleResults();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> progress = dataSource.getProgress();</span><br><span class=\"line\">            T image = dataSource.getResult();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (image != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              onNewResultInternal(</span><br><span class=\"line\">                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFinished) &#123;</span><br><span class=\"line\">              onFailureInternal(id, dataSource, <span class=\"keyword\">new</span> NullPointerException(), <span class=\"comment\">/* isFinished */</span> <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailureImpl</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDataSource() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的mDataSouceSupplier是controller在创建时有构造方法传入</span></span><br><span class=\"line\">    DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; result = mDataSourceSupplier.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个问题, DataSource是什么时候启动的? 我们在DraweeController.build创建过程中发现创建了Supplier&lt;DataSource&lt;&gt;&gt;,  controller的getDataSource实际上就是从Supplier获取的DataSource</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------&gt; PipelineDraweeControllerBuilder.getDataSourceForRequest</span><br><span class=\"line\">--------&gt; ImagePipeline.fetchDecodedImage // 在这个方法中创建了producerSequence</span><br><span class=\"line\">---------&gt; ImagePipeline.submitFetchRequest</span><br><span class=\"line\">----------&gt; CloseableProducerToDataSourceAdapter&lt;T&gt;.craete</span><br><span class=\"line\">-----------&gt; new CloseableProducerToDataSourceAdapter</span><br></pre></td></tr></table></figure>\n<p><strong>featchDecodeImage</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; fetchDecodedImage(</span><br><span class=\"line\">      ImageRequest imageRequest,</span><br><span class=\"line\">      Object callerContext,</span><br><span class=\"line\">      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,</span><br><span class=\"line\">      <span class=\"meta\">@Nullable</span> RequestListener requestListener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建Producer序列</span></span><br><span class=\"line\">      Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</span><br><span class=\"line\">          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> submitFetchRequest(</span><br><span class=\"line\">          producerSequence,</span><br><span class=\"line\">          imageRequest,</span><br><span class=\"line\">          lowestPermittedRequestLevelOnSubmit,</span><br><span class=\"line\">          callerContext,</span><br><span class=\"line\">          requestListener);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> DataSources.immediateFailedDataSource(exception);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>CloseableProducerToDataSourceAdapter的构造方法</strong><br>这个构造方法只是简单的调用父类的构造方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractProducerToDataSourceAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Producer&lt;T&gt; producer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      SettableProducerContext settableProducerContext,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      RequestListener requestListener)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mSettableProducerContext = settableProducerContext;</span><br><span class=\"line\">    mRequestListener = requestListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    mRequestListener.onRequestStart(</span><br><span class=\"line\">        settableProducerContext.getImageRequest(),</span><br><span class=\"line\">        mSettableProducerContext.getCallerContext(),</span><br><span class=\"line\">        mSettableProducerContext.getId(),</span><br><span class=\"line\">        mSettableProducerContext.isPrefetch());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class=\"line\">      FrescoSystrace.endSection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// procuder序列启动</span></span><br><span class=\"line\">    producer.produceResults(createConsumer(), settableProducerContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>原来DataSource一创建就会启动produer的工作流程</strong></p>\n<h2 id=\"3-Producer序列的工作流程\"><a href=\"#3-Producer序列的工作流程\" class=\"headerlink\" title=\"3. Producer序列的工作流程\"></a>3. Producer序列的工作流程</h2><h3 id=\"3-1-Producer-Consumer的基本概念\"><a href=\"#3-1-Producer-Consumer的基本概念\" class=\"headerlink\" title=\"3.1 Producer/Consumer的基本概念\"></a>3.1 Producer/Consumer的基本概念</h3><p><strong>模板代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXXProducer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Producer</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Producer mInputProducer;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BitmapMemoryCacheProducer</span><span class=\"params\">(Producer inputProducer)</span> </span>&#123;</span><br><span class=\"line\">        mInputProducer = inputProducer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produceResults</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">final</span> Consumer consumer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">final</span> ProducerContext producerContext)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... 尝试直接得到结果</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(已经获取到结果)&#123;</span><br><span class=\"line\">            consumer.onNewResult(result, status);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer newConsumer = <span class=\"keyword\">new</span> DelegatingConsumer(consumer)&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResultImpl</span><span class=\"params\">(newResult, <span class=\"keyword\">int</span> status)</span> </span>&#123;</span><br><span class=\"line\">                ... 处理上一阶段返回的结果</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isLast)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 将自己处理完成的数据交给上一层producer</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里的getConsumer是构造方法传入的consumer, 也就是上一层producer创建的DelegatingConsumer</span></span><br><span class=\"line\">                    getConsumer().onNewResult();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 进行下一阶段</span></span><br><span class=\"line\">        mInputProducer.produceResults(newConsumer, producerContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Consumer的onNewResult方法</strong><br>onNewResult会直接调用自己的onNewResultImpl方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResult</span><span class=\"params\">(@Nullable T newResult, @Status <span class=\"keyword\">int</span> status)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsFinished) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mIsFinished = isLast(status);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      onNewResultImpl(newResult, status);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      onUnhandledException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按照这样类似责任链的设计模式, 实际上, 往后加入的producer越晚执行</p>\n<h3 id=\"3-2-主要的producer内容梳理\"><a href=\"#3-2-主要的producer内容梳理\" class=\"headerlink\" title=\"3.2 主要的producer内容梳理\"></a>3.2 主要的producer内容梳理</h3><ul>\n<li>BitmapMemoryCacheGetProducer<br>从内存中获取已解码的图片, 因为是直接从内存中获取可以用的, 所以是即时的, 在UI线程中就可以做</li>\n<li>BackgroundThreadHandoffProducer<br>将任务移交给子线程, 这里仅仅是转移线程而已, 具体的工作在具体的线程中完成</li>\n<li>BitmapMemoryCacheKeyMultiplexProducer<br>将多个拥有相同已解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据</li>\n<li>BitmapMemoryCacheProducer<br>又一次获取内存缓存? 我觉得主要是将下一阶段获取的已解码图片存储到缓存中</li>\n<li>DecodeProducer<br>解码</li>\n<li>ResizeAndRotateProducer<br>旋转, 缩放</li>\n<li>AddImageTransformMetaProducer<br>添加MetaData</li>\n<li>EncodeCacheKeyMutiplexProducer<br>将多个拥有相同未解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据；</li>\n<li>EncodedMemoryCacheProducer<br>查找未解码的图片缓存, 将下一步得到的未解码图片保存到缓存中</li>\n<li>DiskCacheReadProducer<br>读磁盘缓存, 有分MainCache和SmallCache, SmallCache存储小图片, 避免大图片被挤出缓存. 启动task并扔进线程池</li>\n<li>DiskCacheWriteProducer<br>存入磁盘缓存, 同样是在线程池中操作</li>\n<li>newNetworkFetchProducer<br>从网络中获取图片</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-介绍：\"><a href=\"#1-介绍：\" class=\"headerlink\" title=\"1. 介绍：\"></a>1. 介绍：</h2><p>fresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。</p>","more":"\n<ul>\n<li>支持加载网络，本地存储和资源图片；</li>\n<li>提供三级缓存（二级memory和一级internal storage）；</li>\n<li>支持JPEGs，PNGs，GIFs，WEBPs等，还支持Progressive JPEG，优秀的动画支持；</li>\n<li>图片圆角，scale，自定义背景，overlays等等；</li>\n<li>优秀的内存管理, 在安卓低版本中会将缓存保存至特殊区域, 而不是java heap, 从而避免oom；</li>\n</ul>\n<h2 id=\"2-主要组成部分\"><a href=\"#2-主要组成部分\" class=\"headerlink\" title=\"2. 主要组成部分\"></a>2. 主要组成部分</h2><p><img src=\"/images/fresco基本结构.jpg\" alt=\"fresco基本结构\"></p>\n<ul>\n<li>DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由ViewHolder负责。</li>\n<li>DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。</li>\n<li>DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。</li>\n<li>DraweeHolder：统筹管理Hierarchy与DraweeController。</li>\n<li>ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。</li>\n<li>Producer/Consumer：Producer也有很多种，是完成具体工作的类. 它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。</li>\n<li>IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。</li>\n</ul>\n<h2 id=\"3-发起图片请求的主要流程\"><a href=\"#3-发起图片请求的主要流程\" class=\"headerlink\" title=\"3. 发起图片请求的主要流程\"></a>3. 发起图片请求的主要流程</h2><h3 id=\"3-1-流程图\"><a href=\"#3-1-流程图\" class=\"headerlink\" title=\"3.1 流程图\"></a>3.1 流程图</h3><p><img src=\"/images/fresco发起请求的流程.jpg\" alt=\"fresco发起请求的主要流程\"></p>\n<h3 id=\"3-2-源码分析\"><a href=\"#3-2-源码分析\" class=\"headerlink\" title=\"3.2 源码分析\"></a>3.2 源码分析</h3><h4 id=\"3-2-1-DraweeView\"><a href=\"#3-2-1-DraweeView\" class=\"headerlink\" title=\"3.2.1 DraweeView\"></a>3.2.1 DraweeView</h4><p>我们常用的类是SimpleDraweeView, 继承关系如下<br>SimpleDraweeView -&gt; GenericDraweeView -&gt; DraweeView -&gt; ImageView<br><strong>注意: 虽然上述的类都是继承于ImageView的, 但是使用时最好不要调用ImageView本身的任何属性和方法, 不然的话使用不了Fresco的功能</strong></p>\n<ul>\n<li>DraweeView: 持有ViewHolder, ViewHolder管理DraweeController和DraweeHierarchy</li>\n<li>GenericDraweeView: 解析xml属性, 创建DraweeHierarchy</li>\n<li>SimpleDraweeView: 我们一般使用的类, 接受请求, 创建爱你DraweeController</li>\n</ul>\n<p><strong>SimpleDraweeView.setImageURI</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Displays an image given by the uri.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> uri uri of the image</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> callerContext caller context</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageURI</span><span class=\"params\">(Uri uri, @Nullable Object callerContext)</span> </span>&#123;</span><br><span class=\"line\">DraweeController controller =</span><br><span class=\"line\">    mControllerBuilder</span><br><span class=\"line\">        .setCallerContext(callerContext)</span><br><span class=\"line\">        .setUri(uri)</span><br><span class=\"line\">        .setOldController(getController())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">setController(controller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mControllerBuilder在setUri方法中创建了ImageRequest, 在build的过程中构建好了请求, cache, 编码, 解码等流程. 最后setController启动请求流程</p>\n<h4 id=\"3-2-2-DraweeControllerBuilder-build\"><a href=\"#3-2-2-DraweeControllerBuilder-build\" class=\"headerlink\" title=\"3.2.2 DraweeControllerBuilder.build\"></a>3.2.2 DraweeControllerBuilder.build</h4><p>在DraweeControllerBuilder.build方法中创建了DataSource. DataSource类似于Java里的Futures，代表数据的来源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; AbstractDraweeControllerBuilder.build</span><br><span class=\"line\">--&gt; AbstractDraweeControllerBuilder.buildController</span><br><span class=\"line\">----&gt; PipelineDraweeControllerBuilder.obtainController // 创建controller并return</span><br><span class=\"line\">-----&gt; AbstractDraweeControllerBuilder.obtainDataSourceSupplier</span><br><span class=\"line\">------&gt; AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest // 创建了Supplier&lt;DataSource&lt;IMAGE&gt;&gt;, 调用supplier.get方法就会创建Data</span><br><span class=\"line\">Source</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-setController\"><a href=\"#3-2-3-setController\" class=\"headerlink\" title=\"3.2.3 setController\"></a>3.2.3 setController</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; DraweeView.setController</span><br><span class=\"line\">--&gt; DraweeHolder.setController</span><br><span class=\"line\">----&gt; DraweeController.setHierarchy</span><br><span class=\"line\">----&gt; DraweeHolder.attachController</span><br><span class=\"line\">-----&gt; AbstractDraweeController.onAttach</span><br><span class=\"line\">------&gt; AbstractDraweeController.submitRequest</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">submitRequest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T closeableImage = getCachedImage(); <span class=\"comment\">// DataSource还没有start,已经开始获取缓存了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closeableImage != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mDataSource = getDataSource(); <span class=\"comment\">// 获取DataSource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = mId;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> wasImmediate = mDataSource.hasResult();</span><br><span class=\"line\">    <span class=\"comment\">// 注册并处理结果</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> DataSubscriber&lt;T&gt; dataSubscriber =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> BaseDataSubscriber&lt;T&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResultImpl</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isFinished = dataSource.isFinished();</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> hasMultipleResults = dataSource.hasMultipleResults();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> progress = dataSource.getProgress();</span><br><span class=\"line\">            T image = dataSource.getResult();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (image != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              onNewResultInternal(</span><br><span class=\"line\">                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFinished) &#123;</span><br><span class=\"line\">              onFailureInternal(id, dataSource, <span class=\"keyword\">new</span> NullPointerException(), <span class=\"comment\">/* isFinished */</span> <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailureImpl</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDataSource() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的mDataSouceSupplier是controller在创建时有构造方法传入</span></span><br><span class=\"line\">    DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; result = mDataSourceSupplier.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个问题, DataSource是什么时候启动的? 我们在DraweeController.build创建过程中发现创建了Supplier&lt;DataSource&lt;&gt;&gt;,  controller的getDataSource实际上就是从Supplier获取的DataSource</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------&gt; PipelineDraweeControllerBuilder.getDataSourceForRequest</span><br><span class=\"line\">--------&gt; ImagePipeline.fetchDecodedImage // 在这个方法中创建了producerSequence</span><br><span class=\"line\">---------&gt; ImagePipeline.submitFetchRequest</span><br><span class=\"line\">----------&gt; CloseableProducerToDataSourceAdapter&lt;T&gt;.craete</span><br><span class=\"line\">-----------&gt; new CloseableProducerToDataSourceAdapter</span><br></pre></td></tr></table></figure>\n<p><strong>featchDecodeImage</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; fetchDecodedImage(</span><br><span class=\"line\">      ImageRequest imageRequest,</span><br><span class=\"line\">      Object callerContext,</span><br><span class=\"line\">      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,</span><br><span class=\"line\">      <span class=\"meta\">@Nullable</span> RequestListener requestListener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建Producer序列</span></span><br><span class=\"line\">      Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</span><br><span class=\"line\">          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> submitFetchRequest(</span><br><span class=\"line\">          producerSequence,</span><br><span class=\"line\">          imageRequest,</span><br><span class=\"line\">          lowestPermittedRequestLevelOnSubmit,</span><br><span class=\"line\">          callerContext,</span><br><span class=\"line\">          requestListener);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> DataSources.immediateFailedDataSource(exception);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>CloseableProducerToDataSourceAdapter的构造方法</strong><br>这个构造方法只是简单的调用父类的构造方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractProducerToDataSourceAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Producer&lt;T&gt; producer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      SettableProducerContext settableProducerContext,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      RequestListener requestListener)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mSettableProducerContext = settableProducerContext;</span><br><span class=\"line\">    mRequestListener = requestListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    mRequestListener.onRequestStart(</span><br><span class=\"line\">        settableProducerContext.getImageRequest(),</span><br><span class=\"line\">        mSettableProducerContext.getCallerContext(),</span><br><span class=\"line\">        mSettableProducerContext.getId(),</span><br><span class=\"line\">        mSettableProducerContext.isPrefetch());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class=\"line\">      FrescoSystrace.endSection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// procuder序列启动</span></span><br><span class=\"line\">    producer.produceResults(createConsumer(), settableProducerContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>原来DataSource一创建就会启动produer的工作流程</strong></p>\n<h2 id=\"3-Producer序列的工作流程\"><a href=\"#3-Producer序列的工作流程\" class=\"headerlink\" title=\"3. Producer序列的工作流程\"></a>3. Producer序列的工作流程</h2><h3 id=\"3-1-Producer-Consumer的基本概念\"><a href=\"#3-1-Producer-Consumer的基本概念\" class=\"headerlink\" title=\"3.1 Producer/Consumer的基本概念\"></a>3.1 Producer/Consumer的基本概念</h3><p><strong>模板代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXXProducer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Producer</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Producer mInputProducer;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BitmapMemoryCacheProducer</span><span class=\"params\">(Producer inputProducer)</span> </span>&#123;</span><br><span class=\"line\">        mInputProducer = inputProducer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produceResults</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">final</span> Consumer consumer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">final</span> ProducerContext producerContext)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... 尝试直接得到结果</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(已经获取到结果)&#123;</span><br><span class=\"line\">            consumer.onNewResult(result, status);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer newConsumer = <span class=\"keyword\">new</span> DelegatingConsumer(consumer)&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResultImpl</span><span class=\"params\">(newResult, <span class=\"keyword\">int</span> status)</span> </span>&#123;</span><br><span class=\"line\">                ... 处理上一阶段返回的结果</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isLast)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 将自己处理完成的数据交给上一层producer</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里的getConsumer是构造方法传入的consumer, 也就是上一层producer创建的DelegatingConsumer</span></span><br><span class=\"line\">                    getConsumer().onNewResult();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 进行下一阶段</span></span><br><span class=\"line\">        mInputProducer.produceResults(newConsumer, producerContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Consumer的onNewResult方法</strong><br>onNewResult会直接调用自己的onNewResultImpl方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResult</span><span class=\"params\">(@Nullable T newResult, @Status <span class=\"keyword\">int</span> status)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsFinished) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mIsFinished = isLast(status);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      onNewResultImpl(newResult, status);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      onUnhandledException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按照这样类似责任链的设计模式, 实际上, 往后加入的producer越晚执行</p>\n<h3 id=\"3-2-主要的producer内容梳理\"><a href=\"#3-2-主要的producer内容梳理\" class=\"headerlink\" title=\"3.2 主要的producer内容梳理\"></a>3.2 主要的producer内容梳理</h3><ul>\n<li>BitmapMemoryCacheGetProducer<br>从内存中获取已解码的图片, 因为是直接从内存中获取可以用的, 所以是即时的, 在UI线程中就可以做</li>\n<li>BackgroundThreadHandoffProducer<br>将任务移交给子线程, 这里仅仅是转移线程而已, 具体的工作在具体的线程中完成</li>\n<li>BitmapMemoryCacheKeyMultiplexProducer<br>将多个拥有相同已解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据</li>\n<li>BitmapMemoryCacheProducer<br>又一次获取内存缓存? 我觉得主要是将下一阶段获取的已解码图片存储到缓存中</li>\n<li>DecodeProducer<br>解码</li>\n<li>ResizeAndRotateProducer<br>旋转, 缩放</li>\n<li>AddImageTransformMetaProducer<br>添加MetaData</li>\n<li>EncodeCacheKeyMutiplexProducer<br>将多个拥有相同未解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据；</li>\n<li>EncodedMemoryCacheProducer<br>查找未解码的图片缓存, 将下一步得到的未解码图片保存到缓存中</li>\n<li>DiskCacheReadProducer<br>读磁盘缓存, 有分MainCache和SmallCache, SmallCache存储小图片, 避免大图片被挤出缓存. 启动task并扔进线程池</li>\n<li>DiskCacheWriteProducer<br>存入磁盘缓存, 同样是在线程池中操作</li>\n<li>newNetworkFetchProducer<br>从网络中获取图片</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckfdrakpy00038mzmsnix8a1w","category_id":"ckfdrakq300058mzmhohjbncw","_id":"ckfdrakqc000f8mzmyq3eca6g"},{"post_id":"ckfdrakq100048mzmwgqbfyru","category_id":"ckfdrakq300058mzmhohjbncw","_id":"ckfdrakqe000j8mzmggp3ewoa"},{"post_id":"ckfdrakqf000m8mzm81uz56qx","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqj000u8mzm8yglntkg"},{"post_id":"ckfdrakq500078mzms9at9vp0","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqk000y8mzmwwpu6cja"},{"post_id":"ckfdrakqh000r8mzm76viv80k","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakql00108mzmq23e4aq8"},{"post_id":"ckfdrakq700098mzm84rt7hid","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakql00128mzm7njwcv1r"},{"post_id":"ckfdrakqj000x8mzmuv7x5oyx","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqm00158mzmk01vptf3"},{"post_id":"ckfdrakqb000c8mzmqg0w0x2p","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqm00188mzma8mpsgf7"},{"post_id":"ckfdrakqk000z8mzmat0hw7rx","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqm001b8mzmrogkw00n"},{"post_id":"ckfdrakqc000h8mzmif6fe1y1","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqn001d8mzmekx8pp4s"},{"post_id":"ckfdrakqc000h8mzmif6fe1y1","category_id":"ckfdrakql00118mzmqueldp8e","_id":"ckfdrakqo001f8mzmn32pma0l"},{"post_id":"ckfdrakq400068mzmcfbh0mgc","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqo001i8mzm3gurtpf7"},{"post_id":"ckfdrakq400068mzmcfbh0mgc","category_id":"ckfdrakqm00168mzms4yl0epm","_id":"ckfdrakqp001l8mzmi9h7yldc"},{"post_id":"ckfdrakqd000i8mzm1yb9ui6l","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqp001n8mzmoaouiqj8"},{"post_id":"ckfdrakqd000i8mzm1yb9ui6l","category_id":"ckfdrakql00118mzmqueldp8e","_id":"ckfdrakqp001p8mzm3jlrfmjx"},{"post_id":"ckfdrakqg000o8mzmmc4orls1","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqp001q8mzmunhdkh9r"},{"post_id":"ckfdrakqg000o8mzmmc4orls1","category_id":"ckfdrakql00118mzmqueldp8e","_id":"ckfdrakqq001s8mzmaw6v9szi"},{"post_id":"ckfdrakqi000t8mzmcirjmq70","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakqq001u8mzmhvrvozzo"},{"post_id":"ckfdrakqi000t8mzmcirjmq70","category_id":"ckfdrakql00118mzmqueldp8e","_id":"ckfdrakqq001x8mzmbkv1lhhr"},{"post_id":"ckfdrakr2002i8mzma4xiwyz9","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakr5002p8mzm68j55jrh"},{"post_id":"ckfdrakr4002l8mzmu3h6jp8k","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakr7002u8mzmnzpmzfc7"},{"post_id":"ckfdrakr4002n8mzmapxgol0g","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakr8002x8mzmm20l13ic"},{"post_id":"ckfdrakr3002j8mzmbl2flq0a","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakr900308mzmeu9lcrji"},{"post_id":"ckfdrakr3002j8mzmbl2flq0a","category_id":"ckfdrakr5002o8mzmlhp3kj7r","_id":"ckfdrakra00338mzmunwnv7np"},{"post_id":"ckfdrakr6002t8mzmcc4ga6wr","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakrb00368mzmsfxk3k64"},{"post_id":"ckfdrakr6002t8mzmcc4ga6wr","category_id":"ckfdrakql00118mzmqueldp8e","_id":"ckfdrakrc00398mzmovmubmtg"},{"post_id":"ckfdrakr8002w8mzmpmfucx7z","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakrd003c8mzm8r93a51f"},{"post_id":"ckfdrakra00328mzmcqh1x92w","category_id":"ckfdrakrb00378mzmhwoummw5","_id":"ckfdrakrg003i8mzmgu6coobi"},{"post_id":"ckfdrakrc003a8mzmnosh8q05","category_id":"ckfdrakrg003k8mzmlfe2bx03","_id":"ckfdrakrl003v8mzm5o2osq7m"},{"post_id":"ckfdrakrj003r8mzmogcw9h5r","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakrl00408mzmc2iuf56g"},{"post_id":"ckfdrakrj003r8mzmogcw9h5r","category_id":"ckfdrakql00118mzmqueldp8e","_id":"ckfdrakrm00438mzmaoe7a3y3"},{"post_id":"ckfdrakrc00388mzmtsddv9g0","category_id":"ckfdrakre003e8mzmiqnvisu7","_id":"ckfdrakrm00468mzmjyfcmi2w"},{"post_id":"ckfdrakrc00388mzmtsddv9g0","category_id":"ckfdrakri003q8mzm9zh4e5ia","_id":"ckfdrakrn00498mzmh34t1i7x"},{"post_id":"ckfdrakrf003h8mzmtk7jiaxn","category_id":"ckfdrakrl003x8mzmgn3zkw2b","_id":"ckfdrakrn004a8mzmhnscqhy5"},{"post_id":"ckfdrakrg003l8mzm8apkv0lb","category_id":"ckfdrakrl003x8mzmgn3zkw2b","_id":"ckfdrakrn004d8mzmd8q99g15"},{"post_id":"ckfdrakri003o8mzmir4zw1q7","category_id":"ckfdrakrn00488mzmd2ku1aoc","_id":"ckfdrakro004f8mzmvkcpo8au"},{"post_id":"ckfdraks3004s8mzmg6wr6f0d","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraks7004x8mzmhrq6e7jb"},{"post_id":"ckfdraks5004t8mzmx9v5kof4","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraks8004z8mzmwfbn6gxo"},{"post_id":"ckfdraks6004v8mzmo4b2h1dk","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraks900528mzmelksiq9a"},{"post_id":"ckfdraks7004w8mzmgpsfdk7y","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraksa00548mzmymj4vydt"},{"post_id":"ckfdraks8004y8mzmtbcgugo1","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraksc00578mzmtxjzsgce"},{"post_id":"ckfdraks900518mzmavos1qva","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraksd005a8mzmhnyhp1go"},{"post_id":"ckfdraksa00538mzmj6pom8qz","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdrakse005e8mzmqa4kvjx1"},{"post_id":"ckfdraksc00568mzmvd69htc3","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraksf005h8mzmgwtnezdr"},{"post_id":"ckfdraksd00598mzm7r3qz8t7","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraksg005k8mzm343ruqmr"},{"post_id":"ckfdrakse005d8mzm1ijjqkzb","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraksg005n8mzmr99xkipn"},{"post_id":"ckfdrakse005d8mzm1ijjqkzb","category_id":"ckfdrakql00118mzmqueldp8e","_id":"ckfdraksh005q8mzmohja3r6i"},{"post_id":"ckfdraksf005g8mzmej1qzzro","category_id":"ckfdrakqc000e8mzmalkng1mt","_id":"ckfdraksh005s8mzmu6x7x2ht"}],"PostTag":[{"post_id":"ckfdrakq400068mzmcfbh0mgc","tag_id":"ckfdrakq600088mzmqime9t13","_id":"ckfdrakqc000g8mzmqojrneks"},{"post_id":"ckfdrakq500078mzms9at9vp0","tag_id":"ckfdrakqc000d8mzmb3o1dwbw","_id":"ckfdrakqf000n8mzm943noduk"},{"post_id":"ckfdrakq700098mzm84rt7hid","tag_id":"ckfdrakqe000k8mzm3zpo8b8s","_id":"ckfdrakqi000s8mzmjoxl8ngv"},{"post_id":"ckfdrakqk000z8mzmat0hw7rx","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakqm00148mzme3kuqovv"},{"post_id":"ckfdrakqa000b8mzmzbuw69cw","tag_id":"ckfdrakqh000q8mzme8yyj5oz","_id":"ckfdrakqm00178mzml59t87u9"},{"post_id":"ckfdrakqa000b8mzmzbuw69cw","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakqm001a8mzmxqt71x4u"},{"post_id":"ckfdrakqb000c8mzmqg0w0x2p","tag_id":"ckfdrakql00138mzmfzbbcps3","_id":"ckfdrakqo001g8mzmcyq8hmsv"},{"post_id":"ckfdrakqb000c8mzmqg0w0x2p","tag_id":"ckfdrakqm00198mzmjqogrv68","_id":"ckfdrakqo001j8mzmu6i7sjun"},{"post_id":"ckfdrakqc000h8mzmif6fe1y1","tag_id":"ckfdrakqh000q8mzme8yyj5oz","_id":"ckfdrakqq001t8mzmpfsykvgr"},{"post_id":"ckfdrakqc000h8mzmif6fe1y1","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakqq001v8mzmsiprgmzy"},{"post_id":"ckfdrakqc000h8mzmif6fe1y1","tag_id":"ckfdrakqp001o8mzmdqojv75m","_id":"ckfdrakqq001y8mzm4lk3cjo5"},{"post_id":"ckfdrakqd000i8mzm1yb9ui6l","tag_id":"ckfdrakqh000q8mzme8yyj5oz","_id":"ckfdrakqr00208mzm09lzrl1d"},{"post_id":"ckfdrakqd000i8mzm1yb9ui6l","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakqr00218mzmympq76cy"},{"post_id":"ckfdrakqf000m8mzm81uz56qx","tag_id":"ckfdrakqr001z8mzmb5822h0w","_id":"ckfdrakqr00248mzm4oyddwvp"},{"post_id":"ckfdrakqf000m8mzm81uz56qx","tag_id":"ckfdrakqm00198mzmjqogrv68","_id":"ckfdrakqs00258mzmtwxr2v14"},{"post_id":"ckfdrakqg000o8mzmmc4orls1","tag_id":"ckfdrakqr00238mzm25iakapo","_id":"ckfdrakqs00288mzm2kasw33d"},{"post_id":"ckfdrakqg000o8mzmmc4orls1","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakqs00298mzm8vxj3b6x"},{"post_id":"ckfdrakqh000r8mzm76viv80k","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakqt002c8mzmlyhcguxq"},{"post_id":"ckfdrakqh000r8mzm76viv80k","tag_id":"ckfdrakqp001o8mzmdqojv75m","_id":"ckfdrakqt002d8mzmcmdz4hdn"},{"post_id":"ckfdrakqi000t8mzmcirjmq70","tag_id":"ckfdrakqh000q8mzme8yyj5oz","_id":"ckfdrakqt002f8mzmweluqy2v"},{"post_id":"ckfdrakqi000t8mzmcirjmq70","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakqt002g8mzmpftc7zoi"},{"post_id":"ckfdrakqj000x8mzmuv7x5oyx","tag_id":"ckfdrakqt002e8mzmxxbr2bki","_id":"ckfdrakqu002h8mzm8wwv1z04"},{"post_id":"ckfdrakr2002i8mzma4xiwyz9","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakr3002k8mzmro4k0it8"},{"post_id":"ckfdrakr4002l8mzmu3h6jp8k","tag_id":"ckfdrakqm00198mzmjqogrv68","_id":"ckfdrakr5002q8mzmbuzol475"},{"post_id":"ckfdrakr4002n8mzmapxgol0g","tag_id":"ckfdrakqp001o8mzmdqojv75m","_id":"ckfdrakr6002s8mzmsdzcx9hm"},{"post_id":"ckfdrakr3002j8mzmbl2flq0a","tag_id":"ckfdrakr4002m8mzmd78zot05","_id":"ckfdrakr7002v8mzmz56913fj"},{"post_id":"ckfdrakr6002t8mzmcc4ga6wr","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakr9002y8mzmm7rxo1nu"},{"post_id":"ckfdrakr8002w8mzmpmfucx7z","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakr900318mzmb7unqty1"},{"post_id":"ckfdrakr9002z8mzmp569zurq","tag_id":"ckfdrakqh000q8mzme8yyj5oz","_id":"ckfdrakrg003j8mzmnato6x4t"},{"post_id":"ckfdrakr9002z8mzmp569zurq","tag_id":"ckfdrakra00348mzm8dgh6nei","_id":"ckfdrakrh003m8mzmpm2jdbg6"},{"post_id":"ckfdrakr9002z8mzmp569zurq","tag_id":"ckfdrakrd003b8mzm04ir4rqg","_id":"ckfdrakri003p8mzmfyeiz0nq"},{"post_id":"ckfdrakra00328mzmcqh1x92w","tag_id":"ckfdrakrf003g8mzm97nq4vn4","_id":"ckfdrakrj003s8mzm34nc161r"},{"post_id":"ckfdrakrj003r8mzmogcw9h5r","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdrakrl003w8mzmcsqzuvh3"},{"post_id":"ckfdrakrk003u8mzmbkx2l28n","tag_id":"ckfdrakrf003g8mzm97nq4vn4","_id":"ckfdrakrl003y8mzmkg3l1z0h"},{"post_id":"ckfdrakrb00358mzmm87g1ol9","tag_id":"ckfdrakrf003g8mzm97nq4vn4","_id":"ckfdrakrm00418mzmkayovxb4"},{"post_id":"ckfdrakrb00358mzmm87g1ol9","tag_id":"ckfdrakrj003t8mzmnwkderx7","_id":"ckfdrakrm00448mzmvjo0mj4y"},{"post_id":"ckfdrakrc00388mzmtsddv9g0","tag_id":"ckfdrakrl003z8mzmoyf4ddfb","_id":"ckfdrakrn00478mzmn86xxscz"},{"post_id":"ckfdrakrc003a8mzmnosh8q05","tag_id":"ckfdrakrm00458mzmyyj9thcx","_id":"ckfdrakrn004c8mzmnt9uazic"},{"post_id":"ckfdrakrd003d8mzmy4j6bptd","tag_id":"ckfdrakrn004b8mzmfreucw1y","_id":"ckfdrakro004g8mzmgylrab4z"},{"post_id":"ckfdrakre003f8mzmwv38on8b","tag_id":"ckfdrakro004e8mzma3o34crb","_id":"ckfdrakro004i8mzm9xguf8eg"},{"post_id":"ckfdrakrf003h8mzmtk7jiaxn","tag_id":"ckfdrakro004e8mzma3o34crb","_id":"ckfdrakrp004l8mzm7x8gmjwr"},{"post_id":"ckfdrakrf003h8mzmtk7jiaxn","tag_id":"ckfdrakrp004j8mzmdx4f2j7i","_id":"ckfdrakrp004m8mzmpzhvdm7s"},{"post_id":"ckfdrakrg003l8mzm8apkv0lb","tag_id":"ckfdrakrp004k8mzmuyv1qm9j","_id":"ckfdrakrq004p8mzmmtyps9dz"},{"post_id":"ckfdrakrg003l8mzm8apkv0lb","tag_id":"ckfdrakro004e8mzma3o34crb","_id":"ckfdrakrq004q8mzmwqpvywmv"},{"post_id":"ckfdrakri003o8mzmir4zw1q7","tag_id":"ckfdrakrq004o8mzm2c5nprzs","_id":"ckfdrakrr004r8mzmyjzljwur"},{"post_id":"ckfdraks3004s8mzmg6wr6f0d","tag_id":"ckfdraks6004u8mzmvaaxji69","_id":"ckfdraksc00588mzmzb1wmrsr"},{"post_id":"ckfdraks3004s8mzmg6wr6f0d","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksd005b8mzmnaunv5e9"},{"post_id":"ckfdraksc00568mzmvd69htc3","tag_id":"ckfdrakql00138mzmfzbbcps3","_id":"ckfdrakse005f8mzmz5lal25x"},{"post_id":"ckfdraksc00568mzmvd69htc3","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksf005i8mzmu1q61mjc"},{"post_id":"ckfdrakse005d8mzm1ijjqkzb","tag_id":"ckfdrakqj000w8mzmsc5d1szu","_id":"ckfdraksg005l8mzmb8siyr4w"},{"post_id":"ckfdrakse005d8mzm1ijjqkzb","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksg005m8mzmfgnyahqf"},{"post_id":"ckfdraks5004t8mzmx9v5kof4","tag_id":"ckfdraks6004u8mzmvaaxji69","_id":"ckfdraksg005p8mzmbpqepw4l"},{"post_id":"ckfdraks5004t8mzmx9v5kof4","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksh005r8mzm61cr6t0v"},{"post_id":"ckfdraks6004v8mzmo4b2h1dk","tag_id":"ckfdraksf005j8mzmnpk635wt","_id":"ckfdraksh005u8mzmyl095y8n"},{"post_id":"ckfdraks6004v8mzmo4b2h1dk","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksh005v8mzm7iq2jjc0"},{"post_id":"ckfdraks7004w8mzmgpsfdk7y","tag_id":"ckfdraksf005j8mzmnpk635wt","_id":"ckfdraksi005y8mzm1qnbwjyd"},{"post_id":"ckfdraks7004w8mzmgpsfdk7y","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksi005z8mzmxhyjrsnh"},{"post_id":"ckfdraks8004y8mzmtbcgugo1","tag_id":"ckfdraksf005j8mzmnpk635wt","_id":"ckfdraksj00628mzm2pbz5j7o"},{"post_id":"ckfdraks8004y8mzmtbcgugo1","tag_id":"ckfdraksj00608mzmeajbk8ay","_id":"ckfdraksj00638mzmpmlwf95j"},{"post_id":"ckfdraks900518mzmavos1qva","tag_id":"ckfdraksf005j8mzmnpk635wt","_id":"ckfdraksk00658mzmc311btzg"},{"post_id":"ckfdraks900518mzmavos1qva","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksk00668mzmho1xqiq5"},{"post_id":"ckfdraksa00538mzmj6pom8qz","tag_id":"ckfdraksf005j8mzmnpk635wt","_id":"ckfdraksk00688mzmmehtlbvz"},{"post_id":"ckfdraksa00538mzmj6pom8qz","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksk00698mzm5zev6aa4"},{"post_id":"ckfdraksd00598mzm7r3qz8t7","tag_id":"ckfdraksk00678mzm9i236ccr","_id":"ckfdraksl006b8mzmfh2f5ota"},{"post_id":"ckfdraksd00598mzm7r3qz8t7","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksl006c8mzmnnkyd5uv"},{"post_id":"ckfdraksf005g8mzmej1qzzro","tag_id":"ckfdraksk006a8mzm1bks1q8v","_id":"ckfdraksl006d8mzmxqvkv24c"},{"post_id":"ckfdraksf005g8mzmej1qzzro","tag_id":"ckfdraks800508mzmzesov5jt","_id":"ckfdraksl006e8mzmat8fhbwn"}],"Tag":[{"name":"AndroidStudio","_id":"ckfdrakq600088mzmqime9t13"},{"name":"Activity","_id":"ckfdrakqc000d8mzmb3o1dwbw"},{"name":"注解","_id":"ckfdrakqe000k8mzm3zpo8b8s"},{"name":"Android","_id":"ckfdrakqh000q8mzme8yyj5oz"},{"name":"View","_id":"ckfdrakqj000w8mzmsc5d1szu"},{"name":"Handler","_id":"ckfdrakql00138mzmfzbbcps3"},{"name":"内存泄露","_id":"ckfdrakqm00198mzmjqogrv68"},{"name":"RecyclerView","_id":"ckfdrakqp001o8mzmdqojv75m"},{"name":"MVP","_id":"ckfdrakqr001z8mzmb5822h0w"},{"name":"Animation","_id":"ckfdrakqr00238mzm25iakapo"},{"name":"Gradle","_id":"ckfdrakqt002e8mzmxxbr2bki"},{"name":"Service","_id":"ckfdrakr4002m8mzmd78zot05"},{"name":"Notification","_id":"ckfdrakra00348mzm8dgh6nei"},{"name":"Uri","_id":"ckfdrakrd003b8mzm04ir4rqg"},{"name":"Flutter","_id":"ckfdrakrf003g8mzm97nq4vn4"},{"name":"RenderObject","_id":"ckfdrakrj003t8mzmnwkderx7"},{"name":"多线程","_id":"ckfdrakrl003z8mzmoyf4ddfb"},{"name":"Kotlin","_id":"ckfdrakrm00458mzmyyj9thcx"},{"name":"jni","_id":"ckfdrakrn004b8mzmfreucw1y"},{"name":"Linux","_id":"ckfdrakro004e8mzma3o34crb"},{"name":"Docker","_id":"ckfdrakrp004j8mzmdx4f2j7i"},{"name":"mysql","_id":"ckfdrakrp004k8mzmuyv1qm9j"},{"name":"Java","_id":"ckfdrakrq004o8mzm2c5nprzs"},{"name":"glide","_id":"ckfdraks6004u8mzmvaaxji69"},{"name":"源码解析","_id":"ckfdraks800508mzmzesov5jt"},{"name":"okhttp3","_id":"ckfdraksf005j8mzmnpk635wt"},{"name":"源码分析","_id":"ckfdraksj00608mzmeajbk8ay"},{"name":"Okhttp3","_id":"ckfdraksk00678mzm9i236ccr"},{"name":"Fresco","_id":"ckfdraksk006a8mzm1bks1q8v"}]}}