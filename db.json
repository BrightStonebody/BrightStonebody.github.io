{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/push.sh","path":"push.sh","modified":1,"renderable":0},{"_id":"source/images/Gradle的构建过程.jpg","path":"images/Gradle的构建过程.jpg","modified":1,"renderable":0},{"_id":"source/images/Text相关计算.webp","path":"images/Text相关计算.webp","modified":1,"renderable":0},{"_id":"source/images/mysql_iptables.png","path":"images/mysql_iptables.png","modified":1,"renderable":0},{"_id":"source/images/startService and bindService.jpg","path":"images/startService and bindService.jpg","modified":1,"renderable":0},{"_id":"source/images/flutter相关属性和android的对应关系.webp","path":"images/flutter相关属性和android的对应关系.webp","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"source/images/fresco基本结构.jpg","path":"images/fresco基本结构.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"source/images/fresco发起请求的流程.jpg","path":"images/fresco发起请求的流程.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"source/push.sh","hash":"9b904e17d4a6e015e04df31078afa655e2af10b0","modified":1633226261038},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1633226261055},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1633226261058},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1633226261055},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1633226261055},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1633226261058},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1633226261058},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1633226261058},{"_id":"themes/next/README.md","hash":"a0430372844df9caea6e9bf96492775ed42a4578","modified":1633226261058},{"_id":"themes/next/_config.yml","hash":"68c179ec4f462873f41c8b7747ccfb48258cdcaa","modified":1633226261059},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1633226261059},{"_id":"themes/next/package.json","hash":"b7fd0a53c7cb4c40c6f236065bfed34e6188e786","modified":1633226261075},{"_id":"themes/next/gulpfile.js","hash":"72e6d5a6e32d5f95d82e4c4d0c963d39555bb760","modified":1633226261062},{"_id":"source/categories/index.md","hash":"79a24c099c0611ec4db9c83dee34941ea6eb0ea6","modified":1633226261032},{"_id":"source/_posts/编译aosp.md","hash":"f8f575daa41a06608ac4355d6e29f5bef249061c","modified":1633226261032},{"_id":"source/notes/boostnote.json","hash":"1d8c7454808e612994ea23361819e2f544c21b99","modified":1633226261038},{"_id":"source/images/Gradle的构建过程.jpg","hash":"4ab64f9e14ad5b25623c820e8855d6e97d9cfcb0","modified":1633226261032},{"_id":"source/images/Text相关计算.webp","hash":"2bc79f17b9a2be8663fe5bbc8487ccfceccc3627","modified":1633226261033},{"_id":"source/images/mysql_iptables.png","hash":"9b8dc491c73623b28c41b1581c728c696ecd365e","modified":1633226261038},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1633226261056},{"_id":"source/images/startService and bindService.jpg","hash":"e22213c4dec3f59761079a0a219ffcbbfe640ec8","modified":1633226261038},{"_id":"source/tags/index.md","hash":"ad018fd214859a5a59b26ad4e49645698e82e3dc","modified":1633226261038},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"838201a0284e90843cd8e762e290c9bd7f10e993","modified":1633226261056},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"2a4ff75ccb91d9001032c08e22489096b850bf4f","modified":1633226261057},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1633226261057},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1633226261057},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1633226261057},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1633226261057},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1633226261057},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"b09c85aa449f46bc025317ed196ec33a877f7c23","modified":1633226261057},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1633226261057},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1633226261058},{"_id":"themes/next/.github/stale.yml","hash":"941209526c2f7d916c76163c9e1ac1af9d956679","modified":1633226261057},{"_id":"themes/next/docs/DATA-FILES.md","hash":"d0d46cb265f0efceffce82214cd36d8b82ddce13","modified":1633226261059},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1633226261059},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"5b4c013e0598b3211ebd899265936cfdaf7c139f","modified":1633226261059},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1633226261059},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1633226261059},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1633226261060},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"08cda41b4bcf687facfda19ab39718ec7a05ae54","modified":1633226261060},{"_id":"themes/next/docs/MATH.md","hash":"f520b336f16665e164d6edf075bdcc6aa17b31bc","modified":1633226261060},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"199e9ef3cb5928af0fe801d03d2d1aeea704cea4","modified":1633226261060},{"_id":"themes/next/languages/es.yml","hash":"7dc1d7d5ea1078ee3b9bc8e0e8d0f15f52a7a4aa","modified":1633226261063},{"_id":"themes/next/languages/en.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1633226261062},{"_id":"themes/next/languages/de.yml","hash":"3d8920676d89494d7d1c74d4238680151ea6d9df","modified":1633226261062},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1633226261062},{"_id":"themes/next/languages/hu.yml","hash":"e4a5f43fb45acd992def3de3b600aa4df4c95ed7","modified":1633226261063},{"_id":"themes/next/languages/fa.yml","hash":"269b5cb70774485d7dbbcf98eec72c9e84e135b2","modified":1633226261063},{"_id":"themes/next/languages/fr.yml","hash":"dfdcfa536c40d06125dff373d042c50e08fcafd8","modified":1633226261063},{"_id":"themes/next/languages/it.yml","hash":"311597c620059dbb99474f19b2110a4485ecf70b","modified":1633226261063},{"_id":"themes/next/languages/ja.yml","hash":"4f929842b3d6aaed709ea99da679d3910ee184e5","modified":1633226261063},{"_id":"themes/next/languages/id.yml","hash":"5665dece8435964a27b5061d7283f339f84721f0","modified":1633226261063},{"_id":"themes/next/languages/ko.yml","hash":"5f5194dd0f5a3c8484e7668bce6fbe23340e531a","modified":1633226261063},{"_id":"themes/next/languages/nl.yml","hash":"561c77ca68e9d51a5ce8c89d3361fdb033c96bba","modified":1633226261064},{"_id":"themes/next/languages/pt-BR.yml","hash":"13b579911e44a8b213e1860f9a50c341be1bf95e","modified":1633226261064},{"_id":"themes/next/languages/pt.yml","hash":"af9d9b581dca45ab9789ca41d3492883a911e383","modified":1633226261064},{"_id":"themes/next/languages/ru.yml","hash":"b485c57dd7b447406dafd0dcfdfc9356266708c9","modified":1633226261064},{"_id":"themes/next/languages/tr.yml","hash":"39caf8a3677fd6dfbd523e73f8482a509e87b603","modified":1633226261064},{"_id":"themes/next/languages/vi.yml","hash":"3c6bb816ee7278afcddac06998c9ebe47ee19aef","modified":1633226261064},{"_id":"themes/next/languages/uk.yml","hash":"4cbdbb0ed09487c9b435be21ac35f62182f53283","modified":1633226261064},{"_id":"themes/next/languages/zh-CN.yml","hash":"e92e1e07a89c9fab27f445f9ec0fa35049fef38c","modified":1633226261064},{"_id":"themes/next/languages/zh-HK.yml","hash":"93d10d6e448c519004b09b11fba980b5036c93af","modified":1633226261064},{"_id":"themes/next/languages/zh-TW.yml","hash":"ae2aa1c6ec1a5a01a3a3bde17bcc3a82f9a35fa7","modified":1633226261065},{"_id":"themes/next/layout/_layout.swig","hash":"512bdf6787b5d9fb1d40b126b0fa8e6f1018d1cd","modified":1633226261065},{"_id":"themes/next/layout/category.swig","hash":"c55debb2588e4746b02d31ec249bf0a84fdea260","modified":1633226261074},{"_id":"themes/next/layout/index.swig","hash":"3bc6fb1e9707d74b96e1346d3f03fe6584f764f4","modified":1633226261074},{"_id":"themes/next/layout/page.swig","hash":"e61d64c055b6497a04affc143f47fdd0a6dc495b","modified":1633226261075},{"_id":"themes/next/layout/tag.swig","hash":"7ff6e34d557a3da1c6a29ecd97842bf73ff213dc","modified":1633226261075},{"_id":"themes/next/layout/post.swig","hash":"382d9f9a9b35e1f369585f7f9f9b5dd6fa58d2f0","modified":1633226261075},{"_id":"themes/next/layout/archive.swig","hash":"59155648f6306888077d1f1d635f63177b36148d","modified":1633226261074},{"_id":"source/_posts/技术Owner的职责.md","hash":"26feab0944858a72a40a312b03e8b526e871bfd3","modified":1638000580100},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1633226261077},{"_id":"source/images/flutter相关属性和android的对应关系.webp","hash":"a474163ef56cd229069c4187a10e783937832536","modified":1633226261033},{"_id":"source/_posts/Java/Java获取泛型类型.md","hash":"9e495f8181558b12eb474c233202f9ecff38fd50","modified":1633226261031},{"_id":"source/_posts/Java/Jni入门.md","hash":"0d7b2495f71b802b54b2da3e3888e367006bb4f3","modified":1633226261031},{"_id":"source/_posts/Java/ThreadLocal.md","hash":"c7ce7dceb51513b75f50c7496418a145b7c2cce8","modified":1633226261031},{"_id":"source/_posts/C/多个cpp文件编译共享同一个-h文件的全局变量.md","hash":"25980caac2bba406b579b8e4a1ba67514bafede3","modified":1633226261030},{"_id":"source/_posts/C/C语言结构体的内存对齐.md","hash":"ae476f35a0e2f6f66078468ca4bc164e8cbd6175","modified":1633226261030},{"_id":"source/_posts/Android/Activity-class-does-not-exist.md","hash":"d5287902384cce9e534833df0b3adc7f9745649c","modified":1633226261022},{"_id":"source/_posts/Android/Activity管理类的封装.md","hash":"de1f2119fff62f1d1d6ecd463c45b7b6c228d98c","modified":1633226261022},{"_id":"source/_posts/Android/Android自定义注解.md","hash":"b2f6b6145abce8c62f1747a909cd4dccbff75e3a","modified":1633226261022},{"_id":"source/_posts/Android/Fragment可见性总结.md","hash":"e8e741544bce4827a531824ad30891ed676f462b","modified":1633226261022},{"_id":"source/_posts/Android/RecyclerView缓存机制总结.md","hash":"8233a49afac982e7fbe9cca9229d9b4a9477d93a","modified":1633226261024},{"_id":"source/_posts/Android/RecyclerView设置item的间距.md","hash":"cc8ecaa5225d60a5052f328662f4e9611c106131","modified":1633226261025},{"_id":"source/_posts/Android/RemoteView刷新View.md","hash":"53f1d5673a4a56a2de5a7cce6368d02e42e470c0","modified":1633226261025},{"_id":"source/_posts/Android/Scale动画组合使用的坑.md","hash":"0d7411367dcdac80bcd4481a8b751f4a633136ca","modified":1633226261025},{"_id":"source/_posts/Android/Handler防止内存泄露.md","hash":"841fc57855133870eabae43a7cb3669dcc2c26a1","modified":1633226261024},{"_id":"source/_posts/Android/Text相关计算.md","hash":"574957924eed0f9f5815d462587b72031043c6a6","modified":1633226261025},{"_id":"source/_posts/Android/LayoutInflater解析.md","hash":"4ac3249fc7d52ac0625ff4fda6482be63be5c6f9","modified":1633226261024},{"_id":"source/_posts/Android/ViewDragHelper的使用.md","hash":"61279079206df47c0d27aa7be4d7332b449a49f9","modified":1633226261026},{"_id":"source/_posts/Android/ViewModel-LiveData和LifeCricle.md","hash":"177b66a00e063d81e124feaf4e61bbea4d894fab","modified":1633226261027},{"_id":"source/_posts/Android/scrollBy-scrollTo-和Scroller.md","hash":"1e698ef72e13593249e66b3019ff689ad76a8547","modified":1633226261028},{"_id":"source/_posts/Android/kotlin协程.md","hash":"5969a7f5bfc0aa099d4d4c154e569e0db42a47d3","modified":1633226261027},{"_id":"source/_posts/Android/外部View随着RecyclerView的滚动而显示或隐藏.md","hash":"9b1e9a135890d8f6927a70874ef6f837195d8744","modified":1633226261028},{"_id":"source/_posts/Android/nested2嵌套滚动机制.md","hash":"a33f280e255abbfdc32b71db81bed61c3244b503","modified":1633226261028},{"_id":"source/_posts/Android/自定义LayoutManager.md","hash":"9e90a0b84b1cb590e1c5cc3da4fff1f3be964445","modified":1633226261030},{"_id":"source/_posts/Android/自定义ViewGroup.md","hash":"b84521614cbf2d9f71474f274b9ba987631125b4","modified":1633226261030},{"_id":"source/_posts/Android/自动滚播TextView.md","hash":"b4d081ef74402cd6a07ceaf5ce5eaadbe6c91aac","modified":1633226261029},{"_id":"source/_posts/Android/通知铃声的自定义遇到的问题-根据uri读取文件.md","hash":"790aaad1100db5ebd887f658ec099c5ce68fbe8f","modified":1633228020346},{"_id":"source/_posts/Java/jvm虚拟机.md","hash":"295a86482e601ab1ae01ac42d8dd009b8caef176","modified":1649350674279},{"_id":"source/_posts/Java/HashMap.md","hash":"b56b33cfccc2492dd1b047d5fe2dd42c20893cb1","modified":1649061577579},{"_id":"source/_posts/Java/ConcurrentHashMap.md","hash":"7c317c71f0228f4a9fba7ebf54876488600dad05","modified":1649151831079},{"_id":"source/_posts/Flutter/flutter-ui源码-初步.md","hash":"9bfae703578916702e654de11f38d73020411738","modified":1633226261031},{"_id":"source/_posts/Flutter/redux源码.md","hash":"58db843d8d296287430168ef96d60f3105f2ba80","modified":1633226261031},{"_id":"source/_posts/Flutter/RenderObject-原理.md","hash":"0d1e59991a602b94210667af15782d2e113f9f93","modified":1633226261031},{"_id":"source/_posts/Flutter/Flutter中常用布局和Android的对应关系.md","hash":"515592e374c7de62e0ecc415617fd775b17fc4d1","modified":1633226261030},{"_id":"source/_posts/Linux/apt常用命令.md","hash":"8cacf9e93680ced7ffc2697597210fc110abff9b","modified":1633226261031},{"_id":"source/_posts/Linux/docker的使用.md","hash":"6f01489de5c21520e7943842d6ead31a9886d2a3","modified":1633226261032},{"_id":"source/_posts/Linux/mysql配置相关.md","hash":"d123a1f405190cb72cce2aeb4e0a4530eb9a5b3b","modified":1633226261032},{"_id":"source/_posts/Kotlin/kotlin-flow.md","hash":"bb204943f7fa8c64602f4916170a2e443390b5aa","modified":1649659580728},{"_id":"source/_posts/Kotlin/协程上下文和异常传播.md","hash":"2c2b22088268ee0c4c3c2190f50447b697b6ebda","modified":1649696172838},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"35a9e1469962a9a163abd0b83677a412516272ef","modified":1633226261056},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"bf8b10715f5529cc6997501d821307895710ba58","modified":1633226261056},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6d79701dd0bb3757722650d9df30eeaacd83344e","modified":1633226261056},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"a0601577b77b8ad89742dc99f98edebf9cc45c10","modified":1633226261056},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"2665f6a9d72090f9452a8811544ff2596e8899be","modified":1633226261060},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"fe3f5cda1975114884d84bef384a562920d70335","modified":1633226261061},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1633226261060},{"_id":"themes/next/docs/ru/README.md","hash":"7302b2e5318c0c13e6484aa6487be29599ebc2b2","modified":1633226261061},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"ebacdc94f6f9724a7c6ef7c3cdde41ff7c37931a","modified":1633226261061},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"3b4dbf0d2ca12ab442b7e0e227769ce100b8a444","modified":1633226261061},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"4245fe9472647226692fcbdd5a52d6e6dcd251bc","modified":1633226261061},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"3ef324cee2761da762eaa5d8d9b9f9601dc264bc","modified":1633226261061},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1633226261061},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"264d131b8865bae069f8e4d78a33a0f59d28e36b","modified":1633226261062},{"_id":"themes/next/docs/zh-CN/README.md","hash":"1766bd2e528ec148d3c5dd55e6be55449fcda94e","modified":1633226261062},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"2d60a18340c9260cd4dc81fe8acc7983d6b2d011","modified":1633226261062},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"8109a531d3a7f5a306e36d4304c11f0c7c180c87","modified":1633226261062},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"815676d904f92748ddf4f529bed2baf066997bc6","modified":1633226261065},{"_id":"themes/next/layout/_macro/post.swig","hash":"e80d07467dcd614e940451737f4c1eaab8c8d272","modified":1633226261065},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1116597ae81c391981f3a8b80fa6febe5796583d","modified":1633226261065},{"_id":"themes/next/layout/_partials/comments.swig","hash":"3a72e3d72980fa0944008b36b284b044d0e84b2a","modified":1633226261065},{"_id":"themes/next/layout/_partials/footer.swig","hash":"ee6ae67a3c7b99ee768afbd36882390b9f4db5b0","modified":1633226261066},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"b9d3f6534efb9e637ac46318fa07c2e5607bf830","modified":1633226261067},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1633226261069},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1633226261069},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1633226261069},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1633226261070},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"9675acc599ffa546f05a60375c1637b0327be4fd","modified":1633226261069},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1633226261071},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1633226261072},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"4abfcb5dae0e6dec5e288baa3a9fe4065829b392","modified":1633226261072},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1633226261070},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1633226261073},{"_id":"themes/next/scripts/events/index.js","hash":"ac2945693791e62a3046248f2a511afadcaebc16","modified":1633226261075},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1633226261077},{"_id":"themes/next/scripts/filters/locals.js","hash":"6794137c0a019b09bc277a564a7c12b522893650","modified":1633226261077},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1633226261077},{"_id":"themes/next/scripts/helpers/engine.js","hash":"b357cbc5d5b39b1bb5221149e7d358135a7ba56d","modified":1633226261077},{"_id":"themes/next/scripts/filters/post.js","hash":"3c1e483c2c4a1c5a2f9a99b81ce0fda5fd21926b","modified":1633226261077},{"_id":"themes/next/scripts/helpers/font.js","hash":"32268fb4c59c5b37c1eb1c9582ab630e09e5cc7d","modified":1633226261077},{"_id":"themes/next/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1633226261078},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"e60e6c0aaa979d42b01685ba2a03a76fa6e059e2","modified":1633226261077},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1633226261078},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1633226261078},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"8fc05f22b88553bc1d96e0c925799cd97920fc6a","modified":1633226261078},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"fad54f0e9e225a70390209f63d9b3cc566a5ebcb","modified":1633226261078},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1633226261078},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1633226261078},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1633226261078},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1633226261078},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1633226261079},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1633226261079},{"_id":"themes/next/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1633226261091},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1633226261092},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1633226261092},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1633226261092},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1633226261092},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1633226261092},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1633226261093},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1633226261093},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1633226261093},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1633226261093},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1633226261093},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1633226261094},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1633226261094},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1633226261094},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1633226261094},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1633226261094},{"_id":"themes/next/source/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1633226261095},{"_id":"themes/next/source/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1633226261095},{"_id":"themes/next/source/js/next-boot.js","hash":"a6a82905c6abb8e0ec418ef6b0509b946b955807","modified":1633226261095},{"_id":"themes/next/source/js/motion.js","hash":"71e5caff1d87b1b7256f61e6b318bedf495f9e75","modified":1633226261095},{"_id":"themes/next/source/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1633226261095},{"_id":"themes/next/source/js/utils.js","hash":"a2984bf0631756a904cd43f8e3a8f6fb15b9ceb5","modified":1633226261096},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1633226261096},{"_id":"source/_posts/Android/Framework/handler机制源码解析.md","hash":"a243214a032e5b52ccec21f61bf7db73053e9945","modified":1633226261022},{"_id":"source/_posts/Android/Framework/startService-和bindService.md","hash":"5a727647ac03713390f997482fb511aea1b05f00","modified":1633226261023},{"_id":"source/_posts/Android/Framework/屏幕刷新机制.md","hash":"9df49fa0682b933847e7423e98c3296a83a21154","modified":1633226261023},{"_id":"source/_posts/Android/Framework/源码探究Activity的生命周期.md","hash":"478cd87fecfddc2125e314a4bc4a567f89c11dec","modified":1633226261023},{"_id":"source/_posts/Android/Framework/Binder源码笔记.md","hash":"10ad0fa94a99689f84bbc4d0c6370bf97f596b99","modified":1636468140433},{"_id":"source/_posts/Android/Framework/事件分发机制.md","hash":"463f4cc0814e8a309eaccfe1c248cbaddee0e062","modified":1637125751990},{"_id":"source/_posts/Android/Framework/应用进程是如何启动的.md","hash":"7e2506d556c4cbce6757c94ac75db17d1676f43d","modified":1651478091567},{"_id":"source/_posts/Android/Framework/InputManagerService.md","hash":"3b9f4839ce36dbde8c3951ac93002c182dfd9cd8","modified":1634565704909},{"_id":"source/_posts/Android/Framework/MultiDex原理.md","hash":"44aaf65cb35850bea39e8596b2b54bfe332635d2","modified":1640430246178},{"_id":"source/_posts/Android/gradle/gradle相关基础.md","hash":"98315145e112e0ae29f7c232ff64f8fb41a6a794","modified":1647764796104},{"_id":"source/_posts/Android/Framework/RequestLayout和Invalidate.md","hash":"ebcb790a457c79db20897957efb5be73a32d025a","modified":1651488782324},{"_id":"source/_posts/Android/gradle/自定义注解处理器并发布为gradle组件.md","hash":"20e6b6cf7fe3825df643450e01bfc036a2946b82","modified":1647162655158},{"_id":"source/_posts/Android/gradle/自定义gradle插件.md","hash":"b1b06040ad3d3faa8be5161bd177f64f4410cb7a","modified":1651654402297},{"_id":"source/_posts/Android/gradle/transform和asm初探.md","hash":"10e6dee8b30a270a489a68f072d800c238dbb5f1","modified":1651654241638},{"_id":"source/_posts/Android/源码解析/Glide源码-缓存机制.md","hash":"341b22ae64ceeb6d364ba0122692d435cb71c8e3","modified":1633226261028},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-CacheInterceptor.md","hash":"ff3c9309b30f404a7925472871b2cda13b7732cd","modified":1633226261029},{"_id":"source/_posts/Android/源码解析/Glide源码-主要流程.md","hash":"243c4ad838aa9193485edbc48b6e8d447ede30ca","modified":1633226261028},{"_id":"source/_posts/Android/源码解析/Fresco源码解析.md","hash":"04651ad66299074b34b4f8efc27efdaefc080d4a","modified":1645874333511},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor.md","hash":"b25c018d5544af20ff29ec9cf791552071953507","modified":1633226261029},{"_id":"source/_posts/Android/源码解析/Retrofit源码解析.md","hash":"bd0b98cdb70365cedfd9809473d2ab37b55f225d","modified":1655224033144},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-责任链的分析.md","hash":"8419f0836bc402a9b75c6c3b10a85fe3a91e5d04","modified":1633226261029},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-ConnectInterceptor.md","hash":"a40125b2fd611865ef70b4fac320310098b16c10","modified":1633226261029},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-CallServerInterceptor.md","hash":"45a46ac02727e10dd4ddfab75e316a4ff773a2de","modified":1633226261029},{"_id":"source/_posts/Android/源码解析/OkHttp3源码-发起请求的主要流程.md","hash":"15c015e95289cddc5ee02bd8420e66c22456e054","modified":1655016894364},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1633226261087},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1633226261087},{"_id":"source/images/fresco基本结构.jpg","hash":"e0db204389df9e7cf9624f48a283e9e11449e487","modified":1633226261037},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"f5d2c5a3421ae52888be62e2c837459d1175cc93","modified":1633226261066},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"7487ca8f0e4b16351ea0d6b35dc52b0d32176d57","modified":1633226261066},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"0f4565e123e2ceccaff08316bc38151cda7fcbc4","modified":1633226261066},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"30528a8da30994b1ef9355a72b09b2cd85a7c0e9","modified":1633226261066},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"ff33b5797f5e4b5cbcb3c222c17bc636c6b88df6","modified":1633226261067},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d488664bc16608b5f829f959c2058b4381be244a","modified":1633226261067},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"fbec9f77139e1f300509c38446416b4b26350cfa","modified":1633226261067},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"a56e4f6ad95c106f361d354f828d1ef4810b1d76","modified":1633226261067},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1633226261067},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1633226261068},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"becfa683c3e5409e20cdb7b1dc8a6db331bddefe","modified":1633226261067},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"7fa01334a0ba84500e920bb9202baa08067d2ee1","modified":1633226261068},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1633226261068},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"733d6874aa4f50d1071e670a554508a5a0094eb3","modified":1633226261068},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"bebf630963c1c65fd152859a1ba316b03be17cce","modified":1633226261068},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1633226261068},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"6aead2977147b7054a35c4865cac8544f3394b4f","modified":1633226261069},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"246ff123cbaa507f23514c0c51c6cc006685898e","modified":1633226261069},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1633226261070},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1633226261070},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1633226261070},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1633226261070},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"194201cce870c1af6f5123a62cb766cd24e46217","modified":1633226261070},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1633226261070},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1633226261071},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1633226261071},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1633226261071},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1633226261071},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1633226261072},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1633226261072},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"fb27a38f9a4b8fcba4f637b03904f7a83cc73416","modified":1633226261072},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"1130b8bd60f3b84397974486e6586d7f0afaf836","modified":1633226261071},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"fe3cdd70224bd0c8171513a5dfed7b85deb7f23d","modified":1633226261071},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"9719cb5858896aef86c2e0bec0ace259936680c4","modified":1633226261071},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"8063f65cdaae80840fcf427b875ae606f678dfa5","modified":1633226261072},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f95bc4d7ffaddc3c0df0ef3eeeaac58ff83f560","modified":1633226261072},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"a9c8e7987b63b9ef66e47b966aea05ac77ff920a","modified":1633226261072},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"e456d7a2aaabe55447f78cd952b30d70a6c1e742","modified":1633226261073},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1633226261073},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1633226261073},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1633226261073},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1633226261073},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"67e63c25d509f02a6057ee9724f1b6efd647f72f","modified":1633226261073},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"ac6a3995c1330d2d73300b2427006509d0f8dba5","modified":1633226261073},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"7f2941d119abca6627561fb010dad96fa48d2092","modified":1633226261074},{"_id":"themes/next/layout/_third-party/statistics/tencent-analytics.swig","hash":"493a1ef6c8f475d4dd3156a6ab37690dc75695ea","modified":1633226261074},{"_id":"themes/next/layout/_third-party/statistics/tencent-mta.swig","hash":"198813a3f382bda4278fe3759bf0f18a5769bb33","modified":1633226261074},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"4958fa997ff6df2b2ce05341f40cc3a81b0f91bb","modified":1633226261074},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"7fa72dc60c078842979861622839b109683e05a3","modified":1633226261074},{"_id":"themes/next/scripts/events/lib/config.js","hash":"246e55d48f2f3ef510c11594c7c08ddb93ac0928","modified":1633226261075},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1633226261075},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"311a54c0a0b6192502e68ce8c0b20e77aed3b996","modified":1633226261076},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1fc2a94b94108175848ba9541d05898c071386d0","modified":1633226261076},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1633226261076},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1633226261076},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"d2ce60980fc148bfb877981aabd07bf45d2cdcda","modified":1633226261076},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"c081166868e6428a07c51c5674b86b7a4cc9c2a8","modified":1633226261076},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1633226261076},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"3c4bdc2a682f9889a532e1cb856bc5caeb4208e1","modified":1633226261076},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"5201cd09a5e263282ccbf205f07d46f4c6d3f700","modified":1633226261076},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1633226261087},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1633226261087},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0a25f3df1b5c39794365efde387647da81da884a","modified":1633226261088},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"b9d7058db61df7bbd2b58779efe45621a06ffc18","modified":1633226261090},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c261d685c5ed0df34718d94bb2ba977c0ed443e6","modified":1633226261091},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"52550138127ae9ebbe049bcdacd94d767c003855","modified":1633226261090},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"50bc57e66331c0f15a4527010b4ca3316ac92403","modified":1633226261091},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"bb31a17d34c9dd6f9e5082fa56955c71e32c2722","modified":1633226261091},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d8e861f2ecc1954ab8c44942fb8404b0693e1849","modified":1633226261091},{"_id":"themes/next/source/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1633226261096},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1633226261096},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1633226261097},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1633226261097},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1633226261097},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1633226261097},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1633226261097},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1633226261102},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1633226261102},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"990bd301ce2de0a6b936781c58318f3945d81bc2","modified":1633226261083},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"80d359661d08b80ad561b97f8508766b3e1f6d01","modified":1633226261079},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1633226261083},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"47ee915d7b0a97e74140a25fbfc01c04d6781534","modified":1633226261079},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"112f5e8f1fe5cec4419e87acfbdef0e615ed23f3","modified":1633226261079},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"170c4598cbbe49cd1527f94158d97d2320a6b906","modified":1633226261081},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"41c7cd1b63d49476ed5fbdd26ab9411d8f44bd05","modified":1633226261081},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"d8ba44b8e1a0332c5c1079ff65fc83d2918a5865","modified":1633226261085},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1633226261085},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2067e15799a3a3cda8bfe7782d67a4dc42f1ef79","modified":1633226261085},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1633226261086},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1633226261086},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1633226261086},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f3c5f1dadc01042381444102d35174dacc6f079a","modified":1633226261086},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1633226261087},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1633226261089},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1633226261089},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"08c2679a31f195940fe1e6c76e64799fb21cda99","modified":1633226261088},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"316ee13fc26d327c8862c2455211144c180cf9c1","modified":1633226261089},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1633226261089},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"eeab294e14abbae231107e1a327e907b25323136","modified":1633226261089},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1633226261089},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4341f0e057b42e8c47629bb3196fca3b49f0cc19","modified":1633226261088},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"24a086a6904bbf5355a354403c9b0e6069f7eb01","modified":1633226261088},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"48743ac61af37a4de2026667e15a65de5e8cf542","modified":1633226261088},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e321bd62f5e04d1fdc101a470ec13604e99816a5","modified":1633226261088},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1633226261088},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"f1f81bca31e82ccbd375f0cb9fb8dbb3beac810d","modified":1633226261089},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f5abb2ea7746586738fb4e82107fceed041708ee","modified":1633226261089},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"c0ed534696ed86560c95ab2a3541b2b42a41ed39","modified":1633226261090},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c59226767164285d6708d8762f937f93bab264ca","modified":1633226261090},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0424a1fcffa1ae82fe70935972a894aca885bf9a","modified":1633226261090},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1633226261090},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1633226261098},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1633226261099},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1633226261099},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1633226261101},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"0672ea2acf28dcc2cfc5244da36d3387d71a17cb","modified":1633226261082},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1633226261082},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"5528a755b180312d008054653633d857aeeb6780","modified":1633226261082},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"4b237e2344f35e9d1f6dbc3842d5e432d478ebfd","modified":1633226261083},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b5ba1b3d5535ccf1e5df6f4cd8ee0147d7278be9","modified":1633226261083},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1633226261083},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"d5d85d3646d184e0340924addcfd2523fb289d00","modified":1633226261083},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a7ed54e2f52185a7b6bb9a8201f6c3aa74b0cb00","modified":1633226261083},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"cc4beedb56c37246d9e0f74e4b2cc34231dabc65","modified":1633226261084},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1633226261084},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1633226261083},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1633226261084},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1633226261084},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"1db4ce981fe9fcb9ee4279395c29553efbb43947","modified":1633226261084},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"e2ad7ccf1865a45548e3f31c70fac2c65d6ef534","modified":1633226261084},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"eaa62b5de4ddb18378c1a4049a172d4fa4b655d8","modified":1633226261084},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1633226261084},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"9a18b186b08ec220d1b17cf83812bcdd06077814","modified":1633226261084},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1633226261079},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1633226261080},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6336c2b129db802221b1fd75e5fbe8aab85c0a1f","modified":1633226261080},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1633226261079},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1633226261079},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1633226261080},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"602a3c3d2785965b23412b5c219dfe74b5fb0844","modified":1633226261080},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"98227b4de364b48b11e21efcf4f1beb2ed3ab329","modified":1633226261080},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"4b84f35e7040f9adb5cc540c366d7f9eb4c48bcc","modified":1633226261080},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"3566136c06d96b34e1e7a3eca72fb0f40a63af80","modified":1633226261080},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2e2a09dddd2a394a635bcefb6207b6cddcb784c7","modified":1633226261080},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"d557a0de91a428330b43cdae9f1ec7167d24e2e4","modified":1633226261080},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"f8ba308231cf81453e41457796e94f1ce886d855","modified":1633226261081},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1633226261081},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1633226261081},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1633226261081},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"5248880398c1318624bdab95109c1c9fdb8eec02","modified":1633226261081},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1633226261082},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1633226261082},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1633226261081},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1633226261082},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2d9d68a431a334626d463bb1bdfbcd2ea8242e94","modified":1633226261082},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"2b536832cfc81667dadd9603c8c700e44d458261","modified":1633226261085},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1633226261085},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"4b980363822c24b3ad85c271719210a8ad2b646e","modified":1633226261085},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1633226261085},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1633226261086},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"879f9cec9c88d65b2e31af4346b2bc0f6941f05d","modified":1633226261086},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"5bf28a03ef021c27cfd713971caca5a0b9466fd1","modified":1633226261086},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"068b304be305fbfd0220276d56b93cefd968f0b6","modified":1633226261087},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1633226261087},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"419fa6cfc103d08dfd6a385ab7f24468c644d581","modified":1633226261087},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1633226261087},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1633226261101},{"_id":"source/images/fresco发起请求的流程.jpg","hash":"cbbd3d068fc5a39146539504ce3f2d435ad9adbb","modified":1633226261036},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1633226261100},{"_id":"public/notes/boostnote.json","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1655224043856},{"_id":"public/atom.xml","hash":"2900c4f3b350c1dda54d31d7392a4f462cd0cf16","modified":1655224043857},{"_id":"public/content.json","hash":"86e111772e432926ee142a3e5516399a97be275a","modified":1655224043858},{"_id":"public/search.xml","hash":"3f47335e2864b8823468b49c09117314d82f590f","modified":1655224043875},{"_id":"public/sitemap.xml","hash":"5eb9bb637989074ade6b76e277b01d099620642e","modified":1655224043875},{"_id":"public/categories/index.html","hash":"564539675be642d6c4138f954fd98d0eebcc91f3","modified":1655224043908},{"_id":"public/tags/index.html","hash":"2c1b8875f96afcabf00fff2f6be3640ee667649f","modified":1655224043908},{"_id":"public/2022/04/11/Kotlin/协程上下文和异常传播/index.html","hash":"8b9cb4c18f250facc0a9a562d48d89712a10c4e7","modified":1655224043909},{"_id":"public/2022/04/07/Java/jvm虚拟机/index.html","hash":"dae94ceb73abbff98071e052c85a4abe1203aad2","modified":1655224043909},{"_id":"public/2021/12/25/Android/Framework/MultiDex原理/index.html","hash":"2703c56c65c401af6c6eaf8d72086997ba6396c7","modified":1655224043909},{"_id":"public/2021/11/27/技术Owner的职责/index.html","hash":"ad9e182e69d6171fb8220d49b495a3bb005df8ee","modified":1655224043909},{"_id":"public/2021/10/18/Android/Framework/InputManagerService/index.html","hash":"72b9dfa9732ccc6be972f6a925513bd97ed58e05","modified":1655224043909},{"_id":"public/2020/10/04/Android/Fragment可见性总结/index.html","hash":"e00a0c6241004c96c83c4e07b76268df543b74e0","modified":1655224043909},{"_id":"public/2020/02/26/Flutter/Flutter中常用布局和Android的对应关系/index.html","hash":"dab17c8f69df1143daf5bbe643831fb64aaa5c0c","modified":1655224043909},{"_id":"public/2019/09/15/Android/RemoteView刷新View/index.html","hash":"0d5baec15c5ff84eff931278407bc2cb579cdcfa","modified":1655224043909},{"_id":"public/2019/07/19/Android/Text相关计算/index.html","hash":"35b17991cdeb6aeea6cf33bf684b572f1d666759","modified":1655224043909},{"_id":"public/2019/05/02/Linux/apt常用命令/index.html","hash":"eda780fbc06b0bd6eb28dab4d4ee3fe321384c5d","modified":1655224043909},{"_id":"public/2019/04/16/Android/Activity-class-does-not-exist/index.html","hash":"09c9e4d3e680a52118e7f56d95f1027d17b15530","modified":1655224043909},{"_id":"public/archives/index.html","hash":"b69895bee39ae345f788426f09ea3645c7393719","modified":1655224043909},{"_id":"public/archives/page/2/index.html","hash":"2eff3b1a4d2af97c14a27250295598b276cef043","modified":1655224043909},{"_id":"public/archives/page/3/index.html","hash":"e94cbc163a0aa4efbaf838f20aeb6f228e5fc5c2","modified":1655224043909},{"_id":"public/archives/page/4/index.html","hash":"e91a61302ed60546c34f050e45b524fe68164d32","modified":1655224043909},{"_id":"public/archives/page/5/index.html","hash":"835df806a0a6bbcf2e58197b72b636cf8fc8fda7","modified":1655224043909},{"_id":"public/archives/2019/index.html","hash":"c2510c231ed601e46410b6c7817a612a8d2afa74","modified":1655224043909},{"_id":"public/archives/page/7/index.html","hash":"83241909f8738d27b861b3cbf91320ff5862c572","modified":1655224043909},{"_id":"public/archives/2019/page/2/index.html","hash":"97ff14c96df3d2cea56e62531dcf38e9bb2103c4","modified":1655224043909},{"_id":"public/archives/2019/page/3/index.html","hash":"87e128c57cdf7853d300583990b2bbc809f64277","modified":1655224043910},{"_id":"public/archives/2019/page/4/index.html","hash":"f8c58d3183d2c3191fc0188f4810f8c2f0d83b3c","modified":1655224043910},{"_id":"public/archives/2019/04/index.html","hash":"9a19aec9ff4f3ba597731aa148d2f6e57a4fd06b","modified":1655224043910},{"_id":"public/archives/2019/05/index.html","hash":"9d48e7bb60ca7871ecd6f06896a0e3e3e7012098","modified":1655224043910},{"_id":"public/archives/2019/06/index.html","hash":"d3bdc067a6f92ed72544153cc42b620821bda909","modified":1655224043910},{"_id":"public/archives/2019/07/index.html","hash":"672f7294339bf0f03fff2d4114e4229f9b0bba1f","modified":1655224043910},{"_id":"public/archives/2019/08/index.html","hash":"a30620224ba1ccd3b67df8376542cc005cf11067","modified":1655224043910},{"_id":"public/archives/page/6/index.html","hash":"84267a02c7c40cba2c622c0d0d12c81a5a9dbba8","modified":1655224043910},{"_id":"public/archives/2019/09/index.html","hash":"791714ec980124ceb975f21f626199221dd472e2","modified":1655224043910},{"_id":"public/archives/2019/11/index.html","hash":"b8012beb418db0c92216f5c9db34ea3514a71dd1","modified":1655224043910},{"_id":"public/archives/2019/12/index.html","hash":"77466a7e404ac8439607fb84fd30fd8f6d40cebd","modified":1655224043910},{"_id":"public/archives/2020/index.html","hash":"30e0d37b4375019cdd2c49c9350e7c96c98544d5","modified":1655224043910},{"_id":"public/archives/2020/page/2/index.html","hash":"d8124a7805bd1dcfc11c4eeedc7b37d3fe031478","modified":1655224043910},{"_id":"public/archives/2020/01/index.html","hash":"29ec7b1032f5b753f56a0fd828f2ded4cc611194","modified":1655224043910},{"_id":"public/archives/2020/02/index.html","hash":"07e7e67dc96e7a7dd2a3d5ba2e03d931b212a6aa","modified":1655224043910},{"_id":"public/archives/2020/03/index.html","hash":"c9c79bf7984b4cd953a79c6e0582b9e7fb953be8","modified":1655224043910},{"_id":"public/archives/2020/06/index.html","hash":"4c0ea840d28fbcdd18b1236383fa72d50a53060b","modified":1655224043910},{"_id":"public/archives/2020/07/index.html","hash":"c05b9e0b598fde316eb0b5bffe60fa36e87c1fc6","modified":1655224043910},{"_id":"public/archives/2020/08/index.html","hash":"5d4106bdddc331f6f876b2fe50e65ae9cdc276a1","modified":1655224043910},{"_id":"public/archives/2020/09/index.html","hash":"e0d7d4f442e127ed8710d69affff8b2e84c43a75","modified":1655224043910},{"_id":"public/archives/2020/10/index.html","hash":"2dab1d8c086119662bcf00bf5500d7865bc0da9b","modified":1655224043910},{"_id":"public/archives/2021/index.html","hash":"5904851a00025db361d51832ac8766e39564f751","modified":1655224043910},{"_id":"public/archives/2021/01/index.html","hash":"f1142e574fdb082707fb01183853a29d558a444e","modified":1655224043910},{"_id":"public/archives/2021/page/2/index.html","hash":"3a2a885e3afb96dd3ae36f84548f6c448831f807","modified":1655224043910},{"_id":"public/archives/2021/02/index.html","hash":"d71ec2e7126e057fbcb78f74bee3b0246d0de55d","modified":1655224043910},{"_id":"public/archives/2021/03/index.html","hash":"7efc78377998ea172cc89508da3057a1e69ed9e9","modified":1655224043910},{"_id":"public/archives/2021/05/index.html","hash":"1e4906cfc05b15c3cd3eb071101ce9ceb4042997","modified":1655224043910},{"_id":"public/archives/2021/07/index.html","hash":"d000f53f1fae5f528b6c4e71428c16c13a9f7c08","modified":1655224043910},{"_id":"public/archives/2021/10/index.html","hash":"6f16d92e4889923e009e7db17bb43c9e72303767","modified":1655224043910},{"_id":"public/archives/2021/11/index.html","hash":"5d06f05ec8e6206676674e0a2dcbc3957636b9cb","modified":1655224043910},{"_id":"public/archives/2021/12/index.html","hash":"762d24c60a09737146537a3faa34a7c45116667a","modified":1655224043911},{"_id":"public/archives/2022/index.html","hash":"52a1d13941d2261e859e13f7d418fa19a523b274","modified":1655224043911},{"_id":"public/archives/2022/03/index.html","hash":"f3829f654293fe928236db9aebb52b0ed7304b86","modified":1655224043911},{"_id":"public/archives/2022/04/index.html","hash":"d45772cdc9036af43cdab0d0416dfb533544bc54","modified":1655224043911},{"_id":"public/archives/2022/05/index.html","hash":"f3e9b4f5bd36b575f1b4561e54b6c73761b47b87","modified":1655224043911},{"_id":"public/categories/java/index.html","hash":"444aeb4afbbf4d19163d13f75b685b3a770072df","modified":1655224043911},{"_id":"public/categories/C-C/index.html","hash":"09cac1d3e11c87a710066528d89dc7110911d255","modified":1655224043911},{"_id":"public/categories/java/多线程/index.html","hash":"12c58d74921664cec1bfc1bfd5337e0c066e6b75","modified":1655224043911},{"_id":"public/categories/Java/index.html","hash":"b74eedda714079908d4640290760daea66f1b819","modified":1655224043911},{"_id":"public/categories/Android/index.html","hash":"31db8b829e1de006300faeabcf8fddf85f96d367","modified":1655224043911},{"_id":"public/categories/Android/page/2/index.html","hash":"d40838ea2c38847e5634c1eb12b88d8cb2aa4bf8","modified":1655224043911},{"_id":"public/categories/Android/page/3/index.html","hash":"5c478bc033c815e0b33275cd58fc634b71fdc21d","modified":1655224043911},{"_id":"public/categories/Android/AndroidStudio/index.html","hash":"cb75a249b82e719881f326d3075a212347b912de","modified":1655224043911},{"_id":"public/categories/Android/View/index.html","hash":"f22a8b815bcab483065884da83430177c8c0bacb","modified":1655224043911},{"_id":"public/categories/Kotlin/index.html","hash":"08fc731c3d9f0b6b4ed0dbdc7356179807a9200b","modified":1655224043911},{"_id":"public/categories/Flutter/index.html","hash":"72ec214e554d336e64af1276401ca795ea209415","modified":1655224043911},{"_id":"public/categories/Linux/index.html","hash":"7faf036d9a1e7fb805e5670a65ff4a7498d0b2da","modified":1655224043911},{"_id":"public/categories/Android/Service/index.html","hash":"57f7b380e5a236278a99897a61f6b53b3117f6c5","modified":1655224043911},{"_id":"public/categories/Android/Service/Framework/index.html","hash":"9aaba857db692b026dd9d083b8389b0597709b3d","modified":1655224043911},{"_id":"public/tags/AOSP/index.html","hash":"698cc7972b13db2cf41ad3bcba0a72ffea972276","modified":1655224043911},{"_id":"public/tags/多线程/index.html","hash":"11dfc9c559fe552f4c9f8e3b530856992fe65bff","modified":1655224043911},{"_id":"public/tags/jni/index.html","hash":"1367d44f97a5546996df27fa199f72161fa6de7a","modified":1655224043911},{"_id":"public/tags/Java/index.html","hash":"53bcfc3df6521056a6bf90efe04372436c3ef20f","modified":1655224043911},{"_id":"public/tags/AndroidStudio/index.html","hash":"8c59ba6b2f89cbf268c964a0ea8d6ce13fac9335","modified":1655224043911},{"_id":"public/tags/View/index.html","hash":"3a3cb3aaac2c066589021f6b26d9f07ef1a1a568","modified":1655224043911},{"_id":"public/tags/View/page/2/index.html","hash":"1b0656ccf2c30c18bb120289dca3572ab29f27a6","modified":1655224043911},{"_id":"public/tags/RecyclerView/index.html","hash":"c9c33bf68e57c4182183becce15a7cec5cdc8000","modified":1655224043911},{"_id":"public/tags/Android/index.html","hash":"25d935ffea83b41383e5bee53a7e29200aacb42e","modified":1655224043911},{"_id":"public/tags/注解/index.html","hash":"78861a09c41f5eedb121937b71b0e9e5c1e7b2b6","modified":1655224043911},{"_id":"public/tags/Activity/index.html","hash":"91e91d66ba95c79e3a2de3d33c2b83bd46437191","modified":1655224043911},{"_id":"public/tags/Handler/index.html","hash":"72bdb163a8221d1c0a6c8309111d684d8743a306","modified":1655224043911},{"_id":"public/tags/内存泄露/index.html","hash":"90b7b9158c87231919f143cb23dbfd0df888174d","modified":1655224043911},{"_id":"public/tags/Animation/index.html","hash":"ab161c00a4b9e10d54f849bd1292580ddffe5a4f","modified":1655224043912},{"_id":"public/tags/Fragment/index.html","hash":"372ab5f3ddaafbff207bee385ddb5d11b727641c","modified":1655224043912},{"_id":"public/tags/Kotlin/index.html","hash":"0735773ab894f8360cdbd956547a041f862a17c9","modified":1655224043912},{"_id":"public/tags/ViewModel/index.html","hash":"1bbf1fed46c69bdbc169469f2d3746a2f41788d0","modified":1655224043912},{"_id":"public/tags/nested2/index.html","hash":"58b09ca56ab625296b51d987acc7fc05d895660d","modified":1655224043912},{"_id":"public/tags/Flutter/index.html","hash":"55d995e15848f67d00afb1b28f09aecd2479d96d","modified":1655224043912},{"_id":"public/tags/Redux/index.html","hash":"6a6de4a39e3d0c73991870f9d0c18d99a39c1e7f","modified":1655224043912},{"_id":"public/tags/Linux/index.html","hash":"66ddc4dce3ca34d8655845b7c3974d0c7b5cdb48","modified":1655224043912},{"_id":"public/tags/Notification/index.html","hash":"f679bff44e30ad4089da5ab8bf558ac377a4da0b","modified":1655224043912},{"_id":"public/tags/Uri/index.html","hash":"2561681a0b132aff90b54505705fc3d955691703","modified":1655224043912},{"_id":"public/tags/Docker/index.html","hash":"dd9394aaf8092389925dd578b6511d10210b0d0d","modified":1655224043912},{"_id":"public/tags/mysql/index.html","hash":"b7afb22209171481e0e3079b609a1ffefb84e1e4","modified":1655224043912},{"_id":"public/tags/RenderObject/index.html","hash":"ca6ec995b6b71fce57a48c85209c45115ff6e9b8","modified":1655224043912},{"_id":"public/tags/源码解析/index.html","hash":"7c9e9dabdf8e6d18645b1db4f79c8beaf0d368dc","modified":1655224043912},{"_id":"public/tags/Service/index.html","hash":"861fcd9b81eb403076b6ce60b7ad75c768704b11","modified":1655224043912},{"_id":"public/tags/Framework/index.html","hash":"94cc14d0a7a5e78c73078f1d3a88b00095f764a8","modified":1655224043912},{"_id":"public/tags/Gradle/index.html","hash":"24361e8dd9a223b7a5831f3e54db1a67e902c114","modified":1655224043912},{"_id":"public/tags/glide/index.html","hash":"c632edb25e690b3f5e9e0f165e49849855246908","modified":1655224043912},{"_id":"public/tags/okhttp3/index.html","hash":"6b68b88057ac87ef0646e26dace02c4d04d37f0e","modified":1655224043912},{"_id":"public/tags/Fresco/index.html","hash":"4993a95192e6c5144a745f83fa266d5f9fd3c2e2","modified":1655224043912},{"_id":"public/tags/源码分析/index.html","hash":"71fafb6b04a4ca4f919232f1e116ed749b66b504","modified":1655224043912},{"_id":"public/tags/Okhttp3/index.html","hash":"32561a9366ec1262816ab7971f601e1a4411081f","modified":1655224043912},{"_id":"public/2022/05/02/Android/Framework/RequestLayout和Invalidate/index.html","hash":"e5149940a295a3cfa1d5037a749c7d666b4db391","modified":1655224043912},{"_id":"public/2022/04/04/Java/ConcurrentHashMap/index.html","hash":"758fc0e07e52f71331b2c1d67cb02d3acaeec380","modified":1655224043912},{"_id":"public/2022/04/04/Java/HashMap/index.html","hash":"b3adde00d8a76b8c88d45b3102b2204d10b33600","modified":1655224043912},{"_id":"public/2022/03/21/Android/gradle/transform和asm初探/index.html","hash":"c2e8f6fda49d6cd780c2398a3bd45c238c2ba27e","modified":1655224043913},{"_id":"public/2022/03/19/Android/gradle/自定义gradle插件/index.html","hash":"a8a9d2f84a8baa2937f348ba0363e0857991dca9","modified":1655224043913},{"_id":"public/2022/03/13/Android/gradle/自定义注解处理器并发布为gradle组件/index.html","hash":"1334cefe50f83976570ae59df304a987d7df9e7e","modified":1655224043913},{"_id":"public/2021/11/03/Android/Framework/Binder源码笔记/index.html","hash":"275e4d239296b0f99c70461db67807c70a53690b","modified":1655224043913},{"_id":"public/2021/07/24/Android/nested2嵌套滚动机制/index.html","hash":"e9c587ab594e1e00bf46e1fe279ba52a9ac750c8","modified":1655224043913},{"_id":"public/2021/05/22/编译aosp/index.html","hash":"b7f796d59fc06c5927fee2b7c2e7db26211ed514","modified":1655224043913},{"_id":"public/2021/03/18/Android/Framework/屏幕刷新机制/index.html","hash":"95c6d18f9c53fff2a017f5ba1ebef35cfbdbb0ab","modified":1655224043913},{"_id":"public/2021/03/07/Android/Framework/应用进程是如何启动的/index.html","hash":"b796a9928a3af0fdd2c8325fa24c3072d871ce9b","modified":1655224043913},{"_id":"public/2021/02/26/Android/自定义LayoutManager/index.html","hash":"24e59da286036c4d75af156d4d14a5342a0d7a93","modified":1655224043913},{"_id":"public/2021/01/24/Flutter/redux源码/index.html","hash":"651094c46bf1b2d75392fdeaa559fa7ed5ac55c2","modified":1655224043913},{"_id":"public/2021/01/02/Android/Framework/源码探究Activity的生命周期/index.html","hash":"34fd329df5758945c29d5cf7ec9cde6a6ec5d55a","modified":1655224043913},{"_id":"public/2020/09/22/Flutter/RenderObject-原理/index.html","hash":"2d73f3455c6e475da6cb201be92acfec09a3eac6","modified":1655224043913},{"_id":"public/2020/08/14/Flutter/flutter-ui源码-初步/index.html","hash":"b6c1a57cbfa005f971023166f0c99ed53eadfd88","modified":1655224043913},{"_id":"public/2020/07/23/Java/Java获取泛型类型/index.html","hash":"d9a84ed48b0f441942f413aee488a59126eda117","modified":1655224043913},{"_id":"public/2020/07/15/Android/kotlin协程/index.html","hash":"a48a5cbcc5647b4d7403fc7a94487eba0971839f","modified":1655224043913},{"_id":"public/2020/06/27/Android/Android自定义注解/index.html","hash":"e5f04689aeadc19dceb6a34b7303dddc77582de7","modified":1655224043913},{"_id":"public/2020/06/18/Android/gradle/gradle相关基础/index.html","hash":"d764d9dedc81cb8beec66cd05814cbdff28ac987","modified":1655224043913},{"_id":"public/2020/03/20/Android/源码解析/Fresco源码解析/index.html","hash":"7052995f41dcc03b1bb30bde89b9ee1ff27e12af","modified":1655224043913},{"_id":"public/2020/02/19/Android/ViewDragHelper的使用/index.html","hash":"3c02a72ce996ab1cedb2285788a567fecaf04987","modified":1655224043914},{"_id":"public/2020/01/09/Android/外部View随着RecyclerView的滚动而显示或隐藏/index.html","hash":"cdba63d59efa6b0b277e8caed068c06dec982589","modified":1655224043914},{"_id":"public/2019/12/31/Android/自动滚播TextView/index.html","hash":"594f975834262daa5051ace5687bcc7fcd647ef0","modified":1655224043914},{"_id":"public/2019/12/21/Android/ViewModel-LiveData和LifeCricle/index.html","hash":"cef991f9ca431f0c938a344e3356031fdd2301a0","modified":1655224043914},{"_id":"public/2019/11/18/Android/源码解析/Glide源码-缓存机制/index.html","hash":"754be2c3a4c92db5a7485154458ca54b713441ff","modified":1655224043914},{"_id":"public/2019/11/18/Android/源码解析/Glide源码-主要流程/index.html","hash":"64bfc8551faeb71ac73445ad570af4f581d1bbc4","modified":1655224043914},{"_id":"public/2019/11/17/Android/源码解析/OkHttp3源码-CallServerInterceptor/index.html","hash":"394fd1c10909fcb82b4ab05e531a598e180e5fba","modified":1655224043914},{"_id":"public/2019/11/15/Android/源码解析/OkHttp3源码-ConnectInterceptor/index.html","hash":"526d96589c2ee89a3b55321151c0cce47b10271f","modified":1655224043914},{"_id":"public/2019/11/14/Android/源码解析/OkHttp3源码-CacheInterceptor/index.html","hash":"2c9e4da6ab03bd01f743d6e7259b885b31879bfd","modified":1655224043914},{"_id":"public/2019/11/14/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor/index.html","hash":"a291ce30f0048e5a19942f6e7f7dbdc8e7676802","modified":1655224043914},{"_id":"public/2019/11/14/Android/源码解析/OkHttp3源码-责任链的分析/index.html","hash":"467a1c993428fe3369c256dce57ae6ca691134d8","modified":1655224043914},{"_id":"public/2019/11/13/Android/源码解析/OkHttp3源码-发起请求的主要流程/index.html","hash":"badb60beb2b8cf4739d9a396b0098dce9dac9834","modified":1655224043914},{"_id":"public/2019/11/12/Linux/docker的使用/index.html","hash":"e4b7211d0ff5b34418949a5b08e3bac7ccfb2579","modified":1655224043914},{"_id":"public/2019/11/09/Android/Framework/handler机制源码解析/index.html","hash":"c64dbee11a760ad8d601d7110f59831b1167d67f","modified":1655224043915},{"_id":"public/2019/08/28/Android/通知铃声的自定义遇到的问题-根据uri读取文件/index.html","hash":"259a2b02725cb9ad8e015d7a61a5d59f76237642","modified":1655224043915},{"_id":"public/2019/08/15/Android/RecyclerView缓存机制总结/index.html","hash":"87814c509c44efc7eb9837841c0c44ec2db2dd61","modified":1655224043915},{"_id":"public/2019/08/13/Android/Framework/事件分发机制/index.html","hash":"90f3a2f95b9b9bd4fbb018c7359058efd69514f9","modified":1655224043915},{"_id":"public/2019/08/13/Android/LayoutInflater解析/index.html","hash":"4907b7581d9875cdff58478d2c2713584f986f3b","modified":1655224043915},{"_id":"public/2019/08/02/Android/Scale动画组合使用的坑/index.html","hash":"1d7274d95fc1291db38416f3d035785711cf11f3","modified":1655224043915},{"_id":"public/2019/07/22/Java/ThreadLocal/index.html","hash":"a37b190d05e0284a98c46f1efbcad2b092b71c4e","modified":1655224043915},{"_id":"public/2019/07/09/Android/RecyclerView设置item的间距/index.html","hash":"3e1582a404f172adaefe2aebfecab131b034593e","modified":1655224043915},{"_id":"public/2019/07/04/Android/Framework/startService-和bindService/index.html","hash":"9ccece0804c05ff3d41c14aa964a8d3e2bc584e5","modified":1655224043915},{"_id":"public/2019/06/16/Android/scrollBy-scrollTo-和Scroller/index.html","hash":"745300cdfd1ea086394633f7c2bc4d75431d5da9","modified":1655224043915},{"_id":"public/2019/05/04/Linux/mysql配置相关/index.html","hash":"52319090568163142bc0011e1e84738943936ff0","modified":1655224043915},{"_id":"public/2019/04/14/Android/Activity管理类的封装/index.html","hash":"c33bb96fe713ef5cc36e0664b9aa1623b9a60eb5","modified":1655224043915},{"_id":"public/2019/04/14/Android/Handler防止内存泄露/index.html","hash":"58a4df7d1348b651a6c322ccd0bcb01529aba47d","modified":1655224043915},{"_id":"public/2019/04/13/Java/Jni入门/index.html","hash":"2550fe0bb2669690ca8bd58714b8950612daccdb","modified":1655224043915},{"_id":"public/2019/04/13/Android/自定义ViewGroup/index.html","hash":"c741b1d932a9a2a20cd6d260d543c25dceec86c9","modified":1655224043915},{"_id":"public/2019/04/13/C/多个cpp文件编译共享同一个-h文件的全局变量/index.html","hash":"79e0ead75a0ae42573ec6ce0a381002555473e8b","modified":1655224043915},{"_id":"public/2019/04/13/C/C语言结构体的内存对齐/index.html","hash":"4192209b84c7b83df26a2c4f64872cac7fff3194","modified":1655224043915},{"_id":"public/2021/10/04/Kotlin/kotlin-flow/index.html","hash":"c9fb61fd8280861374747b1c6d9dd76ed02db818","modified":1655224043915},{"_id":"public/index.html","hash":"d8aa7b56112f331e71d617e28b3c579b6880ba4d","modified":1655224043915},{"_id":"public/page/2/index.html","hash":"796ea6ac606a95df7c5f7979123c8ddabd6525a7","modified":1655224043915},{"_id":"public/page/3/index.html","hash":"ed05626cece36477ad246e3719d9b195443b1bbd","modified":1655224043915},{"_id":"public/page/4/index.html","hash":"5a38e29f453f77db6c70cda27949f054ffa8a646","modified":1655224043915},{"_id":"public/page/5/index.html","hash":"203fc82f2e5b54eb17a5fb68f97ff6599606115d","modified":1655224043916},{"_id":"public/page/6/index.html","hash":"0f8f450bc6bb98c0dadb738a649810d9ddf58859","modified":1655224043916},{"_id":"public/page/7/index.html","hash":"839af12d35bbb738bdcd80955ddb543e07745640","modified":1655224043916},{"_id":"public/archives/2022/06/index.html","hash":"6cc86d138456e0ad0092108a77ad98920f86e4d1","modified":1655224043921},{"_id":"public/2022/06/12/Android/源码解析/Retrofit源码解析/index.html","hash":"e449850f87925a80470fe6e76adedd6717be084b","modified":1655224043921},{"_id":"public/push.sh","hash":"9b904e17d4a6e015e04df31078afa655e2af10b0","modified":1655224043923},{"_id":"public/images/Gradle的构建过程.jpg","hash":"4ab64f9e14ad5b25623c820e8855d6e97d9cfcb0","modified":1655224043923},{"_id":"public/images/mysql_iptables.png","hash":"9b8dc491c73623b28c41b1581c728c696ecd365e","modified":1655224043923},{"_id":"public/images/startService and bindService.jpg","hash":"e22213c4dec3f59761079a0a219ffcbbfe640ec8","modified":1655224043923},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1655224043923},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1655224043923},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1655224043923},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1655224043923},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1655224043923},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1655224043924},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1655224043924},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1655224043924},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1655224043924},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1655224043924},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1655224043924},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1655224043924},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1655224043924},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1655224043924},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1655224043924},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1655224043924},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1655224043924},{"_id":"public/images/Text相关计算.webp","hash":"2bc79f17b9a2be8663fe5bbc8487ccfceccc3627","modified":1655224044216},{"_id":"public/images/flutter相关属性和android的对应关系.webp","hash":"a474163ef56cd229069c4187a10e783937832536","modified":1655224044217},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1655224044217},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1655224044217},{"_id":"public/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1655224044219},{"_id":"public/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1655224044219},{"_id":"public/js/next-boot.js","hash":"a6a82905c6abb8e0ec418ef6b0509b946b955807","modified":1655224044219},{"_id":"public/js/motion.js","hash":"71e5caff1d87b1b7256f61e6b318bedf495f9e75","modified":1655224044220},{"_id":"public/js/utils.js","hash":"a2984bf0631756a904cd43f8e3a8f6fb15b9ceb5","modified":1655224044220},{"_id":"public/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1655224044220},{"_id":"public/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1655224044220},{"_id":"public/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1655224044220},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1655224044220},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1655224044220},{"_id":"public/css/main.css","hash":"6decebcaff8604bd39875dda9ba95e01ff6024ee","modified":1655224044220},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1655224044220},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1655224044220},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1655224044220},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1655224044220},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1655224044240},{"_id":"public/images/fresco基本结构.jpg","hash":"e0db204389df9e7cf9624f48a283e9e11449e487","modified":1655224044241},{"_id":"public/images/fresco发起请求的流程.jpg","hash":"cbbd3d068fc5a39146539504ce3f2d435ad9adbb","modified":1655224044243}],"Category":[{"name":"java","_id":"cl4edno790009g0jeh68d2h2s"},{"name":"C/C++","_id":"cl4edno7c000eg0jeo0aazet1"},{"name":"多线程","parent":"cl4edno790009g0jeh68d2h2s","_id":"cl4edno7i000og0jek3waw5pr"},{"name":"Java","_id":"cl4edno7k000vg0jel1g75x9x"},{"name":"Android","_id":"cl4edno7m0011g0jeqdxphz1j"},{"name":"AndroidStudio","parent":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7v001zg0jeqx51qf9k"},{"name":"View","parent":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7v0022g0je9k9wn8pz"},{"name":"Kotlin","_id":"cl4edno8c002rg0jelorvm980"},{"name":"Flutter","_id":"cl4edno8p003tg0je32otooxt"},{"name":"Linux","_id":"cl4edno8t0042g0jejmf5kqsr"},{"name":"Service","parent":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno95004ug0jedoz9i3c3"},{"name":"Framework","parent":"cl4edno95004ug0jedoz9i3c3","_id":"cl4edno990052g0jeozjjwqcx"}],"Data":[],"Page":[{"title":"categories","date":"2019-04-13T04:54:42.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-04-13 12:54:42\ntype: \"categories\"\n---\n","updated":"2021-10-03T01:57:41.032Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl4edno6k0000g0jef85jzu9v","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"{\n  \"folders\": [],\n  \"version\": \"1.0\"\n}\n","source":"notes/boostnote.json","raw":"{\n  \"folders\": [],\n  \"version\": \"1.0\"\n}\n","date":"2021-10-03T01:57:41.038Z","updated":"2021-10-03T01:57:41.038Z","path":"notes/boostnote.json","layout":"false","title":"","comments":1,"_id":"cl4edno6o0002g0jej8a4vfet","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-04-14T12:06:37.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-04-14 20:06:37\ntype: \"tags\"\n---\n","updated":"2021-10-03T01:57:41.038Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl4edno6r0004g0jeqrz1ce2l","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"编译aosp","date":"2021-05-22T09:12:59.000Z","_content":"\n# 注意事项\n1. 在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘\n\n\n# 下载源代码\n\n1. 下载 Repo 工具，并确保它可执行：\n\n```shell\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+x ~/bin/repo\n```\n\n使用清华源\n```shell\ncurl https://mirrors.tuna.tsinghua.edu.cn/git-repo-downloads/repo  > ~/bin/repo\nchmod a+x ~/bin/repo\n```\n\n2. 初始化 Repo\n\n-b 后面可以指定要同步代码的安卓系统版本代号\n版本代号可以在下面的链接中查找\nhttps://source.android.com/setup/start/build-numbers\n\n```shell\nrepo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1\n```\n\n使用清华源\n```shell\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r40\n```\n\n3. 同步 Repo\n\n需要几个小时的时间同步代码\n```shell\nrepo sync \n```\n\n# 编译\n\n执行下面的命令，\nlunch 选择编译模式（ 这里我选择的是  aosp_x86_64-eng）\nm （m 命令系统会根据cpu性能自动选取需要使用的线程，你也可以根据cpu多少使用 make -jN, N表示cpu个数x2）\n\n\n```shell\nsource build/envsetup.sh\nlunch  aosp_x86_64-eng\nm \n```\n\n## 坑点\n* 找不到对应的MacOSX.sdk\nCould not find a supported mac sdk: [“10.10” “10.11” “10.12” “10.13”]\n\n我的系统版本是10.15，你需要到 https://github.com/phracker/MacOSX-SDKs/releases 下载需要的版本\n\n我这里下载的是MacOSX10.12.sdk，解压复制到如下目录：\n/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs\n\n* 不知名报错、\n\n找到文件：源文件根目录/system/sepolicy/tests/Android.bp，删除掉第14行的一行代码：\n\n```\n    // libsepolwrap gets loaded from the system python, which does not have the\n    // ASAN runtime. So turn off sanitization for ourself, and  use static\n    // libraries, since the shared libraries will use ASAN.\n    static_libs: [\n        \"libbase\",\n        \"libsepol\",\n    ],\n    stl: \"libc++_static\", // 删除掉这一行\n    sanitize: {\n        never: true,\n    },\n```\n\n# 使用 Android Studio 阅读源码\n\n1. 生成 Android Studio 工程配置文件\n\n生成 android.iml 和 android.ipr 文件。\n\n其中 iml 文件 表示 information of modules, 用来描述 AOSP 的模块信息。\nipr 文件 表示 IDEA project configuration ，用来描述 IDEA 的工程配置信息，双击此文件时系统将直接使用 Andorid Studio 打开此项目。\n\n```shell\n# 设置 AOSP 编译所需的环境变量\nsource build/envsetup.sh\n# 使用 idegen.sh 脚本生成 IDEA 工程文件\ndevelopment/tools/idegen/idegen.sh\n```\n\n\n","source":"_posts/编译aosp.md","raw":"---\ntitle: 编译aosp\ndate: 2021-05-22 17:12:59\ntags:\n- AOSP\n---\n\n# 注意事项\n1. 在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘\n\n\n# 下载源代码\n\n1. 下载 Repo 工具，并确保它可执行：\n\n```shell\ncurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo\nchmod a+x ~/bin/repo\n```\n\n使用清华源\n```shell\ncurl https://mirrors.tuna.tsinghua.edu.cn/git-repo-downloads/repo  > ~/bin/repo\nchmod a+x ~/bin/repo\n```\n\n2. 初始化 Repo\n\n-b 后面可以指定要同步代码的安卓系统版本代号\n版本代号可以在下面的链接中查找\nhttps://source.android.com/setup/start/build-numbers\n\n```shell\nrepo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1\n```\n\n使用清华源\n```shell\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r40\n```\n\n3. 同步 Repo\n\n需要几个小时的时间同步代码\n```shell\nrepo sync \n```\n\n# 编译\n\n执行下面的命令，\nlunch 选择编译模式（ 这里我选择的是  aosp_x86_64-eng）\nm （m 命令系统会根据cpu性能自动选取需要使用的线程，你也可以根据cpu多少使用 make -jN, N表示cpu个数x2）\n\n\n```shell\nsource build/envsetup.sh\nlunch  aosp_x86_64-eng\nm \n```\n\n## 坑点\n* 找不到对应的MacOSX.sdk\nCould not find a supported mac sdk: [“10.10” “10.11” “10.12” “10.13”]\n\n我的系统版本是10.15，你需要到 https://github.com/phracker/MacOSX-SDKs/releases 下载需要的版本\n\n我这里下载的是MacOSX10.12.sdk，解压复制到如下目录：\n/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs\n\n* 不知名报错、\n\n找到文件：源文件根目录/system/sepolicy/tests/Android.bp，删除掉第14行的一行代码：\n\n```\n    // libsepolwrap gets loaded from the system python, which does not have the\n    // ASAN runtime. So turn off sanitization for ourself, and  use static\n    // libraries, since the shared libraries will use ASAN.\n    static_libs: [\n        \"libbase\",\n        \"libsepol\",\n    ],\n    stl: \"libc++_static\", // 删除掉这一行\n    sanitize: {\n        never: true,\n    },\n```\n\n# 使用 Android Studio 阅读源码\n\n1. 生成 Android Studio 工程配置文件\n\n生成 android.iml 和 android.ipr 文件。\n\n其中 iml 文件 表示 information of modules, 用来描述 AOSP 的模块信息。\nipr 文件 表示 IDEA project configuration ，用来描述 IDEA 的工程配置信息，双击此文件时系统将直接使用 Andorid Studio 打开此项目。\n\n```shell\n# 设置 AOSP 编译所需的环境变量\nsource build/envsetup.sh\n# 使用 idegen.sh 脚本生成 IDEA 工程文件\ndevelopment/tools/idegen/idegen.sh\n```\n\n\n","slug":"编译aosp","published":1,"updated":"2021-10-03T01:57:41.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno6l0001g0jeqr5d50zq","content":"<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><ol>\n<li>在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘</li>\n</ol><a id=\"more\"></a>\n<h1 id=\"下载源代码\"><a href=\"#下载源代码\" class=\"headerlink\" title=\"下载源代码\"></a>下载源代码</h1><ol>\n<li>下载 Repo 工具，并确保它可执行：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class=\"line\">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>\n<p>使用清华源<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://mirrors.tuna.tsinghua.edu.cn/git-repo-downloads/repo  &gt; ~/bin/repo</span><br><span class=\"line\">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>初始化 Repo</li>\n</ol>\n<p>-b 后面可以指定要同步代码的安卓系统版本代号<br>版本代号可以在下面的链接中查找<br><a href=\"https://source.android.com/setup/start/build-numbers\" target=\"_blank\" rel=\"noopener\">https://source.android.com/setup/start/build-numbers</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1</span><br></pre></td></tr></table></figure>\n<p>使用清华源<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r40</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>同步 Repo</li>\n</ol>\n<p>需要几个小时的时间同步代码<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo sync</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h1><p>执行下面的命令，<br>lunch 选择编译模式（ 这里我选择的是  aosp_x86_64-eng）<br>m （m 命令系统会根据cpu性能自动选取需要使用的线程，你也可以根据cpu多少使用 make -jN, N表示cpu个数x2）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source build/envsetup.sh</span><br><span class=\"line\">lunch  aosp_x86_64-eng</span><br><span class=\"line\">m</span><br></pre></td></tr></table></figure>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><ul>\n<li>找不到对应的MacOSX.sdk<br>Could not find a supported mac sdk: [“10.10” “10.11” “10.12” “10.13”]</li>\n</ul>\n<p>我的系统版本是10.15，你需要到 <a href=\"https://github.com/phracker/MacOSX-SDKs/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/phracker/MacOSX-SDKs/releases</a> 下载需要的版本</p>\n<p>我这里下载的是MacOSX10.12.sdk，解压复制到如下目录：<br>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</p>\n<ul>\n<li>不知名报错、</li>\n</ul>\n<p>找到文件：源文件根目录/system/sepolicy/tests/Android.bp，删除掉第14行的一行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// libsepolwrap gets loaded from the system python, which does not have the</span><br><span class=\"line\">// ASAN runtime. So turn off sanitization for ourself, and  use static</span><br><span class=\"line\">// libraries, since the shared libraries will use ASAN.</span><br><span class=\"line\">static_libs: [</span><br><span class=\"line\">    &quot;libbase&quot;,</span><br><span class=\"line\">    &quot;libsepol&quot;,</span><br><span class=\"line\">],</span><br><span class=\"line\">stl: &quot;libc++_static&quot;, // 删除掉这一行</span><br><span class=\"line\">sanitize: &#123;</span><br><span class=\"line\">    never: true,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用-Android-Studio-阅读源码\"><a href=\"#使用-Android-Studio-阅读源码\" class=\"headerlink\" title=\"使用 Android Studio 阅读源码\"></a>使用 Android Studio 阅读源码</h1><ol>\n<li>生成 Android Studio 工程配置文件</li>\n</ol>\n<p>生成 android.iml 和 android.ipr 文件。</p>\n<p>其中 iml 文件 表示 information of modules, 用来描述 AOSP 的模块信息。<br>ipr 文件 表示 IDEA project configuration ，用来描述 IDEA 的工程配置信息，双击此文件时系统将直接使用 Andorid Studio 打开此项目。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 设置 AOSP 编译所需的环境变量</span><br><span class=\"line\">source build/envsetup.sh</span><br><span class=\"line\"><span class=\"meta\">#</span> 使用 idegen.sh 脚本生成 IDEA 工程文件</span><br><span class=\"line\">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><ol>\n<li>在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘</li>\n</ol>","more":"\n<h1 id=\"下载源代码\"><a href=\"#下载源代码\" class=\"headerlink\" title=\"下载源代码\"></a>下载源代码</h1><ol>\n<li>下载 Repo 工具，并确保它可执行：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class=\"line\">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>\n<p>使用清华源<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://mirrors.tuna.tsinghua.edu.cn/git-repo-downloads/repo  &gt; ~/bin/repo</span><br><span class=\"line\">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>初始化 Repo</li>\n</ol>\n<p>-b 后面可以指定要同步代码的安卓系统版本代号<br>版本代号可以在下面的链接中查找<br><a href=\"https://source.android.com/setup/start/build-numbers\" target=\"_blank\" rel=\"noopener\">https://source.android.com/setup/start/build-numbers</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1</span><br></pre></td></tr></table></figure>\n<p>使用清华源<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r40</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>同步 Repo</li>\n</ol>\n<p>需要几个小时的时间同步代码<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repo sync</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h1><p>执行下面的命令，<br>lunch 选择编译模式（ 这里我选择的是  aosp_x86_64-eng）<br>m （m 命令系统会根据cpu性能自动选取需要使用的线程，你也可以根据cpu多少使用 make -jN, N表示cpu个数x2）</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source build/envsetup.sh</span><br><span class=\"line\">lunch  aosp_x86_64-eng</span><br><span class=\"line\">m</span><br></pre></td></tr></table></figure>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><ul>\n<li>找不到对应的MacOSX.sdk<br>Could not find a supported mac sdk: [“10.10” “10.11” “10.12” “10.13”]</li>\n</ul>\n<p>我的系统版本是10.15，你需要到 <a href=\"https://github.com/phracker/MacOSX-SDKs/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/phracker/MacOSX-SDKs/releases</a> 下载需要的版本</p>\n<p>我这里下载的是MacOSX10.12.sdk，解压复制到如下目录：<br>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</p>\n<ul>\n<li>不知名报错、</li>\n</ul>\n<p>找到文件：源文件根目录/system/sepolicy/tests/Android.bp，删除掉第14行的一行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// libsepolwrap gets loaded from the system python, which does not have the</span><br><span class=\"line\">// ASAN runtime. So turn off sanitization for ourself, and  use static</span><br><span class=\"line\">// libraries, since the shared libraries will use ASAN.</span><br><span class=\"line\">static_libs: [</span><br><span class=\"line\">    &quot;libbase&quot;,</span><br><span class=\"line\">    &quot;libsepol&quot;,</span><br><span class=\"line\">],</span><br><span class=\"line\">stl: &quot;libc++_static&quot;, // 删除掉这一行</span><br><span class=\"line\">sanitize: &#123;</span><br><span class=\"line\">    never: true,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用-Android-Studio-阅读源码\"><a href=\"#使用-Android-Studio-阅读源码\" class=\"headerlink\" title=\"使用 Android Studio 阅读源码\"></a>使用 Android Studio 阅读源码</h1><ol>\n<li>生成 Android Studio 工程配置文件</li>\n</ol>\n<p>生成 android.iml 和 android.ipr 文件。</p>\n<p>其中 iml 文件 表示 information of modules, 用来描述 AOSP 的模块信息。<br>ipr 文件 表示 IDEA project configuration ，用来描述 IDEA 的工程配置信息，双击此文件时系统将直接使用 Andorid Studio 打开此项目。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 设置 AOSP 编译所需的环境变量</span><br><span class=\"line\">source build/envsetup.sh</span><br><span class=\"line\"><span class=\"meta\">#</span> 使用 idegen.sh 脚本生成 IDEA 工程文件</span><br><span class=\"line\">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>\n"},{"title":"技术Owner的职责","date":"2021-11-27T07:58:24.000Z","_content":"\n* 参与需求评审，完成可行性调研，完善细节。\n   * 要督促完成UI/UE评审，埋点评审\n* 技术评审，输出技术方案，拆分需求子任务，给出详细排期\n* 开始开发，定期站会，同步风险\n  * 发生变更，更改排期\n  * 需求提测前，推进case评审\n  * 自测\n","source":"_posts/技术Owner的职责.md","raw":"---\ntitle: 技术Owner的职责\ndate: 2021-11-27 15:58:24\ntags:\n---\n\n* 参与需求评审，完成可行性调研，完善细节。\n   * 要督促完成UI/UE评审，埋点评审\n* 技术评审，输出技术方案，拆分需求子任务，给出详细排期\n* 开始开发，定期站会，同步风险\n  * 发生变更，更改排期\n  * 需求提测前，推进case评审\n  * 自测\n","slug":"技术Owner的职责","published":1,"updated":"2021-11-27T08:09:40.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno760006g0jeoikcsfne","content":"<ul>\n<li>参与需求评审，完成可行性调研，完善细节。<ul>\n<li>要督促完成UI/UE评审，埋点评审</li>\n</ul>\n</li>\n<li>技术评审，输出技术方案，拆分需求子任务，给出详细排期</li>\n<li>开始开发，定期站会，同步风险<ul>\n<li>发生变更，更改排期</li>\n<li>需求提测前，推进case评审</li>\n<li>自测</li>\n</ul>\n</li>\n</ul>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>参与需求评审，完成可行性调研，完善细节。<ul>\n<li>要督促完成UI/UE评审，埋点评审</li>\n</ul>\n</li>\n<li>技术评审，输出技术方案，拆分需求子任务，给出详细排期</li>\n<li>开始开发，定期站会，同步风险<ul>\n<li>发生变更，更改排期</li>\n<li>需求提测前，推进case评审</li>\n<li>自测</li>\n</ul>\n</li>\n</ul>"},{"title":"ThreadLocal","date":"2019-07-22T05:57:12.000Z","_content":"\n# ThreadLocal\n\n## 作用\n\n**当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量**\n\n## 源码分析\n\n### set()\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n\ncreateMap()方法：\n```java\nvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n```\n查看Thread类的代码：\n```java\n/* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n**Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value**\n\n### get()方法\n```java\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n```\n其中的ThreadLocalMap.Entry\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\n**Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己**\n\n### 总结\n**Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值**\n","source":"_posts/Java/ThreadLocal.md","raw":"---\ntitle: ThreadLocal\ndate: 2019-07-22 13:57:12\ntags:\n- 多线程\ncategories:\n- java\n- 多线程\n---\n\n# ThreadLocal\n\n## 作用\n\n**当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量**\n\n## 源码分析\n\n### set()\n\n```java\npublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n\ncreateMap()方法：\n```java\nvoid createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n```\n查看Thread类的代码：\n```java\n/* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n**Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value**\n\n### get()方法\n```java\npublic T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n```\n其中的ThreadLocalMap.Entry\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\n**Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己**\n\n### 总结\n**Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值**\n","slug":"Java/ThreadLocal","published":1,"updated":"2021-10-03T01:57:41.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno770007g0jei3ujt3ey","content":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p><strong>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量</strong></p><a id=\"more\"></a>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>createMap()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">        t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看Thread类的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class=\"line\"><span class=\"comment\">     * by the ThreadLocal class. */</span></span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value</strong></p>\n<h3 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get()方法\"></a>get()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的ThreadLocalMap.Entry<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p><strong>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程所对应的副本。从线程的角度来看，目标变量就像是本地变量</strong></p>","more":"\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set()\"></a>set()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>createMap()方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">        t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>查看Thread类的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class=\"line\"><span class=\"comment\">     * by the ThreadLocal class. */</span></span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Thread类中有一个Thread.ThreadLocalMap成员变量。也就是说，ThreadLocal的set方法，实质是在Thread的threadlocals成员中添加value</strong></p>\n<h3 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get()方法\"></a>get()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>其中的ThreadLocalMap.Entry<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Entry中的key时ThreadLocal的弱引用， 所以在ThreadLocal的get方法中map.getEntry(this)传入的是自己</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Thread类中有一个ThreadLocalMap成员对象，这个变量在Thread类中并没有使用，只有在ThreadLocal类中才有用到。ThreadLocalMap里的Entry固定为ThreadLocal的弱引用。也就是说ThreadLocal是将value存储到Thread中，调用get和set方法是，先得到当前的Thread线程对象，获取到thread中的map，在以自己为key获取到value值</strong></p>\n"},{"title":"Jni入门","date":"2019-04-13T05:12:47.000Z","categries":["java"],"_content":"\n# Jni入门\n\n参考:\n[JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki](http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html)\n\n### 1、编写native方法，使用javah创建头文件\n```java\npublic class HelloWorld {\n    public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现\n}\n```\n\n```java\njavah -jni -classpath JniCalcINterface \n```\n参数说明：\nclasspath：类搜索路径，这里表示从当前的 bin 目录下查找\nd：将生成的头文件放到当前的 jni 目录下\no： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）\n\n**注意：-d和-o只能使用其中一个参数。**\n\n创建的.h文件如下\n```c++\n/* DO NOT EDIT THIS FILE - it is machine generated */  \n#include <jni.h>  \n/* Header for class com_study_jnilearn_HelloWorld */  \n\n#ifndef _Included_com_study_jnilearn_HelloWorld  \n#define _Included_com_study_jnilearn_HelloWorld  \n#ifdef __cplusplus  \nextern \"C\" {  \n#endif  \n/* \n * Class:     com_study_jnilearn_HelloWorld \n * Method:    sayHello \n * Signature: (Ljava/lang/String;)Ljava/lang/String; \n */  \nJNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello  \n  (JNIEnv *, jclass, jstring);  \n\n#ifdef __cplusplus  \n}  \n#endif  \n#endif  \n```\n\n**注意 extern \"C\"表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern \"C\"后面\n\n### 3、编译出so文件\n```shell\ngcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so  \n```\n\n参数含义:\n\n-L \n* 表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。\n\n-l (L的小写)\n* 表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test\n\n-include\n* 包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。\n\n-I (i 的大写)\n* 指定头文件的所在的目录，可以使用相对路径。\n\n-shared \n* 指定生成动态链接库\n\n-fPIC\n* 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。\n\n-o \n* 指定编译后动态库生成的路径和文件名\n\n### 4、加载动态库\n```java\nstatic{\n    System.loadLibrary(\"HelloWorld\");  //方式一\n    System.load(\"/Users/yangxin/Desktop/libHelloWorld.jnilib\" //方式二);\n}\n```\n方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀\n方式2：指定动态库的绝对路径名，需要加上前缀和后缀 **推荐使用这种方法**\n\n如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。\n有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。\n\n* 将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下\n\n* 给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。\n\n### 5、运行java程序\n\n\n\n","source":"_posts/Java/Jni入门.md","raw":"---\ntitle: Jni入门\ndate: 2019-04-13 13:12:47\ncategries:\n- java\ntags:\n- jni\n---\n\n# Jni入门\n\n参考:\n[JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki](http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html)\n\n### 1、编写native方法，使用javah创建头文件\n```java\npublic class HelloWorld {\n    public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现\n}\n```\n\n```java\njavah -jni -classpath JniCalcINterface \n```\n参数说明：\nclasspath：类搜索路径，这里表示从当前的 bin 目录下查找\nd：将生成的头文件放到当前的 jni 目录下\no： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）\n\n**注意：-d和-o只能使用其中一个参数。**\n\n创建的.h文件如下\n```c++\n/* DO NOT EDIT THIS FILE - it is machine generated */  \n#include <jni.h>  \n/* Header for class com_study_jnilearn_HelloWorld */  \n\n#ifndef _Included_com_study_jnilearn_HelloWorld  \n#define _Included_com_study_jnilearn_HelloWorld  \n#ifdef __cplusplus  \nextern \"C\" {  \n#endif  \n/* \n * Class:     com_study_jnilearn_HelloWorld \n * Method:    sayHello \n * Signature: (Ljava/lang/String;)Ljava/lang/String; \n */  \nJNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello  \n  (JNIEnv *, jclass, jstring);  \n\n#ifdef __cplusplus  \n}  \n#endif  \n#endif  \n```\n\n**注意 extern \"C\"表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern \"C\"后面\n\n### 3、编译出so文件\n```shell\ngcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so  \n```\n\n参数含义:\n\n-L \n* 表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。\n\n-l (L的小写)\n* 表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test\n\n-include\n* 包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。\n\n-I (i 的大写)\n* 指定头文件的所在的目录，可以使用相对路径。\n\n-shared \n* 指定生成动态链接库\n\n-fPIC\n* 表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。\n\n-o \n* 指定编译后动态库生成的路径和文件名\n\n### 4、加载动态库\n```java\nstatic{\n    System.loadLibrary(\"HelloWorld\");  //方式一\n    System.load(\"/Users/yangxin/Desktop/libHelloWorld.jnilib\" //方式二);\n}\n```\n方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀\n方式2：指定动态库的绝对路径名，需要加上前缀和后缀 **推荐使用这种方法**\n\n如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。\n有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。\n\n* 将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下\n\n* 给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。\n\n### 5、运行java程序\n\n\n\n","slug":"Java/Jni入门","published":1,"updated":"2021-10-03T01:57:41.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno780008g0jem6e0zgpb","content":"<h1 id=\"Jni入门\"><a href=\"#Jni入门\" class=\"headerlink\" title=\"Jni入门\"></a>Jni入门</h1><p>参考:<br><a href=\"http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html\" target=\"_blank\" rel=\"noopener\">JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki</a></p><a id=\"more\"></a>\n<h3 id=\"1、编写native方法，使用javah创建头文件\"><a href=\"#1、编写native方法，使用javah创建头文件\" class=\"headerlink\" title=\"1、编写native方法，使用javah创建头文件\"></a>1、编写native方法，使用javah创建头文件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> String <span class=\"title\">sayHello</span><span class=\"params\">(String name)</span></span>; <span class=\"comment\">// 1.声明这是一个native函数，由本地代码实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javah -jni -classpath JniCalcINterface</span><br></pre></td></tr></table></figure>\n<p>参数说明：<br>classpath：类搜索路径，这里表示从当前的 bin 目录下查找<br>d：将生成的头文件放到当前的 jni 目录下<br>o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）</p>\n<p><strong>注意：-d和-o只能使用其中一个参数。</strong></p>\n<p>创建的.h文件如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span>  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;  </span></span></span><br><span class=\"line\"><span class=\"comment\">/* Header for class com_study_jnilearn_HelloWorld */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _Included_com_study_jnilearn_HelloWorld  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _Included_com_study_jnilearn_HelloWorld  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus  </span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Class:     com_study_jnilearn_HelloWorld </span></span><br><span class=\"line\"><span class=\"comment\"> * Method:    sayHello </span></span><br><span class=\"line\"><span class=\"comment\"> * Signature: (Ljava/lang/String;)Ljava/lang/String; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello  </span><br><span class=\"line\">  (JNIEnv *, jclass, jstring);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>**注意 extern “C”表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern “C”后面</p>\n<h3 id=\"3、编译出so文件\"><a href=\"#3、编译出so文件\" class=\"headerlink\" title=\"3、编译出so文件\"></a>3、编译出so文件</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so</span><br></pre></td></tr></table></figure>\n<p>参数含义:</p>\n<p>-L </p>\n<ul>\n<li>表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。</li>\n</ul>\n<p>-l (L的小写)</p>\n<ul>\n<li>表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test</li>\n</ul>\n<p>-include</p>\n<ul>\n<li>包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。</li>\n</ul>\n<p>-I (i 的大写)</p>\n<ul>\n<li>指定头文件的所在的目录，可以使用相对路径。</li>\n</ul>\n<p>-shared </p>\n<ul>\n<li>指定生成动态链接库</li>\n</ul>\n<p>-fPIC</p>\n<ul>\n<li>表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。</li>\n</ul>\n<p>-o </p>\n<ul>\n<li>指定编译后动态库生成的路径和文件名</li>\n</ul>\n<h3 id=\"4、加载动态库\"><a href=\"#4、加载动态库\" class=\"headerlink\" title=\"4、加载动态库\"></a>4、加载动态库</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">\"HelloWorld\"</span>);  <span class=\"comment\">//方式一</span></span><br><span class=\"line\">    System.load(<span class=\"string\">\"/Users/yangxin/Desktop/libHelloWorld.jnilib\"</span> <span class=\"comment\">//方式二);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀<br>方式2：指定动态库的绝对路径名，需要加上前缀和后缀 <strong>推荐使用这种方法</strong></p>\n<p>如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。<br>有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。</p>\n<ul>\n<li><p>将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下</p>\n</li>\n<li><p>给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。</p>\n</li>\n</ul>\n<h3 id=\"5、运行java程序\"><a href=\"#5、运行java程序\" class=\"headerlink\" title=\"5、运行java程序\"></a>5、运行java程序</h3>","site":{"data":{}},"excerpt":"<h1 id=\"Jni入门\"><a href=\"#Jni入门\" class=\"headerlink\" title=\"Jni入门\"></a>Jni入门</h1><p>参考:<br><a href=\"http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html\" target=\"_blank\" rel=\"noopener\">JNI 开发流程 - JNI/NDK 开发指南 - 极客学院Wiki</a></p>","more":"\n<h3 id=\"1、编写native方法，使用javah创建头文件\"><a href=\"#1、编写native方法，使用javah创建头文件\" class=\"headerlink\" title=\"1、编写native方法，使用javah创建头文件\"></a>1、编写native方法，使用javah创建头文件</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorld</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> String <span class=\"title\">sayHello</span><span class=\"params\">(String name)</span></span>; <span class=\"comment\">// 1.声明这是一个native函数，由本地代码实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javah -jni -classpath JniCalcINterface</span><br></pre></td></tr></table></figure>\n<p>参数说明：<br>classpath：类搜索路径，这里表示从当前的 bin 目录下查找<br>d：将生成的头文件放到当前的 jni 目录下<br>o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）</p>\n<p><strong>注意：-d和-o只能使用其中一个参数。</strong></p>\n<p>创建的.h文件如下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span>  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;  </span></span></span><br><span class=\"line\"><span class=\"comment\">/* Header for class com_study_jnilearn_HelloWorld */</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _Included_com_study_jnilearn_HelloWorld  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _Included_com_study_jnilearn_HelloWorld  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus  </span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * Class:     com_study_jnilearn_HelloWorld </span></span><br><span class=\"line\"><span class=\"comment\"> * Method:    sayHello </span></span><br><span class=\"line\"><span class=\"comment\"> * Signature: (Ljava/lang/String;)Ljava/lang/String; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\">JNIEXPORT jstring JNICALL Java_com_study_jnilearn_HelloWorld_sayHello  </span><br><span class=\"line\">  (JNIEnv *, jclass, jstring);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus  </span></span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<p>**注意 extern “C”表示兼容C语言，当调用C编写的.h头文件或者函数的时候，一定要写在extern “C”后面</p>\n<h3 id=\"3、编译出so文件\"><a href=\"#3、编译出so文件\" class=\"headerlink\" title=\"3、编译出so文件\"></a>3、编译出so文件</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloWorld.c -o libHelloWorld.so</span><br></pre></td></tr></table></figure>\n<p>参数含义:</p>\n<p>-L </p>\n<ul>\n<li>表示要链接的库所在的目录。-L.  表示要链接的库在当前目录， -L/usr/lib 表示要连接的库在/usr/lib下。目录在/usr/lib时，系统会自动搜索这个目录，可以不用指明。</li>\n</ul>\n<p>-l (L的小写)</p>\n<ul>\n<li>表示需要链接库的名称，注意不是库文件名称，比如库文件为 libtest.so，那么库名称为test</li>\n</ul>\n<p>-include</p>\n<ul>\n<li>包含头文件，这个很少用，因为一般情况下在源码中，都有指定头文件。</li>\n</ul>\n<p>-I (i 的大写)</p>\n<ul>\n<li>指定头文件的所在的目录，可以使用相对路径。</li>\n</ul>\n<p>-shared </p>\n<ul>\n<li>指定生成动态链接库</li>\n</ul>\n<p>-fPIC</p>\n<ul>\n<li>表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时事通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码共享的目的。</li>\n</ul>\n<p>-o </p>\n<ul>\n<li>指定编译后动态库生成的路径和文件名</li>\n</ul>\n<h3 id=\"4、加载动态库\"><a href=\"#4、加载动态库\" class=\"headerlink\" title=\"4、加载动态库\"></a>4、加载动态库</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">    System.loadLibrary(<span class=\"string\">\"HelloWorld\"</span>);  <span class=\"comment\">//方式一</span></span><br><span class=\"line\">    System.load(<span class=\"string\">\"/Users/yangxin/Desktop/libHelloWorld.jnilib\"</span> <span class=\"comment\">//方式二);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀<br>方式2：指定动态库的绝对路径名，需要加上前缀和后缀 <strong>推荐使用这种方法</strong></p>\n<p>如果使用方式1，java 会去 java.library.path 系统属性指定的目录下查找动态库文件，如果没有找到会抛出java.lang.UnsatisfiedLinkError异常。<br>有两种方式可以让 Java 从 java.library.path 找到动态链接库文件，聪明的你应该已经想到了。</p>\n<ul>\n<li><p>将动态链接库拷贝到java.library.path目录下, linux可以拷贝到/usr/local/lib目录下</p>\n</li>\n<li><p>给 jvm 添加“-Djava.library.path=动态链接库搜索目录”参数，指定系统属性 java.library.path 的值 java -Djava.library.path=/Users/yangxin/Desktop Linux/Unix 环境下可以通过设置 LD_LIBRARY_PATH 环境变量，指定库的搜索目录。</p>\n</li>\n</ul>\n<h3 id=\"5、运行java程序\"><a href=\"#5、运行java程序\" class=\"headerlink\" title=\"5、运行java程序\"></a>5、运行java程序</h3>"},{"title":"多个cpp文件编译共享同一个.h文件的全局变量","date":"2019-04-13T05:12:22.000Z","_content":"\n# 多个cpp文件编译共享同一个.h文件的全局变量\n\n在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案:\n\n## 一个cpp文件多次#include一个.h文件\n> 使用#ifndef\n\n```c++\n//在.h头文件中\n#ifndef <标示> //自定义的一个标示, 习惯性用.h文件名大写\n#define <标示>\n//...头文件内容\n#endif\n```\n原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容\n\n**这种方法只能解决一个cpp源文件中的重复include问题**\n\n## 多个cpp文件多次#include一个.h文件\n### 使用static关键字\n```c++\n//.h头文件\nstatic int i;\nstatic void func();\n```\n* #### static修饰变量\n变量static标记之后，多个cpp文件include不会出现问题。\n**但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的**\n下面是网上的一些解释:\n> 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。\n> \n> 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。\n\n* #### static修饰函数\n函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。\n*似乎是这样的。。。我的理解。网上说static和inline经常配合使用*\n\n### 使用extern关键字\nextern表明该变量在别的地方已经定义过了，在这里要使用那个变量\n\n```c++\n//cpp文件\nextern int i;\n```\n经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。\n\n定义在.h文件的情况下，**在使用extern时，不能include定义它的.h文件。**否则还是会出现重定义的问题。\n","source":"_posts/C/多个cpp文件编译共享同一个-h文件的全局变量.md","raw":"---\ntitle: 多个cpp文件编译共享同一个.h文件的全局变量\ndate: 2019-04-13 13:12:22\ncategories: \n- C/C++\ntags:\n---\n\n# 多个cpp文件编译共享同一个.h文件的全局变量\n\n在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案:\n\n## 一个cpp文件多次#include一个.h文件\n> 使用#ifndef\n\n```c++\n//在.h头文件中\n#ifndef <标示> //自定义的一个标示, 习惯性用.h文件名大写\n#define <标示>\n//...头文件内容\n#endif\n```\n原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容\n\n**这种方法只能解决一个cpp源文件中的重复include问题**\n\n## 多个cpp文件多次#include一个.h文件\n### 使用static关键字\n```c++\n//.h头文件\nstatic int i;\nstatic void func();\n```\n* #### static修饰变量\n变量static标记之后，多个cpp文件include不会出现问题。\n**但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的**\n下面是网上的一些解释:\n> 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。\n> \n> 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。\n\n* #### static修饰函数\n函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。\n*似乎是这样的。。。我的理解。网上说static和inline经常配合使用*\n\n### 使用extern关键字\nextern表明该变量在别的地方已经定义过了，在这里要使用那个变量\n\n```c++\n//cpp文件\nextern int i;\n```\n经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。\n\n定义在.h文件的情况下，**在使用extern时，不能include定义它的.h文件。**否则还是会出现重定义的问题。\n","slug":"C/多个cpp文件编译共享同一个-h文件的全局变量","published":1,"updated":"2021-10-03T01:57:41.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7a000bg0jeta98k380","content":"<h1 id=\"多个cpp文件编译共享同一个-h文件的全局变量\"><a href=\"#多个cpp文件编译共享同一个-h文件的全局变量\" class=\"headerlink\" title=\"多个cpp文件编译共享同一个.h文件的全局变量\"></a>多个cpp文件编译共享同一个.h文件的全局变量</h1><a id=\"more\"></a><p>在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案:</p>\n<h2 id=\"一个cpp文件多次-include一个-h文件\"><a href=\"#一个cpp文件多次-include一个-h文件\" class=\"headerlink\" title=\"一个cpp文件多次#include一个.h文件\"></a>一个cpp文件多次#include一个.h文件</h2><blockquote>\n<p>使用#ifndef</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在.h头文件中</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> <span class=\"meta-string\">&lt;标示&gt; //自定义的一个标示, 习惯性用.h文件名大写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> <span class=\"meta-string\">&lt;标示&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//...头文件内容</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容</p>\n<p><strong>这种方法只能解决一个cpp源文件中的重复include问题</strong></p>\n<h2 id=\"多个cpp文件多次-include一个-h文件\"><a href=\"#多个cpp文件多次-include一个-h文件\" class=\"headerlink\" title=\"多个cpp文件多次#include一个.h文件\"></a>多个cpp文件多次#include一个.h文件</h2><h3 id=\"使用static关键字\"><a href=\"#使用static关键字\" class=\"headerlink\" title=\"使用static关键字\"></a>使用static关键字</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h头文件</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"static修饰变量\"><a href=\"#static修饰变量\" class=\"headerlink\" title=\"static修饰变量\"></a>static修饰变量</h4><p>变量static标记之后，多个cpp文件include不会出现问题。<br><strong>但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的</strong><br>下面是网上的一些解释:</p>\n<blockquote>\n<p>定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。</p>\n<p>假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。</p>\n</blockquote>\n</li>\n<li><h4 id=\"static修饰函数\"><a href=\"#static修饰函数\" class=\"headerlink\" title=\"static修饰函数\"></a>static修饰函数</h4><p>函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。<br><em>似乎是这样的。。。我的理解。网上说static和inline经常配合使用</em></p>\n</li>\n</ul>\n<h3 id=\"使用extern关键字\"><a href=\"#使用extern关键字\" class=\"headerlink\" title=\"使用extern关键字\"></a>使用extern关键字</h3><p>extern表明该变量在别的地方已经定义过了，在这里要使用那个变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cpp文件</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i;</span><br></pre></td></tr></table></figure>\n<p>经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。</p>\n<p>定义在.h文件的情况下，<strong>在使用extern时，不能include定义它的.h文件。</strong>否则还是会出现重定义的问题。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"多个cpp文件编译共享同一个-h文件的全局变量\"><a href=\"#多个cpp文件编译共享同一个-h文件的全局变量\" class=\"headerlink\" title=\"多个cpp文件编译共享同一个.h文件的全局变量\"></a>多个cpp文件编译共享同一个.h文件的全局变量</h1>","more":"<p>在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案:</p>\n<h2 id=\"一个cpp文件多次-include一个-h文件\"><a href=\"#一个cpp文件多次-include一个-h文件\" class=\"headerlink\" title=\"一个cpp文件多次#include一个.h文件\"></a>一个cpp文件多次#include一个.h文件</h2><blockquote>\n<p>使用#ifndef</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在.h头文件中</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> <span class=\"meta-string\">&lt;标示&gt; //自定义的一个标示, 习惯性用.h文件名大写</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> <span class=\"meta-string\">&lt;标示&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">//...头文件内容</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容</p>\n<p><strong>这种方法只能解决一个cpp源文件中的重复include问题</strong></p>\n<h2 id=\"多个cpp文件多次-include一个-h文件\"><a href=\"#多个cpp文件多次-include一个-h文件\" class=\"headerlink\" title=\"多个cpp文件多次#include一个.h文件\"></a>多个cpp文件多次#include一个.h文件</h2><h3 id=\"使用static关键字\"><a href=\"#使用static关键字\" class=\"headerlink\" title=\"使用static关键字\"></a>使用static关键字</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//.h头文件</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"static修饰变量\"><a href=\"#static修饰变量\" class=\"headerlink\" title=\"static修饰变量\"></a>static修饰变量</h4><p>变量static标记之后，多个cpp文件include不会出现问题。<br><strong>但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的</strong><br>下面是网上的一些解释:</p>\n<blockquote>\n<p>定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。</p>\n<p>假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。</p>\n</blockquote>\n</li>\n<li><h4 id=\"static修饰函数\"><a href=\"#static修饰函数\" class=\"headerlink\" title=\"static修饰函数\"></a>static修饰函数</h4><p>函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。<br><em>似乎是这样的。。。我的理解。网上说static和inline经常配合使用</em></p>\n</li>\n</ul>\n<h3 id=\"使用extern关键字\"><a href=\"#使用extern关键字\" class=\"headerlink\" title=\"使用extern关键字\"></a>使用extern关键字</h3><p>extern表明该变量在别的地方已经定义过了，在这里要使用那个变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//cpp文件</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i;</span><br></pre></td></tr></table></figure>\n<p>经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。</p>\n<p>定义在.h文件的情况下，<strong>在使用extern时，不能include定义它的.h文件。</strong>否则还是会出现重定义的问题。</p>\n"},{"title":"C语言结构体的内存对齐","date":"2019-04-13T05:11:14.000Z","_content":"\n# C语言结构体的内存对齐\n\n## 内存对齐原则\n* 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数\n\n* 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。）\n\n* 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍\n\n## pragram pack(4)\n设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节\n\n## 例子：\n```c++\n# pragram pack(8)\n\nstruct S3\n{\n    double d;\n    char c;\n    int i;\n};\nstruct S4\n{\n    char c1;\n    struct S3 s3;\n    double d;\n};\nprintf(\"%d\\n\", sizeof(struct S4));\n```\n\n最后的输出为 32\n\n## 参考：\n[[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园](https://www.cnblogs.com/zwh0214/p/8833314.html)\n\n## C语言联合体union的sizeof\n\n**分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。**\n\n","source":"_posts/C/C语言结构体的内存对齐.md","raw":"---\ntitle: C语言结构体的内存对齐\ndate: 2019-04-13 13:11:14\ncategories: \n- C/C++\ntags:\n---\n\n# C语言结构体的内存对齐\n\n## 内存对齐原则\n* 数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数\n\n* 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。）\n\n* 结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍\n\n## pragram pack(4)\n设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节\n\n## 例子：\n```c++\n# pragram pack(8)\n\nstruct S3\n{\n    double d;\n    char c;\n    int i;\n};\nstruct S4\n{\n    char c1;\n    struct S3 s3;\n    double d;\n};\nprintf(\"%d\\n\", sizeof(struct S4));\n```\n\n最后的输出为 32\n\n## 参考：\n[[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园](https://www.cnblogs.com/zwh0214/p/8833314.html)\n\n## C语言联合体union的sizeof\n\n**分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。**\n\n","slug":"C/C语言结构体的内存对齐","published":1,"updated":"2021-10-03T01:57:41.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7a000cg0jeq3mf9itx","content":"<h1 id=\"C语言结构体的内存对齐\"><a href=\"#C语言结构体的内存对齐\" class=\"headerlink\" title=\"C语言结构体的内存对齐\"></a>C语言结构体的内存对齐</h1><h2 id=\"内存对齐原则\"><a href=\"#内存对齐原则\" class=\"headerlink\" title=\"内存对齐原则\"></a>内存对齐原则</h2><ul>\n<li><p>数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数</p>\n</li>\n<li><p>结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。）</p>\n</li>\n<li><p>结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍</p>\n</li>\n</ul><a id=\"more\"></a>\n<h2 id=\"pragram-pack-4\"><a href=\"#pragram-pack-4\" class=\"headerlink\" title=\"pragram pack(4)\"></a>pragram pack(4)</h2><p>设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节</p>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># pragram pack(8)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S4</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> c1;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span> <span class=\"title\">s3</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(struct S4));</span><br></pre></td></tr></table></figure>\n<p>最后的输出为 32</p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://www.cnblogs.com/zwh0214/p/8833314.html\" target=\"_blank\" rel=\"noopener\">[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园</a></p>\n<h2 id=\"C语言联合体union的sizeof\"><a href=\"#C语言联合体union的sizeof\" class=\"headerlink\" title=\"C语言联合体union的sizeof\"></a>C语言联合体union的sizeof</h2><p><strong>分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"C语言结构体的内存对齐\"><a href=\"#C语言结构体的内存对齐\" class=\"headerlink\" title=\"C语言结构体的内存对齐\"></a>C语言结构体的内存对齐</h1><h2 id=\"内存对齐原则\"><a href=\"#内存对齐原则\" class=\"headerlink\" title=\"内存对齐原则\"></a>内存对齐原则</h2><ul>\n<li><p>数据成员对齐规则：结构（struct或联合union）的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置: min(#pragma pack()指定的数,这个数据%成员的自身长度)的倍数</p>\n</li>\n<li><p>结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从min(#pragram pack() , 内部长度最长的数据成员)的整数倍地址开始存储。（struct a里存有struct b，b里有char，int，double等元素，那b应该从min(#pragram pack(), 8)的整数倍开始存储。）</p>\n</li>\n<li><p>结构体的总大小，也就是sizeof的结果，必须是 min(#pragram pack() , 长度最长的数据成员) 的整数倍</p>\n</li>\n</ul>","more":"\n<h2 id=\"pragram-pack-4\"><a href=\"#pragram-pack-4\" class=\"headerlink\" title=\"pragram pack(4)\"></a>pragram pack(4)</h2><p>设置内存对齐的字节数， 默认为系统字长，64位系统为8字节，32位系统为4字节</p>\n<h2 id=\"例子：\"><a href=\"#例子：\" class=\"headerlink\" title=\"例子：\"></a>例子：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># pragram pack(8)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S4</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> c1;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">S3</span> <span class=\"title\">s3</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, <span class=\"keyword\">sizeof</span>(struct S4));</span><br></pre></td></tr></table></figure>\n<p>最后的输出为 32</p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://www.cnblogs.com/zwh0214/p/8833314.html\" target=\"_blank\" rel=\"noopener\">[C/C++] 结构体内存对齐用法 - 我自逍遥笑 - 博客园</a></p>\n<h2 id=\"C语言联合体union的sizeof\"><a href=\"#C语言联合体union的sizeof\" class=\"headerlink\" title=\"C语言联合体union的sizeof\"></a>C语言联合体union的sizeof</h2><p><strong>分配给union的实际大小不仅要满足是对齐大小的整数倍，同时要满足实际大小不能小于最大成员的大小。</strong></p>\n"},{"title":"Java获取泛型类型","date":"2020-07-23T12:05:38.000Z","_content":"\n## 获取泛型class的通用方法\n\n```java\nType type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n\n```\n\n因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型\n\n## 无法获取到泛型类型\n\n```java\n// 1. \nclass SuperClass<T>{\n\n}\nSuperClass<String> object = SuperClass<String>()\n\n// 2.\nSubClass<T> extends SuperClass<T>{\n\n}\nSubClass<String> object = SubClass<Strng>()\n```\n\n## 可以获取到泛型类型\n\n```java\n// 1. 子类继承父类时, 明确了泛型类型\nSubClass extends SuperClass<String>{\n\n}\n// 2. 匿名内部类, 子类继承父类的特殊情况\nabstract class SuperClass<T>{\n\n}\nSuperClass<String> object = new SuperClass<String>(){\n    ...\n}\n```\n","source":"_posts/Java/Java获取泛型类型.md","raw":"---\ntitle: Java获取泛型类型\ndate: 2020-07-23 20:05:38\ncategories:\n- Java\ntags:\n- Java\n---\n\n## 获取泛型class的通用方法\n\n```java\nType type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n\n```\n\n因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型\n\n## 无法获取到泛型类型\n\n```java\n// 1. \nclass SuperClass<T>{\n\n}\nSuperClass<String> object = SuperClass<String>()\n\n// 2.\nSubClass<T> extends SuperClass<T>{\n\n}\nSubClass<String> object = SubClass<Strng>()\n```\n\n## 可以获取到泛型类型\n\n```java\n// 1. 子类继承父类时, 明确了泛型类型\nSubClass extends SuperClass<String>{\n\n}\n// 2. 匿名内部类, 子类继承父类的特殊情况\nabstract class SuperClass<T>{\n\n}\nSuperClass<String> object = new SuperClass<String>(){\n    ...\n}\n```\n","slug":"Java/Java获取泛型类型","published":1,"updated":"2021-10-03T01:57:41.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7c000dg0je32vo7uev","content":"<h2 id=\"获取泛型class的通用方法\"><a href=\"#获取泛型class的通用方法\" class=\"headerlink\" title=\"获取泛型class的通用方法\"></a>获取泛型class的通用方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<p>因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型</p>\n<h2 id=\"无法获取到泛型类型\"><a href=\"#无法获取到泛型类型\" class=\"headerlink\" title=\"无法获取到泛型类型\"></a>无法获取到泛型类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass&lt;String&gt; object = SuperClass&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.</span></span><br><span class=\"line\">SubClass&lt;T&gt; extends SuperClass&lt;T&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubClass&lt;String&gt; object = SubClass&lt;Strng&gt;()</span><br></pre></td></tr></table></figure>\n<h2 id=\"可以获取到泛型类型\"><a href=\"#可以获取到泛型类型\" class=\"headerlink\" title=\"可以获取到泛型类型\"></a>可以获取到泛型类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 子类继承父类时, 明确了泛型类型</span></span><br><span class=\"line\">SubClass extends SuperClass&lt;String&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2. 匿名内部类, 子类继承父类的特殊情况</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass&lt;String&gt; object = <span class=\"keyword\">new</span> SuperClass&lt;String&gt;()&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"获取泛型class的通用方法\"><a href=\"#获取泛型class的通用方法\" class=\"headerlink\" title=\"获取泛型class的通用方法\"></a>获取泛型class的通用方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>","more":"\n<p>因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型</p>\n<h2 id=\"无法获取到泛型类型\"><a href=\"#无法获取到泛型类型\" class=\"headerlink\" title=\"无法获取到泛型类型\"></a>无法获取到泛型类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass&lt;String&gt; object = SuperClass&lt;String&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2.</span></span><br><span class=\"line\">SubClass&lt;T&gt; extends SuperClass&lt;T&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubClass&lt;String&gt; object = SubClass&lt;Strng&gt;()</span><br></pre></td></tr></table></figure>\n<h2 id=\"可以获取到泛型类型\"><a href=\"#可以获取到泛型类型\" class=\"headerlink\" title=\"可以获取到泛型类型\"></a>可以获取到泛型类型</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 子类继承父类时, 明确了泛型类型</span></span><br><span class=\"line\">SubClass extends SuperClass&lt;String&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2. 匿名内部类, 子类继承父类的特殊情况</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperClass&lt;String&gt; object = <span class=\"keyword\">new</span> SuperClass&lt;String&gt;()&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Activity class {} does not exist","date":"2019-04-16T11:23:35.000Z","_content":"\n# Activity class {} does not exist\n\n有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。\n\n**解决办法：**\n使用adb命令\n```shell\nadb uninstall [包名]\n```\n\n估计可能是调试的APP没有彻底卸载造成的。","source":"_posts/Android/Activity-class-does-not-exist.md","raw":"---\ntitle: 'Activity class {} does not exist'\ndate: 2019-04-16 19:23:35\ntags:\n- AndroidStudio\ncategories:\n- Android\n- AndroidStudio\n---\n\n# Activity class {} does not exist\n\n有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。\n\n**解决办法：**\n使用adb命令\n```shell\nadb uninstall [包名]\n```\n\n估计可能是调试的APP没有彻底卸载造成的。","slug":"Android/Activity-class-does-not-exist","published":1,"updated":"2021-10-03T01:57:41.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7d000hg0jetewhzjas","content":"<h1 id=\"Activity-class-does-not-exist\"><a href=\"#Activity-class-does-not-exist\" class=\"headerlink\" title=\"Activity class {} does not exist\"></a>Activity class {} does not exist</h1><a id=\"more\"></a><p>有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。</p>\n<p><strong>解决办法：</strong><br>使用adb命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb uninstall [包名]</span><br></pre></td></tr></table></figure></p>\n<p>估计可能是调试的APP没有彻底卸载造成的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Activity-class-does-not-exist\"><a href=\"#Activity-class-does-not-exist\" class=\"headerlink\" title=\"Activity class {} does not exist\"></a>Activity class {} does not exist</h1>","more":"<p>有时候真机调试，在手机上卸载调试的APP就会出现上述的问题。</p>\n<p><strong>解决办法：</strong><br>使用adb命令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb uninstall [包名]</span><br></pre></td></tr></table></figure></p>\n<p>估计可能是调试的APP没有彻底卸载造成的。</p>\n"},{"title":"RecyclerView设置item的间距","date":"2019-07-09T09:29:55.000Z","_content":"\n# RecyclerView设置item的间距\n\n## 关于GridLayoutManager\n\n当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，**实际上就是将屏幕均分为四份，每一份都是180px宽**（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。\n\n## 自定义ItemDecoration\n\n### getItemOffsets方法\n\n设置ItemView的内嵌偏移长度\n\nItemView 外面会包裹着一个矩形（outRect）\n内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔\n相当于为item添加了padding\n\n**常用的getItemOffsets的计算**\n\n```java\n// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等\npublic class EmojiItemDecoration extends RecyclerView.ItemDecoration {\n\n    private int mNumColumn;\n    private int mVerticalSpacing;\n    private int mItemWidth;\n    private int mItemHorizontalSpacing;\n    private boolean mInitSpacing = false;\n\n    public EmojiItemDecoration(int column, int itemWidth, int verticalSpacing) {\n        mNumColumn = column;\n        mItemWidth = itemWidth;\n        mVerticalSpacing = verticalSpacing;\n    }\n\n    @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {\n\n        if (!mInitSpacing) {\n            mInitSpacing = true;\n            int parentWidth = parent.getWidth();\n\n            mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + 1);\n        }\n        int position = parent.getChildAdapterPosition(view);\n        int column = position % mNumColumn;\n\n        outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn;\n        outRect.right = (column + 1) * mItemHorizontalSpacing / mNumColumn;\n        \n\n        if (position < mNumColumn) {\n            outRect.top = Dimensions.pxFromDp(12);\n        }\n\n        if (position >= mNumColumn) {\n            outRect.top = mVerticalSpacing;\n        }\n    }\n}\n```\n\n","source":"_posts/Android/RecyclerView设置item的间距.md","raw":"---\ntitle: RecyclerView设置item的间距\ndate: 2019-07-09 17:29:55\ntags:\n- View\n- RecyclerView\ncategories:\n- Android\n---\n\n# RecyclerView设置item的间距\n\n## 关于GridLayoutManager\n\n当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，**实际上就是将屏幕均分为四份，每一份都是180px宽**（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。\n\n## 自定义ItemDecoration\n\n### getItemOffsets方法\n\n设置ItemView的内嵌偏移长度\n\nItemView 外面会包裹着一个矩形（outRect）\n内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔\n相当于为item添加了padding\n\n**常用的getItemOffsets的计算**\n\n```java\n// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等\npublic class EmojiItemDecoration extends RecyclerView.ItemDecoration {\n\n    private int mNumColumn;\n    private int mVerticalSpacing;\n    private int mItemWidth;\n    private int mItemHorizontalSpacing;\n    private boolean mInitSpacing = false;\n\n    public EmojiItemDecoration(int column, int itemWidth, int verticalSpacing) {\n        mNumColumn = column;\n        mItemWidth = itemWidth;\n        mVerticalSpacing = verticalSpacing;\n    }\n\n    @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {\n\n        if (!mInitSpacing) {\n            mInitSpacing = true;\n            int parentWidth = parent.getWidth();\n\n            mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + 1);\n        }\n        int position = parent.getChildAdapterPosition(view);\n        int column = position % mNumColumn;\n\n        outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn;\n        outRect.right = (column + 1) * mItemHorizontalSpacing / mNumColumn;\n        \n\n        if (position < mNumColumn) {\n            outRect.top = Dimensions.pxFromDp(12);\n        }\n\n        if (position >= mNumColumn) {\n            outRect.top = mVerticalSpacing;\n        }\n    }\n}\n```\n\n","slug":"Android/RecyclerView设置item的间距","published":1,"updated":"2021-10-03T01:57:41.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7e000ig0jen4yl3fww","content":"<h1 id=\"RecyclerView设置item的间距\"><a href=\"#RecyclerView设置item的间距\" class=\"headerlink\" title=\"RecyclerView设置item的间距\"></a>RecyclerView设置item的间距</h1><a id=\"more\"></a><h2 id=\"关于GridLayoutManager\"><a href=\"#关于GridLayoutManager\" class=\"headerlink\" title=\"关于GridLayoutManager\"></a>关于GridLayoutManager</h2><p>当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，<strong>实际上就是将屏幕均分为四份，每一份都是180px宽</strong>（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。</p>\n<h2 id=\"自定义ItemDecoration\"><a href=\"#自定义ItemDecoration\" class=\"headerlink\" title=\"自定义ItemDecoration\"></a>自定义ItemDecoration</h2><h3 id=\"getItemOffsets方法\"><a href=\"#getItemOffsets方法\" class=\"headerlink\" title=\"getItemOffsets方法\"></a>getItemOffsets方法</h3><p>设置ItemView的内嵌偏移长度</p>\n<p>ItemView 外面会包裹着一个矩形（outRect）<br>内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔<br>相当于为item添加了padding</p>\n<p><strong>常用的getItemOffsets的计算</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmojiItemDecoration</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ItemDecoration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mNumColumn;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mVerticalSpacing;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mItemWidth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mItemHorizontalSpacing;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mInitSpacing = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EmojiItemDecoration</span><span class=\"params\">(<span class=\"keyword\">int</span> column, <span class=\"keyword\">int</span> itemWidth, <span class=\"keyword\">int</span> verticalSpacing)</span> </span>&#123;</span><br><span class=\"line\">        mNumColumn = column;</span><br><span class=\"line\">        mItemWidth = itemWidth;</span><br><span class=\"line\">        mVerticalSpacing = verticalSpacing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getItemOffsets</span><span class=\"params\">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mInitSpacing) &#123;</span><br><span class=\"line\">            mInitSpacing = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> parentWidth = parent.getWidth();</span><br><span class=\"line\"></span><br><span class=\"line\">            mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> position = parent.getChildAdapterPosition(view);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> column = position % mNumColumn;</span><br><span class=\"line\"></span><br><span class=\"line\">        outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn;</span><br><span class=\"line\">        outRect.right = (column + <span class=\"number\">1</span>) * mItemHorizontalSpacing / mNumColumn;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position &lt; mNumColumn) &#123;</span><br><span class=\"line\">            outRect.top = Dimensions.pxFromDp(<span class=\"number\">12</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position &gt;= mNumColumn) &#123;</span><br><span class=\"line\">            outRect.top = mVerticalSpacing;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"RecyclerView设置item的间距\"><a href=\"#RecyclerView设置item的间距\" class=\"headerlink\" title=\"RecyclerView设置item的间距\"></a>RecyclerView设置item的间距</h1>","more":"<h2 id=\"关于GridLayoutManager\"><a href=\"#关于GridLayoutManager\" class=\"headerlink\" title=\"关于GridLayoutManager\"></a>关于GridLayoutManager</h2><p>当一个RecyclerView设置了一个GridLayoutManager(this,count)，并且count为4的时候，<strong>实际上就是将屏幕均分为四份，每一份都是180px宽</strong>（以720px为例，我们只考虑左右，暂不考虑上下，原理是相同的），如果不设置ItemDecoration，那么默认item由左开始布置。</p>\n<h2 id=\"自定义ItemDecoration\"><a href=\"#自定义ItemDecoration\" class=\"headerlink\" title=\"自定义ItemDecoration\"></a>自定义ItemDecoration</h2><h3 id=\"getItemOffsets方法\"><a href=\"#getItemOffsets方法\" class=\"headerlink\" title=\"getItemOffsets方法\"></a>getItemOffsets方法</h3><p>设置ItemView的内嵌偏移长度</p>\n<p>ItemView 外面会包裹着一个矩形（outRect）<br>内嵌偏移长度 是指：该矩形（outRect）与 ItemView的间隔<br>相当于为item添加了padding</p>\n<p><strong>常用的getItemOffsets的计算</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 是item在GridLayoutManager中居中显示，并且item之间的间距，每列第一个item和每列最后一个item到recyclerview边界的距离都相等</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmojiItemDecoration</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecyclerView</span>.<span class=\"title\">ItemDecoration</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mNumColumn;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mVerticalSpacing;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mItemWidth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mItemHorizontalSpacing;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mInitSpacing = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EmojiItemDecoration</span><span class=\"params\">(<span class=\"keyword\">int</span> column, <span class=\"keyword\">int</span> itemWidth, <span class=\"keyword\">int</span> verticalSpacing)</span> </span>&#123;</span><br><span class=\"line\">        mNumColumn = column;</span><br><span class=\"line\">        mItemWidth = itemWidth;</span><br><span class=\"line\">        mVerticalSpacing = verticalSpacing;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getItemOffsets</span><span class=\"params\">(Rect outRect, View view, RecyclerView parent, RecyclerView.State state)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mInitSpacing) &#123;</span><br><span class=\"line\">            mInitSpacing = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> parentWidth = parent.getWidth();</span><br><span class=\"line\"></span><br><span class=\"line\">            mItemHorizontalSpacing = (parentWidth - parent.getPaddingLeft() - parent.getPaddingRight() - mItemWidth * mNumColumn) / (mNumColumn + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> position = parent.getChildAdapterPosition(view);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> column = position % mNumColumn;</span><br><span class=\"line\"></span><br><span class=\"line\">        outRect.left = (mNumColumn - column) * mItemHorizontalSpacing / mNumColumn;</span><br><span class=\"line\">        outRect.right = (column + <span class=\"number\">1</span>) * mItemHorizontalSpacing / mNumColumn;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position &lt; mNumColumn) &#123;</span><br><span class=\"line\">            outRect.top = Dimensions.pxFromDp(<span class=\"number\">12</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (position &gt;= mNumColumn) &#123;</span><br><span class=\"line\">            outRect.top = mVerticalSpacing;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"RecyclerView缓存机制总结","date":"2019-08-14T16:31:17.000Z","_content":"\n# RecyclerView缓存机制总结\n\n## 基本概念\n**scrapped:** \nA \"scrapped\" view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse\n\n## RecyclerView中涉及到缓存的集合\n\n* mAttachedScrap\n    * 显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。\n* mChangedScrap\n    * 显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生\n* mCachedViews \n    * 在屏幕外的Holder。缓存，幕刃大小为2。\n* mRecyclerPool\n    * 在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法\n\nmAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。\nmRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法\n**很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。**\n\n## RecyclerView获取Holder的顺序(sdk 28)\n\n1. getChangedScrapViewForPosition\n2. getScrapOrHiddenOrCachedHolderForPosition\n3. getScrapOrCachedViewForId\n4. getChildViewHolder\n5. mViewCacheExtension.getViewForPositionAndType\n6. getRecycledViewPool().getRecycledView\n7. mAdapter.createViewHolder\n\n## 四级缓存\n1. mAttachedScrap  mChangedScrap\n2. mCacheView\n3. mViewCacheExtension\n4. mRecyclerPool\n\n## ListView的缓存机制\n\n### 缓存的集合\n* mActiveViews \n    * 屏幕内的view，可直接重用\n* mScrapViews\n    * 屏幕外的view，需要调用bind\n\n### 与RecyclerView的不同\n1. 缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。\n2. RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。 \n而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView）\n3. RecyclerView可以实现局部刷新， ListView不行\n\n\n## 参考：\n[RecyclerView源码分析缓存机制](https://blog.jiahuan.me/2018/07/27/RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/)\n\n[RecyclerView的缓存机制](https://www.jianshu.com/p/efe81969f69d)\n\n[Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21#wechat_redirect)\n\n\n## test\n\n**Recycler.onMeasure()**\n```java\n@Override\nprotected  void  onMeasure(int widthSpec, int heightSpec)  {\n    if (mLayout == null) {\n        // 未设置LayoutManager，采用defaultMeasure\n        defaultOnMeasure(widthSpec, heightSpec);\n        return;\n    }\n     // 自动测量\n    if (mLayout.isAutoMeasureEnabled()) {\n        ...\n        // 交给 LayoutManager测量自身\n        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n        final  boolean measureSpecModeIsExactly =\n                    widthMode == MeasureSpec._EXACTLY_ && heightMode == MeasureSpec. _EXACTLY_ ;\n        // 当宽高都为 EXACTLY,结束测量\n        if (measureSpecModeIsExactly || mAdapter == null) {\n            return;\n        }\n        if (mState.mLayoutStep == State. _STEP_START_ ) {\n        // 进行第一步测量\n            dispatchLayoutStep1();\n        }\n        ...\n        // 进行第二步测量\n        dispatchLayoutStep2();\n        // now we can get the width and height from the children.\n        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n      \n        // 如果 RecyclerView 宽高不是 exactly 并且至少一个child的宽高不是 exactly\n        // 就需要进行二次测量\n        if (mLayout.shouldMeasureTwice()) {\n            ...\n            dispatchLayoutStep2();\n            // now we can get the width and height from the children.\n            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n        }\n    } else {\n        if (mHasFixSize) {\n            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n            return;\n        }\n\n        \n    }\n}\n```","source":"_posts/Android/RecyclerView缓存机制总结.md","raw":"---\ntitle: RecyclerView缓存机制总结\ndate: 2019-08-15 00:31:17\ntags:\n- Android\n- View\ncategories:\n- Android\n- View\n---\n\n# RecyclerView缓存机制总结\n\n## 基本概念\n**scrapped:** \nA \"scrapped\" view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse\n\n## RecyclerView中涉及到缓存的集合\n\n* mAttachedScrap\n    * 显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。\n* mChangedScrap\n    * 显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生\n* mCachedViews \n    * 在屏幕外的Holder。缓存，幕刃大小为2。\n* mRecyclerPool\n    * 在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法\n\nmAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。\nmRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法\n**很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。**\n\n## RecyclerView获取Holder的顺序(sdk 28)\n\n1. getChangedScrapViewForPosition\n2. getScrapOrHiddenOrCachedHolderForPosition\n3. getScrapOrCachedViewForId\n4. getChildViewHolder\n5. mViewCacheExtension.getViewForPositionAndType\n6. getRecycledViewPool().getRecycledView\n7. mAdapter.createViewHolder\n\n## 四级缓存\n1. mAttachedScrap  mChangedScrap\n2. mCacheView\n3. mViewCacheExtension\n4. mRecyclerPool\n\n## ListView的缓存机制\n\n### 缓存的集合\n* mActiveViews \n    * 屏幕内的view，可直接重用\n* mScrapViews\n    * 屏幕外的view，需要调用bind\n\n### 与RecyclerView的不同\n1. 缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。\n2. RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。 \n而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView）\n3. RecyclerView可以实现局部刷新， ListView不行\n\n\n## 参考：\n[RecyclerView源码分析缓存机制](https://blog.jiahuan.me/2018/07/27/RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/)\n\n[RecyclerView的缓存机制](https://www.jianshu.com/p/efe81969f69d)\n\n[Android ListView 与 RecyclerView 对比浅析--缓存机制](https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653578065&idx=2&sn=25e64a8bb7b5934cf0ce2e49549a80d6&chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&scene=21#wechat_redirect)\n\n\n## test\n\n**Recycler.onMeasure()**\n```java\n@Override\nprotected  void  onMeasure(int widthSpec, int heightSpec)  {\n    if (mLayout == null) {\n        // 未设置LayoutManager，采用defaultMeasure\n        defaultOnMeasure(widthSpec, heightSpec);\n        return;\n    }\n     // 自动测量\n    if (mLayout.isAutoMeasureEnabled()) {\n        ...\n        // 交给 LayoutManager测量自身\n        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n        final  boolean measureSpecModeIsExactly =\n                    widthMode == MeasureSpec._EXACTLY_ && heightMode == MeasureSpec. _EXACTLY_ ;\n        // 当宽高都为 EXACTLY,结束测量\n        if (measureSpecModeIsExactly || mAdapter == null) {\n            return;\n        }\n        if (mState.mLayoutStep == State. _STEP_START_ ) {\n        // 进行第一步测量\n            dispatchLayoutStep1();\n        }\n        ...\n        // 进行第二步测量\n        dispatchLayoutStep2();\n        // now we can get the width and height from the children.\n        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n      \n        // 如果 RecyclerView 宽高不是 exactly 并且至少一个child的宽高不是 exactly\n        // 就需要进行二次测量\n        if (mLayout.shouldMeasureTwice()) {\n            ...\n            dispatchLayoutStep2();\n            // now we can get the width and height from the children.\n            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);\n        }\n    } else {\n        if (mHasFixSize) {\n            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);\n            return;\n        }\n\n        \n    }\n}\n```","slug":"Android/RecyclerView缓存机制总结","published":1,"updated":"2021-10-03T01:57:41.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7g000lg0jex9qy6yk2","content":"<h1 id=\"RecyclerView缓存机制总结\"><a href=\"#RecyclerView缓存机制总结\" class=\"headerlink\" title=\"RecyclerView缓存机制总结\"></a>RecyclerView缓存机制总结</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><a id=\"more\"></a><p><strong>scrapped:</strong><br>A “scrapped” view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse</p>\n<h2 id=\"RecyclerView中涉及到缓存的集合\"><a href=\"#RecyclerView中涉及到缓存的集合\" class=\"headerlink\" title=\"RecyclerView中涉及到缓存的集合\"></a>RecyclerView中涉及到缓存的集合</h2><ul>\n<li>mAttachedScrap<ul>\n<li>显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。</li>\n</ul>\n</li>\n<li>mChangedScrap<ul>\n<li>显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生</li>\n</ul>\n</li>\n<li>mCachedViews <ul>\n<li>在屏幕外的Holder。缓存，幕刃大小为2。</li>\n</ul>\n</li>\n<li>mRecyclerPool<ul>\n<li>在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法</li>\n</ul>\n</li>\n</ul>\n<p>mAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。<br>mRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法<br><strong>很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。</strong></p>\n<h2 id=\"RecyclerView获取Holder的顺序-sdk-28\"><a href=\"#RecyclerView获取Holder的顺序-sdk-28\" class=\"headerlink\" title=\"RecyclerView获取Holder的顺序(sdk 28)\"></a>RecyclerView获取Holder的顺序(sdk 28)</h2><ol>\n<li>getChangedScrapViewForPosition</li>\n<li>getScrapOrHiddenOrCachedHolderForPosition</li>\n<li>getScrapOrCachedViewForId</li>\n<li>getChildViewHolder</li>\n<li>mViewCacheExtension.getViewForPositionAndType</li>\n<li>getRecycledViewPool().getRecycledView</li>\n<li>mAdapter.createViewHolder</li>\n</ol>\n<h2 id=\"四级缓存\"><a href=\"#四级缓存\" class=\"headerlink\" title=\"四级缓存\"></a>四级缓存</h2><ol>\n<li>mAttachedScrap  mChangedScrap</li>\n<li>mCacheView</li>\n<li>mViewCacheExtension</li>\n<li>mRecyclerPool</li>\n</ol>\n<h2 id=\"ListView的缓存机制\"><a href=\"#ListView的缓存机制\" class=\"headerlink\" title=\"ListView的缓存机制\"></a>ListView的缓存机制</h2><h3 id=\"缓存的集合\"><a href=\"#缓存的集合\" class=\"headerlink\" title=\"缓存的集合\"></a>缓存的集合</h3><ul>\n<li>mActiveViews <ul>\n<li>屏幕内的view，可直接重用</li>\n</ul>\n</li>\n<li>mScrapViews<ul>\n<li>屏幕外的view，需要调用bind</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与RecyclerView的不同\"><a href=\"#与RecyclerView的不同\" class=\"headerlink\" title=\"与RecyclerView的不同\"></a>与RecyclerView的不同</h3><ol>\n<li>缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。</li>\n<li>RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。<br>而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView）</li>\n<li>RecyclerView可以实现局部刷新， ListView不行</li>\n</ol>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://blog.jiahuan.me/2018/07/27/RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">RecyclerView源码分析缓存机制</a></p>\n<p><a href=\"https://www.jianshu.com/p/efe81969f69d\" target=\"_blank\" rel=\"noopener\">RecyclerView的缓存机制</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578065&amp;idx=2&amp;sn=25e64a8bb7b5934cf0ce2e49549a80d6&amp;chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">Android ListView 与 RecyclerView 对比浅析–缓存机制</a></p>\n<h2 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h2><p><strong>Recycler.onMeasure()</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span>  <span class=\"keyword\">void</span>  <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthSpec, <span class=\"keyword\">int</span> heightSpec)</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLayout == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 未设置LayoutManager，采用defaultMeasure</span></span><br><span class=\"line\">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 自动测量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 交给 LayoutManager测量自身</span></span><br><span class=\"line\">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">        <span class=\"keyword\">final</span>  <span class=\"keyword\">boolean</span> measureSpecModeIsExactly =</span><br><span class=\"line\">                    widthMode == MeasureSpec._EXACTLY_ &amp;&amp; heightMode == MeasureSpec. _EXACTLY_ ;</span><br><span class=\"line\">        <span class=\"comment\">// 当宽高都为 EXACTLY,结束测量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (measureSpecModeIsExactly || mAdapter == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mState.mLayoutStep == State. _STEP_START_ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 进行第一步测量</span></span><br><span class=\"line\">            dispatchLayoutStep1();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 进行第二步测量</span></span><br><span class=\"line\">        dispatchLayoutStep2();</span><br><span class=\"line\">        <span class=\"comment\">// now we can get the width and height from the children.</span></span><br><span class=\"line\">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 如果 RecyclerView 宽高不是 exactly 并且至少一个child的宽高不是 exactly</span></span><br><span class=\"line\">        <span class=\"comment\">// 就需要进行二次测量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\">            <span class=\"comment\">// now we can get the width and height from the children.</span></span><br><span class=\"line\">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHasFixSize) &#123;</span><br><span class=\"line\">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"RecyclerView缓存机制总结\"><a href=\"#RecyclerView缓存机制总结\" class=\"headerlink\" title=\"RecyclerView缓存机制总结\"></a>RecyclerView缓存机制总结</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2>","more":"<p><strong>scrapped:</strong><br>A “scrapped” view is a view that is still attached to its parent RecyclerView but that has been marked for removal or reuse</p>\n<h2 id=\"RecyclerView中涉及到缓存的集合\"><a href=\"#RecyclerView中涉及到缓存的集合\" class=\"headerlink\" title=\"RecyclerView中涉及到缓存的集合\"></a>RecyclerView中涉及到缓存的集合</h2><ul>\n<li>mAttachedScrap<ul>\n<li>显示在屏幕中，未与RecyclerView分离但被标记移除的Holder。 实际上是从屏幕上分离出来的ViewHolder，但是又即将添加到屏幕上去的ViewHolder。</li>\n</ul>\n</li>\n<li>mChangedScrap<ul>\n<li>显示在屏幕中，数据已经发生改变的Holder。notifxxx方法时产生</li>\n</ul>\n</li>\n<li>mCachedViews <ul>\n<li>在屏幕外的Holder。缓存，幕刃大小为2。</li>\n</ul>\n</li>\n<li>mRecyclerPool<ul>\n<li>在屏幕外的Holder。当mCachedViews满时，存储至此。按照ViewType进行分类存储。默认大小为5。从中取出的Holder需要调用onBindViewHolder方法</li>\n</ul>\n</li>\n</ul>\n<p>mAttachedScrap、mChangedScrap、mCachedViews中取出的Holder是直接可用的，不需要调用onCreatedViewHolder和onBindViewHolder方法。<br>mRecyclerPool中取出的Holder是无效的，需要调用onBindViewHolder方法<br><strong>很奇怪，按照网上mChangedScrap的解释，其中的Holder明显是需要调用onBindViewHolder方法的。但是网上的解释同时又都说不需要调用。。</strong></p>\n<h2 id=\"RecyclerView获取Holder的顺序-sdk-28\"><a href=\"#RecyclerView获取Holder的顺序-sdk-28\" class=\"headerlink\" title=\"RecyclerView获取Holder的顺序(sdk 28)\"></a>RecyclerView获取Holder的顺序(sdk 28)</h2><ol>\n<li>getChangedScrapViewForPosition</li>\n<li>getScrapOrHiddenOrCachedHolderForPosition</li>\n<li>getScrapOrCachedViewForId</li>\n<li>getChildViewHolder</li>\n<li>mViewCacheExtension.getViewForPositionAndType</li>\n<li>getRecycledViewPool().getRecycledView</li>\n<li>mAdapter.createViewHolder</li>\n</ol>\n<h2 id=\"四级缓存\"><a href=\"#四级缓存\" class=\"headerlink\" title=\"四级缓存\"></a>四级缓存</h2><ol>\n<li>mAttachedScrap  mChangedScrap</li>\n<li>mCacheView</li>\n<li>mViewCacheExtension</li>\n<li>mRecyclerPool</li>\n</ol>\n<h2 id=\"ListView的缓存机制\"><a href=\"#ListView的缓存机制\" class=\"headerlink\" title=\"ListView的缓存机制\"></a>ListView的缓存机制</h2><h3 id=\"缓存的集合\"><a href=\"#缓存的集合\" class=\"headerlink\" title=\"缓存的集合\"></a>缓存的集合</h3><ul>\n<li>mActiveViews <ul>\n<li>屏幕内的view，可直接重用</li>\n</ul>\n</li>\n<li>mScrapViews<ul>\n<li>屏幕外的view，需要调用bind</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与RecyclerView的不同\"><a href=\"#与RecyclerView的不同\" class=\"headerlink\" title=\"与RecyclerView的不同\"></a>与RecyclerView的不同</h3><ol>\n<li>缓存不同： RecyclerView缓存的是ViewHolder，避免了每次的findViewByid，ListView缓存的是View。</li>\n<li>RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView。<br>而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView）</li>\n<li>RecyclerView可以实现局部刷新， ListView不行</li>\n</ol>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"https://blog.jiahuan.me/2018/07/27/RecyclerView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/\" target=\"_blank\" rel=\"noopener\">RecyclerView源码分析缓存机制</a></p>\n<p><a href=\"https://www.jianshu.com/p/efe81969f69d\" target=\"_blank\" rel=\"noopener\">RecyclerView的缓存机制</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578065&amp;idx=2&amp;sn=25e64a8bb7b5934cf0ce2e49549a80d6&amp;chksm=84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">Android ListView 与 RecyclerView 对比浅析–缓存机制</a></p>\n<h2 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h2><p><strong>Recycler.onMeasure()</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span>  <span class=\"keyword\">void</span>  <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthSpec, <span class=\"keyword\">int</span> heightSpec)</span>  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLayout == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 未设置LayoutManager，采用defaultMeasure</span></span><br><span class=\"line\">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 自动测量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 交给 LayoutManager测量自身</span></span><br><span class=\"line\">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">        <span class=\"keyword\">final</span>  <span class=\"keyword\">boolean</span> measureSpecModeIsExactly =</span><br><span class=\"line\">                    widthMode == MeasureSpec._EXACTLY_ &amp;&amp; heightMode == MeasureSpec. _EXACTLY_ ;</span><br><span class=\"line\">        <span class=\"comment\">// 当宽高都为 EXACTLY,结束测量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (measureSpecModeIsExactly || mAdapter == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mState.mLayoutStep == State. _STEP_START_ ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 进行第一步测量</span></span><br><span class=\"line\">            dispatchLayoutStep1();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"comment\">// 进行第二步测量</span></span><br><span class=\"line\">        dispatchLayoutStep2();</span><br><span class=\"line\">        <span class=\"comment\">// now we can get the width and height from the children.</span></span><br><span class=\"line\">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 如果 RecyclerView 宽高不是 exactly 并且至少一个child的宽高不是 exactly</span></span><br><span class=\"line\">        <span class=\"comment\">// 就需要进行二次测量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            dispatchLayoutStep2();</span><br><span class=\"line\">            <span class=\"comment\">// now we can get the width and height from the children.</span></span><br><span class=\"line\">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mHasFixSize) &#123;</span><br><span class=\"line\">            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Android自定义注解","date":"2020-06-27T03:06:02.000Z","_content":"\n因为要自定义一个页面导航工具，需要使用自定义注解\n\n## 1. 创建Java Library\n\n创建两个新的module，**创建时module一定要选择Java Library**\n\n两个module分别是:\n* libnavannotation 注解\n* libnavcompile 注解处理器\n\n\n\n## 2. 定义注解\n\n定义两个注解ActivityDestination, FragmentDestination\n\n```kotlin\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class ActivityDestination(\n    val pageUrl: String,\n    val needLogin: Boolean = false,\n    val asStarter: Boolean = false\n)\n```\n\n```kotlin\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class FragmentDestination(\n    val pageUrl: String,\n    val needLogin: Boolean = false,\n    val asStarter: Boolean = false\n)\n```\n\n## 3. 定义注解处理器（关键）\n\n### 3.1 配置build.gradle\n\n```groovy\napply plugin: 'java-library'\napply plugin: 'kotlin'\napply plugin: 'kotlin-kapt'\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    implementation 'com.alibaba:fastjson:1.2.59'\n\n    implementation project(':libnavannotation')\n    implementation 'com.google.auto.service:auto-service:1.0-rc6'\n//    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'\n    kapt 'com.google.auto.service:auto-service:1.0-rc6'\n}\n\nsourceCompatibility = \"8\"\ntargetCompatibility = \"8\"\n```\n\n需要注意以下几点：\n* 如果注解处理器是使用kotlin编写的，那么，一定要添加`kotlin-kapt`插件\n* implementation 导入annotation注解模块\n* 导入auto-service注解处理器依赖，如果是纯Java代码，可以使用`annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'`， **如果是kotlin代码，必须使用`    kapt 'com.google.auto.service:auto-service:1.0-rc6'`。** 我这里还implementation了auto-service\n\n### 3.2 编写注解处理器\n\n```kotlin\n\n@AutoService(Processor::class)\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\n@SupportedAnnotationTypes(\n    \"com.example.libnavannotation.ActivityDestination\",\n    \"com.example.libnavannotation.FragmentDestination\"\n)\nclass NavProcessor : AbstractProcessor() {\n\n    override fun init(processingEnv: ProcessingEnvironment) {\n        super.init(processingEnv)\n        \n        ...\n        \n    }\n\n    override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {\n\n        ...\n        \n    }\n}\n```\n\n**注意注解处理器类上面的几个注解**\n\n### 3.3 创建processor configuration file\n\n这里取决于gradle的版本，**高版本必须创建processor配置文件，否则不会执行注解处理器的代码**\n\n* 需要在注解处理器所在module的 main 底下新建一个package，名称为 resources\n* 在 `resources` 底下新建文件 `META-INF/services/javax.annotation.processing.Processor`\n* 在 `javax.annotation.processing.Processor` 下写入 注解处理器的全名称  eg: `com.example.libnavcompiler.NavProcessor`\n\n## 4. 使用注解\n\n在Android工程module中配置build.gradle\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\n\n...\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    ...\n\n    implementation project(\":libnavannotation\")\n//    annotationProcessor project(\":libnavcompiler\")\n    kapt project(\":libnavcompiler\")\n}\n```\n\n导入 注解module、注解处理器module\nkotlin相关的注意事项和 注解处理器module 中的一样\n\n```kotlin\n@FragmentDestination(pageUrl = \"main/tabs/home\", asStarter = true)\nclass HomeFragment : Fragment() {\n    \n    ...\n\n}\n```\n\n在build中点击`make project`，即可执行直接处理器中的代码。如果遇到不成功，可以`rebuild`再试一次\n\n## 参考\n\n[教你如何完全解析Kotlin中的注解](https://juejin.im/post/5cb7ebeee51d456e8833394b#heading-0)\n\n[Android 开发之 自定义注解处理器](https://juejin.im/post/5e58dca26fb9a07cb24aa1d6#heading-4)\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Android自定义注解.md","raw":"---\ntitle: Android自定义注解\ndate: 2020-06-27 11:06:02\ntags:\n- 注解\ncategories:\n- Android\n---\n\n因为要自定义一个页面导航工具，需要使用自定义注解\n\n## 1. 创建Java Library\n\n创建两个新的module，**创建时module一定要选择Java Library**\n\n两个module分别是:\n* libnavannotation 注解\n* libnavcompile 注解处理器\n\n\n\n## 2. 定义注解\n\n定义两个注解ActivityDestination, FragmentDestination\n\n```kotlin\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class ActivityDestination(\n    val pageUrl: String,\n    val needLogin: Boolean = false,\n    val asStarter: Boolean = false\n)\n```\n\n```kotlin\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\nannotation class FragmentDestination(\n    val pageUrl: String,\n    val needLogin: Boolean = false,\n    val asStarter: Boolean = false\n)\n```\n\n## 3. 定义注解处理器（关键）\n\n### 3.1 配置build.gradle\n\n```groovy\napply plugin: 'java-library'\napply plugin: 'kotlin'\napply plugin: 'kotlin-kapt'\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    implementation 'com.alibaba:fastjson:1.2.59'\n\n    implementation project(':libnavannotation')\n    implementation 'com.google.auto.service:auto-service:1.0-rc6'\n//    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'\n    kapt 'com.google.auto.service:auto-service:1.0-rc6'\n}\n\nsourceCompatibility = \"8\"\ntargetCompatibility = \"8\"\n```\n\n需要注意以下几点：\n* 如果注解处理器是使用kotlin编写的，那么，一定要添加`kotlin-kapt`插件\n* implementation 导入annotation注解模块\n* 导入auto-service注解处理器依赖，如果是纯Java代码，可以使用`annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'`， **如果是kotlin代码，必须使用`    kapt 'com.google.auto.service:auto-service:1.0-rc6'`。** 我这里还implementation了auto-service\n\n### 3.2 编写注解处理器\n\n```kotlin\n\n@AutoService(Processor::class)\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\n@SupportedAnnotationTypes(\n    \"com.example.libnavannotation.ActivityDestination\",\n    \"com.example.libnavannotation.FragmentDestination\"\n)\nclass NavProcessor : AbstractProcessor() {\n\n    override fun init(processingEnv: ProcessingEnvironment) {\n        super.init(processingEnv)\n        \n        ...\n        \n    }\n\n    override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {\n\n        ...\n        \n    }\n}\n```\n\n**注意注解处理器类上面的几个注解**\n\n### 3.3 创建processor configuration file\n\n这里取决于gradle的版本，**高版本必须创建processor配置文件，否则不会执行注解处理器的代码**\n\n* 需要在注解处理器所在module的 main 底下新建一个package，名称为 resources\n* 在 `resources` 底下新建文件 `META-INF/services/javax.annotation.processing.Processor`\n* 在 `javax.annotation.processing.Processor` 下写入 注解处理器的全名称  eg: `com.example.libnavcompiler.NavProcessor`\n\n## 4. 使用注解\n\n在Android工程module中配置build.gradle\n\n```groovy\napply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\napply plugin: 'kotlin-kapt'\n\n...\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"\n\n    ...\n\n    implementation project(\":libnavannotation\")\n//    annotationProcessor project(\":libnavcompiler\")\n    kapt project(\":libnavcompiler\")\n}\n```\n\n导入 注解module、注解处理器module\nkotlin相关的注意事项和 注解处理器module 中的一样\n\n```kotlin\n@FragmentDestination(pageUrl = \"main/tabs/home\", asStarter = true)\nclass HomeFragment : Fragment() {\n    \n    ...\n\n}\n```\n\n在build中点击`make project`，即可执行直接处理器中的代码。如果遇到不成功，可以`rebuild`再试一次\n\n## 参考\n\n[教你如何完全解析Kotlin中的注解](https://juejin.im/post/5cb7ebeee51d456e8833394b#heading-0)\n\n[Android 开发之 自定义注解处理器](https://juejin.im/post/5e58dca26fb9a07cb24aa1d6#heading-4)\n\n\n\n\n\n\n\n\n\n","slug":"Android/Android自定义注解","published":1,"updated":"2021-10-03T01:57:41.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7h000ng0je4r4g6nh6","content":"<p>因为要自定义一个页面导航工具，需要使用自定义注解</p><a id=\"more\"></a>\n<h2 id=\"1-创建Java-Library\"><a href=\"#1-创建Java-Library\" class=\"headerlink\" title=\"1. 创建Java Library\"></a>1. 创建Java Library</h2><p>创建两个新的module，<strong>创建时module一定要选择Java Library</strong></p>\n<p>两个module分别是:</p>\n<ul>\n<li>libnavannotation 注解</li>\n<li>libnavcompile 注解处理器</li>\n</ul>\n<h2 id=\"2-定义注解\"><a href=\"#2-定义注解\" class=\"headerlink\" title=\"2. 定义注解\"></a>2. 定义注解</h2><p>定义两个注解ActivityDestination, FragmentDestination</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityDestination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pageUrl: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> needLogin: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> asStarter: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentDestination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pageUrl: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> needLogin: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> asStarter: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-定义注解处理器（关键）\"><a href=\"#3-定义注解处理器（关键）\" class=\"headerlink\" title=\"3. 定义注解处理器（关键）\"></a>3. 定义注解处理器（关键）</h2><h3 id=\"3-1-配置build-gradle\"><a href=\"#3-1-配置build-gradle\" class=\"headerlink\" title=\"3.1 配置build.gradle\"></a>3.1 配置build.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    implementation <span class=\"string\">'com.alibaba:fastjson:1.2.59'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">':libnavannotation'</span>)</span><br><span class=\"line\">    implementation <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\"><span class=\"comment\">//    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\">    kapt <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"8\"</span></span><br></pre></td></tr></table></figure>\n<p>需要注意以下几点：</p>\n<ul>\n<li>如果注解处理器是使用kotlin编写的，那么，一定要添加<code>kotlin-kapt</code>插件</li>\n<li>implementation 导入annotation注解模块</li>\n<li>导入auto-service注解处理器依赖，如果是纯Java代码，可以使用<code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>， <strong>如果是kotlin代码，必须使用<code>kapt &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>。</strong> 我这里还implementation了auto-service</li>\n</ul>\n<h3 id=\"3-2-编写注解处理器\"><a href=\"#3-2-编写注解处理器\" class=\"headerlink\" title=\"3.2 编写注解处理器\"></a>3.2 编写注解处理器</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@AutoService(Processor::class)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"meta-string\">\"com.example.libnavannotation.ActivityDestination\"</span>,</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"meta-string\">\"com.example.libnavannotation.FragmentDestination\"</span></span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NavProcessor</span> : <span class=\"type\">AbstractProcessor</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">init</span><span class=\"params\">(processingEnv: <span class=\"type\">ProcessingEnvironment</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(processingEnv)</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(annotations: <span class=\"type\">Set</span>&lt;<span class=\"type\">TypeElement</span>&gt;, roundEnv: <span class=\"type\">RoundEnvironment</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意注解处理器类上面的几个注解</strong></p>\n<h3 id=\"3-3-创建processor-configuration-file\"><a href=\"#3-3-创建processor-configuration-file\" class=\"headerlink\" title=\"3.3 创建processor configuration file\"></a>3.3 创建processor configuration file</h3><p>这里取决于gradle的版本，<strong>高版本必须创建processor配置文件，否则不会执行注解处理器的代码</strong></p>\n<ul>\n<li>需要在注解处理器所在module的 main 底下新建一个package，名称为 resources</li>\n<li>在 <code>resources</code> 底下新建文件 <code>META-INF/services/javax.annotation.processing.Processor</code></li>\n<li>在 <code>javax.annotation.processing.Processor</code> 下写入 注解处理器的全名称  eg: <code>com.example.libnavcompiler.NavProcessor</code></li>\n</ul>\n<h2 id=\"4-使用注解\"><a href=\"#4-使用注解\" class=\"headerlink\" title=\"4. 使用注解\"></a>4. 使用注解</h2><p>在Android工程module中配置build.gradle</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android-extensions'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">\":libnavannotation\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//    annotationProcessor project(\":libnavcompiler\")</span></span><br><span class=\"line\">    kapt project(<span class=\"string\">\":libnavcompiler\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>导入 注解module、注解处理器module<br>kotlin相关的注意事项和 注解处理器module 中的一样</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FragmentDestination(pageUrl = <span class=\"meta-string\">\"main/tabs/home\"</span>, asStarter = true)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeFragment</span> : <span class=\"type\">Fragment</span></span>() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在build中点击<code>make project</code>，即可执行直接处理器中的代码。如果遇到不成功，可以<code>rebuild</code>再试一次</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/post/5cb7ebeee51d456e8833394b#heading-0\" target=\"_blank\" rel=\"noopener\">教你如何完全解析Kotlin中的注解</a></p>\n<p><a href=\"https://juejin.im/post/5e58dca26fb9a07cb24aa1d6#heading-4\" target=\"_blank\" rel=\"noopener\">Android 开发之 自定义注解处理器</a></p>\n","site":{"data":{}},"excerpt":"<p>因为要自定义一个页面导航工具，需要使用自定义注解</p>","more":"\n<h2 id=\"1-创建Java-Library\"><a href=\"#1-创建Java-Library\" class=\"headerlink\" title=\"1. 创建Java Library\"></a>1. 创建Java Library</h2><p>创建两个新的module，<strong>创建时module一定要选择Java Library</strong></p>\n<p>两个module分别是:</p>\n<ul>\n<li>libnavannotation 注解</li>\n<li>libnavcompile 注解处理器</li>\n</ul>\n<h2 id=\"2-定义注解\"><a href=\"#2-定义注解\" class=\"headerlink\" title=\"2. 定义注解\"></a>2. 定义注解</h2><p>定义两个注解ActivityDestination, FragmentDestination</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ActivityDestination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pageUrl: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> needLogin: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> asStarter: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentDestination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> pageUrl: String,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> needLogin: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">val</span> asStarter: <span class=\"built_in\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-定义注解处理器（关键）\"><a href=\"#3-定义注解处理器（关键）\" class=\"headerlink\" title=\"3. 定义注解处理器（关键）\"></a>3. 定义注解处理器（关键）</h2><h3 id=\"3-1-配置build-gradle\"><a href=\"#3-1-配置build-gradle\" class=\"headerlink\" title=\"3.1 配置build.gradle\"></a>3.1 配置build.gradle</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'java-library'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    implementation <span class=\"string\">'com.alibaba:fastjson:1.2.59'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">':libnavannotation'</span>)</span><br><span class=\"line\">    implementation <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\"><span class=\"comment\">//    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\">    kapt <span class=\"string\">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sourceCompatibility = <span class=\"string\">\"8\"</span></span><br><span class=\"line\">targetCompatibility = <span class=\"string\">\"8\"</span></span><br></pre></td></tr></table></figure>\n<p>需要注意以下几点：</p>\n<ul>\n<li>如果注解处理器是使用kotlin编写的，那么，一定要添加<code>kotlin-kapt</code>插件</li>\n<li>implementation 导入annotation注解模块</li>\n<li>导入auto-service注解处理器依赖，如果是纯Java代码，可以使用<code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>， <strong>如果是kotlin代码，必须使用<code>kapt &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>。</strong> 我这里还implementation了auto-service</li>\n</ul>\n<h3 id=\"3-2-编写注解处理器\"><a href=\"#3-2-编写注解处理器\" class=\"headerlink\" title=\"3.2 编写注解处理器\"></a>3.2 编写注解处理器</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@AutoService(Processor::class)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class=\"line\"><span class=\"meta\">@SupportedAnnotationTypes(</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"meta-string\">\"com.example.libnavannotation.ActivityDestination\"</span>,</span></span><br><span class=\"line\"><span class=\"meta\">    <span class=\"meta-string\">\"com.example.libnavannotation.FragmentDestination\"</span></span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NavProcessor</span> : <span class=\"type\">AbstractProcessor</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">init</span><span class=\"params\">(processingEnv: <span class=\"type\">ProcessingEnvironment</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(processingEnv)</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(annotations: <span class=\"type\">Set</span>&lt;<span class=\"type\">TypeElement</span>&gt;, roundEnv: <span class=\"type\">RoundEnvironment</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意注解处理器类上面的几个注解</strong></p>\n<h3 id=\"3-3-创建processor-configuration-file\"><a href=\"#3-3-创建processor-configuration-file\" class=\"headerlink\" title=\"3.3 创建processor configuration file\"></a>3.3 创建processor configuration file</h3><p>这里取决于gradle的版本，<strong>高版本必须创建processor配置文件，否则不会执行注解处理器的代码</strong></p>\n<ul>\n<li>需要在注解处理器所在module的 main 底下新建一个package，名称为 resources</li>\n<li>在 <code>resources</code> 底下新建文件 <code>META-INF/services/javax.annotation.processing.Processor</code></li>\n<li>在 <code>javax.annotation.processing.Processor</code> 下写入 注解处理器的全名称  eg: <code>com.example.libnavcompiler.NavProcessor</code></li>\n</ul>\n<h2 id=\"4-使用注解\"><a href=\"#4-使用注解\" class=\"headerlink\" title=\"4. 使用注解\"></a>4. 使用注解</h2><p>在Android工程module中配置build.gradle</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-android-extensions'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'kotlin-kapt'</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    implementation project(<span class=\"string\">\":libnavannotation\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//    annotationProcessor project(\":libnavcompiler\")</span></span><br><span class=\"line\">    kapt project(<span class=\"string\">\":libnavcompiler\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>导入 注解module、注解处理器module<br>kotlin相关的注意事项和 注解处理器module 中的一样</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FragmentDestination(pageUrl = <span class=\"meta-string\">\"main/tabs/home\"</span>, asStarter = true)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeFragment</span> : <span class=\"type\">Fragment</span></span>() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在build中点击<code>make project</code>，即可执行直接处理器中的代码。如果遇到不成功，可以<code>rebuild</code>再试一次</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://juejin.im/post/5cb7ebeee51d456e8833394b#heading-0\" target=\"_blank\" rel=\"noopener\">教你如何完全解析Kotlin中的注解</a></p>\n<p><a href=\"https://juejin.im/post/5e58dca26fb9a07cb24aa1d6#heading-4\" target=\"_blank\" rel=\"noopener\">Android 开发之 自定义注解处理器</a></p>\n"},{"title":"RemoteView刷新view","date":"2019-09-15T08:09:50.000Z","_content":"\n# RemoteView刷新View\n\n## 通知栏\n在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了\n但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。\n\n在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。\n其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了\n\n## 关于Intent\n由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。\n\n在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。\n这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。\n\n也就是说，**Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象**\n\n","source":"_posts/Android/RemoteView刷新View.md","raw":"---\ntitle: RemoteView刷新view\ndate: 2019-09-15 16:09:50\ntags:\n- Android\n- View\ncategories:\n- Android\n- View\n---\n\n# RemoteView刷新View\n\n## 通知栏\n在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了\n但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。\n\n在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。\n其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了\n\n## 关于Intent\n由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。\n\n在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。\n这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。\n\n也就是说，**Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象**\n\n","slug":"Android/RemoteView刷新View","published":1,"updated":"2021-10-03T01:57:41.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7i000rg0jetgjp9021","content":"<h1 id=\"RemoteView刷新View\"><a href=\"#RemoteView刷新View\" class=\"headerlink\" title=\"RemoteView刷新View\"></a>RemoteView刷新View</h1><h2 id=\"通知栏\"><a href=\"#通知栏\" class=\"headerlink\" title=\"通知栏\"></a>通知栏</h2><p>在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了<br>但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。</p><a id=\"more\"></a>\n<p>在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。<br>其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了</p>\n<h2 id=\"关于Intent\"><a href=\"#关于Intent\" class=\"headerlink\" title=\"关于Intent\"></a>关于Intent</h2><p>由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。</p>\n<p>在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。<br>这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。</p>\n<p>也就是说，<strong>Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"RemoteView刷新View\"><a href=\"#RemoteView刷新View\" class=\"headerlink\" title=\"RemoteView刷新View\"></a>RemoteView刷新View</h1><h2 id=\"通知栏\"><a href=\"#通知栏\" class=\"headerlink\" title=\"通知栏\"></a>通知栏</h2><p>在Notification通知栏的相关开发中，RemoteView刷新view只要重新发送一遍Notification，保证message_id是相同的就可以了<br>但是由于在实际的需求中出现了异步刷新的场景。即，当要刷新时，先直接刷新textview，调起线程刷新获取image资源，在回调里调用RemoteView的setxxx方法，刷新ImageView。 在这种情况下，出现了刷新不及时的情况，图片的刷新有时成功有时不成功。</p>","more":"\n<p>在这种情况下，更改了刷新逻辑，当数据更新时直接刷新textview，并发送notification。在回调里调用RemoteView的相关方法，刷新image，并在回调里再次发送notification，以确保通知的view是最新的。<br>其中，虽然是发送了两次notification，但是并不用每次都new一个新的RemoteView出来， 即RemoteView可以重复利用，setContent的时候设置回去就好了</p>\n<h2 id=\"关于Intent\"><a href=\"#关于Intent\" class=\"headerlink\" title=\"关于Intent\"></a>关于Intent</h2><p>由于通知栏的按钮的响应操作都很复杂，所以采取的方法时每次都发送一个广播，添加指定的action和extra，在广播接收器中进行指定的操作。</p>\n<p>在操作的过程出出现了一个问题。通知栏有多个按钮，但是一开始，不同按钮的intent的action和extra的key都是一样的，extra的value不同，然后在广播接收器内判断extra来区分不同的按钮。<br>这样做并没达到想要的效果。所有的按钮接收到的intent中的extra值 都是得到的代码中添加的最后一个value值。</p>\n<p>也就是说，<strong>Intent中，设置了相同的action值，相同的extra的key，之后设置的value值是会覆盖之前的value的。即使是不同的Intent对象</strong></p>\n"},{"title":"Activity管理类的封装","date":"2019-04-14T11:41:50.000Z","_content":"\n### 使用场景\n有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的\n\n我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。\n**这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用**\n\n```java\npublic class FinishActivityManager extends BaseActivity {\n    private FinishActivityManager() {\n    }\n    private static FinishActivityManager sManager;\n    private Stack<WeakReference<Activity>> mActivityStack;\n    public static FinishActivityManager getManager() {\n        if (sManager == null) {\n            synchronized (FinishActivityManager.class) {\n                if (sManager == null) {\n                    sManager = new FinishActivityManager();\n                }\n            }\n        }\n        return sManager;\n    }\n    /**\n     * 添加Activity到栈\n     * @param activity\n     */\n    public void addActivity(Activity activity) {\n        if (mActivityStack == null) {\n            mActivityStack = new Stack<>();\n        }\n        mActivityStack.add(new WeakReference<>(activity));\n    }\n    /**\n     * 检查弱引用是否释放，若释放，则从栈中清理掉该元素\n     */\n    public void checkWeakReference() {\n        if (mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity temp = activityReference.get();\n                if (temp == null) {\n                    it.remove();\n                }\n            }\n        }\n    }\n    /**\n     * 获取当前Activity（栈中最后一个压入的）\n     * @return\n     */\n    public Activity currentActivity() {\n        checkWeakReference();\n        if (mActivityStack != null && !mActivityStack.isEmpty()) {\n            return mActivityStack.lastElement().get();\n        }\n        return null;\n    }\n    /**\n     * 关闭当前Activity（栈中最后一个压入的）\n     */\n    public void finishActivity() {\n        Activity activity = currentActivity();\n        if (activity != null) {\n            finishActivity(activity);\n        }\n    }\n    /**\n     * 关闭指定的Activity\n     * @param activity\n     */\n    public void finishActivity(Activity activity) {\n        if (activity != null && mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity temp = activityReference.get();\n                // 清理掉已经释放的activity\n                if (temp == null) {\n                    it.remove();\n                    continue;\n                }\n                if (temp == activity) {\n                    it.remove();\n                }\n            }\n            activity.finish();\n        }\n    }\n    /**\n     * 关闭指定类名的所有Activity\n     * @param cls\n     */\n    public void finishActivity(Class<?> cls) {\n        if (mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity activity = activityReference.get();\n                // 清理掉已经释放的activity\n                if (activity == null) {\n                    it.remove();\n                    continue;\n                }\n                if (activity.getClass().equals(cls)) {\n                    it.remove();\n                    activity.finish();\n                }\n            }\n        }\n    }\n    /**\n     * 结束所有Activity\n     */\n    public void finishAllActivity() {\n        if (mActivityStack != null) {\n            for (WeakReference<Activity> activityReference : mActivityStack) {\n                Activity activity = activityReference.get();\n                if (activity != null) {\n                    activity.finish();\n                }\n            }\n            mActivityStack.clear();\n        }\n    }\n    /**\n     * 退出应用程序\n     */\n    public void exitApp() {\n        try {\n            finishAllActivity();\n            // 退出JVM,释放所占内存资源,0表示正常退出\n            System.exit(0);\n            // 从系统中kill掉应用程序\n            android.os.Process.killProcess(android.os.Process.myPid());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n然后是一个BaseActivity类， 重写onCreate和onDestory方法\n\n```java\npackage com.example.chenlei.test;\n\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\n\npublic class BaseActivity extends AppCompatActivity {\n\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        MyActivityManager.addActivity(this);\n        Log.i(\"有activity新添加\", \"onCreate: \");\n    }\n\n\n\n    @Override\n    protected void onDestroy() {\n        Log.i(\"有activity被销毁\", \"onDestroy: \"+ MyActivityManager.getSize());\n        MyActivityManager.finishActivity(this);\n        super.onDestroy();\n    }\n}\n\n```\n\n接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作\n\n\n网上原文：\n<http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html>\n","source":"_posts/Android/Activity管理类的封装.md","raw":"---\ntitle: Activity管理类的封装\ndate: 2019-04-14 19:41:50\ntags:\n- Activity\ncategories:\n- Android\n---\n\n### 使用场景\n有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的\n\n我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。\n**这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用**\n\n```java\npublic class FinishActivityManager extends BaseActivity {\n    private FinishActivityManager() {\n    }\n    private static FinishActivityManager sManager;\n    private Stack<WeakReference<Activity>> mActivityStack;\n    public static FinishActivityManager getManager() {\n        if (sManager == null) {\n            synchronized (FinishActivityManager.class) {\n                if (sManager == null) {\n                    sManager = new FinishActivityManager();\n                }\n            }\n        }\n        return sManager;\n    }\n    /**\n     * 添加Activity到栈\n     * @param activity\n     */\n    public void addActivity(Activity activity) {\n        if (mActivityStack == null) {\n            mActivityStack = new Stack<>();\n        }\n        mActivityStack.add(new WeakReference<>(activity));\n    }\n    /**\n     * 检查弱引用是否释放，若释放，则从栈中清理掉该元素\n     */\n    public void checkWeakReference() {\n        if (mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity temp = activityReference.get();\n                if (temp == null) {\n                    it.remove();\n                }\n            }\n        }\n    }\n    /**\n     * 获取当前Activity（栈中最后一个压入的）\n     * @return\n     */\n    public Activity currentActivity() {\n        checkWeakReference();\n        if (mActivityStack != null && !mActivityStack.isEmpty()) {\n            return mActivityStack.lastElement().get();\n        }\n        return null;\n    }\n    /**\n     * 关闭当前Activity（栈中最后一个压入的）\n     */\n    public void finishActivity() {\n        Activity activity = currentActivity();\n        if (activity != null) {\n            finishActivity(activity);\n        }\n    }\n    /**\n     * 关闭指定的Activity\n     * @param activity\n     */\n    public void finishActivity(Activity activity) {\n        if (activity != null && mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity temp = activityReference.get();\n                // 清理掉已经释放的activity\n                if (temp == null) {\n                    it.remove();\n                    continue;\n                }\n                if (temp == activity) {\n                    it.remove();\n                }\n            }\n            activity.finish();\n        }\n    }\n    /**\n     * 关闭指定类名的所有Activity\n     * @param cls\n     */\n    public void finishActivity(Class<?> cls) {\n        if (mActivityStack != null) {\n            // 使用迭代器进行安全删除\n            for (Iterator<WeakReference<Activity>> it = mActivityStack.iterator(); it.hasNext(); ) {\n                WeakReference<Activity> activityReference = it.next();\n                Activity activity = activityReference.get();\n                // 清理掉已经释放的activity\n                if (activity == null) {\n                    it.remove();\n                    continue;\n                }\n                if (activity.getClass().equals(cls)) {\n                    it.remove();\n                    activity.finish();\n                }\n            }\n        }\n    }\n    /**\n     * 结束所有Activity\n     */\n    public void finishAllActivity() {\n        if (mActivityStack != null) {\n            for (WeakReference<Activity> activityReference : mActivityStack) {\n                Activity activity = activityReference.get();\n                if (activity != null) {\n                    activity.finish();\n                }\n            }\n            mActivityStack.clear();\n        }\n    }\n    /**\n     * 退出应用程序\n     */\n    public void exitApp() {\n        try {\n            finishAllActivity();\n            // 退出JVM,释放所占内存资源,0表示正常退出\n            System.exit(0);\n            // 从系统中kill掉应用程序\n            android.os.Process.killProcess(android.os.Process.myPid());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n然后是一个BaseActivity类， 重写onCreate和onDestory方法\n\n```java\npackage com.example.chenlei.test;\n\nimport android.os.Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\n\npublic class BaseActivity extends AppCompatActivity {\n\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        MyActivityManager.addActivity(this);\n        Log.i(\"有activity新添加\", \"onCreate: \");\n    }\n\n\n\n    @Override\n    protected void onDestroy() {\n        Log.i(\"有activity被销毁\", \"onDestroy: \"+ MyActivityManager.getSize());\n        MyActivityManager.finishActivity(this);\n        super.onDestroy();\n    }\n}\n\n```\n\n接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作\n\n\n网上原文：\n<http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html>\n","slug":"Android/Activity管理类的封装","published":1,"updated":"2021-10-03T01:57:41.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7j000tg0jerthpae1o","content":"<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的</p><a id=\"more\"></a>\n<p>我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。<br><strong>这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinishActivityManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">FinishActivityManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> FinishActivityManager sManager;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;WeakReference&lt;Activity&gt;&gt; mActivityStack;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinishActivityManager <span class=\"title\">getManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (FinishActivityManager.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    sManager = <span class=\"keyword\">new</span> FinishActivityManager();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加Activity到栈</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addActivity</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mActivityStack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mActivityStack.add(<span class=\"keyword\">new</span> WeakReference&lt;&gt;(activity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查弱引用是否释放，若释放，则从栈中清理掉该元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkWeakReference</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity temp = activityReference.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取当前Activity（栈中最后一个压入的）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">currentActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        checkWeakReference();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span> &amp;&amp; !mActivityStack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mActivityStack.lastElement().get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭当前Activity（栈中最后一个压入的）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Activity activity = currentActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            finishActivity(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭指定的Activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span> &amp;&amp; mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity temp = activityReference.get();</span><br><span class=\"line\">                <span class=\"comment\">// 清理掉已经释放的activity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == activity) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activity.finish();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭指定类名的所有Activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cls</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity activity = activityReference.get();</span><br><span class=\"line\">                <span class=\"comment\">// 清理掉已经释放的activity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity.getClass().equals(cls)) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    activity.finish();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 结束所有Activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishAllActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (WeakReference&lt;Activity&gt; activityReference : mActivityStack) &#123;</span><br><span class=\"line\">                Activity activity = activityReference.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    activity.finish();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mActivityStack.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 退出应用程序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exitApp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            finishAllActivity();</span><br><span class=\"line\">            <span class=\"comment\">// 退出JVM,释放所占内存资源,0表示正常退出</span></span><br><span class=\"line\">            System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 从系统中kill掉应用程序</span></span><br><span class=\"line\">            android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是一个BaseActivity类， 重写onCreate和onDestory方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.chenlei.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.annotation.Nullable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        MyActivityManager.addActivity(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"有activity新添加\"</span>, <span class=\"string\">\"onCreate: \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"有activity被销毁\"</span>, <span class=\"string\">\"onDestroy: \"</span>+ MyActivityManager.getSize());</span><br><span class=\"line\">        MyActivityManager.finishActivity(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作</p>\n<p>网上原文：<br><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html\" target=\"_blank\" rel=\"noopener\">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>有的时候我们需要在一个activity1中销毁另一个制定的activity2。或者是在程序的某个位置销毁所有的activity，达到退出整个app的目的</p>","more":"\n<p>我在网上找到一个做法，考虑的很严谨，在stack里存的不是activity，而是WeakReference。作者的愿意是担心出现有activity被finish之后ActivityMannager却忘了通知的情况，然后就是内存泄露 。。<br><strong>这里主要是说在系统内存不足杀死Activity时onDestory方法不会被调用</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FinishActivityManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">FinishActivityManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> FinishActivityManager sManager;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Stack&lt;WeakReference&lt;Activity&gt;&gt; mActivityStack;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> FinishActivityManager <span class=\"title\">getManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (FinishActivityManager.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    sManager = <span class=\"keyword\">new</span> FinishActivityManager();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 添加Activity到栈</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addActivity</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mActivityStack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mActivityStack.add(<span class=\"keyword\">new</span> WeakReference&lt;&gt;(activity));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 检查弱引用是否释放，若释放，则从栈中清理掉该元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkWeakReference</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity temp = activityReference.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取当前Activity（栈中最后一个压入的）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">currentActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        checkWeakReference();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span> &amp;&amp; !mActivityStack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mActivityStack.lastElement().get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭当前Activity（栈中最后一个压入的）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Activity activity = currentActivity();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            finishActivity(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭指定的Activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span> &amp;&amp; mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity temp = activityReference.get();</span><br><span class=\"line\">                <span class=\"comment\">// 清理掉已经释放的activity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == activity) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            activity.finish();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 关闭指定类名的所有Activity</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> cls</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishActivity</span><span class=\"params\">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用迭代器进行安全删除</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;WeakReference&lt;Activity&gt;&gt; it = mActivityStack.iterator(); it.hasNext(); ) &#123;</span><br><span class=\"line\">                WeakReference&lt;Activity&gt; activityReference = it.next();</span><br><span class=\"line\">                Activity activity = activityReference.get();</span><br><span class=\"line\">                <span class=\"comment\">// 清理掉已经释放的activity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity.getClass().equals(cls)) &#123;</span><br><span class=\"line\">                    it.remove();</span><br><span class=\"line\">                    activity.finish();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 结束所有Activity</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">finishAllActivity</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mActivityStack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (WeakReference&lt;Activity&gt; activityReference : mActivityStack) &#123;</span><br><span class=\"line\">                Activity activity = activityReference.get();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    activity.finish();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mActivityStack.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 退出应用程序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">exitApp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            finishAllActivity();</span><br><span class=\"line\">            <span class=\"comment\">// 退出JVM,释放所占内存资源,0表示正常退出</span></span><br><span class=\"line\">            System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 从系统中kill掉应用程序</span></span><br><span class=\"line\">            android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是一个BaseActivity类， 重写onCreate和onDestory方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.chenlei.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.os.Bundle;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.annotation.Nullable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        MyActivityManager.addActivity(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"有activity新添加\"</span>, <span class=\"string\">\"onCreate: \"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"有activity被销毁\"</span>, <span class=\"string\">\"onDestroy: \"</span>+ MyActivityManager.getSize());</span><br><span class=\"line\">        MyActivityManager.finishActivity(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来所有的activity类都继承自BaseActivity， 然后就可以在制定的activity类中对ActivityManager类进行操作</p>\n<p>网上原文：<br><a href=\"http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html\" target=\"_blank\" rel=\"noopener\">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0629/8124.html</a></p>\n"},{"title":"Handler防止内存泄露","date":"2019-04-14T10:59:55.000Z","_content":"\n# Handler防止内存泄露\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyHandler mHandler = new MyHandler(this);\n    private TextView mTextView ;\n    private static class MyHandler extends Handler {\n        private WeakReference<Context> reference;\n        public MyHandler(Context context) {\n            reference = new WeakReference<>(context);\n        }\n        @Override\n        public void handleMessage(Message msg) {\n            MainActivity activity = (MainActivity) reference.get();\n            if(activity != null){\n                activity.mTextView.setText(\"\");\n            }\n        }\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mTextView = (TextView)findViewById(R.id.textview);\n        loadData();\n    }\n   //loadData()方法是在子线程中，执行\n    private void loadData() {\n        //...request\n        Message message = Message.obtain();\n        mHandler.sendMessage(message);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        //如果你的Handler被delay（延时了）,可以做如下的处理\n        mHandler.removeCallbacksAndMessages(null);\n    }\n}\n```\n\n## 解释\n\n创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息\n\n使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。\n\n\n\n","source":"_posts/Android/Handler防止内存泄露.md","raw":"---\ntitle: Handler防止内存泄露\ndate: 2019-04-14 18:59:55\ntags:\n- Handler\n- 内存泄露\ncategories: \n- Android\n---\n\n# Handler防止内存泄露\n\n```java\npublic class MainActivity extends AppCompatActivity {\n    private MyHandler mHandler = new MyHandler(this);\n    private TextView mTextView ;\n    private static class MyHandler extends Handler {\n        private WeakReference<Context> reference;\n        public MyHandler(Context context) {\n            reference = new WeakReference<>(context);\n        }\n        @Override\n        public void handleMessage(Message msg) {\n            MainActivity activity = (MainActivity) reference.get();\n            if(activity != null){\n                activity.mTextView.setText(\"\");\n            }\n        }\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mTextView = (TextView)findViewById(R.id.textview);\n        loadData();\n    }\n   //loadData()方法是在子线程中，执行\n    private void loadData() {\n        //...request\n        Message message = Message.obtain();\n        mHandler.sendMessage(message);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        //如果你的Handler被delay（延时了）,可以做如下的处理\n        mHandler.removeCallbacksAndMessages(null);\n    }\n}\n```\n\n## 解释\n\n创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息\n\n使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。\n\n\n\n","slug":"Android/Handler防止内存泄露","published":1,"updated":"2021-10-03T01:57:41.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7k000xg0je3unq0zbe","content":"<h1 id=\"Handler防止内存泄露\"><a href=\"#Handler防止内存泄露\" class=\"headerlink\" title=\"Handler防止内存泄露\"></a>Handler防止内存泄露</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyHandler mHandler = <span class=\"keyword\">new</span> MyHandler(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextView mTextView ;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> WeakReference&lt;Context&gt; reference;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyHandler</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">            reference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            MainActivity activity = (MainActivity) reference.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                activity.mTextView.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class=\"line\">        loadData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//loadData()方法是在子线程中，执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...request</span></span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        mHandler.sendMessage(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">        <span class=\"comment\">//如果你的Handler被delay（延时了）,可以做如下的处理</span></span><br><span class=\"line\">        mHandler.removeCallbacksAndMessages(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息</p>\n<p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Handler防止内存泄露\"><a href=\"#Handler防止内存泄露\" class=\"headerlink\" title=\"Handler防止内存泄露\"></a>Handler防止内存泄露</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MyHandler mHandler = <span class=\"keyword\">new</span> MyHandler(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextView mTextView ;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> WeakReference&lt;Context&gt; reference;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyHandler</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">            reference = <span class=\"keyword\">new</span> WeakReference&lt;&gt;(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">            MainActivity activity = (MainActivity) reference.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(activity != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                activity.mTextView.setText(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class=\"line\">        loadData();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//loadData()方法是在子线程中，执行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...request</span></span><br><span class=\"line\">        Message message = Message.obtain();</span><br><span class=\"line\">        mHandler.sendMessage(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">        <span class=\"comment\">//如果你的Handler被delay（延时了）,可以做如下的处理</span></span><br><span class=\"line\">        mHandler.removeCallbacksAndMessages(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，如果你的Handler被delay（延时了），在Activity的Destroy时或者Stop时应该移除消息队列中的消息</p>\n<p>使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages()；来移除指定的Runnable和Message。</p>\n"},{"title":"Scale动画组合使用的坑","date":"2019-08-02T01:43:37.000Z","_content":"\n# Scale动画组合使用的坑\n\n## API\n```java\n        Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n```\n参数1: X的初始值\n参数2: X的最终值\n参数3: Y的初始值\n参数4: Y的最终值\n参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放\n参数6: X轴缩放轴点，1f表示以View的最右端为轴点\n参数7: Y轴，同参数5\n参数8: Y轴，同参数6\n\n## 问题\n一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小\n```java\n// start animation\n        AnimationSet animationSet = new AnimationSet(false);\n        Animation alpha = new AlphaAnimation(0, 100);\n        alpha.setDuration(80);\n        Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n        scale.setDuration(160);\n        scale.setInterpolator(PathInterpolatorCompat.create(0.32f, 0.66f, 0.6f, 1f));\n        Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n        scale2.setDuration(70);\n        scale2.setStartOffset(160);\n        animationSet.addAnimation(scale);\n        animationSet.addAnimation(scale2);\n        animationSet.addAnimation(alpha);\n        tv.startAnimation(animationSet);\n```\n\n但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小\n\n## 原因\nscale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子\n```java\nAnimation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\nscale2.setDuration(70);\nscale2.setStartOffset(160);\n```","source":"_posts/Android/Scale动画组合使用的坑.md","raw":"---\ntitle: Scale动画组合使用的坑\ndate: 2019-08-02 09:43:37\ntags:\n- Animation\n- View\ncategories:\n- Android\n- View\n---\n\n# Scale动画组合使用的坑\n\n## API\n```java\n        Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n```\n参数1: X的初始值\n参数2: X的最终值\n参数3: Y的初始值\n参数4: Y的最终值\n参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放\n参数6: X轴缩放轴点，1f表示以View的最右端为轴点\n参数7: Y轴，同参数5\n参数8: Y轴，同参数6\n\n## 问题\n一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小\n```java\n// start animation\n        AnimationSet animationSet = new AnimationSet(false);\n        Animation alpha = new AlphaAnimation(0, 100);\n        alpha.setDuration(80);\n        Animation scale = new ScaleAnimation(0.6f, 1.03f, 0.6f, 1.03f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n        scale.setDuration(160);\n        scale.setInterpolator(PathInterpolatorCompat.create(0.32f, 0.66f, 0.6f, 1f));\n        Animation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\n        scale2.setDuration(70);\n        scale2.setStartOffset(160);\n        animationSet.addAnimation(scale);\n        animationSet.addAnimation(scale2);\n        animationSet.addAnimation(alpha);\n        tv.startAnimation(animationSet);\n```\n\n但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小\n\n## 原因\nscale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子\n```java\nAnimation scale2 = new ScaleAnimation(1.03f, 1f, 1.03f, 1f, Animation.RELATIVE_TO_SELF, 1f, Animation.RELATIVE_TO_SELF, 0);\nscale2.setDuration(70);\nscale2.setStartOffset(160);\n```","slug":"Android/Scale动画组合使用的坑","published":1,"updated":"2021-10-03T01:57:41.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7l000zg0jeulpykk34","content":"<h1 id=\"Scale动画组合使用的坑\"><a href=\"#Scale动画组合使用的坑\" class=\"headerlink\" title=\"Scale动画组合使用的坑\"></a>Scale动画组合使用的坑</h1><h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation scale = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<p>参数1: X的初始值<br>参数2: X的最终值<br>参数3: Y的初始值<br>参数4: Y的最终值<br>参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放<br>参数6: X轴缩放轴点，1f表示以View的最右端为轴点<br>参数7: Y轴，同参数5<br>参数8: Y轴，同参数6</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// start animation</span></span><br><span class=\"line\">        AnimationSet animationSet = <span class=\"keyword\">new</span> AnimationSet(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        Animation alpha = <span class=\"keyword\">new</span> AlphaAnimation(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        alpha.setDuration(<span class=\"number\">80</span>);</span><br><span class=\"line\">        Animation scale = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">        scale.setDuration(<span class=\"number\">160</span>);</span><br><span class=\"line\">        scale.setInterpolator(PathInterpolatorCompat.create(<span class=\"number\">0.32f</span>, <span class=\"number\">0.66f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1f</span>));</span><br><span class=\"line\">        Animation scale2 = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">        scale2.setDuration(<span class=\"number\">70</span>);</span><br><span class=\"line\">        scale2.setStartOffset(<span class=\"number\">160</span>);</span><br><span class=\"line\">        animationSet.addAnimation(scale);</span><br><span class=\"line\">        animationSet.addAnimation(scale2);</span><br><span class=\"line\">        animationSet.addAnimation(alpha);</span><br><span class=\"line\">        tv.startAnimation(animationSet);</span><br></pre></td></tr></table></figure></p>\n<p>但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>scale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation scale2 = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">scale2.setDuration(<span class=\"number\">70</span>);</span><br><span class=\"line\">scale2.setStartOffset(<span class=\"number\">160</span>);</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Scale动画组合使用的坑\"><a href=\"#Scale动画组合使用的坑\" class=\"headerlink\" title=\"Scale动画组合使用的坑\"></a>Scale动画组合使用的坑</h1><h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation scale = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>","more":"\n<p>参数1: X的初始值<br>参数2: X的最终值<br>参数3: Y的初始值<br>参数4: Y的最终值<br>参数5: X轴，Animation.RELATIVE_TO_SELF表示根据view大小的百分比进行缩放<br>参数6: X轴缩放轴点，1f表示以View的最右端为轴点<br>参数7: Y轴，同参数5<br>参数8: Y轴，同参数6</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>一个补间动画AnimationSet中有两个ScaleAnimation，先放大后缩小<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// start animation</span></span><br><span class=\"line\">        AnimationSet animationSet = <span class=\"keyword\">new</span> AnimationSet(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        Animation alpha = <span class=\"keyword\">new</span> AlphaAnimation(<span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">        alpha.setDuration(<span class=\"number\">80</span>);</span><br><span class=\"line\">        Animation scale = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1.03f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">        scale.setDuration(<span class=\"number\">160</span>);</span><br><span class=\"line\">        scale.setInterpolator(PathInterpolatorCompat.create(<span class=\"number\">0.32f</span>, <span class=\"number\">0.66f</span>, <span class=\"number\">0.6f</span>, <span class=\"number\">1f</span>));</span><br><span class=\"line\">        Animation scale2 = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">        scale2.setDuration(<span class=\"number\">70</span>);</span><br><span class=\"line\">        scale2.setStartOffset(<span class=\"number\">160</span>);</span><br><span class=\"line\">        animationSet.addAnimation(scale);</span><br><span class=\"line\">        animationSet.addAnimation(scale2);</span><br><span class=\"line\">        animationSet.addAnimation(alpha);</span><br><span class=\"line\">        tv.startAnimation(animationSet);</span><br></pre></td></tr></table></figure></p>\n<p>但是最后的动画效果却非常不流畅，通过加长动画效果，发现动画在放大后缩回的过程中，缩一定程度后直接突变到了最初始的大小</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>scale动画是根据当前的值进行缩放的，所以scale2应该改成这个样子<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animation scale2 = <span class=\"keyword\">new</span> ScaleAnimation(<span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, <span class=\"number\">1.03f</span>, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">1f</span>, Animation.RELATIVE_TO_SELF, <span class=\"number\">0</span>);</span><br><span class=\"line\">scale2.setDuration(<span class=\"number\">70</span>);</span><br><span class=\"line\">scale2.setStartOffset(<span class=\"number\">160</span>);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Fragment可见性总结","date":"2020-10-04T10:28:37.000Z","_content":"\n## onResume()/onPause()\n\n**不要用这两个方法为可见性依据做操作。** 触发onResume()/onPause()的场景有很多\n\n* **Activity执行onResume()/onPause()**，其所有的 Fragment 都会的 onResume()/onPause() 方法，即使Fragment是状态是隐藏的\n* **在当前Activity中添加一个Fragment时**，被添加的Fragment都会调用onResume，这包括通过add和replace的方式添加；在Fragment销毁的情况下都会触发onPause，如果是add到回退栈的情况，back键就会触发onPause，如果是replace的情况，则被替换掉的Fragment会触发onPause。\n* **ViewPager 预加载：** 被预加载的Fragment也会执行 onResume()/onPause() \n\n## isVisible()\n\n注释说是可以用来判断其可见性，**但是如果你是在Fragment的onResume/onPause方法中调用这两个方法判断是不准确的，**onResume的方法中isVisible()有可能为false, 而onPause的方法中isVisible()也有可能为true。\n\n## onHiddenChanged()\n\n就是对Fragment进行show和hide的时候会回调onHiddenChanged方法。除此之外的操作，如add/replace/remove都不会触发这个方法。\n\n## setUserVisibleHint()/getUserVisibleHint()\n\ngetUserVisibleHint() 默认返回true， 只有和 ViewPager 配合使用有效，ViewPager 选中的 fragment 调用 getUserVisibleHint() 会返回true。 **在ViewPager2无效**\n\n## 判断fragment是否可见的保险操作？？ maybe\n\n```java\nfinal boolean parentVisible = parentFragment == null ? true : parentFragment.isVisible()=\nfinal boolean visible = isVisible() && parentVisible && getUserVisibleHint()\n```\n\n","source":"_posts/Android/Fragment可见性总结.md","raw":"---\ntitle: Fragment可见性总结\ndate: 2020-10-04 18:28:37\ntags:\n- Fragment\n---\n\n## onResume()/onPause()\n\n**不要用这两个方法为可见性依据做操作。** 触发onResume()/onPause()的场景有很多\n\n* **Activity执行onResume()/onPause()**，其所有的 Fragment 都会的 onResume()/onPause() 方法，即使Fragment是状态是隐藏的\n* **在当前Activity中添加一个Fragment时**，被添加的Fragment都会调用onResume，这包括通过add和replace的方式添加；在Fragment销毁的情况下都会触发onPause，如果是add到回退栈的情况，back键就会触发onPause，如果是replace的情况，则被替换掉的Fragment会触发onPause。\n* **ViewPager 预加载：** 被预加载的Fragment也会执行 onResume()/onPause() \n\n## isVisible()\n\n注释说是可以用来判断其可见性，**但是如果你是在Fragment的onResume/onPause方法中调用这两个方法判断是不准确的，**onResume的方法中isVisible()有可能为false, 而onPause的方法中isVisible()也有可能为true。\n\n## onHiddenChanged()\n\n就是对Fragment进行show和hide的时候会回调onHiddenChanged方法。除此之外的操作，如add/replace/remove都不会触发这个方法。\n\n## setUserVisibleHint()/getUserVisibleHint()\n\ngetUserVisibleHint() 默认返回true， 只有和 ViewPager 配合使用有效，ViewPager 选中的 fragment 调用 getUserVisibleHint() 会返回true。 **在ViewPager2无效**\n\n## 判断fragment是否可见的保险操作？？ maybe\n\n```java\nfinal boolean parentVisible = parentFragment == null ? true : parentFragment.isVisible()=\nfinal boolean visible = isVisible() && parentVisible && getUserVisibleHint()\n```\n\n","slug":"Android/Fragment可见性总结","published":1,"updated":"2021-10-03T01:57:41.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7m0012g0jesu2ue3wq","content":"<h2 id=\"onResume-onPause\"><a href=\"#onResume-onPause\" class=\"headerlink\" title=\"onResume()/onPause()\"></a>onResume()/onPause()</h2><p><strong>不要用这两个方法为可见性依据做操作。</strong> 触发onResume()/onPause()的场景有很多</p><a id=\"more\"></a>\n<ul>\n<li><strong>Activity执行onResume()/onPause()</strong>，其所有的 Fragment 都会的 onResume()/onPause() 方法，即使Fragment是状态是隐藏的</li>\n<li><strong>在当前Activity中添加一个Fragment时</strong>，被添加的Fragment都会调用onResume，这包括通过add和replace的方式添加；在Fragment销毁的情况下都会触发onPause，如果是add到回退栈的情况，back键就会触发onPause，如果是replace的情况，则被替换掉的Fragment会触发onPause。</li>\n<li><strong>ViewPager 预加载：</strong> 被预加载的Fragment也会执行 onResume()/onPause() </li>\n</ul>\n<h2 id=\"isVisible\"><a href=\"#isVisible\" class=\"headerlink\" title=\"isVisible()\"></a>isVisible()</h2><p>注释说是可以用来判断其可见性，<strong>但是如果你是在Fragment的onResume/onPause方法中调用这两个方法判断是不准确的，</strong>onResume的方法中isVisible()有可能为false, 而onPause的方法中isVisible()也有可能为true。</p>\n<h2 id=\"onHiddenChanged\"><a href=\"#onHiddenChanged\" class=\"headerlink\" title=\"onHiddenChanged()\"></a>onHiddenChanged()</h2><p>就是对Fragment进行show和hide的时候会回调onHiddenChanged方法。除此之外的操作，如add/replace/remove都不会触发这个方法。</p>\n<h2 id=\"setUserVisibleHint-getUserVisibleHint\"><a href=\"#setUserVisibleHint-getUserVisibleHint\" class=\"headerlink\" title=\"setUserVisibleHint()/getUserVisibleHint()\"></a>setUserVisibleHint()/getUserVisibleHint()</h2><p>getUserVisibleHint() 默认返回true， 只有和 ViewPager 配合使用有效，ViewPager 选中的 fragment 调用 getUserVisibleHint() 会返回true。 <strong>在ViewPager2无效</strong></p>\n<h2 id=\"判断fragment是否可见的保险操作？？-maybe\"><a href=\"#判断fragment是否可见的保险操作？？-maybe\" class=\"headerlink\" title=\"判断fragment是否可见的保险操作？？ maybe\"></a>判断fragment是否可见的保险操作？？ maybe</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> parentVisible = parentFragment == <span class=\"keyword\">null</span> ? <span class=\"keyword\">true</span> : parentFragment.isVisible()=</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> visible = isVisible() &amp;&amp; parentVisible &amp;&amp; getUserVisibleHint()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"onResume-onPause\"><a href=\"#onResume-onPause\" class=\"headerlink\" title=\"onResume()/onPause()\"></a>onResume()/onPause()</h2><p><strong>不要用这两个方法为可见性依据做操作。</strong> 触发onResume()/onPause()的场景有很多</p>","more":"\n<ul>\n<li><strong>Activity执行onResume()/onPause()</strong>，其所有的 Fragment 都会的 onResume()/onPause() 方法，即使Fragment是状态是隐藏的</li>\n<li><strong>在当前Activity中添加一个Fragment时</strong>，被添加的Fragment都会调用onResume，这包括通过add和replace的方式添加；在Fragment销毁的情况下都会触发onPause，如果是add到回退栈的情况，back键就会触发onPause，如果是replace的情况，则被替换掉的Fragment会触发onPause。</li>\n<li><strong>ViewPager 预加载：</strong> 被预加载的Fragment也会执行 onResume()/onPause() </li>\n</ul>\n<h2 id=\"isVisible\"><a href=\"#isVisible\" class=\"headerlink\" title=\"isVisible()\"></a>isVisible()</h2><p>注释说是可以用来判断其可见性，<strong>但是如果你是在Fragment的onResume/onPause方法中调用这两个方法判断是不准确的，</strong>onResume的方法中isVisible()有可能为false, 而onPause的方法中isVisible()也有可能为true。</p>\n<h2 id=\"onHiddenChanged\"><a href=\"#onHiddenChanged\" class=\"headerlink\" title=\"onHiddenChanged()\"></a>onHiddenChanged()</h2><p>就是对Fragment进行show和hide的时候会回调onHiddenChanged方法。除此之外的操作，如add/replace/remove都不会触发这个方法。</p>\n<h2 id=\"setUserVisibleHint-getUserVisibleHint\"><a href=\"#setUserVisibleHint-getUserVisibleHint\" class=\"headerlink\" title=\"setUserVisibleHint()/getUserVisibleHint()\"></a>setUserVisibleHint()/getUserVisibleHint()</h2><p>getUserVisibleHint() 默认返回true， 只有和 ViewPager 配合使用有效，ViewPager 选中的 fragment 调用 getUserVisibleHint() 会返回true。 <strong>在ViewPager2无效</strong></p>\n<h2 id=\"判断fragment是否可见的保险操作？？-maybe\"><a href=\"#判断fragment是否可见的保险操作？？-maybe\" class=\"headerlink\" title=\"判断fragment是否可见的保险操作？？ maybe\"></a>判断fragment是否可见的保险操作？？ maybe</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> parentVisible = parentFragment == <span class=\"keyword\">null</span> ? <span class=\"keyword\">true</span> : parentFragment.isVisible()=</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> visible = isVisible() &amp;&amp; parentVisible &amp;&amp; getUserVisibleHint()</span><br></pre></td></tr></table></figure>\n"},{"title":"LayoutInflater解析","date":"2019-08-13T12:31:21.000Z","Categories":["Android","View"],"_content":"\n# LayoutInflater解析\n\n## 源码\n\n```\nView result = root;\n```\n\n``` \n// Temp is the root view that was found in the xml\nfinal View temp = createViewFromTag(root, name, inflaterContext, attrs);\n\nViewGroup.LayoutParams params = null;\nif (root != null) {\n    // Create layout params that match root, if supplied\n    params = root.generateLayoutParams(attrs);\n    if (!attachToRoot) {\n        // Set the layout params for temp if we are not\n        // attaching. (If we are, we use addView, below)\n        temp.setLayoutParams(params);\n    }\n}\n```\n\n``` \n// Inflate all children under temp against its context.\n\nrInflateChildren(parser, temp, attrs, true);\n\n// We are supposed to attach all the views we found (int temp)\n// to root. Do that now.\nif (root != null && attachToRoot) {\n    root.addView(temp, params);\n}\n\n// Decide whether to return the root that was passed in or the\n// top view found in xml.\nif (root == null || !attachToRoot) {\n    result = temp;\n}\n```\n\n```\nreturn result;\n```\n\n### 使用方法\n```\nLayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ;\n```\n* 第一个参数是layout资源文件id\n* 第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam\n* 第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中\n\n**需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view**\n\n","source":"_posts/Android/LayoutInflater解析.md","raw":"---\ntitle: LayoutInflater解析\ndate: 2019-08-13 20:31:21\ntags:\n- Android\n- View\nCategories:\n- Android\n- View\n---\n\n# LayoutInflater解析\n\n## 源码\n\n```\nView result = root;\n```\n\n``` \n// Temp is the root view that was found in the xml\nfinal View temp = createViewFromTag(root, name, inflaterContext, attrs);\n\nViewGroup.LayoutParams params = null;\nif (root != null) {\n    // Create layout params that match root, if supplied\n    params = root.generateLayoutParams(attrs);\n    if (!attachToRoot) {\n        // Set the layout params for temp if we are not\n        // attaching. (If we are, we use addView, below)\n        temp.setLayoutParams(params);\n    }\n}\n```\n\n``` \n// Inflate all children under temp against its context.\n\nrInflateChildren(parser, temp, attrs, true);\n\n// We are supposed to attach all the views we found (int temp)\n// to root. Do that now.\nif (root != null && attachToRoot) {\n    root.addView(temp, params);\n}\n\n// Decide whether to return the root that was passed in or the\n// top view found in xml.\nif (root == null || !attachToRoot) {\n    result = temp;\n}\n```\n\n```\nreturn result;\n```\n\n### 使用方法\n```\nLayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ;\n```\n* 第一个参数是layout资源文件id\n* 第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam\n* 第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中\n\n**需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view**\n\n","slug":"Android/LayoutInflater解析","published":1,"updated":"2021-10-03T01:57:41.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7n0015g0jem7yntiso","content":"<h1 id=\"LayoutInflater解析\"><a href=\"#LayoutInflater解析\" class=\"headerlink\" title=\"LayoutInflater解析\"></a>LayoutInflater解析</h1><h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View result = root;</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Temp is the root view that was found in the xml</span><br><span class=\"line\">final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\"></span><br><span class=\"line\">ViewGroup.LayoutParams params = null;</span><br><span class=\"line\">if (root != null) &#123;</span><br><span class=\"line\">    // Create layout params that match root, if supplied</span><br><span class=\"line\">    params = root.generateLayoutParams(attrs);</span><br><span class=\"line\">    if (!attachToRoot) &#123;</span><br><span class=\"line\">        // Set the layout params for temp if we are not</span><br><span class=\"line\">        // attaching. (If we are, we use addView, below)</span><br><span class=\"line\">        temp.setLayoutParams(params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Inflate all children under temp against its context.</span><br><span class=\"line\"></span><br><span class=\"line\">rInflateChildren(parser, temp, attrs, true);</span><br><span class=\"line\"></span><br><span class=\"line\">// We are supposed to attach all the views we found (int temp)</span><br><span class=\"line\">// to root. Do that now.</span><br><span class=\"line\">if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class=\"line\">    root.addView(temp, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Decide whether to return the root that was passed in or the</span><br><span class=\"line\">// top view found in xml.</span><br><span class=\"line\">if (root == null || !attachToRoot) &#123;</span><br><span class=\"line\">    result = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return result;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数是layout资源文件id</li>\n<li>第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam</li>\n<li>第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中</li>\n</ul>\n<p><strong>需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view</strong></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"LayoutInflater解析\"><a href=\"#LayoutInflater解析\" class=\"headerlink\" title=\"LayoutInflater解析\"></a>LayoutInflater解析</h1><h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View result = root;</span><br></pre></td></tr></table></figure>","more":"\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Temp is the root view that was found in the xml</span><br><span class=\"line\">final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class=\"line\"></span><br><span class=\"line\">ViewGroup.LayoutParams params = null;</span><br><span class=\"line\">if (root != null) &#123;</span><br><span class=\"line\">    // Create layout params that match root, if supplied</span><br><span class=\"line\">    params = root.generateLayoutParams(attrs);</span><br><span class=\"line\">    if (!attachToRoot) &#123;</span><br><span class=\"line\">        // Set the layout params for temp if we are not</span><br><span class=\"line\">        // attaching. (If we are, we use addView, below)</span><br><span class=\"line\">        temp.setLayoutParams(params);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Inflate all children under temp against its context.</span><br><span class=\"line\"></span><br><span class=\"line\">rInflateChildren(parser, temp, attrs, true);</span><br><span class=\"line\"></span><br><span class=\"line\">// We are supposed to attach all the views we found (int temp)</span><br><span class=\"line\">// to root. Do that now.</span><br><span class=\"line\">if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class=\"line\">    root.addView(temp, params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Decide whether to return the root that was passed in or the</span><br><span class=\"line\">// top view found in xml.</span><br><span class=\"line\">if (root == null || !attachToRoot) &#123;</span><br><span class=\"line\">    result = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return result;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayoutInflater.from(context).inflate(int resource, ViewGroup root, boolean attachToRoot) ;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>第一个参数是layout资源文件id</li>\n<li>第二个参数是父布局。 当第二个参数为null时，将不会为inflate出来的view添加layoutParam</li>\n<li>第三个参数是是否加入到父布局中。若为空，则，调用root.addView直接加入到父布局中</li>\n</ul>\n<p><strong>需要注意的是，当root!=null，且attachToRoot为true时，Inflater返回的父布局的view，而不是解析出的view</strong></p>\n"},{"title":"Text相关计算","date":"2019-07-19T03:09:42.000Z","_content":"\n# Text相关计算\n\n## Text的相关属性\n![图片](/images/Text相关计算.webp)\n\nBaseline上方的值为正，下方的值为负\n\n## TextSize和TextView大小的转换\n\n相关参数包括：\n\n* 基准点是baseline\n\n* Ascent是baseline之上至字符最高处的距离\n\n* Descent是baseline之下至字符最低处的距离\n\n* 其实是上一行字符的descent到下一行的ascent之间的距离\n\n* Top指的是指的是最高字符到baseline的值，即ascent的最大值\n\n* 同上，bottom指的是最下字符到baseline的值，即descent的最大值\n\n## 参考\n[Paint 绘制文字属性](https://www.jianshu.com/p/1728b725b4a6)\n[TextView文字实际高度分析](https://neutra.github.io/2016/TextView%E6%96%87%E5%AD%97%E5%AE%9E%E9%99%85%E9%AB%98%E5%BA%A6%E5%88%86%E6%9E%90/)\n","source":"_posts/Android/Text相关计算.md","raw":"---\ntitle: Text相关计算\ndate: 2019-07-19 11:09:42\ntags:\n- View\ncategories:\n- Android\n---\n\n# Text相关计算\n\n## Text的相关属性\n![图片](/images/Text相关计算.webp)\n\nBaseline上方的值为正，下方的值为负\n\n## TextSize和TextView大小的转换\n\n相关参数包括：\n\n* 基准点是baseline\n\n* Ascent是baseline之上至字符最高处的距离\n\n* Descent是baseline之下至字符最低处的距离\n\n* 其实是上一行字符的descent到下一行的ascent之间的距离\n\n* Top指的是指的是最高字符到baseline的值，即ascent的最大值\n\n* 同上，bottom指的是最下字符到baseline的值，即descent的最大值\n\n## 参考\n[Paint 绘制文字属性](https://www.jianshu.com/p/1728b725b4a6)\n[TextView文字实际高度分析](https://neutra.github.io/2016/TextView%E6%96%87%E5%AD%97%E5%AE%9E%E9%99%85%E9%AB%98%E5%BA%A6%E5%88%86%E6%9E%90/)\n","slug":"Android/Text相关计算","published":1,"updated":"2021-10-03T01:57:41.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno7n0017g0jexfmss2rq","content":"<h1 id=\"Text相关计算\"><a href=\"#Text相关计算\" class=\"headerlink\" title=\"Text相关计算\"></a>Text相关计算</h1><h2 id=\"Text的相关属性\"><a href=\"#Text的相关属性\" class=\"headerlink\" title=\"Text的相关属性\"></a>Text的相关属性</h2><p><img src=\"/images/Text相关计算.webp\" alt=\"图片\"></p><p>Baseline上方的值为正，下方的值为负</p><a id=\"more\"></a>\n\n<h2 id=\"TextSize和TextView大小的转换\"><a href=\"#TextSize和TextView大小的转换\" class=\"headerlink\" title=\"TextSize和TextView大小的转换\"></a>TextSize和TextView大小的转换</h2><p>相关参数包括：</p>\n<ul>\n<li><p>基准点是baseline</p>\n</li>\n<li><p>Ascent是baseline之上至字符最高处的距离</p>\n</li>\n<li><p>Descent是baseline之下至字符最低处的距离</p>\n</li>\n<li><p>其实是上一行字符的descent到下一行的ascent之间的距离</p>\n</li>\n<li><p>Top指的是指的是最高字符到baseline的值，即ascent的最大值</p>\n</li>\n<li><p>同上，bottom指的是最下字符到baseline的值，即descent的最大值</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.jianshu.com/p/1728b725b4a6\" target=\"_blank\" rel=\"noopener\">Paint 绘制文字属性</a><br><a href=\"https://neutra.github.io/2016/TextView%E6%96%87%E5%AD%97%E5%AE%9E%E9%99%85%E9%AB%98%E5%BA%A6%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">TextView文字实际高度分析</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Text相关计算\"><a href=\"#Text相关计算\" class=\"headerlink\" title=\"Text相关计算\"></a>Text相关计算</h1><h2 id=\"Text的相关属性\"><a href=\"#Text的相关属性\" class=\"headerlink\" title=\"Text的相关属性\"></a>Text的相关属性</h2><p><img src=\"/images/Text相关计算.webp\" alt=\"图片\"></p><p>Baseline上方的值为正，下方的值为负</p>","more":"\n\n<h2 id=\"TextSize和TextView大小的转换\"><a href=\"#TextSize和TextView大小的转换\" class=\"headerlink\" title=\"TextSize和TextView大小的转换\"></a>TextSize和TextView大小的转换</h2><p>相关参数包括：</p>\n<ul>\n<li><p>基准点是baseline</p>\n</li>\n<li><p>Ascent是baseline之上至字符最高处的距离</p>\n</li>\n<li><p>Descent是baseline之下至字符最低处的距离</p>\n</li>\n<li><p>其实是上一行字符的descent到下一行的ascent之间的距离</p>\n</li>\n<li><p>Top指的是指的是最高字符到baseline的值，即ascent的最大值</p>\n</li>\n<li><p>同上，bottom指的是最下字符到baseline的值，即descent的最大值</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.jianshu.com/p/1728b725b4a6\" target=\"_blank\" rel=\"noopener\">Paint 绘制文字属性</a><br><a href=\"https://neutra.github.io/2016/TextView%E6%96%87%E5%AD%97%E5%AE%9E%E9%99%85%E9%AB%98%E5%BA%A6%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"noopener\">TextView文字实际高度分析</a></p>\n"},{"title":"ViewDragHelper的使用","date":"2020-02-19T02:36:30.000Z","_content":"\nViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部\n\n**参考**\n\n[ViewDragHelper 的基本使用](https://www.jianshu.com/p/a9e0a98e4d42)\n\n# 常用Api\n\n**初始化**\n\n```java\npublic static ViewDragHelper create(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb)\n```\n\n第一个参数是父布局, 第二个参数是自定义的监听回调\n\n**拦截事件**\n\n在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断\n\n```java\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\n    //ViewDragHelper对事件进行拦截\n    //注意, ACTION_DOWN事件不会被拦截\n    //当clampViewPositionXxx方法没有修改left或top值时, 不会拦截\n    //是的, shouldInterceptTouchEvent中会调用callback.clampViewPositionXxx方法\n    return mViewDragHelper.shouldInterceptTouchEvent(ev);\n}\n\n@Override\npublic boolean onTouchEvent(MotionEvent event) {\n    //将事件传递给ViewDragHelper进行处理\n    mViewDragHelper.processTouchEvent(event);\n    return true;\n}\n```\n\n**处理computeScroll**\n\n因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法)\n\n```java\n@Override\npublic void computeScroll() {\n    super.computeScroll();\n    if (mViewDragHelper != null && mViewDragHelper.continueSettling(true)){\n        invalidate();\n    }\n}\n```\n\n**处理CallBack回调**\n\n```java\nprivate ViewDragHelper.Callback mCallback = new ViewDragHelper.Callback() {\n\n    // tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动\n    @Override\n    public boolean tryCaptureView(View child, int pointerId) {\n    }\n\n    // clampViewPositionHorizontal() 判断水平方向上将要移动到的位置\n    // left 将要移动到的left值\n    // dx 表示速度\n    @Override\n    public int clampViewPositionHorizontal(View child, int left, int dx) {\n    }\n\n    // 同clampViewPositionHorizontal(), 换成了垂直方向而已\n    @Override\n    public int clampViewPositionVertical(View child, int top, int dy) {\n    }\n\n    // 手指拖拽后释放\n    // releasedChild 拖拽的view\n    // xvel, yvel拖拽动速度\n    @Override\n    public void onViewReleased(View releasedChild, float xvel, float yvel) {\n    }\n};\n```\n\nViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法\n\n还有一些常用的关于边缘滑动相关的重写方法\n\n在这里就不写了\n\n## 例子\n\n实现一个支持拖拽, 有粘性的ViewGroup\n\n```java\npublic class DragLayout extends LinearLayout {\n\n    private float mRaftValue = UIUtils.dip2Px(getContext(), 20); //回弹临界距离\n\n    private float mRaftYVel = 1000.0f; // 回弹临界速度\n\n    private ViewDragHelper mDragHelper;\n\n    private OnDismissListener mOnDismissListener;\n\n    private boolean mDragToggle = true;\n\n    public DragLayout(@NonNull Context context) {\n        this(context, null);\n    }\n\n    public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n    public void setOnDismissListener(OnDismissListener onDismissListener) {\n        mOnDismissListener = onDismissListener;\n    }\n\n    private void init() {\n        ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {\n            private int mCurrentTop;\n\n            @Override\n            public boolean tryCaptureView(@NonNull View child, int pointerId) {\n                return mDragToggle;\n            }\n\n\n            @Override\n            public int clampViewPositionVertical(@NonNull View child, int top, int dy) {\n                // 禁止向上滑动\n                if (top < 0) {\n                    top = 0;\n                }\n                mCurrentTop = top;\n                return top;\n            }\n\n            @Override\n            public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) {\n                super.onViewReleased(releasedChild, xvel, yvel);\n                // 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画\n                // 还需要限定一个速度，优化用户体验\n                if (mCurrentTop <= mRaftValue && yvel <= mRaftYVel) {\n                    mDragHelper.settleCapturedViewAt(0, 0);\n                    invalidate();\n                } else { // 从底部滑出\n                    if (mOnDismissListener != null) {\n                        mOnDismissListener.onDismiss();\n                    }\n                }\n            }\n\n            // 响应垂直滑动事件\n            // 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件\n            // 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中,\n            // 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截.\n            // 所以需要重写并返回一个非0值\n            @Override\n            public int getViewVerticalDragRange(@NonNull View child) {\n                return 1;\n            }\n        };\n\n        mDragHelper = ViewDragHelper.create(this, callback);\n\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        return super.dispatchTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n\n        return mDragHelper.shouldInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        try {\n            mDragHelper.processTouchEvent(event);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return true;\n    }\n\n    @Override\n    public void computeScroll() {\n        if (mDragHelper != null && mDragHelper.continueSettling(true)) {\n            invalidate();\n        }\n    }\n\n    public interface OnDismissListener {\n        void onDismiss();\n    }\n}\n```\n\n**注意** 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽","source":"_posts/Android/ViewDragHelper的使用.md","raw":"---\ntitle: ViewDragHelper的使用\ndate: 2020-02-19 10:36:30\ntags:\n- View\ncategories:\n- Android\n---\n\nViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部\n\n**参考**\n\n[ViewDragHelper 的基本使用](https://www.jianshu.com/p/a9e0a98e4d42)\n\n# 常用Api\n\n**初始化**\n\n```java\npublic static ViewDragHelper create(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb)\n```\n\n第一个参数是父布局, 第二个参数是自定义的监听回调\n\n**拦截事件**\n\n在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断\n\n```java\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\n    //ViewDragHelper对事件进行拦截\n    //注意, ACTION_DOWN事件不会被拦截\n    //当clampViewPositionXxx方法没有修改left或top值时, 不会拦截\n    //是的, shouldInterceptTouchEvent中会调用callback.clampViewPositionXxx方法\n    return mViewDragHelper.shouldInterceptTouchEvent(ev);\n}\n\n@Override\npublic boolean onTouchEvent(MotionEvent event) {\n    //将事件传递给ViewDragHelper进行处理\n    mViewDragHelper.processTouchEvent(event);\n    return true;\n}\n```\n\n**处理computeScroll**\n\n因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法)\n\n```java\n@Override\npublic void computeScroll() {\n    super.computeScroll();\n    if (mViewDragHelper != null && mViewDragHelper.continueSettling(true)){\n        invalidate();\n    }\n}\n```\n\n**处理CallBack回调**\n\n```java\nprivate ViewDragHelper.Callback mCallback = new ViewDragHelper.Callback() {\n\n    // tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动\n    @Override\n    public boolean tryCaptureView(View child, int pointerId) {\n    }\n\n    // clampViewPositionHorizontal() 判断水平方向上将要移动到的位置\n    // left 将要移动到的left值\n    // dx 表示速度\n    @Override\n    public int clampViewPositionHorizontal(View child, int left, int dx) {\n    }\n\n    // 同clampViewPositionHorizontal(), 换成了垂直方向而已\n    @Override\n    public int clampViewPositionVertical(View child, int top, int dy) {\n    }\n\n    // 手指拖拽后释放\n    // releasedChild 拖拽的view\n    // xvel, yvel拖拽动速度\n    @Override\n    public void onViewReleased(View releasedChild, float xvel, float yvel) {\n    }\n};\n```\n\nViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法\n\n还有一些常用的关于边缘滑动相关的重写方法\n\n在这里就不写了\n\n## 例子\n\n实现一个支持拖拽, 有粘性的ViewGroup\n\n```java\npublic class DragLayout extends LinearLayout {\n\n    private float mRaftValue = UIUtils.dip2Px(getContext(), 20); //回弹临界距离\n\n    private float mRaftYVel = 1000.0f; // 回弹临界速度\n\n    private ViewDragHelper mDragHelper;\n\n    private OnDismissListener mOnDismissListener;\n\n    private boolean mDragToggle = true;\n\n    public DragLayout(@NonNull Context context) {\n        this(context, null);\n    }\n\n    public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public DragLayout(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init();\n    }\n\n    public void setOnDismissListener(OnDismissListener onDismissListener) {\n        mOnDismissListener = onDismissListener;\n    }\n\n    private void init() {\n        ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {\n            private int mCurrentTop;\n\n            @Override\n            public boolean tryCaptureView(@NonNull View child, int pointerId) {\n                return mDragToggle;\n            }\n\n\n            @Override\n            public int clampViewPositionVertical(@NonNull View child, int top, int dy) {\n                // 禁止向上滑动\n                if (top < 0) {\n                    top = 0;\n                }\n                mCurrentTop = top;\n                return top;\n            }\n\n            @Override\n            public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) {\n                super.onViewReleased(releasedChild, xvel, yvel);\n                // 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画\n                // 还需要限定一个速度，优化用户体验\n                if (mCurrentTop <= mRaftValue && yvel <= mRaftYVel) {\n                    mDragHelper.settleCapturedViewAt(0, 0);\n                    invalidate();\n                } else { // 从底部滑出\n                    if (mOnDismissListener != null) {\n                        mOnDismissListener.onDismiss();\n                    }\n                }\n            }\n\n            // 响应垂直滑动事件\n            // 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件\n            // 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中,\n            // 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截.\n            // 所以需要重写并返回一个非0值\n            @Override\n            public int getViewVerticalDragRange(@NonNull View child) {\n                return 1;\n            }\n        };\n\n        mDragHelper = ViewDragHelper.create(this, callback);\n\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        return super.dispatchTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n\n        return mDragHelper.shouldInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        try {\n            mDragHelper.processTouchEvent(event);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return true;\n    }\n\n    @Override\n    public void computeScroll() {\n        if (mDragHelper != null && mDragHelper.continueSettling(true)) {\n            invalidate();\n        }\n    }\n\n    public interface OnDismissListener {\n        void onDismiss();\n    }\n}\n```\n\n**注意** 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽","slug":"Android/ViewDragHelper的使用","published":1,"updated":"2021-10-03T01:57:41.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8a002ng0jea551m4nr","content":"<p>ViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部</p><a id=\"more\"></a>\n<p><strong>参考</strong></p>\n<p><a href=\"https://www.jianshu.com/p/a9e0a98e4d42\" target=\"_blank\" rel=\"noopener\">ViewDragHelper 的基本使用</a></p>\n<h1 id=\"常用Api\"><a href=\"#常用Api\" class=\"headerlink\" title=\"常用Api\"></a>常用Api</h1><p><strong>初始化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewDragHelper <span class=\"title\">create</span><span class=\"params\">(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb)</span></span></span><br></pre></td></tr></table></figure>\n<p>第一个参数是父布局, 第二个参数是自定义的监听回调</p>\n<p><strong>拦截事件</strong></p>\n<p>在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ViewDragHelper对事件进行拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//注意, ACTION_DOWN事件不会被拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//当clampViewPositionXxx方法没有修改left或top值时, 不会拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//是的, shouldInterceptTouchEvent中会调用callback.clampViewPositionXxx方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将事件传递给ViewDragHelper进行处理</span></span><br><span class=\"line\">    mViewDragHelper.processTouchEvent(event);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>处理computeScroll</strong></p>\n<p>因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.computeScroll();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mViewDragHelper != <span class=\"keyword\">null</span> &amp;&amp; mViewDragHelper.continueSettling(<span class=\"keyword\">true</span>))&#123;</span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>处理CallBack回调</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ViewDragHelper.Callback mCallback = <span class=\"keyword\">new</span> ViewDragHelper.Callback() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryCaptureView</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// clampViewPositionHorizontal() 判断水平方向上将要移动到的位置</span></span><br><span class=\"line\">    <span class=\"comment\">// left 将要移动到的left值</span></span><br><span class=\"line\">    <span class=\"comment\">// dx 表示速度</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionHorizontal</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> dx)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 同clampViewPositionHorizontal(), 换成了垂直方向而已</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionVertical</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 手指拖拽后释放</span></span><br><span class=\"line\">    <span class=\"comment\">// releasedChild 拖拽的view</span></span><br><span class=\"line\">    <span class=\"comment\">// xvel, yvel拖拽动速度</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewReleased</span><span class=\"params\">(View releasedChild, <span class=\"keyword\">float</span> xvel, <span class=\"keyword\">float</span> yvel)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>ViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法</p>\n<p>还有一些常用的关于边缘滑动相关的重写方法</p>\n<p>在这里就不写了</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>实现一个支持拖拽, 有粘性的ViewGroup</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DragLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinearLayout</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mRaftValue = UIUtils.dip2Px(getContext(), <span class=\"number\">20</span>); <span class=\"comment\">//回弹临界距离</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mRaftYVel = <span class=\"number\">1000.0f</span>; <span class=\"comment\">// 回弹临界速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewDragHelper mDragHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OnDismissListener mOnDismissListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mDragToggle = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(context, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(context, attrs, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnDismissListener</span><span class=\"params\">(OnDismissListener onDismissListener)</span> </span>&#123;</span><br><span class=\"line\">        mOnDismissListener = onDismissListener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ViewDragHelper.Callback callback = <span class=\"keyword\">new</span> ViewDragHelper.Callback() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentTop;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryCaptureView</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mDragToggle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionVertical</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 禁止向上滑动</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    top = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mCurrentTop = top;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> top;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewReleased</span><span class=\"params\">(@NonNull View releasedChild, <span class=\"keyword\">float</span> xvel, <span class=\"keyword\">float</span> yvel)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onViewReleased(releasedChild, xvel, yvel);</span><br><span class=\"line\">                <span class=\"comment\">// 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画</span></span><br><span class=\"line\">                <span class=\"comment\">// 还需要限定一个速度，优化用户体验</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mCurrentTop &lt;= mRaftValue &amp;&amp; yvel &lt;= mRaftYVel) &#123;</span><br><span class=\"line\">                    mDragHelper.settleCapturedViewAt(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 从底部滑出</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mOnDismissListener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        mOnDismissListener.onDismiss();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 响应垂直滑动事件</span></span><br><span class=\"line\">            <span class=\"comment\">// 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件</span></span><br><span class=\"line\">            <span class=\"comment\">// 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中,</span></span><br><span class=\"line\">            <span class=\"comment\">// 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截.</span></span><br><span class=\"line\">            <span class=\"comment\">// 所以需要重写并返回一个非0值</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getViewVerticalDragRange</span><span class=\"params\">(@NonNull View child)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        mDragHelper = ViewDragHelper.create(<span class=\"keyword\">this</span>, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mDragHelper.processTouchEvent(event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDragHelper != <span class=\"keyword\">null</span> &amp;&amp; mDragHelper.continueSettling(<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnDismissListener</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onDismiss</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong> 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽</p>\n","site":{"data":{}},"excerpt":"<p>ViewDragHelper是一个V4包下的类, 可以帮助实现对子View的滑动拖放需求. 通常定义在自定义ViewGroup的内部</p>","more":"\n<p><strong>参考</strong></p>\n<p><a href=\"https://www.jianshu.com/p/a9e0a98e4d42\" target=\"_blank\" rel=\"noopener\">ViewDragHelper 的基本使用</a></p>\n<h1 id=\"常用Api\"><a href=\"#常用Api\" class=\"headerlink\" title=\"常用Api\"></a>常用Api</h1><p><strong>初始化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewDragHelper <span class=\"title\">create</span><span class=\"params\">(@NonNull ViewGroup forParent, @NonNull ViewDragHelper.Callback cb)</span></span></span><br></pre></td></tr></table></figure>\n<p>第一个参数是父布局, 第二个参数是自定义的监听回调</p>\n<p><strong>拦截事件</strong></p>\n<p>在自定义的ViewGroup中需要将点击事件交给ViewDragHelper来判断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ViewDragHelper对事件进行拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//注意, ACTION_DOWN事件不会被拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//当clampViewPositionXxx方法没有修改left或top值时, 不会拦截</span></span><br><span class=\"line\">    <span class=\"comment\">//是的, shouldInterceptTouchEvent中会调用callback.clampViewPositionXxx方法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mViewDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将事件传递给ViewDragHelper进行处理</span></span><br><span class=\"line\">    mViewDragHelper.processTouchEvent(event);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>处理computeScroll</strong></p>\n<p>因为ViewDragHelper内部是通过Scroller来实现的, 所以要重写computeScroll方法(当Scroller处理滑动时, 会调用computeScroll方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.computeScroll();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mViewDragHelper != <span class=\"keyword\">null</span> &amp;&amp; mViewDragHelper.continueSettling(<span class=\"keyword\">true</span>))&#123;</span><br><span class=\"line\">        invalidate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>处理CallBack回调</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ViewDragHelper.Callback mCallback = <span class=\"keyword\">new</span> ViewDragHelper.Callback() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// tryCaptureView()我们可以在这个方法指定ViewGroup中的哪个子View可以被移动</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryCaptureView</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// clampViewPositionHorizontal() 判断水平方向上将要移动到的位置</span></span><br><span class=\"line\">    <span class=\"comment\">// left 将要移动到的left值</span></span><br><span class=\"line\">    <span class=\"comment\">// dx 表示速度</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionHorizontal</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> dx)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 同clampViewPositionHorizontal(), 换成了垂直方向而已</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionVertical</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 手指拖拽后释放</span></span><br><span class=\"line\">    <span class=\"comment\">// releasedChild 拖拽的view</span></span><br><span class=\"line\">    <span class=\"comment\">// xvel, yvel拖拽动速度</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewReleased</span><span class=\"params\">(View releasedChild, <span class=\"keyword\">float</span> xvel, <span class=\"keyword\">float</span> yvel)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>ViewDragHelper.Callback 是一个抽象类, 有很多可以重写的方法, 上面的是常用的方法</p>\n<p>还有一些常用的关于边缘滑动相关的重写方法</p>\n<p>在这里就不写了</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>实现一个支持拖拽, 有粘性的ViewGroup</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DragLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinearLayout</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mRaftValue = UIUtils.dip2Px(getContext(), <span class=\"number\">20</span>); <span class=\"comment\">//回弹临界距离</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mRaftYVel = <span class=\"number\">1000.0f</span>; <span class=\"comment\">// 回弹临界速度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewDragHelper mDragHelper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> OnDismissListener mOnDismissListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mDragToggle = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(context, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(context, attrs, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DragLayout</span><span class=\"params\">(@NonNull Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setOnDismissListener</span><span class=\"params\">(OnDismissListener onDismissListener)</span> </span>&#123;</span><br><span class=\"line\">        mOnDismissListener = onDismissListener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ViewDragHelper.Callback callback = <span class=\"keyword\">new</span> ViewDragHelper.Callback() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurrentTop;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryCaptureView</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> pointerId)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> mDragToggle;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">clampViewPositionVertical</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> top, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 禁止向上滑动</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (top &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    top = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mCurrentTop = top;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> top;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onViewReleased</span><span class=\"params\">(@NonNull View releasedChild, <span class=\"keyword\">float</span> xvel, <span class=\"keyword\">float</span> yvel)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.onViewReleased(releasedChild, xvel, yvel);</span><br><span class=\"line\">                <span class=\"comment\">// 这里限定一个范围，在这个范围之内，可以进行回弹，大于这个范围，触发动画</span></span><br><span class=\"line\">                <span class=\"comment\">// 还需要限定一个速度，优化用户体验</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mCurrentTop &lt;= mRaftValue &amp;&amp; yvel &lt;= mRaftYVel) &#123;</span><br><span class=\"line\">                    mDragHelper.settleCapturedViewAt(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 从底部滑出</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (mOnDismissListener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        mOnDismissListener.onDismiss();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 响应垂直滑动事件</span></span><br><span class=\"line\">            <span class=\"comment\">// 当子view会消费点击事件, 比如 clickable为true, 需要mDragHelper拦截点击事件</span></span><br><span class=\"line\">            <span class=\"comment\">// 而在mDragHelper.shouldInterceptTouchEvent(ev)方法中,</span></span><br><span class=\"line\">            <span class=\"comment\">// 当getViewVerticalDragRange和getViewHorizontalDragRange都返回0时, 不会拦截.</span></span><br><span class=\"line\">            <span class=\"comment\">// 所以需要重写并返回一个非0值</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getViewVerticalDragRange</span><span class=\"params\">(@NonNull View child)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        mDragHelper = ViewDragHelper.create(<span class=\"keyword\">this</span>, callback);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.dispatchTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mDragHelper.shouldInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            mDragHelper.processTouchEvent(event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mDragHelper != <span class=\"keyword\">null</span> &amp;&amp; mDragHelper.continueSettling(<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnDismissListener</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onDismiss</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong> 在xml布局中, DragLayout必须只有一个直接子View, 这样才能实现对所有内容的拖拽</p>\n"},{"title":"kotlin协程","date":"2020-07-15T03:30:02.000Z","_content":"\n\n## Async\n\n首先看一个例子，先后调用两个挂起函数\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了一些有用的事\n    return 29\n}\n\n/** 输出\n\nThe answer is 42\nCompleted in 2017 ms\n\n**/\n```\n\n可以发现，两个挂起函数是同步执行的，有先后顺序\n\n使用async\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了些有用的事\n    return 29\n}\n\n/** 输出\nThe answer is 42\nCompleted in 1024 ms\n**/\n```\n\n在结果耗时上，两个挂起方法达到了异步的效果。这得益于`async`关键字\n在概念上，`async` 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。\n\n## 调度器与线程\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    launch { // 运行在父协程的上下文中，即 runBlocking 主协程\n        println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Unconfined) { // 不受限的——将工作在主线程中\n        println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Default) { // 将会获取默认调度器\n        println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // 将使它获得一个新的线程\n        println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n    }    \n}\n\n/** 输出 注意先后顺序\n\nUnconfined            : I'm working in thread main @coroutine#3\nDefault               : I'm working in thread DefaultDispatcher-worker-1 @coroutine#4\nmain runBlocking      : I'm working in thread main @coroutine#2\nnewSingleThreadContext: I'm working in thread MyOwnThread @coroutine#5\n\n**/\n```\n\n* `launch { …… }` :\n    * 当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。\n* `launch(Dispatchers.Default) { …… }` :\n    * 当协程在 GlobalScope 中启动时，使用的是由` Dispatchers.Default `代表的默认调度器。 默认调度器使用共享的后台线程池。 所以` launch(Dispatchers.Default) { …… } `与` GlobalScope.launch { …… } `使用相同的调度器。 \n    `Dispatchers.Default `适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list\n* `launch(Dispatchers.IO) { …… }` :\n    * 针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 \n* `launch(newSingleThreadContext(\"...\")) { ... }` :\n    * `newSingleThreadContext` 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 `close` 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。???\n* `launch(Dispatchers.Unconfined) { ... }` :\n    * 完全没搞懂这玩意儿..\n\n\n## 在Android中使用协程作用域\n\n```kotlin\nimport kotlinx.coroutines.*\n\nclass Activity {\n    private val mainScope = MainScope()\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n\n    fun doSomething() {\n        // 在示例中启动了 10 个协程，且每个都工作了不同的时长\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // Activity 类结束\n\nfun main() = runBlocking<Unit> {\n    val activity = Activity()\n    activity.doSomething() // 运行测试函数\n    println(\"Launched coroutines\")\n    delay(500L) // 延迟半秒钟\n    println(\"Destroying activity!\")\n    activity.destroy() // 取消所有的协程\n    delay(1000) // 为了在视觉上确认它们没有工作    \n}\n```\n\n通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 `Dispatchers.Main` 作为默认调度器的 UI 应用程序 创建作用域.\n\n在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程\n\n## 异步流\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = flow { // 流构建器\n    for (i in 1..3) {\n        delay(100) // 假装我们在这里做了一些有用的事情\n        emit(i) // 发送下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // 启动并发的协程以验证主线程并未阻塞\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // 收集这个流\n    foo().collect { value -> println(value) } \n}\n\n/** 输出\n\nI'm not blocked 1\n1\nI'm not blocked 2\n2\nI'm not blocked 3\n3\n**/\n```\n\n上方的程序: \n* 名为 flow 的 Flow 类型构建器函数。\n* flow { ... } 构建块中的代码可以挂起。\n* 函数 foo() 不再标有 suspend 修饰符。\n* 流使用 emit 函数 发射 值。\n* 流使用 collect 函数 收集 值。\n\nkotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算\n\n## suspendCancellableCoroutine\n\n```kotlin\nprivate suspend fun loadPageSuspend(productCategoryType: Int, page: Int): ProductListLoadResultBean =\n            suspendCancellableCoroutine { cnt ->\n                ProductManagementAPI.requestProductList(\n                        category = productCategoryType,\n                        page = page,\n                        keyword = getKeyword(),\n                        orderBy = getOrderType(),\n                        desc =  isOrderDesc(),\n                        listener = object : INetRequestListener<ProductListLoadResultBean> {\n                            override fun onSuccess(result: DataHull<ProductListLoadResultBean>?) {\n                                result?.let {\n                                    cnt.resumeWith(Result.success(it.data))\n\n                                } ?: kotlin.run {\n                                    cnt.resumeWithException(Exception())\n                                }\n                            }\n\n                            override fun onError(error: DataHull<ProductListLoadResultBean>?, isNetError: Boolean) {\n                                cnt.resumeWithException(Exception(error?.stateBean?.message))\n                            }\n\n                        }\n                )\n            }\n```\n","source":"_posts/Android/kotlin协程.md","raw":"---\ntitle: kotlin协程\ndate: 2020-07-15 11:30:02\ntags: \n- Kotlin\ncategories:\n- Kotlin\n---\n\n\n## Async\n\n首先看一个例子，先后调用两个挂起函数\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = doSomethingUsefulOne()\n        val two = doSomethingUsefulTwo()\n        println(\"The answer is ${one + two}\")\n    }\n    println(\"Completed in $time ms\")    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了一些有用的事\n    return 29\n}\n\n/** 输出\n\nThe answer is 42\nCompleted in 2017 ms\n\n**/\n```\n\n可以发现，两个挂起函数是同步执行的，有先后顺序\n\n使用async\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlin.system.*\n\nfun main() = runBlocking<Unit> {\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")    \n}\n\nsuspend fun doSomethingUsefulOne(): Int {\n    delay(1000L) // 假设我们在这里做了些有用的事\n    return 13\n}\n\nsuspend fun doSomethingUsefulTwo(): Int {\n    delay(1000L) // 假设我们在这里也做了些有用的事\n    return 29\n}\n\n/** 输出\nThe answer is 42\nCompleted in 1024 ms\n**/\n```\n\n在结果耗时上，两个挂起方法达到了异步的效果。这得益于`async`关键字\n在概念上，`async` 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。\n\n## 调度器与线程\n\n```kotlin\nimport kotlinx.coroutines.*\n\nfun main() = runBlocking<Unit> {\n    launch { // 运行在父协程的上下文中，即 runBlocking 主协程\n        println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Unconfined) { // 不受限的——将工作在主线程中\n        println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(Dispatchers.Default) { // 将会获取默认调度器\n        println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // 将使它获得一个新的线程\n        println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")\n    }    \n}\n\n/** 输出 注意先后顺序\n\nUnconfined            : I'm working in thread main @coroutine#3\nDefault               : I'm working in thread DefaultDispatcher-worker-1 @coroutine#4\nmain runBlocking      : I'm working in thread main @coroutine#2\nnewSingleThreadContext: I'm working in thread MyOwnThread @coroutine#5\n\n**/\n```\n\n* `launch { …… }` :\n    * 当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。\n* `launch(Dispatchers.Default) { …… }` :\n    * 当协程在 GlobalScope 中启动时，使用的是由` Dispatchers.Default `代表的默认调度器。 默认调度器使用共享的后台线程池。 所以` launch(Dispatchers.Default) { …… } `与` GlobalScope.launch { …… } `使用相同的调度器。 \n    `Dispatchers.Default `适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list\n* `launch(Dispatchers.IO) { …… }` :\n    * 针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 \n* `launch(newSingleThreadContext(\"...\")) { ... }` :\n    * `newSingleThreadContext` 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 `close` 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。???\n* `launch(Dispatchers.Unconfined) { ... }` :\n    * 完全没搞懂这玩意儿..\n\n\n## 在Android中使用协程作用域\n\n```kotlin\nimport kotlinx.coroutines.*\n\nclass Activity {\n    private val mainScope = MainScope()\n    \n    fun destroy() {\n        mainScope.cancel()\n    }\n\n    fun doSomething() {\n        // 在示例中启动了 10 个协程，且每个都工作了不同的时长\n        repeat(10) { i ->\n            mainScope.launch {\n                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间\n                println(\"Coroutine $i is done\")\n            }\n        }\n    }\n} // Activity 类结束\n\nfun main() = runBlocking<Unit> {\n    val activity = Activity()\n    activity.doSomething() // 运行测试函数\n    println(\"Launched coroutines\")\n    delay(500L) // 延迟半秒钟\n    println(\"Destroying activity!\")\n    activity.destroy() // 取消所有的协程\n    delay(1000) // 为了在视觉上确认它们没有工作    \n}\n```\n\n通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 `Dispatchers.Main` 作为默认调度器的 UI 应用程序 创建作用域.\n\n在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程\n\n## 异步流\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun foo(): Flow<Int> = flow { // 流构建器\n    for (i in 1..3) {\n        delay(100) // 假装我们在这里做了一些有用的事情\n        emit(i) // 发送下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // 启动并发的协程以验证主线程并未阻塞\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // 收集这个流\n    foo().collect { value -> println(value) } \n}\n\n/** 输出\n\nI'm not blocked 1\n1\nI'm not blocked 2\n2\nI'm not blocked 3\n3\n**/\n```\n\n上方的程序: \n* 名为 flow 的 Flow 类型构建器函数。\n* flow { ... } 构建块中的代码可以挂起。\n* 函数 foo() 不再标有 suspend 修饰符。\n* 流使用 emit 函数 发射 值。\n* 流使用 collect 函数 收集 值。\n\nkotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算\n\n## suspendCancellableCoroutine\n\n```kotlin\nprivate suspend fun loadPageSuspend(productCategoryType: Int, page: Int): ProductListLoadResultBean =\n            suspendCancellableCoroutine { cnt ->\n                ProductManagementAPI.requestProductList(\n                        category = productCategoryType,\n                        page = page,\n                        keyword = getKeyword(),\n                        orderBy = getOrderType(),\n                        desc =  isOrderDesc(),\n                        listener = object : INetRequestListener<ProductListLoadResultBean> {\n                            override fun onSuccess(result: DataHull<ProductListLoadResultBean>?) {\n                                result?.let {\n                                    cnt.resumeWith(Result.success(it.data))\n\n                                } ?: kotlin.run {\n                                    cnt.resumeWithException(Exception())\n                                }\n                            }\n\n                            override fun onError(error: DataHull<ProductListLoadResultBean>?, isNetError: Boolean) {\n                                cnt.resumeWithException(Exception(error?.stateBean?.message))\n                            }\n\n                        }\n                )\n            }\n```\n","slug":"Android/kotlin协程","published":1,"updated":"2021-10-03T01:57:41.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8a002og0jet2oqxgzy","content":"<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><p>首先看一个例子，先后调用两个挂起函数</p><a id=\"more\"></a>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> one = doSomethingUsefulOne()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> two = doSomethingUsefulTwo()</span><br><span class=\"line\">        println(<span class=\"string\">\"The answer is <span class=\"subst\">$&#123;one + two&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">\"Completed in <span class=\"variable\">$time</span> ms\"</span>)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulOne</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">13</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulTwo</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里也做了一些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">29</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">The answer is 42</span></span><br><span class=\"line\"><span class=\"comment\">Completed in 2017 ms</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，两个挂起函数是同步执行的，有先后顺序</p>\n<p>使用async</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class=\"line\">        println(<span class=\"string\">\"The answer is <span class=\"subst\">$&#123;one.await() + two.await()&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">\"Completed in <span class=\"variable\">$time</span> ms\"</span>)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulOne</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">13</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulTwo</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里也做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">29</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\">The answer is 42</span></span><br><span class=\"line\"><span class=\"comment\">Completed in 1024 ms</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>在结果耗时上，两个挂起方法达到了异步的效果。这得益于<code>async</code>关键字<br>在概念上，<code>async</code> 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p>\n<h2 id=\"调度器与线程\"><a href=\"#调度器与线程\" class=\"headerlink\" title=\"调度器与线程\"></a>调度器与线程</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    launch &#123; <span class=\"comment\">// 运行在父协程的上下文中，即 runBlocking 主协程</span></span><br><span class=\"line\">        println(<span class=\"string\">\"main runBlocking      : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(Dispatchers.Unconfined) &#123; <span class=\"comment\">// 不受限的——将工作在主线程中</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Unconfined            : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(Dispatchers.Default) &#123; <span class=\"comment\">// 将会获取默认调度器</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Default               : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(newSingleThreadContext(<span class=\"string\">\"MyOwnThread\"</span>)) &#123; <span class=\"comment\">// 将使它获得一个新的线程</span></span><br><span class=\"line\">        println(<span class=\"string\">\"newSingleThreadContext: I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出 注意先后顺序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Unconfined            : I'm working in thread main <span class=\"doctag\">@coroutine</span>#3</span></span><br><span class=\"line\"><span class=\"comment\">Default               : I'm working in thread DefaultDispatcher-worker-1 <span class=\"doctag\">@coroutine</span>#4</span></span><br><span class=\"line\"><span class=\"comment\">main runBlocking      : I'm working in thread main <span class=\"doctag\">@coroutine</span>#2</span></span><br><span class=\"line\"><span class=\"comment\">newSingleThreadContext: I'm working in thread MyOwnThread <span class=\"doctag\">@coroutine</span>#5</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>launch { …… }</code> :<ul>\n<li>当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.Default) { …… }</code> :<ul>\n<li>当协程在 GlobalScope 中启动时，使用的是由<code>Dispatchers.Default</code>代表的默认调度器。 默认调度器使用共享的后台线程池。 所以<code>launch(Dispatchers.Default) { …… }</code>与<code>GlobalScope.launch { …… }</code>使用相同的调度器。<br><code>Dispatchers.Default</code>适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.IO) { …… }</code> :<ul>\n<li>针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 </li>\n</ul>\n</li>\n<li><code>launch(newSingleThreadContext(&quot;...&quot;)) { ... }</code> :<ul>\n<li><code>newSingleThreadContext</code> 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 <code>close</code> 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。???</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.Unconfined) { ... }</code> :<ul>\n<li>完全没搞懂这玩意儿..</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在Android中使用协程作用域\"><a href=\"#在Android中使用协程作用域\" class=\"headerlink\" title=\"在Android中使用协程作用域\"></a>在Android中使用协程作用域</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mainScope = MainScope()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mainScope.cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在示例中启动了 10 个协程，且每个都工作了不同的时长</span></span><br><span class=\"line\">        repeat(<span class=\"number\">10</span>) &#123; i -&gt;</span><br><span class=\"line\">            mainScope.launch &#123;</span><br><span class=\"line\">                delay((i + <span class=\"number\">1</span>) * <span class=\"number\">200L</span>) <span class=\"comment\">// 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span></span><br><span class=\"line\">                println(<span class=\"string\">\"Coroutine <span class=\"variable\">$i</span> is done\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// Activity 类结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> activity = Activity()</span><br><span class=\"line\">    activity.doSomething() <span class=\"comment\">// 运行测试函数</span></span><br><span class=\"line\">    println(<span class=\"string\">\"Launched coroutines\"</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">500L</span>) <span class=\"comment\">// 延迟半秒钟</span></span><br><span class=\"line\">    println(<span class=\"string\">\"Destroying activity!\"</span>)</span><br><span class=\"line\">    activity.destroy() <span class=\"comment\">// 取消所有的协程</span></span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>) <span class=\"comment\">// 为了在视觉上确认它们没有工作    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 <code>Dispatchers.Main</code> 作为默认调度器的 UI 应用程序 创建作用域.</p>\n<p>在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程</p>\n<h2 id=\"异步流\"><a href=\"#异步流\" class=\"headerlink\" title=\"异步流\"></a>异步流</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123; <span class=\"comment\">// 流构建器</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们在这里做了一些有用的事情</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发送下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class=\"line\">    launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (k <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"I'm not blocked <span class=\"variable\">$k</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 收集这个流</span></span><br><span class=\"line\">    foo().collect &#123; value -&gt; println(value) &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 1</span></span><br><span class=\"line\"><span class=\"comment\">1</span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 2</span></span><br><span class=\"line\"><span class=\"comment\">2</span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 3</span></span><br><span class=\"line\"><span class=\"comment\">3</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>上方的程序: </p>\n<ul>\n<li>名为 flow 的 Flow 类型构建器函数。</li>\n<li>flow { … } 构建块中的代码可以挂起。</li>\n<li>函数 foo() 不再标有 suspend 修饰符。</li>\n<li>流使用 emit 函数 发射 值。</li>\n<li>流使用 collect 函数 收集 值。</li>\n</ul>\n<p>kotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算</p>\n<h2 id=\"suspendCancellableCoroutine\"><a href=\"#suspendCancellableCoroutine\" class=\"headerlink\" title=\"suspendCancellableCoroutine\"></a>suspendCancellableCoroutine</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadPageSuspend</span><span class=\"params\">(productCategoryType: <span class=\"type\">Int</span>, page: <span class=\"type\">Int</span>)</span></span>: ProductListLoadResultBean =</span><br><span class=\"line\">            suspendCancellableCoroutine &#123; cnt -&gt;</span><br><span class=\"line\">                ProductManagementAPI.requestProductList(</span><br><span class=\"line\">                        category = productCategoryType,</span><br><span class=\"line\">                        page = page,</span><br><span class=\"line\">                        keyword = getKeyword(),</span><br><span class=\"line\">                        orderBy = getOrderType(),</span><br><span class=\"line\">                        desc =  isOrderDesc(),</span><br><span class=\"line\">                        listener = <span class=\"keyword\">object</span> : INetRequestListener&lt;ProductListLoadResultBean&gt; &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(result: <span class=\"type\">DataHull</span>&lt;<span class=\"type\">ProductListLoadResultBean</span>&gt;?)</span></span> &#123;</span><br><span class=\"line\">                                result?.let &#123;</span><br><span class=\"line\">                                    cnt.resumeWith(Result.success(it.<span class=\"keyword\">data</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">                                &#125; ?: kotlin.run &#123;</span><br><span class=\"line\">                                    cnt.resumeWithException(Exception())</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(error: <span class=\"type\">DataHull</span>&lt;<span class=\"type\">ProductListLoadResultBean</span>&gt;?, isNetError: <span class=\"type\">Boolean</span>)</span></span> &#123;</span><br><span class=\"line\">                                cnt.resumeWithException(Exception(error?.stateBean?.message))</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Async\"><a href=\"#Async\" class=\"headerlink\" title=\"Async\"></a>Async</h2><p>首先看一个例子，先后调用两个挂起函数</p>","more":"\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> one = doSomethingUsefulOne()</span><br><span class=\"line\">        <span class=\"keyword\">val</span> two = doSomethingUsefulTwo()</span><br><span class=\"line\">        println(<span class=\"string\">\"The answer is <span class=\"subst\">$&#123;one + two&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">\"Completed in <span class=\"variable\">$time</span> ms\"</span>)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulOne</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">13</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulTwo</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里也做了一些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">29</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">The answer is 42</span></span><br><span class=\"line\"><span class=\"comment\">Completed in 2017 ms</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，两个挂起函数是同步执行的，有先后顺序</p>\n<p>使用async</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class=\"line\">        println(<span class=\"string\">\"The answer is <span class=\"subst\">$&#123;one.await() + two.await()&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    println(<span class=\"string\">\"Completed in <span class=\"variable\">$time</span> ms\"</span>)    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulOne</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">13</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomethingUsefulTwo</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">    delay(<span class=\"number\">1000L</span>) <span class=\"comment\">// 假设我们在这里也做了些有用的事</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">29</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\">The answer is 42</span></span><br><span class=\"line\"><span class=\"comment\">Completed in 1024 ms</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>在结果耗时上，两个挂起方法达到了异步的效果。这得益于<code>async</code>关键字<br>在概念上，<code>async</code> 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p>\n<h2 id=\"调度器与线程\"><a href=\"#调度器与线程\" class=\"headerlink\" title=\"调度器与线程\"></a>调度器与线程</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    launch &#123; <span class=\"comment\">// 运行在父协程的上下文中，即 runBlocking 主协程</span></span><br><span class=\"line\">        println(<span class=\"string\">\"main runBlocking      : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(Dispatchers.Unconfined) &#123; <span class=\"comment\">// 不受限的——将工作在主线程中</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Unconfined            : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(Dispatchers.Default) &#123; <span class=\"comment\">// 将会获取默认调度器</span></span><br><span class=\"line\">        println(<span class=\"string\">\"Default               : I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    launch(newSingleThreadContext(<span class=\"string\">\"MyOwnThread\"</span>)) &#123; <span class=\"comment\">// 将使它获得一个新的线程</span></span><br><span class=\"line\">        println(<span class=\"string\">\"newSingleThreadContext: I'm working in thread <span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>\"</span>)</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出 注意先后顺序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Unconfined            : I'm working in thread main <span class=\"doctag\">@coroutine</span>#3</span></span><br><span class=\"line\"><span class=\"comment\">Default               : I'm working in thread DefaultDispatcher-worker-1 <span class=\"doctag\">@coroutine</span>#4</span></span><br><span class=\"line\"><span class=\"comment\">main runBlocking      : I'm working in thread main <span class=\"doctag\">@coroutine</span>#2</span></span><br><span class=\"line\"><span class=\"comment\">newSingleThreadContext: I'm working in thread MyOwnThread <span class=\"doctag\">@coroutine</span>#5</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>launch { …… }</code> :<ul>\n<li>当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.Default) { …… }</code> :<ul>\n<li>当协程在 GlobalScope 中启动时，使用的是由<code>Dispatchers.Default</code>代表的默认调度器。 默认调度器使用共享的后台线程池。 所以<code>launch(Dispatchers.Default) { …… }</code>与<code>GlobalScope.launch { …… }</code>使用相同的调度器。<br><code>Dispatchers.Default</code>适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.IO) { …… }</code> :<ul>\n<li>针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 </li>\n</ul>\n</li>\n<li><code>launch(newSingleThreadContext(&quot;...&quot;)) { ... }</code> :<ul>\n<li><code>newSingleThreadContext</code> 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 <code>close</code> 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。???</li>\n</ul>\n</li>\n<li><code>launch(Dispatchers.Unconfined) { ... }</code> :<ul>\n<li>完全没搞懂这玩意儿..</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在Android中使用协程作用域\"><a href=\"#在Android中使用协程作用域\" class=\"headerlink\" title=\"在Android中使用协程作用域\"></a>在Android中使用协程作用域</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mainScope = MainScope()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        mainScope.cancel()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在示例中启动了 10 个协程，且每个都工作了不同的时长</span></span><br><span class=\"line\">        repeat(<span class=\"number\">10</span>) &#123; i -&gt;</span><br><span class=\"line\">            mainScope.launch &#123;</span><br><span class=\"line\">                delay((i + <span class=\"number\">1</span>) * <span class=\"number\">200L</span>) <span class=\"comment\">// 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span></span><br><span class=\"line\">                println(<span class=\"string\">\"Coroutine <span class=\"variable\">$i</span> is done\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"comment\">// Activity 类结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> activity = Activity()</span><br><span class=\"line\">    activity.doSomething() <span class=\"comment\">// 运行测试函数</span></span><br><span class=\"line\">    println(<span class=\"string\">\"Launched coroutines\"</span>)</span><br><span class=\"line\">    delay(<span class=\"number\">500L</span>) <span class=\"comment\">// 延迟半秒钟</span></span><br><span class=\"line\">    println(<span class=\"string\">\"Destroying activity!\"</span>)</span><br><span class=\"line\">    activity.destroy() <span class=\"comment\">// 取消所有的协程</span></span><br><span class=\"line\">    delay(<span class=\"number\">1000</span>) <span class=\"comment\">// 为了在视觉上确认它们没有工作    </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 <code>Dispatchers.Main</code> 作为默认调度器的 UI 应用程序 创建作用域.</p>\n<p>在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程</p>\n<h2 id=\"异步流\"><a href=\"#异步流\" class=\"headerlink\" title=\"异步流\"></a>异步流</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123; <span class=\"comment\">// 流构建器</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们在这里做了一些有用的事情</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发送下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class=\"line\">    launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (k <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"I'm not blocked <span class=\"variable\">$k</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 收集这个流</span></span><br><span class=\"line\">    foo().collect &#123; value -&gt; println(value) &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 输出</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 1</span></span><br><span class=\"line\"><span class=\"comment\">1</span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 2</span></span><br><span class=\"line\"><span class=\"comment\">2</span></span><br><span class=\"line\"><span class=\"comment\">I'm not blocked 3</span></span><br><span class=\"line\"><span class=\"comment\">3</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br></pre></td></tr></table></figure>\n<p>上方的程序: </p>\n<ul>\n<li>名为 flow 的 Flow 类型构建器函数。</li>\n<li>flow { … } 构建块中的代码可以挂起。</li>\n<li>函数 foo() 不再标有 suspend 修饰符。</li>\n<li>流使用 emit 函数 发射 值。</li>\n<li>流使用 collect 函数 收集 值。</li>\n</ul>\n<p>kotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算</p>\n<h2 id=\"suspendCancellableCoroutine\"><a href=\"#suspendCancellableCoroutine\" class=\"headerlink\" title=\"suspendCancellableCoroutine\"></a>suspendCancellableCoroutine</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">loadPageSuspend</span><span class=\"params\">(productCategoryType: <span class=\"type\">Int</span>, page: <span class=\"type\">Int</span>)</span></span>: ProductListLoadResultBean =</span><br><span class=\"line\">            suspendCancellableCoroutine &#123; cnt -&gt;</span><br><span class=\"line\">                ProductManagementAPI.requestProductList(</span><br><span class=\"line\">                        category = productCategoryType,</span><br><span class=\"line\">                        page = page,</span><br><span class=\"line\">                        keyword = getKeyword(),</span><br><span class=\"line\">                        orderBy = getOrderType(),</span><br><span class=\"line\">                        desc =  isOrderDesc(),</span><br><span class=\"line\">                        listener = <span class=\"keyword\">object</span> : INetRequestListener&lt;ProductListLoadResultBean&gt; &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onSuccess</span><span class=\"params\">(result: <span class=\"type\">DataHull</span>&lt;<span class=\"type\">ProductListLoadResultBean</span>&gt;?)</span></span> &#123;</span><br><span class=\"line\">                                result?.let &#123;</span><br><span class=\"line\">                                    cnt.resumeWith(Result.success(it.<span class=\"keyword\">data</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">                                &#125; ?: kotlin.run &#123;</span><br><span class=\"line\">                                    cnt.resumeWithException(Exception())</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                            <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onError</span><span class=\"params\">(error: <span class=\"type\">DataHull</span>&lt;<span class=\"type\">ProductListLoadResultBean</span>&gt;?, isNetError: <span class=\"type\">Boolean</span>)</span></span> &#123;</span><br><span class=\"line\">                                cnt.resumeWithException(Exception(error?.stateBean?.message))</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                )</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"外部View随着RecyclerView的滚动而显示或隐藏","date":"2020-01-09T15:01:39.000Z","_content":"\n\n外部的View上滑显示, 下滑隐藏\n```java\nmOutsideOnScrollListener = new OnScrollListener() {\n    boolean controlsVisible = false;\n    int scrolledDistance = 0;\n\n    @Override\n    public void onScrollStateChanged(int newState) {\n        if (newState == RecyclerView.SCROLL_STATE_IDLE) {\n            scrolledDistance = 0;\n        }\n    }\n\n    @Override\n    public void onScrolled(int dx, int dy) {\n        if ((controlsVisible && dy < 0) || (!controlsVisible && dy > 0){\n            scrolledDistance += dy;\n        }\n        if (scrolledDistance < thresholdToShow && controlsVisible) {\n            //UP\n            scrolledDistance = 0;\n            controlsVisible = false;\n            view.onShow();\n        } else if (scrolledDistance >= thresholdToHide && !controlsVisible) {\n            //DOWN\n            scrolledDistance = 0;\n            controlsVisible = true;\n            view.onPause();\n        }\n    }\n};\n```\n\n* 我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。\n```java\nif ((controlsVisible && dy < 0) || (!controlsVisible && dy > 0)) {\n    scrolledDistance += dy;\n}\n```\n\n* 如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。\n\n```java\nif (scrolledDistance < thresholdToShow && controlsVisible) {\n    //UP\n    scrolledDistance = 0;\n    controlsVisible = false;\n    view.onResume();\n} else if (scrolledDistance >= thresholdToHide && !controlsVisible) {\n    //DOWN\n    scrolledDistance = 0;\n    controlsVisible = true;\n    view.onPause();\n}\n```","source":"_posts/Android/外部View随着RecyclerView的滚动而显示或隐藏.md","raw":"---\ntitle: 外部View随着RecyclerView的滚动而显示或隐藏\ndate: 2020-01-09 23:01:39\ntags:\n- RecyclerView\ncategories:\n- Android\n---\n\n\n外部的View上滑显示, 下滑隐藏\n```java\nmOutsideOnScrollListener = new OnScrollListener() {\n    boolean controlsVisible = false;\n    int scrolledDistance = 0;\n\n    @Override\n    public void onScrollStateChanged(int newState) {\n        if (newState == RecyclerView.SCROLL_STATE_IDLE) {\n            scrolledDistance = 0;\n        }\n    }\n\n    @Override\n    public void onScrolled(int dx, int dy) {\n        if ((controlsVisible && dy < 0) || (!controlsVisible && dy > 0){\n            scrolledDistance += dy;\n        }\n        if (scrolledDistance < thresholdToShow && controlsVisible) {\n            //UP\n            scrolledDistance = 0;\n            controlsVisible = false;\n            view.onShow();\n        } else if (scrolledDistance >= thresholdToHide && !controlsVisible) {\n            //DOWN\n            scrolledDistance = 0;\n            controlsVisible = true;\n            view.onPause();\n        }\n    }\n};\n```\n\n* 我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。\n```java\nif ((controlsVisible && dy < 0) || (!controlsVisible && dy > 0)) {\n    scrolledDistance += dy;\n}\n```\n\n* 如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。\n\n```java\nif (scrolledDistance < thresholdToShow && controlsVisible) {\n    //UP\n    scrolledDistance = 0;\n    controlsVisible = false;\n    view.onResume();\n} else if (scrolledDistance >= thresholdToHide && !controlsVisible) {\n    //DOWN\n    scrolledDistance = 0;\n    controlsVisible = true;\n    view.onPause();\n}\n```","slug":"Android/外部View随着RecyclerView的滚动而显示或隐藏","published":1,"updated":"2021-10-03T01:57:41.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8b002qg0jee8xauc0y","content":"<p>外部的View上滑显示, 下滑隐藏<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mOutsideOnScrollListener = <span class=\"keyword\">new</span> OnScrollListener() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScrollStateChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE) &#123;</span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScrolled</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((controlsVisible &amp;&amp; dy &lt; <span class=\"number\">0</span>) || (!controlsVisible &amp;&amp; dy &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            scrolledDistance += dy;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//UP</span></span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            view.onShow();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//DOWN</span></span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            controlsVisible = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            view.onPause();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p><a id=\"more\"></a>\n<ul>\n<li><p>我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((controlsVisible &amp;&amp; dy &lt; <span class=\"number\">0</span>) || (!controlsVisible &amp;&amp; dy &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    scrolledDistance += dy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//UP</span></span><br><span class=\"line\">    scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">    controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    view.onResume();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//DOWN</span></span><br><span class=\"line\">    scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">    controlsVisible = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    view.onPause();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>外部的View上滑显示, 下滑隐藏<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mOutsideOnScrollListener = <span class=\"keyword\">new</span> OnScrollListener() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScrollStateChanged</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE) &#123;</span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onScrolled</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((controlsVisible &amp;&amp; dy &lt; <span class=\"number\">0</span>) || (!controlsVisible &amp;&amp; dy &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            scrolledDistance += dy;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//UP</span></span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            view.onShow();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//DOWN</span></span><br><span class=\"line\">            scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            controlsVisible = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            view.onPause();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>","more":"\n<ul>\n<li><p>我们计算总的滚动距离（每一次滚动的总和）。但是，我们只关心View隐藏时的向上滑动或者View显示时的向下滑动，因为这些是我们所关心的情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((controlsVisible &amp;&amp; dy &lt; <span class=\"number\">0</span>) || (!controlsVisible &amp;&amp; dy &gt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">    scrolledDistance += dy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果当滚动值超过某个阈值（你可以设置阈值，值越大，需要滚动滚动更多的距离，才能看到显示/隐藏View的效果）。我们根据滚动的方向来显示/隐藏View（DY＞0意味着我们向下滚动，Dy＜0意味着我们向上滚动）。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (scrolledDistance &lt; thresholdToShow &amp;&amp; controlsVisible) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//UP</span></span><br><span class=\"line\">    scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">    controlsVisible = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    view.onResume();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (scrolledDistance &gt;= thresholdToHide &amp;&amp; !controlsVisible) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//DOWN</span></span><br><span class=\"line\">    scrolledDistance = <span class=\"number\">0</span>;</span><br><span class=\"line\">    controlsVisible = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    view.onPause();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ViewModel,LiveData和Lifecycle","date":"2019-12-21T12:19:41.000Z","_content":"\n# ViewModel、Lifecycles和LiveData\n## 1. ViewModel:\nViewModel是Google官方提供的组件，是用来处理和存放和UI相关的数据的，可以把UI和数据进行分离。但就这一点来说的话，其实没有必要一定使用Google提供的ViewModel组件，我们使用自定义的ViewModel类同样可以达到这样的效果。\n\n还有一个很重要的特性，我们都知道，在配置改变时，Activity会出现销毁重建，比如说横竖屏切换的时候。ViewModel的生命周期和Activity是不一样的，它不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，可以将和UI相关的数据存放在ViewModel中，这样，即使Activity销毁重建，页面上显示的数据也不会丢失。\n```java\npublic abstract class ViewModel {\n    // 在ViewModel销毁的时候做回收工作，主要是为了防止ViewModel的泄漏\n    protected void onCleared() {\n    }\n}\n```\n### ViewModel的创建和存储过程\n主要是要搞清楚上面说的：Activity销毁重建的时候，ViewModel是如何保持不重建的。\n注意，这里只是在Activity因为配置改变而销毁重建的情况下。还有一种情况是，App由前台进入后台，因为内存紧张，Activity被系统销毁。这种情况下，ViewModel是无法保存数据的。\n\n以下全都以Activity举例，Fragment也是一样的\n在Activity中获取ViewModel：\n```java\nviewModel = ViewModelProviders.of(this).get(XxxViewModel.class);\n```\nViewModelProviders#of\n```java\n@NonNull\n@MainThread\npublic static ViewModelProvider of(@NonNull FragmentActivity activity,\n        @Nullable Factory factory) {\n    Application application = checkApplication(activity);\n    if (factory == null) {\n        // 使用默认的工厂类\n        // 如果想要在ViewModel的构造方法里传参，需要自定义factory类\n        factory = ViewModelProvider.AndroidViewModelFactory\n                                    .getInstance(application);\n    }\n    return new ViewModelProvider(ViewModelStores.of(activity), factory);\n}\n```\nviewModelProvider#get\n```java\n// 从ViewModelStore中获取ViewModel，没有则创建\npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {\n    ViewModel viewModel = mViewModelStore.get(key);\n    if (modelClass.isInstance(viewModel)) {\n        return (T) viewModel;\n    } else {\n        ...\n    }\n    viewModel = mFactory.create(modelClass);\n    mViewModelStore.put(key, viewModel);\n    return (T) viewModel;\n}\n\npublic class ViewModelStore {\n    // ViewModel的集合，key是由ViewModel类名构成的字符串\n    private final HashMap<String, ViewModel> mMap = new HashMap<>();\n    ...\n}\n```\nViewModelStore中存储了一个Activity/Fragment的所有ViewModel。那现在问题就转变成了探究ViewModelStore的获取和存储的过程\n\nViewModelStores#of\n```java\npublic static ViewModelStore of(@NonNull FragmentActivity activity) {\n    if (activity instanceof ViewModelStoreOwner) {\n        return ((ViewModelStoreOwner) activity).getViewModelStore();\n    }\n    return holderFragmentFor(activity).getViewModelStore();\n}\n```\n这里先判断FragmentActivity是否实现了ViewModelStoreOwner接口。不同的依赖包，实现有可能是不一样的。高版本的support-v4和androidx中的Fragment和FragmentActivity都实现了这个接口。\n```java\npublic interface ViewModelStoreOwner {\n    @NonNull\n    ViewModelStore getViewModelStore();\n}\n```\n#### 实现了ViewModelStoreOwner接口\n\nFragmentActivity\n```java\npublic class FragmentActivity extends SupportActivity implements ViewModelStoreOwner, ...{\n    private ViewModelStore mViewModelStore;\n        \n    public ViewModelStore getViewModelStore() {\n        ...\n    }\n}\n```\n\n实现了ViewModelStoreOwner接口的FragmentActivity会直接持有ViewModelStore的引用\n\n主要关注三个方法：\ngetViewModelStore()\nonCreate()\nonRetainNonConfigurationInstance()\n\n```java\npublic ViewModelStore getViewModelStore() {\n    if (this.getApplication() == null) {\n       ...\n    } else {\n        if (this.mViewModelStore == null) {\n            FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances) this.getLastNonConfigurationInstance();\n            if (nc != null) {\n                this.mViewModelStore = nc.viewModelStore;\n            }\n\n            if (this.mViewModelStore == null) {\n                this.mViewModelStore = new ViewModelStore();\n            }\n        }\n\n        return this.mViewModelStore;\n    }\n}\n\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    ...\n    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)this.getLastNonConfigurationInstance();\n    if (nc != null && nc.viewModelStore != null && this.mViewModelStore == null)\n    {\n        this.mViewModelStore = nc.viewModelStore;\n    }\n    ...\n}\n// 在页面销毁时，保存ViewModelStore\npublic final Object onRetainNonConfigurationInstance() {\n     Object custom = onRetainCustomNonConfigurationInstance();\n     ViewModelStore viewModelStore = mViewModelStore;\n     if (viewModelStore == null) {\n         // 如果NonConfigurationInstance保存了viewModelStore，把它取出来\n        NonConfigurationInstances nc = getLastNonConfigurationInstance();\n        if (nc != null) {\n            viewModelStore = nc.viewModelStore;\n          }\n       }\n     if (viewModelStore == null && custom == null) {\n          return null;\n       }\n      NonConfigurationInstances nci = new NonConfigurationInstances();\n      nci.custom = custom; \n      //把viewModelStore放到NonConfigurationInstances中并返回\n      nci.viewModelStore = viewModelStore;\n      //这样当页面被重建而销毁时ViewModelStore就被保存起来了。\n      return nci;\n}\n```\n\nViewModelStore在onCreate里会从NonConfigurationInstances里尝试取出，然后在onRetainNonConfigurationInstanc方法中保存到NonConfigurationInstances。\nonRetainNonConfigurationInstance何时被调用，数据又是怎样保存的呢？了解过Activity启动流程的都知道ActivityThread，它控制着Activity的生命周期，当ActivityThread执行performDestroyActivity这个方法时，会调用Activity#retainNonConfigurationInstances获取到保存的数据并保存到ActivityClientRecord中。\n\n```java\nActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) {\n   ...\n   ActivityClientRecord r = mActivities.get(token);\n   // 由于状态改变的destroy，这里会为true\n   if (getNonConfigInstance) {\n       //保存retainNonConfigurationInstances中的数据到ActivityClientRecord中\n       r.lastNonConfigurationInstances = r.activity\n                                          .retainNonConfigurationInstances();\n   } \n   ...\n   return r;\n}\n```\n\n当页面重建完成,ActivityThread执行了performLaunchActivity方法时，会调用Activity的attach方法,便会把刚刚存储的数据，传递进去。\n\n```java\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    activity.attach(......, r.lastNonConfigurationInstances,.....);\n    ...\n}\n```\n\n总结：Activity对应的ViewModel保存在ViewModelStore里，FragmentActivity持有ViewModelStore的引用，Activity因配置原因销毁-重建时，ViewModelStore被NonConfigurationInstances保存，重建时从保存处恢复。\n\n#### 未实现ViewModelStoreOwner接口\n\n低版本未实现ViewModelStoreOwner接口，采取的方法是在Activity中注入一个不可见的HolderFragment\n\n```java\npublic static ViewModelStore of(@NonNull FragmentActivity activity) {\n    if (activity instanceof ViewModelStoreOwner) {\n        return ((ViewModelStoreOwner) activity).getViewModelStore();\n    }\n    return holderFragmentFor(activity).getViewModelStore();\n}\n```\n\nHolderFragment:\n\n```java\npublic class HolderFragment extends Fragment implements ViewModelStoreOwner { \n    private static final HolderFragmentManager sHolderFragmentManager = new HolderFragmentManager();\n    \n    private ViewModelStore mViewModelStore = new ViewModelStore();\n    \n    public HolderFragment() {\n        setRetainInstance(true);\n    }\n \n    public static HolderFragment holderFragmentFor(FragmentActivity activity) {\n        // 在activity中插入HolderFragment\n        return sHolderFragmentManager.holderFragmentFor(activity);\n    }\n}\n```\n\nHolderFragment持有mViewModelStore的引用。在HolderFragment的构造方法中，调用了`setRetainInstance(true)`。\n控制一个fragment实例是否在activity因为配置改变而销毁重建的时候被保留。如果设置为true, fragment在activity销毁重建的时候将会被保留。同时，fragment的生命周期将会发生改变，当Activity销毁重建时，fragment生命周期中的onCreate和onDestroy将不会被执行。\n\n总结：HolderFragment实现了ViewModelStoreOwner接口，持有mViewModelStore的引用。由于Fragment和activity的生命周期是绑定的，Fragment内部可以感知到activity的生命周期。同时，通过setRetainInstance(true)，当activity被销毁重建的时候，HolderFragment并不会被销毁，导致mViewModelStore也不会被销毁\nViewModel的销毁：\n\nFragmentActivity#onDestroy\n```java\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    if (this.mViewModelStore != null && !this.isChangingConfigurations()) {\n        //当activity由于非config改变而销毁时清空mViewModelStore\n        this.mViewModelStore.clear();\n    }\n\n    this.mFragments.dispatchDestroy();\n}\n```\n\nHolderFragment#onDestroy\n```java\n@Override\npublic void onDestroy() {\n    super.onDestroy();\n    mViewModelStore.clear();\n}\n```\n\nViewModelStore#clear()\n```java\npublic final void clear() {\n    for (ViewModel vm : mMap.values()) {\n        vm.onCleared();\n    }\n    mMap.clear();\n}\n```\n\n### ViewModel实现更进一步的数据持久化\n\n上面的是 activity 在因为配置改变，销毁重建的情况，在这种情况下，ViewModel 可以自动实现数据保留和现场恢复。\n还有一种情况是，App进入后台，然后因为内存紧张，activity 被系统销毁，然后用户再次打开，activity重建。这种情况下，ViewModel默认是不能实现现场恢复的，需要借助 SavedStateHandle。\n可以简单的把 SavedStateHandle 理解为 onSaveInstanceState()的逻辑从 activity 转移到了ViewModel 中。\n\n要想使用 SavedStateHandle 需要额外导入包：\n```\nimplementation 'androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-alpha01'\n```\n\n然后在获取ViewModel时使用 SavedStateViewModelFactory\n```java\nviewModel = ViewModelProviders.of(this, \n                    new SavedStateViewModelFactory(getApplication(), this))\n                    .get(SaveStateTestViewModel.class);\n```\n\n然后在ViewModel的构造方法里传入SavedStateHandle实例，然后就可以通过SavedStateHandle保存和读取数据了。\n\n```java\npublic class SaveStateTestViewModel extends ViewModel {\n    private SavedStateHandle savedStateHandle;\n    private final MutableLiveData<String> notifyLiveData;\n\n    public SaveStateTestViewModel(SavedStateHandle handle) {\n        this.savedStateHandle = handle;\n        this.notifyLiveData = savedStateHandle.getLiveData(\"key\");\n    }\n\n    public void save(int data){\n        savedStateHandle.set(\"key2\", data);\n    }\n\n    public void setData(String data) {\n        this.notifyLiveData.setValue(data);\n    }\n\n    public MutableLiveData<String> getNotifyLiveData(){\n        return notifyLiveData;\n    }\n}\n```\n\n和 onSaveInstanceState() 的保存和恢复方式一样，不能保存复杂的数据，只能保存可以存入Bundle的那些类型。 也可以SavedStateHandle中使用LiveData的方式进行保存，这样的话稍微有那么一点的好处是你不需要特意的save和get数据，直接把在初始化的时候替换成SavedStateHandle#getLiveData就可以了\n\n## 2. Lifecycles\n\nLifecycles组件是为了方便感知Activity和Fragment的生命周期而出现的，它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。\nLifecycle包含在support library 26.1.0及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。support library在26.1.0之前，需要我们引入另外的包。\n\nlifecycle 组件包括 Lifecycle, LifecycleOwner, LifecycleObserver 三个主要类：\n  - Lifecycle 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。\n  - LifecycleOwner 仅有一个 getLifecycle() 方法，用于返回当前对象的 Lifecycle。\n  - LifecycleObserver，代表观察者\n\n```java\nLifecyclerOwner和LifecycleObserver\npublic interface LifecycleOwner {\n    Lifecycle getLifecycle();\n}\n\npublic interface LifecycleObserver {\n}\n```\n\nLifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口，是被观察者。\nLifecycleOwner#getLifecycle()返回Lifecycle实例. 这是一种解耦实现, LifecycleOwner不包含任何有关生命周期管理的逻辑, 实际的逻辑都在Lifecycle实例中, 我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏。\n并不是所有的google官方的Activity和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有FragmentActivity，AppCompatActivity和v4包下的Fragment。\nLifecycleObserver接口代表生命周期的观察者，它的实现为空。实现LifecycleObserver的类要想感知到生命周期的变化需要借助额外的注解。或者，也可以使用一些继承了LifecycleObserver的子接口。\n\n```java\npublic class MyObserver implements LifecycleObserver {     \n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)    \n    public voidactivityResume() {\n    } \n}\n```\n\n### Lifecycle中的state和event\n\n```java\npublic enum State {\n    DESTROYED,\n    INITIALIZED,\n    CREATED,\n    STARTED,\n    RESUMED;\n    public boolean isAtLeast(@NonNull State state) {\n        return compareTo(state) >= 0;\n    }\n}\n\npublic enum Event {\n    ON_CREATE,\n    ON_START,\n    ON_RESUME,\n    ON_PAUSE,\n    ON_STOP,\n    ON_DESTROY,\n    ON_ANY // ON_ANY代表任意时间\n}\n```\n\n### Lifecycle的获取生命周期的变化\n\n```java\npublic class SupportActivity extends Activity implements LifecycleOwner, Component {\n    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\n    \n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ReportFragment.injectIfNeededIn(this);\n    }\n\n    protected void onSaveInstanceState(Bundle outState) {\n        this.mLifecycleRegistry.markState(State.CREATED);\n        super.onSaveInstanceState(outState);\n    }\n\n    public Lifecycle getLifecycle() {\n        return this.mLifecycleRegistry;\n    }\n}\n```\n\nLifecycleRegistry继承了Lifecycle。SupportActivity是FragmentActivity的父类。在SupportActivity中找不到state和event分发相关的代码，这些相关内容是在ReportFragment中实现的。\n\n```java\npublic class ReportFragment extends Fragment {\n    public static void injectIfNeededIn(Activity activity) {\n        android.app.FragmentManager manager = activity.getFragmentManager();\n        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();\n\n            manager.executePendingTransactions();\n        }\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        dispatchStart(mProcessListener);\n        dispatch(Lifecycle.Event.ON_START);\n    }\n    \n    private void dispatch(Lifecycle.Event event) {\n        Activity activity = getActivity();\n        ...\n        if (activity instanceof LifecycleOwner) {\n            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\n            if (lifecycle instanceof LifecycleRegistry) {\n                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\n            }\n        }\n    }\n    ...\n}\n```\n### LifecycleRegistry#addObserver\n\nLifecycleRegistry继承了Lifecycle，是Activity和Fragment生命周期的真正管理类。 这个类里面的很多逻辑有点绕，我不太能理清楚。主要看一下addObserver这个方法：\n\n```java\npublic class LifecycleRegistry extends Lifecycle {\n\n    private FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap = new FastSafeIterableMap<>();\n    private final WeakReference<LifecycleOwner> mLifecycleOwner;\n    // 当前的state\n    private State mState;\n\n    @Override\n    public void addObserver(@NonNull LifecycleObserver observer) {\n        // observer的state初始化为DESTROYED或者INITIALIZED\n        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n    \n        if (previous != null) {\n            return;\n        }\n        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n        if (lifecycleOwner == null) {\n            // it is null we should be destroyed. Fallback quickly\n            return;\n        }\n    \n        boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;\n        // 得到一个目标state\n        State targetState = calculateTargetState(observer);\n        mAddingObserverCounter++;\n        // 当observer被add进来的时候，会进入循环，分发事件，直到observer的state==targetState\n        while ((statefulObserver.mState.compareTo(targetState) < 0\n                && mObserverMap.contains(observer))) {\n            pushParentState(statefulObserver.mState);\n            // 这里的upEvent(state)会导致statefulObserver.mState在分发的过程中不断更新\n            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\n            popParentState();\n            // mState / subling may have been changed recalculate\n            targetState = calculateTargetState(observer);\n        }\n    \n        if (!isReentrance) {\n            // we do sync only on the top level.\n            sync();\n        }\n        mAddingObserverCounter--;\n    }\n\n    private State calculateTargetState(LifecycleObserver observer) {\n        // 这里的previous指前一个加入进来的Observer\n        Entry<LifecycleObserver, ObserverWithState> previous = mObserverMap.ceil(observer);\n    \n        State siblingState = previous != null ? previous.getValue().mState : null;\n        // 这个mParentStates不知道是啥。。。\n        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)\n                : null;\n        // 这里的min(x, y)是 返回在枚举中order最小的state\n        return min(min(mState, siblingState), parentState);\n    }\n    ...\n}\n```\n\n在addObserver中，ObserverWithState将state和observer包装一下，ObserverWithState内初始的state是DESTROYED或者INITIALIZED。之后会计算一个targetState，在while循环中会不断的分发和更新event。\n\n具体效果看下面的demo：\n\n```java\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    ...\n    handler.postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            TestActivity.this.getLifecycle().addObserver(new GenericLifecycleObserver() {\n                @Override\n                public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {\n                    Log.i(\"chenlei\", \"onStateChanged: \" + event);\n                }\n            });\n        }\n    }, 5000);\n}\n```\n\n这里的GenericLifecycleObserver继承了LifecycleObserver的接口。demo中在create方法里延时5s添加一个LifecycleObserver并打印event。最后打印输出如下：\n\n可以看到从ON_CREATE到ON_RESUME在同一时刻都打印出来了\n\n### ProcessLifecycleOwner\n\nProcessLifecycleOwner实现了LifecycleOwner接口，可以监听当前应用前后台切换，并对此进行响应。\n这个类提供整个应用进程的生命周期。\n你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，Lifecycle.Event.ON_CREATE 事件只会分发一次，而 Lifecycle.Event.ON_DESTROY 永远不被分发。其他事件的分发遵守以下规则：\nProcessLifecycleOwner 会在第一个 Activity 经历 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 事件 延迟一段时间 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。\n这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。\n使用的时候，在Application中添加LifecycleObserver就可以了(实际上，在应用进程中的任意位置都可以）\n\n```java\nclass ApplicationObserver(val analytics: Analytics) : LifecycleObserver {\n    \n    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n    fun onBackground() {    }   \n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onForeground() {    }\n}\n\npublic class MyApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        ProcessLifecycleOwner.get().getLifecycle().addObserver(new ApplicationObserver());\n    }\n}\n```\n\n原理：\n\nProcessLifecycleOwnerInitializer\n```java\npublic class ProcessLifecycleOwnerInitializer extends ContentProvider {\n    @Override\n    public boolean onCreate() {\n        LifecycleDispatcher.init(getContext());\n        ProcessLifecycleOwner.init(getContext());\n        return true;\n    }\n    ...\n}\n```\n\n这个类是ProcessLifecycleOwner初始化的地方，它继承了一个ContentProvider ，这个ContentProvider声明在了Lifecycle包的AndroidManifest.xml里。\n\n这个AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。\n这里利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application 的 onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建。\n\nLifecycleDispatcher#init\n```java\nclass LifecycleDispatcher {\n\n    private static AtomicBoolean sInitialized = new AtomicBoolean(false);\n\n    static void init(Context context) {\n        if (sInitialized.getAndSet(true)) {\n            return;\n        }\n        ((Application) context.getApplicationContext())\n                .registerActivityLifecycleCallbacks(new DispatcherActivityCallback());\n    }\n\n    static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            ReportFragment.injectIfNeededIn(activity);\n        }\n        ...\n    }\n}\n```\n\n在Application中注册一个ActivityLifecycleCallbacks，在ActivityLifecycleCallbacks中有Activity所有生命周期的回调，这样就能监听到每一个Activity的创建和销毁。在onActivityCreated回调中往Activity注入一个了ReportFragment，我没看出来这里的ReportFragment的作用是什么。。\n\nProcessLifecycleOwner\n\n```java\npublic class ProcessLifecycleOwner implements LifecycleOwner {\n    private final LifecycleRegistry mRegistry = new LifecycleRegistry(this);\n    private static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner();\n    static void init(Context context) {\n        sInstance.attach(context);\n    }\n\n    private ActivityInitializationListener mInitializationListener =\n        new ActivityInitializationListener() {\n            @Override\n            public void onCreate() {\n            }\n\n            @Override\n            public void onStart() {\n                activityStarted();\n            }\n\n            @Override\n            public void onResume() {\n                activityResumed();\n            }\n        };\n\n    void attach(Context context) {\n        mHandler = new Handler();\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);\n        Application app = (Application) context.getApplicationContext();\n        app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() {\n            @Override\n            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            //在ReportFragment的生命周期中会有dispatchXxxx(mProcessListener)\n                ReportFragment.get(activity)\n                                .setProcessListener(mInitializationListener);\n            }\n    \n            @Override\n            public void onActivityPaused(Activity activity) {\n                activityPaused();\n            }\n    \n            @Override\n            public void onActivityStopped(Activity activity) {\n                activityStopped();\n            }\n        });\n    }\n\n    void activityResumed() {\n        mResumedCounter++;\n        if (mResumedCounter == 1) {\n            if (mPauseSent) {\n                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);\n                mPauseSent = false;\n            } else {\n                mHandler.removeCallbacks(mDelayedPauseRunnable);\n            }\n        }\n    }\n\n    void activityPaused() {\n        mResumedCounter--;\n        if (mResumedCounter == 0) {\n            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);\n        }\n    }\n    // 在mDelayedPauseRunnable中会调用这个方法\n    private void dispatchPauseIfNeeded() {\n        if (mResumedCounter == 0) {\n            mPauseSent = true;\n            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);\n        }\n    }\n    ...\n}\n```\n\n## 2. LiveData\nViewModel和Lifecycles分别代表数据和UI两端，这两个组件是相对比较独立的，并没有太多直接的关系。为了防止内存泄漏，ViewModel不能直接持有activity和fragment的引用。为了让更好的结合ViewModel和Lifecycles，就需要LiveData。\nLiveData是一种观察者模式, 在 Value发生变化时通知之前注册的所有观察者。同时，借助于Lifecycles，LiveData具有生命周期的感知能力。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。使用LiveData有以下的优点：\n- LiveData 只会将消息通知给活跃的观察者，非活跃观察者将不会收到消息通知。\n- 当非活跃观察者状态变为活跃的时候，LiveData会将自动将最新的消息发送给它。\n- 当相应的 Lifecycle 对象的状态变为 DESTROYED 时，LiveData会自动的移除此观察者，这样就不用担心Fragment和Activity的内存泄漏。\n- LiveData的数据发送和Observer的添加是没有顺序限制的。比如说LiveData在第1s发送消息，然后在第5s添加Observer，Observer依然能够立即接收到第1s发送出的数据，只要数据是当前最新的。这主要和LifecycleRegistry#addObserver的实现有关\n\n### 2.1 LiveData的使用\n\n#### 2.1.1 基本使用\n\n```java\n public class NameViewModel extends ViewModel {\n    private MutableLiveData<String> notifyCurrentName = new MutableLiveData<>();\n\n    private void post(){\n        notifyCurrentName.postValue(\"value\");    \n    }\n    \n    public MutableLiveData<String> getNotifyCurrentName(){\n        return notifyCurrentName;\n    }\n}\n\n// 在activity or fragment中\n// public void observe(LifecycleOwner owner, Observer<T> observer) \ngetViewModel().getNotifyCurrentName().observer(this, new Observer<String>() {\n    @Override\n    public void onChanged(@Nullable Stirng value) {\n        ...\n    }\n}\n\n// 如果不想让LiveData感知到生命周期，可以用observeForever(Observer<T> observer)\ngetViewModel().getNotifyCurrentName().observeForever(new Observer<String>() {\n    @Override\n    public void onChanged(@Nullable Stirng value) {\n        ...\n    }\n}\n```\n\n#### 2.1.2 Transformations#map\nTransformations是用来做LiveData转换的类。\nTransformations#map可以在消息分派给观察者之前对消息进行更改。\n\n```java\nLiveData<User> userLiveData = ...;\nLiveData<String> userName = Transformations.map(userLiveData, user -> {\n    user.name + \" \" + user.lastName\n});\n```\n\n#### 2.1.3 Transformations#switchMap\nswitchMap可以实现LiveData的转换，下面是一个demo，通过switchMap切换LiveData的数据源\n\n```java\npublic class MapTestViewModel extends ViewModel {\n    private MutableLiveData<String> dataSourceA = new MutableLiveData<>();\n    private MutableLiveData<String> dataSourceB = new MutableLiveData<>();\n\n    private MutableLiveData<Boolean> changeDataSource = new MutableLiveData<>();\n\n    private LiveData<String> notifyData = Transformations.switchMap(changeDataSource, new Function<Boolean, LiveData<String>>() {\n        @Override\n        public LiveData<String> apply(Boolean input) {\n            return input ? dataSourceA : dataSourceB;\n        }\n    });\n\n    public void start(Activity activity) {\n        changeDataSource.setValue(true);\n\n        Handler handler = new Handler(activity.getMainLooper());\n        handler.postDelayed(() -> {\n            dataSourceA.postValue(\"data from source A\");\n            dataSourceB.postValue(\"data from source B\");\n        }, 2000);\n        \n        handler.postDelayed(() -> {\n            changeDataSource(false);\n        }, 10000);\n    }\n\n    public void changeDataSource(boolean userA) {\n        changeDataSource.setValue(userA);\n    }\n\n    public LiveData<String> getNotifyData() {\n        return notifyData;\n    }\n}\n\n// activity\nviewModel.start(this);\nviewModel.getNotifyData().observe(MapTestActivity.this, new Observer<String>() {\n    @Override\n    public void onChanged(String s) {\n        Log.i(\"chenlei\", \"onChanged: \" + s);\n    }\n});\n```\n            \n上面的demo中，延时2s同时向dataSourceA和dataSourceB发送数据，并延时10s将数据源从A指向B。在observe中打印结果，最终dataSourceA和dataSourceB在间隔一段时间之后都能打印出来。\n每次调用changeDataSource.setValue(Boolean)，都会调用Function#apply返回一个LiveData，并将notifyData的 Observer 添加到新的LiveData上\n\n### 2.2 LiveData的原理\n\n#### 2.2.1 LiveData\n\n```java\npublic abstract class LiveData<T> {\n    // 存放Observer的集合\n    private SafeIterableMap<Observer<T>, ObserverWrapper> mObservers =                                                                 new SafeIterableMap<>();\n\n    static final int START_VERSION = -1;\n    private int mActiveCount = 0;\n    private int mVersion = START_VERSION;\n\n    ...\n    // 当LiveData的活跃Observer数量由0变成1的时候调用\n    protected void onActive() {}\n    // 当LiveData的活跃Observer数量由1变成0的时候调用\n    protected void onInactive() {}\n\n    ...\n\n    private abstract class ObserverWrapper {\n        final Observer<T> mObserver;\n        boolean mActive;\n        int mLastVersion = START_VERSION;\n    \n        ObserverWrapper(Observer<T> observer) {\n            mObserver = observer;\n        }\n    \n        abstract boolean shouldBeActive();\n    \n        boolean isAttachedTo(LifecycleOwner owner) {\n            return false;\n        }\n    \n        void detachObserver() {\n        }\n    \n        void activeStateChanged(boolean newActive) {\n            // 活跃状态没有改变则return， 防止重复发送消息\n            if (newActive == mActive) {\n                return;\n            }\n            mActive = newActive;\n            boolean wasInactive = LiveData.this.mActiveCount == 0;\n            LiveData.this.mActiveCount += mActive ? 1 : -1;\n            if (wasInactive && mActive) {\n                onActive();\n            }\n            if (LiveData.this.mActiveCount == 0 && !mActive) {\n                onInactive();\n            }\n            if (mActive) {\n                // 开始分发value\n                dispatchingValue(this);\n            }\n        }\n    }\n    ...\n}\n```\n\n#### 2.2.2 LiveData#observer\n\n```java\npublic abstract class LiveData<T> {    \n    ...\n    @MainThread\n    public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<T> observer) {\n        if (owner.getLifecycle().getCurrentState() == DESTROYED) {\n            return;\n        }\n        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        ...\n        if (existing != null) {\n            return;\n        }\n        // 将wrapper将入到lifecycleOwner的生命周期的监听中\n        owner.getLifecycle().addObserver(wrapper);\n    }\n    ...\n}\n```\n\nLifecycleBoundObserver继承自ObserverWrapper，并且实现了\n\n```java\nGenericLifecycleObserver接口。GenericLifecycleObserver接口继承自LifecycleObserver接口\npublic interface GenericLifecycleObserver extends LifecycleObserver {\n    void onStateChanged(LifecycleOwner source, Lifecycle.Event event);\n}\n```\n\n```java\nclass LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {\n    @NonNull final LifecycleOwner mOwner;\n\n    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<T> observer)\n    {\n        super(observer);\n        mOwner = owner;\n    }\n\n    @Override\n    boolean shouldBeActive() {\n        // 通过Lifecycle判断当前Observer是否活跃\n        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);\n    }\n\n    // GenericLifecycleObserver#onStatechanged\n    @Override\n    public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {\n        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n            // 当LifecycleOwner已经被销毁，remove这个Observer。\n            // removeObserver会调用detachObserver()和activeStateChanged(false)\n            // 这也是为什么LiveData可以自动防止UI泄漏的原因\n            removeObserver(mObserver);\n            return;\n        }\n        activeStateChanged(shouldBeActive());\n    }\n\n    @Override\n    boolean isAttachedTo(LifecycleOwner owner) {\n        return mOwner == owner;\n    }\n\n    @Override\n    void detachObserver() {\n        // 从LifecycleOwner中remove观察者\n        mOwner.getLifecycle().removeObserver(this);\n    }\n}\n```\n\nLiveData#observeForever\n\n```java\n@MainThread\npublic void observeForever(@NonNull Observer<T> observer) {\n    AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n    ...\n    if (existing != null) {\n        return;\n    }\n    // 因为observeForever没有LifecycleOwner，为了保持和普通observe方法的特性一致，在添加observe之后立刻检查是否有数据可以发送，\n    wrapper.activeStateChanged(true);\n}\n\nprivate class AlwaysActiveObserver extends ObserverWrapper {\n    AlwaysActiveObserver(Observer<T> observer) {\n        super(observer);\n    }\n\n    @Override\n    boolean shouldBeActive() {\n        return true;\n    }\n}\n```\n\n#### 2.2.3 LiveData#postValue()\nLiveData发送消息使用setValue或者postValue方法。其中setValue只能在主线程中使用，postValue发送消息时会自动切换到主线程。\n\n```java\npublic abstract class LiveData<T> {\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            ...\n            setValue((T) newValue);\n        }\n    };\n\n    ... \n    protected void postValue(T value) {\n        ...\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n    ...\n}\nLiveData#setValue\n@MainThread\nprotected void setValue(T value) {\n    assertMainThread(\"setValue\");\n    mVersion++;\n    mData = value;\n    dispatchingValue(null);\n}\n\nprivate void dispatchingValue(@Nullable ObserverWrapper initiator) {\n    if (mDispatchingValue) {\n        mDispatchInvalidated = true;\n        return;\n    }\n    mDispatchingValue = true;\n    do {\n        mDispatchInvalidated = false;\n        if (initiator != null) {\n            // 向特定的Observer发送数据\n            considerNotify(initiator);\n            initiator = null;\n        } else {\n            // 向所有Observer发送消息\n            for (Iterator<Map.Entry<Observer<T>, ObserverWrapper>> iterator =\n                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                considerNotify(iterator.next().getValue());\n                if (mDispatchInvalidated) {\n                    break;\n                }\n            }\n        }\n    } while (mDispatchInvalidated);\n    mDispatchingValue = false;\n}\n\nprivate void considerNotify(ObserverWrapper observer) {\n    if (!observer.mActive) {\n        return;\n    }\n    if (!observer.shouldBeActive()) {\n        observer.activeStateChanged(false);\n        return;\n    }\n    if (observer.mLastVersion >= mVersion) {\n        // 将要发送的是旧版本，扔掉\n        return;\n    }\n    observer.mLastVersion = mVersion;\n    observer.mObserver.onChanged((T) mData);\n}\n```\n","source":"_posts/Android/ViewModel-LiveData和LifeCricle.md","raw":"---\ntitle: 'ViewModel,LiveData和Lifecycle'\ndate: 2019-12-21 20:19:41\ntags:\n- ViewModel\n---\n\n# ViewModel、Lifecycles和LiveData\n## 1. ViewModel:\nViewModel是Google官方提供的组件，是用来处理和存放和UI相关的数据的，可以把UI和数据进行分离。但就这一点来说的话，其实没有必要一定使用Google提供的ViewModel组件，我们使用自定义的ViewModel类同样可以达到这样的效果。\n\n还有一个很重要的特性，我们都知道，在配置改变时，Activity会出现销毁重建，比如说横竖屏切换的时候。ViewModel的生命周期和Activity是不一样的，它不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，可以将和UI相关的数据存放在ViewModel中，这样，即使Activity销毁重建，页面上显示的数据也不会丢失。\n```java\npublic abstract class ViewModel {\n    // 在ViewModel销毁的时候做回收工作，主要是为了防止ViewModel的泄漏\n    protected void onCleared() {\n    }\n}\n```\n### ViewModel的创建和存储过程\n主要是要搞清楚上面说的：Activity销毁重建的时候，ViewModel是如何保持不重建的。\n注意，这里只是在Activity因为配置改变而销毁重建的情况下。还有一种情况是，App由前台进入后台，因为内存紧张，Activity被系统销毁。这种情况下，ViewModel是无法保存数据的。\n\n以下全都以Activity举例，Fragment也是一样的\n在Activity中获取ViewModel：\n```java\nviewModel = ViewModelProviders.of(this).get(XxxViewModel.class);\n```\nViewModelProviders#of\n```java\n@NonNull\n@MainThread\npublic static ViewModelProvider of(@NonNull FragmentActivity activity,\n        @Nullable Factory factory) {\n    Application application = checkApplication(activity);\n    if (factory == null) {\n        // 使用默认的工厂类\n        // 如果想要在ViewModel的构造方法里传参，需要自定义factory类\n        factory = ViewModelProvider.AndroidViewModelFactory\n                                    .getInstance(application);\n    }\n    return new ViewModelProvider(ViewModelStores.of(activity), factory);\n}\n```\nviewModelProvider#get\n```java\n// 从ViewModelStore中获取ViewModel，没有则创建\npublic <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {\n    ViewModel viewModel = mViewModelStore.get(key);\n    if (modelClass.isInstance(viewModel)) {\n        return (T) viewModel;\n    } else {\n        ...\n    }\n    viewModel = mFactory.create(modelClass);\n    mViewModelStore.put(key, viewModel);\n    return (T) viewModel;\n}\n\npublic class ViewModelStore {\n    // ViewModel的集合，key是由ViewModel类名构成的字符串\n    private final HashMap<String, ViewModel> mMap = new HashMap<>();\n    ...\n}\n```\nViewModelStore中存储了一个Activity/Fragment的所有ViewModel。那现在问题就转变成了探究ViewModelStore的获取和存储的过程\n\nViewModelStores#of\n```java\npublic static ViewModelStore of(@NonNull FragmentActivity activity) {\n    if (activity instanceof ViewModelStoreOwner) {\n        return ((ViewModelStoreOwner) activity).getViewModelStore();\n    }\n    return holderFragmentFor(activity).getViewModelStore();\n}\n```\n这里先判断FragmentActivity是否实现了ViewModelStoreOwner接口。不同的依赖包，实现有可能是不一样的。高版本的support-v4和androidx中的Fragment和FragmentActivity都实现了这个接口。\n```java\npublic interface ViewModelStoreOwner {\n    @NonNull\n    ViewModelStore getViewModelStore();\n}\n```\n#### 实现了ViewModelStoreOwner接口\n\nFragmentActivity\n```java\npublic class FragmentActivity extends SupportActivity implements ViewModelStoreOwner, ...{\n    private ViewModelStore mViewModelStore;\n        \n    public ViewModelStore getViewModelStore() {\n        ...\n    }\n}\n```\n\n实现了ViewModelStoreOwner接口的FragmentActivity会直接持有ViewModelStore的引用\n\n主要关注三个方法：\ngetViewModelStore()\nonCreate()\nonRetainNonConfigurationInstance()\n\n```java\npublic ViewModelStore getViewModelStore() {\n    if (this.getApplication() == null) {\n       ...\n    } else {\n        if (this.mViewModelStore == null) {\n            FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances) this.getLastNonConfigurationInstance();\n            if (nc != null) {\n                this.mViewModelStore = nc.viewModelStore;\n            }\n\n            if (this.mViewModelStore == null) {\n                this.mViewModelStore = new ViewModelStore();\n            }\n        }\n\n        return this.mViewModelStore;\n    }\n}\n\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    ...\n    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)this.getLastNonConfigurationInstance();\n    if (nc != null && nc.viewModelStore != null && this.mViewModelStore == null)\n    {\n        this.mViewModelStore = nc.viewModelStore;\n    }\n    ...\n}\n// 在页面销毁时，保存ViewModelStore\npublic final Object onRetainNonConfigurationInstance() {\n     Object custom = onRetainCustomNonConfigurationInstance();\n     ViewModelStore viewModelStore = mViewModelStore;\n     if (viewModelStore == null) {\n         // 如果NonConfigurationInstance保存了viewModelStore，把它取出来\n        NonConfigurationInstances nc = getLastNonConfigurationInstance();\n        if (nc != null) {\n            viewModelStore = nc.viewModelStore;\n          }\n       }\n     if (viewModelStore == null && custom == null) {\n          return null;\n       }\n      NonConfigurationInstances nci = new NonConfigurationInstances();\n      nci.custom = custom; \n      //把viewModelStore放到NonConfigurationInstances中并返回\n      nci.viewModelStore = viewModelStore;\n      //这样当页面被重建而销毁时ViewModelStore就被保存起来了。\n      return nci;\n}\n```\n\nViewModelStore在onCreate里会从NonConfigurationInstances里尝试取出，然后在onRetainNonConfigurationInstanc方法中保存到NonConfigurationInstances。\nonRetainNonConfigurationInstance何时被调用，数据又是怎样保存的呢？了解过Activity启动流程的都知道ActivityThread，它控制着Activity的生命周期，当ActivityThread执行performDestroyActivity这个方法时，会调用Activity#retainNonConfigurationInstances获取到保存的数据并保存到ActivityClientRecord中。\n\n```java\nActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) {\n   ...\n   ActivityClientRecord r = mActivities.get(token);\n   // 由于状态改变的destroy，这里会为true\n   if (getNonConfigInstance) {\n       //保存retainNonConfigurationInstances中的数据到ActivityClientRecord中\n       r.lastNonConfigurationInstances = r.activity\n                                          .retainNonConfigurationInstances();\n   } \n   ...\n   return r;\n}\n```\n\n当页面重建完成,ActivityThread执行了performLaunchActivity方法时，会调用Activity的attach方法,便会把刚刚存储的数据，传递进去。\n\n```java\nprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n    ...\n    activity.attach(......, r.lastNonConfigurationInstances,.....);\n    ...\n}\n```\n\n总结：Activity对应的ViewModel保存在ViewModelStore里，FragmentActivity持有ViewModelStore的引用，Activity因配置原因销毁-重建时，ViewModelStore被NonConfigurationInstances保存，重建时从保存处恢复。\n\n#### 未实现ViewModelStoreOwner接口\n\n低版本未实现ViewModelStoreOwner接口，采取的方法是在Activity中注入一个不可见的HolderFragment\n\n```java\npublic static ViewModelStore of(@NonNull FragmentActivity activity) {\n    if (activity instanceof ViewModelStoreOwner) {\n        return ((ViewModelStoreOwner) activity).getViewModelStore();\n    }\n    return holderFragmentFor(activity).getViewModelStore();\n}\n```\n\nHolderFragment:\n\n```java\npublic class HolderFragment extends Fragment implements ViewModelStoreOwner { \n    private static final HolderFragmentManager sHolderFragmentManager = new HolderFragmentManager();\n    \n    private ViewModelStore mViewModelStore = new ViewModelStore();\n    \n    public HolderFragment() {\n        setRetainInstance(true);\n    }\n \n    public static HolderFragment holderFragmentFor(FragmentActivity activity) {\n        // 在activity中插入HolderFragment\n        return sHolderFragmentManager.holderFragmentFor(activity);\n    }\n}\n```\n\nHolderFragment持有mViewModelStore的引用。在HolderFragment的构造方法中，调用了`setRetainInstance(true)`。\n控制一个fragment实例是否在activity因为配置改变而销毁重建的时候被保留。如果设置为true, fragment在activity销毁重建的时候将会被保留。同时，fragment的生命周期将会发生改变，当Activity销毁重建时，fragment生命周期中的onCreate和onDestroy将不会被执行。\n\n总结：HolderFragment实现了ViewModelStoreOwner接口，持有mViewModelStore的引用。由于Fragment和activity的生命周期是绑定的，Fragment内部可以感知到activity的生命周期。同时，通过setRetainInstance(true)，当activity被销毁重建的时候，HolderFragment并不会被销毁，导致mViewModelStore也不会被销毁\nViewModel的销毁：\n\nFragmentActivity#onDestroy\n```java\n@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    if (this.mViewModelStore != null && !this.isChangingConfigurations()) {\n        //当activity由于非config改变而销毁时清空mViewModelStore\n        this.mViewModelStore.clear();\n    }\n\n    this.mFragments.dispatchDestroy();\n}\n```\n\nHolderFragment#onDestroy\n```java\n@Override\npublic void onDestroy() {\n    super.onDestroy();\n    mViewModelStore.clear();\n}\n```\n\nViewModelStore#clear()\n```java\npublic final void clear() {\n    for (ViewModel vm : mMap.values()) {\n        vm.onCleared();\n    }\n    mMap.clear();\n}\n```\n\n### ViewModel实现更进一步的数据持久化\n\n上面的是 activity 在因为配置改变，销毁重建的情况，在这种情况下，ViewModel 可以自动实现数据保留和现场恢复。\n还有一种情况是，App进入后台，然后因为内存紧张，activity 被系统销毁，然后用户再次打开，activity重建。这种情况下，ViewModel默认是不能实现现场恢复的，需要借助 SavedStateHandle。\n可以简单的把 SavedStateHandle 理解为 onSaveInstanceState()的逻辑从 activity 转移到了ViewModel 中。\n\n要想使用 SavedStateHandle 需要额外导入包：\n```\nimplementation 'androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-alpha01'\n```\n\n然后在获取ViewModel时使用 SavedStateViewModelFactory\n```java\nviewModel = ViewModelProviders.of(this, \n                    new SavedStateViewModelFactory(getApplication(), this))\n                    .get(SaveStateTestViewModel.class);\n```\n\n然后在ViewModel的构造方法里传入SavedStateHandle实例，然后就可以通过SavedStateHandle保存和读取数据了。\n\n```java\npublic class SaveStateTestViewModel extends ViewModel {\n    private SavedStateHandle savedStateHandle;\n    private final MutableLiveData<String> notifyLiveData;\n\n    public SaveStateTestViewModel(SavedStateHandle handle) {\n        this.savedStateHandle = handle;\n        this.notifyLiveData = savedStateHandle.getLiveData(\"key\");\n    }\n\n    public void save(int data){\n        savedStateHandle.set(\"key2\", data);\n    }\n\n    public void setData(String data) {\n        this.notifyLiveData.setValue(data);\n    }\n\n    public MutableLiveData<String> getNotifyLiveData(){\n        return notifyLiveData;\n    }\n}\n```\n\n和 onSaveInstanceState() 的保存和恢复方式一样，不能保存复杂的数据，只能保存可以存入Bundle的那些类型。 也可以SavedStateHandle中使用LiveData的方式进行保存，这样的话稍微有那么一点的好处是你不需要特意的save和get数据，直接把在初始化的时候替换成SavedStateHandle#getLiveData就可以了\n\n## 2. Lifecycles\n\nLifecycles组件是为了方便感知Activity和Fragment的生命周期而出现的，它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。\nLifecycle包含在support library 26.1.0及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。support library在26.1.0之前，需要我们引入另外的包。\n\nlifecycle 组件包括 Lifecycle, LifecycleOwner, LifecycleObserver 三个主要类：\n  - Lifecycle 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。\n  - LifecycleOwner 仅有一个 getLifecycle() 方法，用于返回当前对象的 Lifecycle。\n  - LifecycleObserver，代表观察者\n\n```java\nLifecyclerOwner和LifecycleObserver\npublic interface LifecycleOwner {\n    Lifecycle getLifecycle();\n}\n\npublic interface LifecycleObserver {\n}\n```\n\nLifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口，是被观察者。\nLifecycleOwner#getLifecycle()返回Lifecycle实例. 这是一种解耦实现, LifecycleOwner不包含任何有关生命周期管理的逻辑, 实际的逻辑都在Lifecycle实例中, 我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏。\n并不是所有的google官方的Activity和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有FragmentActivity，AppCompatActivity和v4包下的Fragment。\nLifecycleObserver接口代表生命周期的观察者，它的实现为空。实现LifecycleObserver的类要想感知到生命周期的变化需要借助额外的注解。或者，也可以使用一些继承了LifecycleObserver的子接口。\n\n```java\npublic class MyObserver implements LifecycleObserver {     \n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)    \n    public voidactivityResume() {\n    } \n}\n```\n\n### Lifecycle中的state和event\n\n```java\npublic enum State {\n    DESTROYED,\n    INITIALIZED,\n    CREATED,\n    STARTED,\n    RESUMED;\n    public boolean isAtLeast(@NonNull State state) {\n        return compareTo(state) >= 0;\n    }\n}\n\npublic enum Event {\n    ON_CREATE,\n    ON_START,\n    ON_RESUME,\n    ON_PAUSE,\n    ON_STOP,\n    ON_DESTROY,\n    ON_ANY // ON_ANY代表任意时间\n}\n```\n\n### Lifecycle的获取生命周期的变化\n\n```java\npublic class SupportActivity extends Activity implements LifecycleOwner, Component {\n    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);\n    \n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        ReportFragment.injectIfNeededIn(this);\n    }\n\n    protected void onSaveInstanceState(Bundle outState) {\n        this.mLifecycleRegistry.markState(State.CREATED);\n        super.onSaveInstanceState(outState);\n    }\n\n    public Lifecycle getLifecycle() {\n        return this.mLifecycleRegistry;\n    }\n}\n```\n\nLifecycleRegistry继承了Lifecycle。SupportActivity是FragmentActivity的父类。在SupportActivity中找不到state和event分发相关的代码，这些相关内容是在ReportFragment中实现的。\n\n```java\npublic class ReportFragment extends Fragment {\n    public static void injectIfNeededIn(Activity activity) {\n        android.app.FragmentManager manager = activity.getFragmentManager();\n        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {\n            manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();\n\n            manager.executePendingTransactions();\n        }\n    }\n    \n    @Override\n    public void onStart() {\n        super.onStart();\n        dispatchStart(mProcessListener);\n        dispatch(Lifecycle.Event.ON_START);\n    }\n    \n    private void dispatch(Lifecycle.Event event) {\n        Activity activity = getActivity();\n        ...\n        if (activity instanceof LifecycleOwner) {\n            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();\n            if (lifecycle instanceof LifecycleRegistry) {\n                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);\n            }\n        }\n    }\n    ...\n}\n```\n### LifecycleRegistry#addObserver\n\nLifecycleRegistry继承了Lifecycle，是Activity和Fragment生命周期的真正管理类。 这个类里面的很多逻辑有点绕，我不太能理清楚。主要看一下addObserver这个方法：\n\n```java\npublic class LifecycleRegistry extends Lifecycle {\n\n    private FastSafeIterableMap<LifecycleObserver, ObserverWithState> mObserverMap = new FastSafeIterableMap<>();\n    private final WeakReference<LifecycleOwner> mLifecycleOwner;\n    // 当前的state\n    private State mState;\n\n    @Override\n    public void addObserver(@NonNull LifecycleObserver observer) {\n        // observer的state初始化为DESTROYED或者INITIALIZED\n        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;\n        ObserverWithState statefulObserver = new ObserverWithState(observer, initialState);\n        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);\n    \n        if (previous != null) {\n            return;\n        }\n        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();\n        if (lifecycleOwner == null) {\n            // it is null we should be destroyed. Fallback quickly\n            return;\n        }\n    \n        boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent;\n        // 得到一个目标state\n        State targetState = calculateTargetState(observer);\n        mAddingObserverCounter++;\n        // 当observer被add进来的时候，会进入循环，分发事件，直到observer的state==targetState\n        while ((statefulObserver.mState.compareTo(targetState) < 0\n                && mObserverMap.contains(observer))) {\n            pushParentState(statefulObserver.mState);\n            // 这里的upEvent(state)会导致statefulObserver.mState在分发的过程中不断更新\n            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));\n            popParentState();\n            // mState / subling may have been changed recalculate\n            targetState = calculateTargetState(observer);\n        }\n    \n        if (!isReentrance) {\n            // we do sync only on the top level.\n            sync();\n        }\n        mAddingObserverCounter--;\n    }\n\n    private State calculateTargetState(LifecycleObserver observer) {\n        // 这里的previous指前一个加入进来的Observer\n        Entry<LifecycleObserver, ObserverWithState> previous = mObserverMap.ceil(observer);\n    \n        State siblingState = previous != null ? previous.getValue().mState : null;\n        // 这个mParentStates不知道是啥。。。\n        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)\n                : null;\n        // 这里的min(x, y)是 返回在枚举中order最小的state\n        return min(min(mState, siblingState), parentState);\n    }\n    ...\n}\n```\n\n在addObserver中，ObserverWithState将state和observer包装一下，ObserverWithState内初始的state是DESTROYED或者INITIALIZED。之后会计算一个targetState，在while循环中会不断的分发和更新event。\n\n具体效果看下面的demo：\n\n```java\n@Override\nprotected void onCreate(@Nullable Bundle savedInstanceState) {\n    ...\n    handler.postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            TestActivity.this.getLifecycle().addObserver(new GenericLifecycleObserver() {\n                @Override\n                public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) {\n                    Log.i(\"chenlei\", \"onStateChanged: \" + event);\n                }\n            });\n        }\n    }, 5000);\n}\n```\n\n这里的GenericLifecycleObserver继承了LifecycleObserver的接口。demo中在create方法里延时5s添加一个LifecycleObserver并打印event。最后打印输出如下：\n\n可以看到从ON_CREATE到ON_RESUME在同一时刻都打印出来了\n\n### ProcessLifecycleOwner\n\nProcessLifecycleOwner实现了LifecycleOwner接口，可以监听当前应用前后台切换，并对此进行响应。\n这个类提供整个应用进程的生命周期。\n你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，Lifecycle.Event.ON_CREATE 事件只会分发一次，而 Lifecycle.Event.ON_DESTROY 永远不被分发。其他事件的分发遵守以下规则：\nProcessLifecycleOwner 会在第一个 Activity 经历 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 事件 延迟一段时间 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。\n这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。\n使用的时候，在Application中添加LifecycleObserver就可以了(实际上，在应用进程中的任意位置都可以）\n\n```java\nclass ApplicationObserver(val analytics: Analytics) : LifecycleObserver {\n    \n    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)\n    fun onBackground() {    }   \n    @OnLifecycleEvent(Lifecycle.Event.ON_START)\n    fun onForeground() {    }\n}\n\npublic class MyApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        ProcessLifecycleOwner.get().getLifecycle().addObserver(new ApplicationObserver());\n    }\n}\n```\n\n原理：\n\nProcessLifecycleOwnerInitializer\n```java\npublic class ProcessLifecycleOwnerInitializer extends ContentProvider {\n    @Override\n    public boolean onCreate() {\n        LifecycleDispatcher.init(getContext());\n        ProcessLifecycleOwner.init(getContext());\n        return true;\n    }\n    ...\n}\n```\n\n这个类是ProcessLifecycleOwner初始化的地方，它继承了一个ContentProvider ，这个ContentProvider声明在了Lifecycle包的AndroidManifest.xml里。\n\n这个AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。\n这里利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application 的 onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建。\n\nLifecycleDispatcher#init\n```java\nclass LifecycleDispatcher {\n\n    private static AtomicBoolean sInitialized = new AtomicBoolean(false);\n\n    static void init(Context context) {\n        if (sInitialized.getAndSet(true)) {\n            return;\n        }\n        ((Application) context.getApplicationContext())\n                .registerActivityLifecycleCallbacks(new DispatcherActivityCallback());\n    }\n\n    static class DispatcherActivityCallback extends EmptyActivityLifecycleCallbacks {\n\n        @Override\n        public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            ReportFragment.injectIfNeededIn(activity);\n        }\n        ...\n    }\n}\n```\n\n在Application中注册一个ActivityLifecycleCallbacks，在ActivityLifecycleCallbacks中有Activity所有生命周期的回调，这样就能监听到每一个Activity的创建和销毁。在onActivityCreated回调中往Activity注入一个了ReportFragment，我没看出来这里的ReportFragment的作用是什么。。\n\nProcessLifecycleOwner\n\n```java\npublic class ProcessLifecycleOwner implements LifecycleOwner {\n    private final LifecycleRegistry mRegistry = new LifecycleRegistry(this);\n    private static final ProcessLifecycleOwner sInstance = new ProcessLifecycleOwner();\n    static void init(Context context) {\n        sInstance.attach(context);\n    }\n\n    private ActivityInitializationListener mInitializationListener =\n        new ActivityInitializationListener() {\n            @Override\n            public void onCreate() {\n            }\n\n            @Override\n            public void onStart() {\n                activityStarted();\n            }\n\n            @Override\n            public void onResume() {\n                activityResumed();\n            }\n        };\n\n    void attach(Context context) {\n        mHandler = new Handler();\n        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);\n        Application app = (Application) context.getApplicationContext();\n        app.registerActivityLifecycleCallbacks(new EmptyActivityLifecycleCallbacks() {\n            @Override\n            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {\n            //在ReportFragment的生命周期中会有dispatchXxxx(mProcessListener)\n                ReportFragment.get(activity)\n                                .setProcessListener(mInitializationListener);\n            }\n    \n            @Override\n            public void onActivityPaused(Activity activity) {\n                activityPaused();\n            }\n    \n            @Override\n            public void onActivityStopped(Activity activity) {\n                activityStopped();\n            }\n        });\n    }\n\n    void activityResumed() {\n        mResumedCounter++;\n        if (mResumedCounter == 1) {\n            if (mPauseSent) {\n                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);\n                mPauseSent = false;\n            } else {\n                mHandler.removeCallbacks(mDelayedPauseRunnable);\n            }\n        }\n    }\n\n    void activityPaused() {\n        mResumedCounter--;\n        if (mResumedCounter == 0) {\n            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);\n        }\n    }\n    // 在mDelayedPauseRunnable中会调用这个方法\n    private void dispatchPauseIfNeeded() {\n        if (mResumedCounter == 0) {\n            mPauseSent = true;\n            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);\n        }\n    }\n    ...\n}\n```\n\n## 2. LiveData\nViewModel和Lifecycles分别代表数据和UI两端，这两个组件是相对比较独立的，并没有太多直接的关系。为了防止内存泄漏，ViewModel不能直接持有activity和fragment的引用。为了让更好的结合ViewModel和Lifecycles，就需要LiveData。\nLiveData是一种观察者模式, 在 Value发生变化时通知之前注册的所有观察者。同时，借助于Lifecycles，LiveData具有生命周期的感知能力。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。使用LiveData有以下的优点：\n- LiveData 只会将消息通知给活跃的观察者，非活跃观察者将不会收到消息通知。\n- 当非活跃观察者状态变为活跃的时候，LiveData会将自动将最新的消息发送给它。\n- 当相应的 Lifecycle 对象的状态变为 DESTROYED 时，LiveData会自动的移除此观察者，这样就不用担心Fragment和Activity的内存泄漏。\n- LiveData的数据发送和Observer的添加是没有顺序限制的。比如说LiveData在第1s发送消息，然后在第5s添加Observer，Observer依然能够立即接收到第1s发送出的数据，只要数据是当前最新的。这主要和LifecycleRegistry#addObserver的实现有关\n\n### 2.1 LiveData的使用\n\n#### 2.1.1 基本使用\n\n```java\n public class NameViewModel extends ViewModel {\n    private MutableLiveData<String> notifyCurrentName = new MutableLiveData<>();\n\n    private void post(){\n        notifyCurrentName.postValue(\"value\");    \n    }\n    \n    public MutableLiveData<String> getNotifyCurrentName(){\n        return notifyCurrentName;\n    }\n}\n\n// 在activity or fragment中\n// public void observe(LifecycleOwner owner, Observer<T> observer) \ngetViewModel().getNotifyCurrentName().observer(this, new Observer<String>() {\n    @Override\n    public void onChanged(@Nullable Stirng value) {\n        ...\n    }\n}\n\n// 如果不想让LiveData感知到生命周期，可以用observeForever(Observer<T> observer)\ngetViewModel().getNotifyCurrentName().observeForever(new Observer<String>() {\n    @Override\n    public void onChanged(@Nullable Stirng value) {\n        ...\n    }\n}\n```\n\n#### 2.1.2 Transformations#map\nTransformations是用来做LiveData转换的类。\nTransformations#map可以在消息分派给观察者之前对消息进行更改。\n\n```java\nLiveData<User> userLiveData = ...;\nLiveData<String> userName = Transformations.map(userLiveData, user -> {\n    user.name + \" \" + user.lastName\n});\n```\n\n#### 2.1.3 Transformations#switchMap\nswitchMap可以实现LiveData的转换，下面是一个demo，通过switchMap切换LiveData的数据源\n\n```java\npublic class MapTestViewModel extends ViewModel {\n    private MutableLiveData<String> dataSourceA = new MutableLiveData<>();\n    private MutableLiveData<String> dataSourceB = new MutableLiveData<>();\n\n    private MutableLiveData<Boolean> changeDataSource = new MutableLiveData<>();\n\n    private LiveData<String> notifyData = Transformations.switchMap(changeDataSource, new Function<Boolean, LiveData<String>>() {\n        @Override\n        public LiveData<String> apply(Boolean input) {\n            return input ? dataSourceA : dataSourceB;\n        }\n    });\n\n    public void start(Activity activity) {\n        changeDataSource.setValue(true);\n\n        Handler handler = new Handler(activity.getMainLooper());\n        handler.postDelayed(() -> {\n            dataSourceA.postValue(\"data from source A\");\n            dataSourceB.postValue(\"data from source B\");\n        }, 2000);\n        \n        handler.postDelayed(() -> {\n            changeDataSource(false);\n        }, 10000);\n    }\n\n    public void changeDataSource(boolean userA) {\n        changeDataSource.setValue(userA);\n    }\n\n    public LiveData<String> getNotifyData() {\n        return notifyData;\n    }\n}\n\n// activity\nviewModel.start(this);\nviewModel.getNotifyData().observe(MapTestActivity.this, new Observer<String>() {\n    @Override\n    public void onChanged(String s) {\n        Log.i(\"chenlei\", \"onChanged: \" + s);\n    }\n});\n```\n            \n上面的demo中，延时2s同时向dataSourceA和dataSourceB发送数据，并延时10s将数据源从A指向B。在observe中打印结果，最终dataSourceA和dataSourceB在间隔一段时间之后都能打印出来。\n每次调用changeDataSource.setValue(Boolean)，都会调用Function#apply返回一个LiveData，并将notifyData的 Observer 添加到新的LiveData上\n\n### 2.2 LiveData的原理\n\n#### 2.2.1 LiveData\n\n```java\npublic abstract class LiveData<T> {\n    // 存放Observer的集合\n    private SafeIterableMap<Observer<T>, ObserverWrapper> mObservers =                                                                 new SafeIterableMap<>();\n\n    static final int START_VERSION = -1;\n    private int mActiveCount = 0;\n    private int mVersion = START_VERSION;\n\n    ...\n    // 当LiveData的活跃Observer数量由0变成1的时候调用\n    protected void onActive() {}\n    // 当LiveData的活跃Observer数量由1变成0的时候调用\n    protected void onInactive() {}\n\n    ...\n\n    private abstract class ObserverWrapper {\n        final Observer<T> mObserver;\n        boolean mActive;\n        int mLastVersion = START_VERSION;\n    \n        ObserverWrapper(Observer<T> observer) {\n            mObserver = observer;\n        }\n    \n        abstract boolean shouldBeActive();\n    \n        boolean isAttachedTo(LifecycleOwner owner) {\n            return false;\n        }\n    \n        void detachObserver() {\n        }\n    \n        void activeStateChanged(boolean newActive) {\n            // 活跃状态没有改变则return， 防止重复发送消息\n            if (newActive == mActive) {\n                return;\n            }\n            mActive = newActive;\n            boolean wasInactive = LiveData.this.mActiveCount == 0;\n            LiveData.this.mActiveCount += mActive ? 1 : -1;\n            if (wasInactive && mActive) {\n                onActive();\n            }\n            if (LiveData.this.mActiveCount == 0 && !mActive) {\n                onInactive();\n            }\n            if (mActive) {\n                // 开始分发value\n                dispatchingValue(this);\n            }\n        }\n    }\n    ...\n}\n```\n\n#### 2.2.2 LiveData#observer\n\n```java\npublic abstract class LiveData<T> {    \n    ...\n    @MainThread\n    public void observe(@NonNull LifecycleOwner owner, @NonNull Observer<T> observer) {\n        if (owner.getLifecycle().getCurrentState() == DESTROYED) {\n            return;\n        }\n        LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer);\n        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n        ...\n        if (existing != null) {\n            return;\n        }\n        // 将wrapper将入到lifecycleOwner的生命周期的监听中\n        owner.getLifecycle().addObserver(wrapper);\n    }\n    ...\n}\n```\n\nLifecycleBoundObserver继承自ObserverWrapper，并且实现了\n\n```java\nGenericLifecycleObserver接口。GenericLifecycleObserver接口继承自LifecycleObserver接口\npublic interface GenericLifecycleObserver extends LifecycleObserver {\n    void onStateChanged(LifecycleOwner source, Lifecycle.Event event);\n}\n```\n\n```java\nclass LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {\n    @NonNull final LifecycleOwner mOwner;\n\n    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer<T> observer)\n    {\n        super(observer);\n        mOwner = owner;\n    }\n\n    @Override\n    boolean shouldBeActive() {\n        // 通过Lifecycle判断当前Observer是否活跃\n        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);\n    }\n\n    // GenericLifecycleObserver#onStatechanged\n    @Override\n    public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {\n        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {\n            // 当LifecycleOwner已经被销毁，remove这个Observer。\n            // removeObserver会调用detachObserver()和activeStateChanged(false)\n            // 这也是为什么LiveData可以自动防止UI泄漏的原因\n            removeObserver(mObserver);\n            return;\n        }\n        activeStateChanged(shouldBeActive());\n    }\n\n    @Override\n    boolean isAttachedTo(LifecycleOwner owner) {\n        return mOwner == owner;\n    }\n\n    @Override\n    void detachObserver() {\n        // 从LifecycleOwner中remove观察者\n        mOwner.getLifecycle().removeObserver(this);\n    }\n}\n```\n\nLiveData#observeForever\n\n```java\n@MainThread\npublic void observeForever(@NonNull Observer<T> observer) {\n    AlwaysActiveObserver wrapper = new AlwaysActiveObserver(observer);\n    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);\n    ...\n    if (existing != null) {\n        return;\n    }\n    // 因为observeForever没有LifecycleOwner，为了保持和普通observe方法的特性一致，在添加observe之后立刻检查是否有数据可以发送，\n    wrapper.activeStateChanged(true);\n}\n\nprivate class AlwaysActiveObserver extends ObserverWrapper {\n    AlwaysActiveObserver(Observer<T> observer) {\n        super(observer);\n    }\n\n    @Override\n    boolean shouldBeActive() {\n        return true;\n    }\n}\n```\n\n#### 2.2.3 LiveData#postValue()\nLiveData发送消息使用setValue或者postValue方法。其中setValue只能在主线程中使用，postValue发送消息时会自动切换到主线程。\n\n```java\npublic abstract class LiveData<T> {\n    private final Runnable mPostValueRunnable = new Runnable() {\n        @Override\n        public void run() {\n            ...\n            setValue((T) newValue);\n        }\n    };\n\n    ... \n    protected void postValue(T value) {\n        ...\n        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);\n    }\n    ...\n}\nLiveData#setValue\n@MainThread\nprotected void setValue(T value) {\n    assertMainThread(\"setValue\");\n    mVersion++;\n    mData = value;\n    dispatchingValue(null);\n}\n\nprivate void dispatchingValue(@Nullable ObserverWrapper initiator) {\n    if (mDispatchingValue) {\n        mDispatchInvalidated = true;\n        return;\n    }\n    mDispatchingValue = true;\n    do {\n        mDispatchInvalidated = false;\n        if (initiator != null) {\n            // 向特定的Observer发送数据\n            considerNotify(initiator);\n            initiator = null;\n        } else {\n            // 向所有Observer发送消息\n            for (Iterator<Map.Entry<Observer<T>, ObserverWrapper>> iterator =\n                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) {\n                considerNotify(iterator.next().getValue());\n                if (mDispatchInvalidated) {\n                    break;\n                }\n            }\n        }\n    } while (mDispatchInvalidated);\n    mDispatchingValue = false;\n}\n\nprivate void considerNotify(ObserverWrapper observer) {\n    if (!observer.mActive) {\n        return;\n    }\n    if (!observer.shouldBeActive()) {\n        observer.activeStateChanged(false);\n        return;\n    }\n    if (observer.mLastVersion >= mVersion) {\n        // 将要发送的是旧版本，扔掉\n        return;\n    }\n    observer.mLastVersion = mVersion;\n    observer.mObserver.onChanged((T) mData);\n}\n```\n","slug":"Android/ViewModel-LiveData和LifeCricle","published":1,"updated":"2021-10-03T01:57:41.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8d002tg0jed0fdphje","content":"<h1 id=\"ViewModel、Lifecycles和LiveData\"><a href=\"#ViewModel、Lifecycles和LiveData\" class=\"headerlink\" title=\"ViewModel、Lifecycles和LiveData\"></a>ViewModel、Lifecycles和LiveData</h1><a id=\"more\"></a><h2 id=\"1-ViewModel\"><a href=\"#1-ViewModel\" class=\"headerlink\" title=\"1. ViewModel:\"></a>1. ViewModel:</h2><p>ViewModel是Google官方提供的组件，是用来处理和存放和UI相关的数据的，可以把UI和数据进行分离。但就这一点来说的话，其实没有必要一定使用Google提供的ViewModel组件，我们使用自定义的ViewModel类同样可以达到这样的效果。</p>\n<p>还有一个很重要的特性，我们都知道，在配置改变时，Activity会出现销毁重建，比如说横竖屏切换的时候。ViewModel的生命周期和Activity是不一样的，它不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，可以将和UI相关的数据存放在ViewModel中，这样，即使Activity销毁重建，页面上显示的数据也不会丢失。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在ViewModel销毁的时候做回收工作，主要是为了防止ViewModel的泄漏</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCleared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ViewModel的创建和存储过程\"><a href=\"#ViewModel的创建和存储过程\" class=\"headerlink\" title=\"ViewModel的创建和存储过程\"></a>ViewModel的创建和存储过程</h3><p>主要是要搞清楚上面说的：Activity销毁重建的时候，ViewModel是如何保持不重建的。<br>注意，这里只是在Activity因为配置改变而销毁重建的情况下。还有一种情况是，App由前台进入后台，因为内存紧张，Activity被系统销毁。这种情况下，ViewModel是无法保存数据的。</p>\n<p>以下全都以Activity举例，Fragment也是一样的<br>在Activity中获取ViewModel：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">viewModel = ViewModelProviders.of(<span class=\"keyword\">this</span>).get(XxxViewModel.class);</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelProviders#of<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Nullable Factory factory)</span> </span>&#123;</span><br><span class=\"line\">    Application application = checkApplication(activity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (factory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用默认的工厂类</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果想要在ViewModel的构造方法里传参，需要自定义factory类</span></span><br><span class=\"line\">        factory = ViewModelProvider.AndroidViewModelFactory</span><br><span class=\"line\">                                    .getInstance(application);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>viewModelProvider#get<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从ViewModelStore中获取ViewModel，没有则创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    viewModel = mFactory.create(modelClass);</span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewModelStore</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ViewModel的集合，key是由ViewModel类名构成的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelStore中存储了一个Activity/Fragment的所有ViewModel。那现在问题就转变成了探究ViewModelStore的获取和存储的过程</p>\n<p>ViewModelStores#of<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelStore <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里先判断FragmentActivity是否实现了ViewModelStoreOwner接口。不同的依赖包，实现有可能是不一样的。高版本的support-v4和androidx中的Fragment和FragmentActivity都实现了这个接口。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ViewModelStoreOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"function\">ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现了ViewModelStoreOwner接口\"><a href=\"#实现了ViewModelStoreOwner接口\" class=\"headerlink\" title=\"实现了ViewModelStoreOwner接口\"></a>实现了ViewModelStoreOwner接口</h4><p>FragmentActivity<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">SupportActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewModelStoreOwner</span>, ...</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewModelStore mViewModelStore;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现了ViewModelStoreOwner接口的FragmentActivity会直接持有ViewModelStore的引用</p>\n<p>主要关注三个方法：<br>getViewModelStore()<br>onCreate()<br>onRetainNonConfigurationInstance()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getApplication() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances) <span class=\"keyword\">this</span>.getLastNonConfigurationInstance();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mViewModelStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)<span class=\"keyword\">this</span>.getLastNonConfigurationInstance();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span> &amp;&amp; nc.viewModelStore != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在页面销毁时，保存ViewModelStore</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">onRetainNonConfigurationInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Object custom = onRetainCustomNonConfigurationInstance();</span><br><span class=\"line\">     ViewModelStore viewModelStore = mViewModelStore;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (viewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 如果NonConfigurationInstance保存了viewModelStore，把它取出来</span></span><br><span class=\"line\">        NonConfigurationInstances nc = getLastNonConfigurationInstance();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            viewModelStore = nc.viewModelStore;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (viewModelStore == <span class=\"keyword\">null</span> &amp;&amp; custom == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">      NonConfigurationInstances nci = <span class=\"keyword\">new</span> NonConfigurationInstances();</span><br><span class=\"line\">      nci.custom = custom; </span><br><span class=\"line\">      <span class=\"comment\">//把viewModelStore放到NonConfigurationInstances中并返回</span></span><br><span class=\"line\">      nci.viewModelStore = viewModelStore;</span><br><span class=\"line\">      <span class=\"comment\">//这样当页面被重建而销毁时ViewModelStore就被保存起来了。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> nci;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ViewModelStore在onCreate里会从NonConfigurationInstances里尝试取出，然后在onRetainNonConfigurationInstanc方法中保存到NonConfigurationInstances。<br>onRetainNonConfigurationInstance何时被调用，数据又是怎样保存的呢？了解过Activity启动流程的都知道ActivityThread，它控制着Activity的生命周期，当ActivityThread执行performDestroyActivity这个方法时，会调用Activity#retainNonConfigurationInstances获取到保存的数据并保存到ActivityClientRecord中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ActivityClientRecord <span class=\"title\">performDestroyActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finishing, <span class=\"keyword\">int</span> configChanges, <span class=\"keyword\">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   ActivityClientRecord r = mActivities.get(token);</span><br><span class=\"line\">   <span class=\"comment\">// 由于状态改变的destroy，这里会为true</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (getNonConfigInstance) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//保存retainNonConfigurationInstances中的数据到ActivityClientRecord中</span></span><br><span class=\"line\">       r.lastNonConfigurationInstances = r.activity</span><br><span class=\"line\">                                          .retainNonConfigurationInstances();</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当页面重建完成,ActivityThread执行了performLaunchActivity方法时，会调用Activity的attach方法,便会把刚刚存储的数据，传递进去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    activity.attach(......, r.lastNonConfigurationInstances,.....);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：Activity对应的ViewModel保存在ViewModelStore里，FragmentActivity持有ViewModelStore的引用，Activity因配置原因销毁-重建时，ViewModelStore被NonConfigurationInstances保存，重建时从保存处恢复。</p>\n<h4 id=\"未实现ViewModelStoreOwner接口\"><a href=\"#未实现ViewModelStoreOwner接口\" class=\"headerlink\" title=\"未实现ViewModelStoreOwner接口\"></a>未实现ViewModelStoreOwner接口</h4><p>低版本未实现ViewModelStoreOwner接口，采取的方法是在Activity中注入一个不可见的HolderFragment</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelStore <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HolderFragment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewModelStoreOwner</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HolderFragmentManager sHolderFragmentManager = <span class=\"keyword\">new</span> HolderFragmentManager();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewModelStore mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HolderFragment</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        setRetainInstance(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HolderFragment <span class=\"title\">holderFragmentFor</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在activity中插入HolderFragment</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sHolderFragmentManager.holderFragmentFor(activity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HolderFragment持有mViewModelStore的引用。在HolderFragment的构造方法中，调用了<code>setRetainInstance(true)</code>。<br>控制一个fragment实例是否在activity因为配置改变而销毁重建的时候被保留。如果设置为true, fragment在activity销毁重建的时候将会被保留。同时，fragment的生命周期将会发生改变，当Activity销毁重建时，fragment生命周期中的onCreate和onDestroy将不会被执行。</p>\n<p>总结：HolderFragment实现了ViewModelStoreOwner接口，持有mViewModelStore的引用。由于Fragment和activity的生命周期是绑定的，Fragment内部可以感知到activity的生命周期。同时，通过setRetainInstance(true)，当activity被销毁重建的时候，HolderFragment并不会被销毁，导致mViewModelStore也不会被销毁<br>ViewModel的销毁：</p>\n<p>FragmentActivity#onDestroy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore != <span class=\"keyword\">null</span> &amp;&amp; !<span class=\"keyword\">this</span>.isChangingConfigurations()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当activity由于非config改变而销毁时清空mViewModelStore</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mViewModelStore.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mFragments.dispatchDestroy();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HolderFragment#onDestroy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    mViewModelStore.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelStore#clear()<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class=\"line\">        vm.onCleared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mMap.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ViewModel实现更进一步的数据持久化\"><a href=\"#ViewModel实现更进一步的数据持久化\" class=\"headerlink\" title=\"ViewModel实现更进一步的数据持久化\"></a>ViewModel实现更进一步的数据持久化</h3><p>上面的是 activity 在因为配置改变，销毁重建的情况，在这种情况下，ViewModel 可以自动实现数据保留和现场恢复。<br>还有一种情况是，App进入后台，然后因为内存紧张，activity 被系统销毁，然后用户再次打开，activity重建。这种情况下，ViewModel默认是不能实现现场恢复的，需要借助 SavedStateHandle。<br>可以简单的把 SavedStateHandle 理解为 onSaveInstanceState()的逻辑从 activity 转移到了ViewModel 中。</p>\n<p>要想使用 SavedStateHandle 需要额外导入包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &apos;androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-alpha01&apos;</span><br></pre></td></tr></table></figure></p>\n<p>然后在获取ViewModel时使用 SavedStateViewModelFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">viewModel = ViewModelProviders.of(<span class=\"keyword\">this</span>, </span><br><span class=\"line\">                    <span class=\"keyword\">new</span> SavedStateViewModelFactory(getApplication(), <span class=\"keyword\">this</span>))</span><br><span class=\"line\">                    .get(SaveStateTestViewModel.class);</span><br></pre></td></tr></table></figure></p>\n<p>然后在ViewModel的构造方法里传入SavedStateHandle实例，然后就可以通过SavedStateHandle保存和读取数据了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveStateTestViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SavedStateHandle savedStateHandle;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MutableLiveData&lt;String&gt; notifyLiveData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SaveStateTestViewModel</span><span class=\"params\">(SavedStateHandle handle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.savedStateHandle = handle;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyLiveData = savedStateHandle.getLiveData(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span>&#123;</span><br><span class=\"line\">        savedStateHandle.set(<span class=\"string\">\"key2\"</span>, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyLiveData.setValue(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"title\">getNotifyLiveData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyLiveData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和 onSaveInstanceState() 的保存和恢复方式一样，不能保存复杂的数据，只能保存可以存入Bundle的那些类型。 也可以SavedStateHandle中使用LiveData的方式进行保存，这样的话稍微有那么一点的好处是你不需要特意的save和get数据，直接把在初始化的时候替换成SavedStateHandle#getLiveData就可以了</p>\n<h2 id=\"2-Lifecycles\"><a href=\"#2-Lifecycles\" class=\"headerlink\" title=\"2. Lifecycles\"></a>2. Lifecycles</h2><p>Lifecycles组件是为了方便感知Activity和Fragment的生命周期而出现的，它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。<br>Lifecycle包含在support library 26.1.0及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。support library在26.1.0之前，需要我们引入另外的包。</p>\n<p>lifecycle 组件包括 Lifecycle, LifecycleOwner, LifecycleObserver 三个主要类：</p>\n<ul>\n<li>Lifecycle 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。</li>\n<li>LifecycleOwner 仅有一个 getLifecycle() 方法，用于返回当前对象的 Lifecycle。</li>\n<li>LifecycleObserver，代表观察者</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LifecyclerOwner和LifecycleObserver</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口，是被观察者。<br>LifecycleOwner#getLifecycle()返回Lifecycle实例. 这是一种解耦实现, LifecycleOwner不包含任何有关生命周期管理的逻辑, 实际的逻辑都在Lifecycle实例中, 我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏。<br>并不是所有的google官方的Activity和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有FragmentActivity，AppCompatActivity和v4包下的Fragment。<br>LifecycleObserver接口代表生命周期的观察者，它的实现为空。实现LifecycleObserver的类要想感知到生命周期的变化需要借助额外的注解。或者，也可以使用一些继承了LifecycleObserver的子接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">voidactivityResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lifecycle中的state和event\"><a href=\"#Lifecycle中的state和event\" class=\"headerlink\" title=\"Lifecycle中的state和event\"></a>Lifecycle中的state和event</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</span><br><span class=\"line\">    DESTROYED,</span><br><span class=\"line\">    INITIALIZED,</span><br><span class=\"line\">    CREATED,</span><br><span class=\"line\">    STARTED,</span><br><span class=\"line\">    RESUMED;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAtLeast</span><span class=\"params\">(@NonNull State state)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compareTo(state) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Event &#123;</span><br><span class=\"line\">    ON_CREATE,</span><br><span class=\"line\">    ON_START,</span><br><span class=\"line\">    ON_RESUME,</span><br><span class=\"line\">    ON_PAUSE,</span><br><span class=\"line\">    ON_STOP,</span><br><span class=\"line\">    ON_DESTROY,</span><br><span class=\"line\">    ON_ANY <span class=\"comment\">// ON_ANY代表任意时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lifecycle的获取生命周期的变化\"><a href=\"#Lifecycle的获取生命周期的变化\" class=\"headerlink\" title=\"Lifecycle的获取生命周期的变化\"></a>Lifecycle的获取生命周期的变化</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SupportActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleOwner</span>, <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LifecycleRegistry mLifecycleRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mLifecycleRegistry.markState(State.CREATED);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onSaveInstanceState(outState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mLifecycleRegistry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleRegistry继承了Lifecycle。SupportActivity是FragmentActivity的父类。在SupportActivity中找不到state和event分发相关的代码，这些相关内容是在ReportFragment中实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReportFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectIfNeededIn</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            manager.beginTransaction().add(<span class=\"keyword\">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class=\"line\"></span><br><span class=\"line\">            manager.executePendingTransactions();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        dispatchStart(mProcessListener);</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_START);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        Activity activity = getActivity();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleOwner) &#123;</span><br><span class=\"line\">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lifecycle <span class=\"keyword\">instanceof</span> LifecycleRegistry) &#123;</span><br><span class=\"line\">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LifecycleRegistry-addObserver\"><a href=\"#LifecycleRegistry-addObserver\" class=\"headerlink\" title=\"LifecycleRegistry#addObserver\"></a>LifecycleRegistry#addObserver</h3><p>LifecycleRegistry继承了Lifecycle，是Activity和Fragment生命周期的真正管理类。 这个类里面的很多逻辑有点绕，我不太能理清楚。主要看一下addObserver这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleRegistry</span> <span class=\"keyword\">extends</span> <span class=\"title\">Lifecycle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = <span class=\"keyword\">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的state</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> State mState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// observer的state初始化为DESTROYED或者INITIALIZED</span></span><br><span class=\"line\">        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">        ObserverWithState statefulObserver = <span class=\"keyword\">new</span> ObserverWithState(observer, initialState);</span><br><span class=\"line\">        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// it is null we should be destroyed. Fallback quickly</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isReentrance = mAddingObserverCounter != <span class=\"number\">0</span> || mHandlingEvent;</span><br><span class=\"line\">        <span class=\"comment\">// 得到一个目标state</span></span><br><span class=\"line\">        State targetState = calculateTargetState(observer);</span><br><span class=\"line\">        mAddingObserverCounter++;</span><br><span class=\"line\">        <span class=\"comment\">// 当observer被add进来的时候，会进入循环，分发事件，直到observer的state==targetState</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class=\"line\">            pushParentState(statefulObserver.mState);</span><br><span class=\"line\">            <span class=\"comment\">// 这里的upEvent(state)会导致statefulObserver.mState在分发的过程中不断更新</span></span><br><span class=\"line\">            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class=\"line\">            popParentState();</span><br><span class=\"line\">            <span class=\"comment\">// mState / subling may have been changed recalculate</span></span><br><span class=\"line\">            targetState = calculateTargetState(observer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isReentrance) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// we do sync only on the top level.</span></span><br><span class=\"line\">            sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAddingObserverCounter--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> State <span class=\"title\">calculateTargetState</span><span class=\"params\">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的previous指前一个加入进来的Observer</span></span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);</span><br><span class=\"line\">    </span><br><span class=\"line\">        State siblingState = previous != <span class=\"keyword\">null</span> ? previous.getValue().mState : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这个mParentStates不知道是啥。。。</span></span><br><span class=\"line\">        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class=\"number\">1</span>)</span><br><span class=\"line\">                : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的min(x, y)是 返回在枚举中order最小的state</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(min(mState, siblingState), parentState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在addObserver中，ObserverWithState将state和observer包装一下，ObserverWithState内初始的state是DESTROYED或者INITIALIZED。之后会计算一个targetState，在while循环中会不断的分发和更新event。</p>\n<p>具体效果看下面的demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    handler.postDelayed(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            TestActivity.<span class=\"keyword\">this</span>.getLifecycle().addObserver(<span class=\"keyword\">new</span> GenericLifecycleObserver() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">                    Log.i(<span class=\"string\">\"chenlei\"</span>, <span class=\"string\">\"onStateChanged: \"</span> + event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的GenericLifecycleObserver继承了LifecycleObserver的接口。demo中在create方法里延时5s添加一个LifecycleObserver并打印event。最后打印输出如下：</p>\n<p>可以看到从ON_CREATE到ON_RESUME在同一时刻都打印出来了</p>\n<h3 id=\"ProcessLifecycleOwner\"><a href=\"#ProcessLifecycleOwner\" class=\"headerlink\" title=\"ProcessLifecycleOwner\"></a>ProcessLifecycleOwner</h3><p>ProcessLifecycleOwner实现了LifecycleOwner接口，可以监听当前应用前后台切换，并对此进行响应。<br>这个类提供整个应用进程的生命周期。<br>你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，Lifecycle.Event.ON_CREATE 事件只会分发一次，而 Lifecycle.Event.ON_DESTROY 永远不被分发。其他事件的分发遵守以下规则：<br>ProcessLifecycleOwner 会在第一个 Activity 经历 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 事件 延迟一段时间 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。<br>这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。<br>使用的时候，在Application中添加LifecycleObserver就可以了(实际上，在应用进程中的任意位置都可以）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ApplicationObserver(val analytics: Analytics) : LifecycleObserver &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">onBackground</span><span class=\"params\">()</span> </span>&#123;    &#125;   </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">onForeground</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">        ProcessLifecycleOwner.get().getLifecycle().addObserver(<span class=\"keyword\">new</span> ApplicationObserver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理：</p>\n<p>ProcessLifecycleOwnerInitializer<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProcessLifecycleOwnerInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        LifecycleDispatcher.init(getContext());</span><br><span class=\"line\">        ProcessLifecycleOwner.init(getContext());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类是ProcessLifecycleOwner初始化的地方，它继承了一个ContentProvider ，这个ContentProvider声明在了Lifecycle包的AndroidManifest.xml里。</p>\n<p>这个AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。<br>这里利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application 的 onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建。</p>\n<p>LifecycleDispatcher#init<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleDispatcher</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicBoolean sInitialized = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInitialized.getAndSet(<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ((Application) context.getApplicationContext())</span><br><span class=\"line\">                .registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> DispatcherActivityCallback());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherActivityCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">EmptyActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            ReportFragment.injectIfNeededIn(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Application中注册一个ActivityLifecycleCallbacks，在ActivityLifecycleCallbacks中有Activity所有生命周期的回调，这样就能监听到每一个Activity的创建和销毁。在onActivityCreated回调中往Activity注入一个了ReportFragment，我没看出来这里的ReportFragment的作用是什么。。</p>\n<p>ProcessLifecycleOwner</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProcessLifecycleOwner</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LifecycleRegistry mRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessLifecycleOwner sInstance = <span class=\"keyword\">new</span> ProcessLifecycleOwner();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        sInstance.attach(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ActivityInitializationListener mInitializationListener =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ActivityInitializationListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                activityStarted();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                activityResumed();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler();</span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">        Application app = (Application) context.getApplicationContext();</span><br><span class=\"line\">        app.registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//在ReportFragment的生命周期中会有dispatchXxxx(mProcessListener)</span></span><br><span class=\"line\">                ReportFragment.get(activity)</span><br><span class=\"line\">                                .setProcessListener(mInitializationListener);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">                activityPaused();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">                activityStopped();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityResumed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mResumedCounter++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPauseSent) &#123;</span><br><span class=\"line\">                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class=\"line\">                mPauseSent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityPaused</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mResumedCounter--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在mDelayedPauseRunnable中会调用这个方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchPauseIfNeeded</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mPauseSent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-LiveData\"><a href=\"#2-LiveData\" class=\"headerlink\" title=\"2. LiveData\"></a>2. LiveData</h2><p>ViewModel和Lifecycles分别代表数据和UI两端，这两个组件是相对比较独立的，并没有太多直接的关系。为了防止内存泄漏，ViewModel不能直接持有activity和fragment的引用。为了让更好的结合ViewModel和Lifecycles，就需要LiveData。<br>LiveData是一种观察者模式, 在 Value发生变化时通知之前注册的所有观察者。同时，借助于Lifecycles，LiveData具有生命周期的感知能力。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。使用LiveData有以下的优点：</p>\n<ul>\n<li>LiveData 只会将消息通知给活跃的观察者，非活跃观察者将不会收到消息通知。</li>\n<li>当非活跃观察者状态变为活跃的时候，LiveData会将自动将最新的消息发送给它。</li>\n<li>当相应的 Lifecycle 对象的状态变为 DESTROYED 时，LiveData会自动的移除此观察者，这样就不用担心Fragment和Activity的内存泄漏。</li>\n<li>LiveData的数据发送和Observer的添加是没有顺序限制的。比如说LiveData在第1s发送消息，然后在第5s添加Observer，Observer依然能够立即接收到第1s发送出的数据，只要数据是当前最新的。这主要和LifecycleRegistry#addObserver的实现有关</li>\n</ul>\n<h3 id=\"2-1-LiveData的使用\"><a href=\"#2-1-LiveData的使用\" class=\"headerlink\" title=\"2.1 LiveData的使用\"></a>2.1 LiveData的使用</h3><h4 id=\"2-1-1-基本使用\"><a href=\"#2-1-1-基本使用\" class=\"headerlink\" title=\"2.1.1 基本使用\"></a>2.1.1 基本使用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; notifyCurrentName = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        notifyCurrentName.postValue(<span class=\"string\">\"value\"</span>);    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"title\">getNotifyCurrentName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyCurrentName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在activity or fragment中</span></span><br><span class=\"line\"><span class=\"comment\">// public void observe(LifecycleOwner owner, Observer&lt;T&gt; observer) </span></span><br><span class=\"line\">getViewModel().getNotifyCurrentName().observer(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Stirng value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果不想让LiveData感知到生命周期，可以用observeForever(Observer&lt;T&gt; observer)</span></span><br><span class=\"line\">getViewModel().getNotifyCurrentName().observeForever(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Stirng value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-1-2-Transformations-map\"><a href=\"#2-1-2-Transformations-map\" class=\"headerlink\" title=\"2.1.2 Transformations#map\"></a>2.1.2 Transformations#map</h4><p>Transformations是用来做LiveData转换的类。<br>Transformations#map可以在消息分派给观察者之前对消息进行更改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;User&gt; userLiveData = ...;</span><br><span class=\"line\">LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class=\"line\">    user.name + <span class=\"string\">\" \"</span> + user.lastName</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-1-3-Transformations-switchMap\"><a href=\"#2-1-3-Transformations-switchMap\" class=\"headerlink\" title=\"2.1.3 Transformations#switchMap\"></a>2.1.3 Transformations#switchMap</h4><p>switchMap可以实现LiveData的转换，下面是一个demo，通过switchMap切换LiveData的数据源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapTestViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; dataSourceA = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; dataSourceB = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;Boolean&gt; changeDataSource = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LiveData&lt;String&gt; notifyData = Transformations.switchMap(changeDataSource, <span class=\"keyword\">new</span> Function&lt;Boolean, LiveData&lt;String&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;String&gt; <span class=\"title\">apply</span><span class=\"params\">(Boolean input)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input ? dataSourceA : dataSourceB;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        changeDataSource.setValue(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Handler handler = <span class=\"keyword\">new</span> Handler(activity.getMainLooper());</span><br><span class=\"line\">        handler.postDelayed(() -&gt; &#123;</span><br><span class=\"line\">            dataSourceA.postValue(<span class=\"string\">\"data from source A\"</span>);</span><br><span class=\"line\">            dataSourceB.postValue(<span class=\"string\">\"data from source B\"</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        handler.postDelayed(() -&gt; &#123;</span><br><span class=\"line\">            changeDataSource(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">10000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">(<span class=\"keyword\">boolean</span> userA)</span> </span>&#123;</span><br><span class=\"line\">        changeDataSource.setValue(userA);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;String&gt; <span class=\"title\">getNotifyData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// activity</span></span><br><span class=\"line\">viewModel.start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">viewModel.getNotifyData().observe(MapTestActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"chenlei\"</span>, <span class=\"string\">\"onChanged: \"</span> + s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的demo中，延时2s同时向dataSourceA和dataSourceB发送数据，并延时10s将数据源从A指向B。在observe中打印结果，最终dataSourceA和dataSourceB在间隔一段时间之后都能打印出来。<br>每次调用changeDataSource.setValue(Boolean)，都会调用Function#apply返回一个LiveData，并将notifyData的 Observer 添加到新的LiveData上</p>\n<h3 id=\"2-2-LiveData的原理\"><a href=\"#2-2-LiveData的原理\" class=\"headerlink\" title=\"2.2 LiveData的原理\"></a>2.2 LiveData的原理</h3><h4 id=\"2-2-1-LiveData\"><a href=\"#2-2-1-LiveData\" class=\"headerlink\" title=\"2.2.1 LiveData\"></a>2.2.1 LiveData</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存放Observer的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SafeIterableMap&lt;Observer&lt;T&gt;, ObserverWrapper&gt; mObservers =                                                                 <span class=\"keyword\">new</span> SafeIterableMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> START_VERSION = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mActiveCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mVersion = START_VERSION;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 当LiveData的活跃Observer数量由0变成1的时候调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当LiveData的活跃Observer数量由1变成0的时候调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onInactive</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;T&gt; mObserver;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> mActive;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mLastVersion = START_VERSION;</span><br><span class=\"line\">    </span><br><span class=\"line\">        ObserverWrapper(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">            mObserver = observer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activeStateChanged</span><span class=\"params\">(<span class=\"keyword\">boolean</span> newActive)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 活跃状态没有改变则return， 防止重复发送消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newActive == mActive) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mActive = newActive;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> wasInactive = LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span>;</span><br><span class=\"line\">            LiveData.<span class=\"keyword\">this</span>.mActiveCount += mActive ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class=\"line\">                onActive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span> &amp;&amp; !mActive) &#123;</span><br><span class=\"line\">                onInactive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mActive) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 开始分发value</span></span><br><span class=\"line\">                dispatchingValue(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-2-LiveData-observer\"><a href=\"#2-2-2-LiveData-observer\" class=\"headerlink\" title=\"2.2.2 LiveData#observer\"></a>2.2.2 LiveData#observer</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"meta\">@MainThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observe</span><span class=\"params\">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LifecycleBoundObserver wrapper = <span class=\"keyword\">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class=\"line\">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将wrapper将入到lifecycleOwner的生命周期的监听中</span></span><br><span class=\"line\">        owner.getLifecycle().addObserver(wrapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleBoundObserver继承自ObserverWrapper，并且实现了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericLifecycleObserver接口。GenericLifecycleObserver接口继承自LifecycleObserver接口</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GenericLifecycleObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">GenericLifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> LifecycleOwner mOwner;</span><br><span class=\"line\"></span><br><span class=\"line\">    LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">        mOwner = owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过Lifecycle判断当前Observer是否活跃</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// GenericLifecycleObserver#onStatechanged</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当LifecycleOwner已经被销毁，remove这个Observer。</span></span><br><span class=\"line\">            <span class=\"comment\">// removeObserver会调用detachObserver()和activeStateChanged(false)</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是为什么LiveData可以自动防止UI泄漏的原因</span></span><br><span class=\"line\">            removeObserver(mObserver);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        activeStateChanged(shouldBeActive());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner == owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从LifecycleOwner中remove观察者</span></span><br><span class=\"line\">        mOwner.getLifecycle().removeObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LiveData#observeForever</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(@NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 因为observeForever没有LifecycleOwner，为了保持和普通observe方法的特性一致，在添加observe之后立刻检查是否有数据可以发送，</span></span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlwaysActiveObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;</span><br><span class=\"line\">    AlwaysActiveObserver(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-3-LiveData-postValue\"><a href=\"#2-2-3-LiveData-postValue\" class=\"headerlink\" title=\"2.2.3 LiveData#postValue()\"></a>2.2.3 LiveData#postValue()</h4><p>LiveData发送消息使用setValue或者postValue方法。其中setValue只能在主线程中使用，postValue发送消息时会自动切换到主线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            setValue((T) newValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LiveData#setValue</span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>);</span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDispatchingValue) &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initiator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向特定的Observer发送数据</span></span><br><span class=\"line\">            considerNotify(initiator);</span><br><span class=\"line\">            initiator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向所有Observer发送消息</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将要发送的是旧版本，扔掉</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"ViewModel、Lifecycles和LiveData\"><a href=\"#ViewModel、Lifecycles和LiveData\" class=\"headerlink\" title=\"ViewModel、Lifecycles和LiveData\"></a>ViewModel、Lifecycles和LiveData</h1>","more":"<h2 id=\"1-ViewModel\"><a href=\"#1-ViewModel\" class=\"headerlink\" title=\"1. ViewModel:\"></a>1. ViewModel:</h2><p>ViewModel是Google官方提供的组件，是用来处理和存放和UI相关的数据的，可以把UI和数据进行分离。但就这一点来说的话，其实没有必要一定使用Google提供的ViewModel组件，我们使用自定义的ViewModel类同样可以达到这样的效果。</p>\n<p>还有一个很重要的特性，我们都知道，在配置改变时，Activity会出现销毁重建，比如说横竖屏切换的时候。ViewModel的生命周期和Activity是不一样的，它不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。因此，可以将和UI相关的数据存放在ViewModel中，这样，即使Activity销毁重建，页面上显示的数据也不会丢失。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在ViewModel销毁的时候做回收工作，主要是为了防止ViewModel的泄漏</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCleared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ViewModel的创建和存储过程\"><a href=\"#ViewModel的创建和存储过程\" class=\"headerlink\" title=\"ViewModel的创建和存储过程\"></a>ViewModel的创建和存储过程</h3><p>主要是要搞清楚上面说的：Activity销毁重建的时候，ViewModel是如何保持不重建的。<br>注意，这里只是在Activity因为配置改变而销毁重建的情况下。还有一种情况是，App由前台进入后台，因为内存紧张，Activity被系统销毁。这种情况下，ViewModel是无法保存数据的。</p>\n<p>以下全都以Activity举例，Fragment也是一样的<br>在Activity中获取ViewModel：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">viewModel = ViewModelProviders.of(<span class=\"keyword\">this</span>).get(XxxViewModel.class);</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelProviders#of<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@NonNull</span></span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelProvider <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Nullable Factory factory)</span> </span>&#123;</span><br><span class=\"line\">    Application application = checkApplication(activity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (factory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用默认的工厂类</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果想要在ViewModel的构造方法里传参，需要自定义factory类</span></span><br><span class=\"line\">        factory = ViewModelProvider.AndroidViewModelFactory</span><br><span class=\"line\">                                    .getInstance(application);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>viewModelProvider#get<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从ViewModelStore中获取ViewModel，没有则创建</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T extends ViewModel&gt; <span class=\"function\">T <span class=\"title\">get</span><span class=\"params\">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class=\"line\">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    viewModel = mFactory.create(modelClass);</span><br><span class=\"line\">    mViewModelStore.put(key, viewModel);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) viewModel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewModelStore</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ViewModel的集合，key是由ViewModel类名构成的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelStore中存储了一个Activity/Fragment的所有ViewModel。那现在问题就转变成了探究ViewModelStore的获取和存储的过程</p>\n<p>ViewModelStores#of<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelStore <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里先判断FragmentActivity是否实现了ViewModelStoreOwner接口。不同的依赖包，实现有可能是不一样的。高版本的support-v4和androidx中的Fragment和FragmentActivity都实现了这个接口。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ViewModelStoreOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">    <span class=\"function\">ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"实现了ViewModelStoreOwner接口\"><a href=\"#实现了ViewModelStoreOwner接口\" class=\"headerlink\" title=\"实现了ViewModelStoreOwner接口\"></a>实现了ViewModelStoreOwner接口</h4><p>FragmentActivity<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FragmentActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">SupportActivity</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewModelStoreOwner</span>, ...</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewModelStore mViewModelStore;</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>实现了ViewModelStoreOwner接口的FragmentActivity会直接持有ViewModelStore的引用</p>\n<p>主要关注三个方法：<br>getViewModelStore()<br>onCreate()<br>onRetainNonConfigurationInstance()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewModelStore <span class=\"title\">getViewModelStore</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.getApplication() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances) <span class=\"keyword\">this</span>.getLastNonConfigurationInstance();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mViewModelStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    FragmentActivity.NonConfigurationInstances nc = (FragmentActivity.NonConfigurationInstances)<span class=\"keyword\">this</span>.getLastNonConfigurationInstance();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span> &amp;&amp; nc.viewModelStore != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"keyword\">this</span>.mViewModelStore == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mViewModelStore = nc.viewModelStore;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 在页面销毁时，保存ViewModelStore</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Object <span class=\"title\">onRetainNonConfigurationInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     Object custom = onRetainCustomNonConfigurationInstance();</span><br><span class=\"line\">     ViewModelStore viewModelStore = mViewModelStore;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (viewModelStore == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 如果NonConfigurationInstance保存了viewModelStore，把它取出来</span></span><br><span class=\"line\">        NonConfigurationInstances nc = getLastNonConfigurationInstance();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nc != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            viewModelStore = nc.viewModelStore;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (viewModelStore == <span class=\"keyword\">null</span> &amp;&amp; custom == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">      NonConfigurationInstances nci = <span class=\"keyword\">new</span> NonConfigurationInstances();</span><br><span class=\"line\">      nci.custom = custom; </span><br><span class=\"line\">      <span class=\"comment\">//把viewModelStore放到NonConfigurationInstances中并返回</span></span><br><span class=\"line\">      nci.viewModelStore = viewModelStore;</span><br><span class=\"line\">      <span class=\"comment\">//这样当页面被重建而销毁时ViewModelStore就被保存起来了。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> nci;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ViewModelStore在onCreate里会从NonConfigurationInstances里尝试取出，然后在onRetainNonConfigurationInstanc方法中保存到NonConfigurationInstances。<br>onRetainNonConfigurationInstance何时被调用，数据又是怎样保存的呢？了解过Activity启动流程的都知道ActivityThread，它控制着Activity的生命周期，当ActivityThread执行performDestroyActivity这个方法时，会调用Activity#retainNonConfigurationInstances获取到保存的数据并保存到ActivityClientRecord中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ActivityClientRecord <span class=\"title\">performDestroyActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finishing, <span class=\"keyword\">int</span> configChanges, <span class=\"keyword\">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   ActivityClientRecord r = mActivities.get(token);</span><br><span class=\"line\">   <span class=\"comment\">// 由于状态改变的destroy，这里会为true</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (getNonConfigInstance) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//保存retainNonConfigurationInstances中的数据到ActivityClientRecord中</span></span><br><span class=\"line\">       r.lastNonConfigurationInstances = r.activity</span><br><span class=\"line\">                                          .retainNonConfigurationInstances();</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当页面重建完成,ActivityThread执行了performLaunchActivity方法时，会调用Activity的attach方法,便会把刚刚存储的数据，传递进去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    activity.attach(......, r.lastNonConfigurationInstances,.....);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结：Activity对应的ViewModel保存在ViewModelStore里，FragmentActivity持有ViewModelStore的引用，Activity因配置原因销毁-重建时，ViewModelStore被NonConfigurationInstances保存，重建时从保存处恢复。</p>\n<h4 id=\"未实现ViewModelStoreOwner接口\"><a href=\"#未实现ViewModelStoreOwner接口\" class=\"headerlink\" title=\"未实现ViewModelStoreOwner接口\"></a>未实现ViewModelStoreOwner接口</h4><p>低版本未实现ViewModelStoreOwner接口，采取的方法是在Activity中注入一个不可见的HolderFragment</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ViewModelStore <span class=\"title\">of</span><span class=\"params\">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HolderFragment:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> <span class=\"keyword\">implements</span> <span class=\"title\">ViewModelStoreOwner</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> HolderFragmentManager sHolderFragmentManager = <span class=\"keyword\">new</span> HolderFragmentManager();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> ViewModelStore mViewModelStore = <span class=\"keyword\">new</span> ViewModelStore();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HolderFragment</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        setRetainInstance(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> HolderFragment <span class=\"title\">holderFragmentFor</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在activity中插入HolderFragment</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sHolderFragmentManager.holderFragmentFor(activity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HolderFragment持有mViewModelStore的引用。在HolderFragment的构造方法中，调用了<code>setRetainInstance(true)</code>。<br>控制一个fragment实例是否在activity因为配置改变而销毁重建的时候被保留。如果设置为true, fragment在activity销毁重建的时候将会被保留。同时，fragment的生命周期将会发生改变，当Activity销毁重建时，fragment生命周期中的onCreate和onDestroy将不会被执行。</p>\n<p>总结：HolderFragment实现了ViewModelStoreOwner接口，持有mViewModelStore的引用。由于Fragment和activity的生命周期是绑定的，Fragment内部可以感知到activity的生命周期。同时，通过setRetainInstance(true)，当activity被销毁重建的时候，HolderFragment并不会被销毁，导致mViewModelStore也不会被销毁<br>ViewModel的销毁：</p>\n<p>FragmentActivity#onDestroy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.mViewModelStore != <span class=\"keyword\">null</span> &amp;&amp; !<span class=\"keyword\">this</span>.isChangingConfigurations()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//当activity由于非config改变而销毁时清空mViewModelStore</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mViewModelStore.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mFragments.dispatchDestroy();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HolderFragment#onDestroy<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    mViewModelStore.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>ViewModelStore#clear()<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class=\"line\">        vm.onCleared();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mMap.clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ViewModel实现更进一步的数据持久化\"><a href=\"#ViewModel实现更进一步的数据持久化\" class=\"headerlink\" title=\"ViewModel实现更进一步的数据持久化\"></a>ViewModel实现更进一步的数据持久化</h3><p>上面的是 activity 在因为配置改变，销毁重建的情况，在这种情况下，ViewModel 可以自动实现数据保留和现场恢复。<br>还有一种情况是，App进入后台，然后因为内存紧张，activity 被系统销毁，然后用户再次打开，activity重建。这种情况下，ViewModel默认是不能实现现场恢复的，需要借助 SavedStateHandle。<br>可以简单的把 SavedStateHandle 理解为 onSaveInstanceState()的逻辑从 activity 转移到了ViewModel 中。</p>\n<p>要想使用 SavedStateHandle 需要额外导入包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation &apos;androidx.lifecycle:lifecycle-viewmodel-savedstate:2.3.0-alpha01&apos;</span><br></pre></td></tr></table></figure></p>\n<p>然后在获取ViewModel时使用 SavedStateViewModelFactory<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">viewModel = ViewModelProviders.of(<span class=\"keyword\">this</span>, </span><br><span class=\"line\">                    <span class=\"keyword\">new</span> SavedStateViewModelFactory(getApplication(), <span class=\"keyword\">this</span>))</span><br><span class=\"line\">                    .get(SaveStateTestViewModel.class);</span><br></pre></td></tr></table></figure></p>\n<p>然后在ViewModel的构造方法里传入SavedStateHandle实例，然后就可以通过SavedStateHandle保存和读取数据了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SaveStateTestViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> SavedStateHandle savedStateHandle;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MutableLiveData&lt;String&gt; notifyLiveData;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SaveStateTestViewModel</span><span class=\"params\">(SavedStateHandle handle)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.savedStateHandle = handle;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyLiveData = savedStateHandle.getLiveData(<span class=\"string\">\"key\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">(<span class=\"keyword\">int</span> data)</span></span>&#123;</span><br><span class=\"line\">        savedStateHandle.set(<span class=\"string\">\"key2\"</span>, data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setData</span><span class=\"params\">(String data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notifyLiveData.setValue(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"title\">getNotifyLiveData</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyLiveData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和 onSaveInstanceState() 的保存和恢复方式一样，不能保存复杂的数据，只能保存可以存入Bundle的那些类型。 也可以SavedStateHandle中使用LiveData的方式进行保存，这样的话稍微有那么一点的好处是你不需要特意的save和get数据，直接把在初始化的时候替换成SavedStateHandle#getLiveData就可以了</p>\n<h2 id=\"2-Lifecycles\"><a href=\"#2-Lifecycles\" class=\"headerlink\" title=\"2. Lifecycles\"></a>2. Lifecycles</h2><p>Lifecycles组件是为了方便感知Activity和Fragment的生命周期而出现的，它可以让任何一个类都能轻松感知到Activity的生命周期，同时又不需要在Activity中编写大量的逻辑处理。<br>Lifecycle包含在support library 26.1.0及之后的依赖包中，如果我们的项目基于这些依赖包，那么不需要额外的引用。support library在26.1.0之前，需要我们引入另外的包。</p>\n<p>lifecycle 组件包括 Lifecycle, LifecycleOwner, LifecycleObserver 三个主要类：</p>\n<ul>\n<li>Lifecycle 类持有 Fragment 和 Activity (LifecycleOwner) 的生命周期状态信息，并且允许其他对象(LifecycleObserver)观察这些信息。</li>\n<li>LifecycleOwner 仅有一个 getLifecycle() 方法，用于返回当前对象的 Lifecycle。</li>\n<li>LifecycleObserver，代表观察者</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LifecyclerOwner和LifecycleObserver</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleOwner是Lifecycle组件包中的一个接口，所有需要管理生命周期的类型都必须实现这个接口，是被观察者。<br>LifecycleOwner#getLifecycle()返回Lifecycle实例. 这是一种解耦实现, LifecycleOwner不包含任何有关生命周期管理的逻辑, 实际的逻辑都在Lifecycle实例中, 我们可以通过传递Lifecycle实例而非LifecycleOwner来防止内存泄漏。<br>并不是所有的google官方的Activity和Fragment类都实现了LifecycleOwner接口, 实现了这个接口有FragmentActivity，AppCompatActivity和v4包下的Fragment。<br>LifecycleObserver接口代表生命周期的观察者，它的实现为空。实现LifecycleObserver的类要想感知到生命周期的变化需要借助额外的注解。或者，也可以使用一些继承了LifecycleObserver的子接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;     </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">voidactivityResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lifecycle中的state和event\"><a href=\"#Lifecycle中的state和event\" class=\"headerlink\" title=\"Lifecycle中的state和event\"></a>Lifecycle中的state和event</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> State &#123;</span><br><span class=\"line\">    DESTROYED,</span><br><span class=\"line\">    INITIALIZED,</span><br><span class=\"line\">    CREATED,</span><br><span class=\"line\">    STARTED,</span><br><span class=\"line\">    RESUMED;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAtLeast</span><span class=\"params\">(@NonNull State state)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compareTo(state) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Event &#123;</span><br><span class=\"line\">    ON_CREATE,</span><br><span class=\"line\">    ON_START,</span><br><span class=\"line\">    ON_RESUME,</span><br><span class=\"line\">    ON_PAUSE,</span><br><span class=\"line\">    ON_STOP,</span><br><span class=\"line\">    ON_DESTROY,</span><br><span class=\"line\">    ON_ANY <span class=\"comment\">// ON_ANY代表任意时间</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lifecycle的获取生命周期的变化\"><a href=\"#Lifecycle的获取生命周期的变化\" class=\"headerlink\" title=\"Lifecycle的获取生命周期的变化\"></a>Lifecycle的获取生命周期的变化</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SupportActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleOwner</span>, <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LifecycleRegistry mLifecycleRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        ReportFragment.injectIfNeededIn(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSaveInstanceState</span><span class=\"params\">(Bundle outState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mLifecycleRegistry.markState(State.CREATED);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onSaveInstanceState(outState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Lifecycle <span class=\"title\">getLifecycle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.mLifecycleRegistry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleRegistry继承了Lifecycle。SupportActivity是FragmentActivity的父类。在SupportActivity中找不到state和event分发相关的代码，这些相关内容是在ReportFragment中实现的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReportFragment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Fragment</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">injectIfNeededIn</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            manager.beginTransaction().add(<span class=\"keyword\">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class=\"line\"></span><br><span class=\"line\">            manager.executePendingTransactions();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onStart();</span><br><span class=\"line\">        dispatchStart(mProcessListener);</span><br><span class=\"line\">        dispatch(Lifecycle.Event.ON_START);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatch</span><span class=\"params\">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        Activity activity = getActivity();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activity <span class=\"keyword\">instanceof</span> LifecycleOwner) &#123;</span><br><span class=\"line\">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lifecycle <span class=\"keyword\">instanceof</span> LifecycleRegistry) &#123;</span><br><span class=\"line\">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"LifecycleRegistry-addObserver\"><a href=\"#LifecycleRegistry-addObserver\" class=\"headerlink\" title=\"LifecycleRegistry#addObserver\"></a>LifecycleRegistry#addObserver</h3><p>LifecycleRegistry继承了Lifecycle，是Activity和Fragment生命周期的真正管理类。 这个类里面的很多逻辑有点绕，我不太能理清楚。主要看一下addObserver这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleRegistry</span> <span class=\"keyword\">extends</span> <span class=\"title\">Lifecycle</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> FastSafeIterableMap&lt;LifecycleObserver, ObserverWithState&gt; mObserverMap = <span class=\"keyword\">new</span> FastSafeIterableMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的state</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> State mState;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// observer的state初始化为DESTROYED或者INITIALIZED</span></span><br><span class=\"line\">        State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class=\"line\">        ObserverWithState statefulObserver = <span class=\"keyword\">new</span> ObserverWithState(observer, initialState);</span><br><span class=\"line\">        ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lifecycleOwner == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// it is null we should be destroyed. Fallback quickly</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isReentrance = mAddingObserverCounter != <span class=\"number\">0</span> || mHandlingEvent;</span><br><span class=\"line\">        <span class=\"comment\">// 得到一个目标state</span></span><br><span class=\"line\">        State targetState = calculateTargetState(observer);</span><br><span class=\"line\">        mAddingObserverCounter++;</span><br><span class=\"line\">        <span class=\"comment\">// 当observer被add进来的时候，会进入循环，分发事件，直到observer的state==targetState</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class=\"line\">            pushParentState(statefulObserver.mState);</span><br><span class=\"line\">            <span class=\"comment\">// 这里的upEvent(state)会导致statefulObserver.mState在分发的过程中不断更新</span></span><br><span class=\"line\">            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class=\"line\">            popParentState();</span><br><span class=\"line\">            <span class=\"comment\">// mState / subling may have been changed recalculate</span></span><br><span class=\"line\">            targetState = calculateTargetState(observer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isReentrance) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// we do sync only on the top level.</span></span><br><span class=\"line\">            sync();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAddingObserverCounter--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> State <span class=\"title\">calculateTargetState</span><span class=\"params\">(LifecycleObserver observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的previous指前一个加入进来的Observer</span></span><br><span class=\"line\">        Entry&lt;LifecycleObserver, ObserverWithState&gt; previous = mObserverMap.ceil(observer);</span><br><span class=\"line\">    </span><br><span class=\"line\">        State siblingState = previous != <span class=\"keyword\">null</span> ? previous.getValue().mState : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这个mParentStates不知道是啥。。。</span></span><br><span class=\"line\">        State parentState = !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - <span class=\"number\">1</span>)</span><br><span class=\"line\">                : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这里的min(x, y)是 返回在枚举中order最小的state</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> min(min(mState, siblingState), parentState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在addObserver中，ObserverWithState将state和observer包装一下，ObserverWithState内初始的state是DESTROYED或者INITIALIZED。之后会计算一个targetState，在while循环中会不断的分发和更新event。</p>\n<p>具体效果看下面的demo：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    handler.postDelayed(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            TestActivity.<span class=\"keyword\">this</span>.getLifecycle().addObserver(<span class=\"keyword\">new</span> GenericLifecycleObserver() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">                    Log.i(<span class=\"string\">\"chenlei\"</span>, <span class=\"string\">\"onStateChanged: \"</span> + event);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的GenericLifecycleObserver继承了LifecycleObserver的接口。demo中在create方法里延时5s添加一个LifecycleObserver并打印event。最后打印输出如下：</p>\n<p>可以看到从ON_CREATE到ON_RESUME在同一时刻都打印出来了</p>\n<h3 id=\"ProcessLifecycleOwner\"><a href=\"#ProcessLifecycleOwner\" class=\"headerlink\" title=\"ProcessLifecycleOwner\"></a>ProcessLifecycleOwner</h3><p>ProcessLifecycleOwner实现了LifecycleOwner接口，可以监听当前应用前后台切换，并对此进行响应。<br>这个类提供整个应用进程的生命周期。<br>你可以将这个 LifecycleOwner 作为全体 Activity 的 LifecycleOwner，Lifecycle.Event.ON_CREATE 事件只会分发一次，而 Lifecycle.Event.ON_DESTROY 永远不被分发。其他事件的分发遵守以下规则：<br>ProcessLifecycleOwner 会在第一个 Activity 经历 Lifecycle.Event.ON_START 和 Lifecycle.Event.ON_RESUME 事件时分发这些事件。 ProcessLifecycleOwner 会在最后一个 Activity 经历 Lifecycle.Event.ON_PAUSE 和 Lifecycle.Event.ON_STOP 事件 延迟一段时间 分发这些事件。这个延时足够长以确保 ProcessLifecycleOwner 不会在 Activity 由于配置变更而销毁重建期间发送任何事件。<br>这个类非常适用于对 app 前后台状态切换时进行响应、且对生命周期不要求毫秒级准确性的场景。<br>使用的时候，在Application中添加LifecycleObserver就可以了(实际上，在应用进程中的任意位置都可以）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ApplicationObserver(val analytics: Analytics) : LifecycleObserver &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">onBackground</span><span class=\"params\">()</span> </span>&#123;    &#125;   </span><br><span class=\"line\">    <span class=\"meta\">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class=\"line\">    <span class=\"function\">fun <span class=\"title\">onForeground</span><span class=\"params\">()</span> </span>&#123;    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">        ProcessLifecycleOwner.get().getLifecycle().addObserver(<span class=\"keyword\">new</span> ApplicationObserver());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原理：</p>\n<p>ProcessLifecycleOwnerInitializer<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProcessLifecycleOwnerInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ContentProvider</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        LifecycleDispatcher.init(getContext());</span><br><span class=\"line\">        ProcessLifecycleOwner.init(getContext());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个类是ProcessLifecycleOwner初始化的地方，它继承了一个ContentProvider ，这个ContentProvider声明在了Lifecycle包的AndroidManifest.xml里。</p>\n<p>这个AndroidManifest.xml最终会合并入我们app module 的AndroidManifest.xml文件中。<br>这里利用了 ContentProvider 的隐式加载。它的 onCreate() 方法执行时机是在Application 的 onCreate()方法之前。这样它就能通过 Application 来监听 Activity 的创建。</p>\n<p>LifecycleDispatcher#init<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleDispatcher</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicBoolean sInitialized = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sInitialized.getAndSet(<span class=\"keyword\">true</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ((Application) context.getApplicationContext())</span><br><span class=\"line\">                .registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> DispatcherActivityCallback());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherActivityCallback</span> <span class=\"keyword\">extends</span> <span class=\"title\">EmptyActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            ReportFragment.injectIfNeededIn(activity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在Application中注册一个ActivityLifecycleCallbacks，在ActivityLifecycleCallbacks中有Activity所有生命周期的回调，这样就能监听到每一个Activity的创建和销毁。在onActivityCreated回调中往Activity注入一个了ReportFragment，我没看出来这里的ReportFragment的作用是什么。。</p>\n<p>ProcessLifecycleOwner</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProcessLifecycleOwner</span> <span class=\"keyword\">implements</span> <span class=\"title\">LifecycleOwner</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> LifecycleRegistry mRegistry = <span class=\"keyword\">new</span> LifecycleRegistry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessLifecycleOwner sInstance = <span class=\"keyword\">new</span> ProcessLifecycleOwner();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        sInstance.attach(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ActivityInitializationListener mInitializationListener =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> ActivityInitializationListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                activityStarted();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResume</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                activityResumed();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> Handler();</span><br><span class=\"line\">        mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class=\"line\">        Application app = (Application) context.getApplicationContext();</span><br><span class=\"line\">        app.registerActivityLifecycleCallbacks(<span class=\"keyword\">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityCreated</span><span class=\"params\">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//在ReportFragment的生命周期中会有dispatchXxxx(mProcessListener)</span></span><br><span class=\"line\">                ReportFragment.get(activity)</span><br><span class=\"line\">                                .setProcessListener(mInitializationListener);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityPaused</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">                activityPaused();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onActivityStopped</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">                activityStopped();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityResumed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mResumedCounter++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPauseSent) &#123;</span><br><span class=\"line\">                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class=\"line\">                mPauseSent = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activityPaused</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mResumedCounter--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 在mDelayedPauseRunnable中会调用这个方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchPauseIfNeeded</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mResumedCounter == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            mPauseSent = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-LiveData\"><a href=\"#2-LiveData\" class=\"headerlink\" title=\"2. LiveData\"></a>2. LiveData</h2><p>ViewModel和Lifecycles分别代表数据和UI两端，这两个组件是相对比较独立的，并没有太多直接的关系。为了防止内存泄漏，ViewModel不能直接持有activity和fragment的引用。为了让更好的结合ViewModel和Lifecycles，就需要LiveData。<br>LiveData是一种观察者模式, 在 Value发生变化时通知之前注册的所有观察者。同时，借助于Lifecycles，LiveData具有生命周期的感知能力。如果观察者（由 Observer 类表示）的生命周期处于 STARTED 或 RESUMED 状态，则 LiveData 会认为该观察者处于活跃状态。使用LiveData有以下的优点：</p>\n<ul>\n<li>LiveData 只会将消息通知给活跃的观察者，非活跃观察者将不会收到消息通知。</li>\n<li>当非活跃观察者状态变为活跃的时候，LiveData会将自动将最新的消息发送给它。</li>\n<li>当相应的 Lifecycle 对象的状态变为 DESTROYED 时，LiveData会自动的移除此观察者，这样就不用担心Fragment和Activity的内存泄漏。</li>\n<li>LiveData的数据发送和Observer的添加是没有顺序限制的。比如说LiveData在第1s发送消息，然后在第5s添加Observer，Observer依然能够立即接收到第1s发送出的数据，只要数据是当前最新的。这主要和LifecycleRegistry#addObserver的实现有关</li>\n</ul>\n<h3 id=\"2-1-LiveData的使用\"><a href=\"#2-1-LiveData的使用\" class=\"headerlink\" title=\"2.1 LiveData的使用\"></a>2.1 LiveData的使用</h3><h4 id=\"2-1-1-基本使用\"><a href=\"#2-1-1-基本使用\" class=\"headerlink\" title=\"2.1.1 基本使用\"></a>2.1.1 基本使用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; notifyCurrentName = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">post</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        notifyCurrentName.postValue(<span class=\"string\">\"value\"</span>);    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MutableLiveData&lt;String&gt; <span class=\"title\">getNotifyCurrentName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyCurrentName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在activity or fragment中</span></span><br><span class=\"line\"><span class=\"comment\">// public void observe(LifecycleOwner owner, Observer&lt;T&gt; observer) </span></span><br><span class=\"line\">getViewModel().getNotifyCurrentName().observer(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Stirng value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果不想让LiveData感知到生命周期，可以用observeForever(Observer&lt;T&gt; observer)</span></span><br><span class=\"line\">getViewModel().getNotifyCurrentName().observeForever(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(@Nullable Stirng value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-1-2-Transformations-map\"><a href=\"#2-1-2-Transformations-map\" class=\"headerlink\" title=\"2.1.2 Transformations#map\"></a>2.1.2 Transformations#map</h4><p>Transformations是用来做LiveData转换的类。<br>Transformations#map可以在消息分派给观察者之前对消息进行更改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LiveData&lt;User&gt; userLiveData = ...;</span><br><span class=\"line\">LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class=\"line\">    user.name + <span class=\"string\">\" \"</span> + user.lastName</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-1-3-Transformations-switchMap\"><a href=\"#2-1-3-Transformations-switchMap\" class=\"headerlink\" title=\"2.1.3 Transformations#switchMap\"></a>2.1.3 Transformations#switchMap</h4><p>switchMap可以实现LiveData的转换，下面是一个demo，通过switchMap切换LiveData的数据源</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapTestViewModel</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewModel</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; dataSourceA = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;String&gt; dataSourceB = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MutableLiveData&lt;Boolean&gt; changeDataSource = <span class=\"keyword\">new</span> MutableLiveData&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LiveData&lt;String&gt; notifyData = Transformations.switchMap(changeDataSource, <span class=\"keyword\">new</span> Function&lt;Boolean, LiveData&lt;String&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;String&gt; <span class=\"title\">apply</span><span class=\"params\">(Boolean input)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> input ? dataSourceA : dataSourceB;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        changeDataSource.setValue(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        Handler handler = <span class=\"keyword\">new</span> Handler(activity.getMainLooper());</span><br><span class=\"line\">        handler.postDelayed(() -&gt; &#123;</span><br><span class=\"line\">            dataSourceA.postValue(<span class=\"string\">\"data from source A\"</span>);</span><br><span class=\"line\">            dataSourceB.postValue(<span class=\"string\">\"data from source B\"</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        handler.postDelayed(() -&gt; &#123;</span><br><span class=\"line\">            changeDataSource(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;, <span class=\"number\">10000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">(<span class=\"keyword\">boolean</span> userA)</span> </span>&#123;</span><br><span class=\"line\">        changeDataSource.setValue(userA);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LiveData&lt;String&gt; <span class=\"title\">getNotifyData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> notifyData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// activity</span></span><br><span class=\"line\">viewModel.start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">viewModel.getNotifyData().observe(MapTestActivity.<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onChanged</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"chenlei\"</span>, <span class=\"string\">\"onChanged: \"</span> + s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的demo中，延时2s同时向dataSourceA和dataSourceB发送数据，并延时10s将数据源从A指向B。在observe中打印结果，最终dataSourceA和dataSourceB在间隔一段时间之后都能打印出来。<br>每次调用changeDataSource.setValue(Boolean)，都会调用Function#apply返回一个LiveData，并将notifyData的 Observer 添加到新的LiveData上</p>\n<h3 id=\"2-2-LiveData的原理\"><a href=\"#2-2-LiveData的原理\" class=\"headerlink\" title=\"2.2 LiveData的原理\"></a>2.2 LiveData的原理</h3><h4 id=\"2-2-1-LiveData\"><a href=\"#2-2-1-LiveData\" class=\"headerlink\" title=\"2.2.1 LiveData\"></a>2.2.1 LiveData</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存放Observer的集合</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SafeIterableMap&lt;Observer&lt;T&gt;, ObserverWrapper&gt; mObservers =                                                                 <span class=\"keyword\">new</span> SafeIterableMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> START_VERSION = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mActiveCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mVersion = START_VERSION;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 当LiveData的活跃Observer数量由0变成1的时候调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onActive</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当LiveData的活跃Observer数量由1变成0的时候调用</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onInactive</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Observer&lt;T&gt; mObserver;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> mActive;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mLastVersion = START_VERSION;</span><br><span class=\"line\">    </span><br><span class=\"line\">        ObserverWrapper(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">            mObserver = observer;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">activeStateChanged</span><span class=\"params\">(<span class=\"keyword\">boolean</span> newActive)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 活跃状态没有改变则return， 防止重复发送消息</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newActive == mActive) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mActive = newActive;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> wasInactive = LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span>;</span><br><span class=\"line\">            LiveData.<span class=\"keyword\">this</span>.mActiveCount += mActive ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class=\"line\">                onActive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (LiveData.<span class=\"keyword\">this</span>.mActiveCount == <span class=\"number\">0</span> &amp;&amp; !mActive) &#123;</span><br><span class=\"line\">                onInactive();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mActive) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 开始分发value</span></span><br><span class=\"line\">                dispatchingValue(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-2-LiveData-observer\"><a href=\"#2-2-2-LiveData-observer\" class=\"headerlink\" title=\"2.2.2 LiveData#observer\"></a>2.2.2 LiveData#observer</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"meta\">@MainThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observe</span><span class=\"params\">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LifecycleBoundObserver wrapper = <span class=\"keyword\">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class=\"line\">        ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将wrapper将入到lifecycleOwner的生命周期的监听中</span></span><br><span class=\"line\">        owner.getLifecycle().addObserver(wrapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LifecycleBoundObserver继承自ObserverWrapper，并且实现了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GenericLifecycleObserver接口。GenericLifecycleObserver接口继承自LifecycleObserver接口</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GenericLifecycleObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifecycleBoundObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">GenericLifecycleObserver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@NonNull</span> <span class=\"keyword\">final</span> LifecycleOwner mOwner;</span><br><span class=\"line\"></span><br><span class=\"line\">    LifecycleBoundObserver(<span class=\"meta\">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">        mOwner = owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过Lifecycle判断当前Observer是否活跃</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// GenericLifecycleObserver#onStatechanged</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStateChanged</span><span class=\"params\">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当LifecycleOwner已经被销毁，remove这个Observer。</span></span><br><span class=\"line\">            <span class=\"comment\">// removeObserver会调用detachObserver()和activeStateChanged(false)</span></span><br><span class=\"line\">            <span class=\"comment\">// 这也是为什么LiveData可以自动防止UI泄漏的原因</span></span><br><span class=\"line\">            removeObserver(mObserver);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        activeStateChanged(shouldBeActive());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isAttachedTo</span><span class=\"params\">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mOwner == owner;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">detachObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从LifecycleOwner中remove观察者</span></span><br><span class=\"line\">        mOwner.getLifecycle().removeObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>LiveData#observeForever</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">observeForever</span><span class=\"params\">(@NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class=\"line\">    AlwaysActiveObserver wrapper = <span class=\"keyword\">new</span> AlwaysActiveObserver(observer);</span><br><span class=\"line\">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (existing != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 因为observeForever没有LifecycleOwner，为了保持和普通observe方法的特性一致，在添加observe之后立刻检查是否有数据可以发送，</span></span><br><span class=\"line\">    wrapper.activeStateChanged(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlwaysActiveObserver</span> <span class=\"keyword\">extends</span> <span class=\"title\">ObserverWrapper</span> </span>&#123;</span><br><span class=\"line\">    AlwaysActiveObserver(Observer&lt;T&gt; observer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">shouldBeActive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-3-LiveData-postValue\"><a href=\"#2-2-3-LiveData-postValue\" class=\"headerlink\" title=\"2.2.3 LiveData#postValue()\"></a>2.2.3 LiveData#postValue()</h4><p>LiveData发送消息使用setValue或者postValue方法。其中setValue只能在主线程中使用，postValue发送消息时会自动切换到主线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveData</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable mPostValueRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            setValue((T) newValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">postValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">LiveData#setValue</span><br><span class=\"line\"><span class=\"meta\">@MainThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    assertMainThread(<span class=\"string\">\"setValue\"</span>);</span><br><span class=\"line\">    mVersion++;</span><br><span class=\"line\">    mData = value;</span><br><span class=\"line\">    dispatchingValue(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">dispatchingValue</span><span class=\"params\">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDispatchingValue) &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        mDispatchInvalidated = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (initiator != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向特定的Observer发送数据</span></span><br><span class=\"line\">            considerNotify(initiator);</span><br><span class=\"line\">            initiator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向所有Observer发送消息</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class=\"line\">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class=\"line\">                considerNotify(iterator.next().getValue());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mDispatchInvalidated) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (mDispatchInvalidated);</span><br><span class=\"line\">    mDispatchingValue = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">considerNotify</span><span class=\"params\">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.mActive) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class=\"line\">        observer.activeStateChanged(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将要发送的是旧版本，扔掉</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    observer.mLastVersion = mVersion;</span><br><span class=\"line\">    observer.mObserver.onChanged((T) mData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"nested2嵌套滚动机制","date":"2021-07-24T08:36:31.000Z","_content":"\n## 开头\nnested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。\n\n## NestedScrollingParent2\n\nNestedScrollingParent2 包含以下接口\n\n```java\npublic interface NestedScrollingParent2 extends NestedScrollingParent {\n/**\n    * 即将开始嵌套滑动，此时嵌套滑动尚未开始，由子控件的 startNestedScroll 方法调用\n    *\n    * @param child  嵌套滑动对应的父类的子类(因为嵌套滑动对于的父控件不一定是一级就能找到的，可能挑了两级父控件的父控件，child的辈分>=target)\n    * @param target 具体嵌套滑动的那个子类\n    * @param axes   嵌套滑动支持的滚动方向\n    * @param type   嵌套滑动的类型，有两种ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    * @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行下面的 onNestedScrollAccepted 等操作\n    */\n   boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes,\n           @NestedScrollType int type);\n\n   /**\n    * 当onStartNestedScroll返回为true时，也就是父控件接受嵌套滑动时，该方法才会调用\n    *\n    * @param child\n    * @param target\n    * @param axes\n    * @param type\n    */\n   void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes,\n           @NestedScrollType int type);\n\n   /**\n    * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件\n    * 在嵌套滑动的子View未滑动之前\n    * ，判断父view是否优先与子view处理(也就是父view可以先消耗，然后给子view消耗）\n    *\n    * @param target   具体嵌套滑动的那个子类\n    * @param dx       水平方向嵌套滑动的子View想要变化的距离\n    * @param dy       垂直方向嵌套滑动的子View想要变化的距离 dy<0向下滑动 dy>0 向上滑动\n    * @param consumed 这个参数要我们在实现这个函数的时候指定，回头告诉子View当前父View消耗的距离\n    *                 consumed[0] 水平消耗的距离，consumed[1] 垂直消耗的距离 好让子view做出相应的调整\n    * @param type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    */\n   void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed,\n           @NestedScrollType int type);\n           \n   /**\n    * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，\n    * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件\n    *\n    * @param target       具体嵌套滑动的那个子类\n    * @param dxConsumed   水平方向嵌套滑动的子控件滑动的距离(消耗的距离)\n    * @param dyConsumed   垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)\n    * @param dxUnconsumed 水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)\n    * @param dyUnconsumed 垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)\n    * @param type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    */\n   void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed,\n           int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type);\n\n    /**\n    * 停止滑动\n    *\n    * @param target\n    * @param type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    */\n void onStopNestedScroll(@NonNull View target, @NestedScrollType int type);\n}\n```\n\n## NestedScrollingChild2\n```java\npublic interface NestedScrollingChild2 extends NestedScrollingChild {\n\n   /**\n    * 开始滑动前调用，在惯性滑动和触摸滑动前都会进行调用，此方法一般在 onInterceptTouchEvent或者onTouch中，通知父类方法开始滑动\n    * 会调用父类方法的 onStartNestedScroll onNestedScrollAccepted 两个方法\n    *\n    * @param axes 滑动方向\n    * @param type 开始滑动的类型 the type of input which cause this scroll event\n    * @return 有父视图并且开始滑动，则返回true 实际上就是看parent的 onStartNestedScroll 方法\n    */\n   boolean startNestedScroll(@ScrollAxis int axes, @NestedScrollType int type);\n\n  /**\n    * 子控件停止滑动，例如手指抬起，惯性滑动结束\n    *\n    * @param type 停止滑动的类型 TYPE_TOUCH，TYPE_NON_TOUCH\n    */\n   void stopNestedScroll(@NestedScrollType int type);\n\n    /**\n    * 判断是否有父View 支持嵌套滑动\n    */\n   boolean hasNestedScrollingParent(@NestedScrollType int type);\n\n /**\n    * 在dispatchNestedPreScroll 之后进行调用\n    * 当滑动的距离父控件消耗后，父控件将剩余的距离再次交个子控件，\n    * 子控件再次消耗部分距离后，又继续将剩余的距离分发给父控件,由父控件判断是否消耗剩下的距离。\n    * 如果四个消耗的距离都是0，则表示没有神可以消耗的了，会直接返回false，否则会调用父控件的\n    * onNestedScroll 方法，父控件继续消耗剩余的距离\n    * 会调用父控件的\n    *\n    * @param dxConsumed     水平方向嵌套滑动的子控件滑动的距离(消耗的距离)    dx<0 向右滑动 dx>0 向左滑动 （保持和 RecycleView 一致）\n    * @param dyConsumed     垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)    dy<0 向下滑动 dy>0 向上滑动 （保持和 RecycleView 一致）\n    * @param dxUnconsumed   水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dx<0 向右滑动 dx>0 向左滑动 （保持和 RecycleView 一致）\n    * @param dyUnconsumed   垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dy<0 向下滑动 dy>0 向上滑动 （保持和 RecycleView 一致）\n    * @param offsetInWindow 子控件在当前window的偏移量\n    * @return 如果返回true, 表示父控件又继续消耗了\n    */\n   boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,\n           int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow,\n           @NestedScrollType int type);\n\n   /**\n    * 子控件在开始滑动前，通知父控件开始滑动，同时由父控件先消耗滑动时间\n    * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离\n    * 最终会调用父view的 onNestedPreScroll 方法\n    *\n    * @param dx             水平方向嵌套滑动的子控件想要变化的距离 dx<0 向右滑动 dx>0 向左滑动 （保持和 RecycleView 一致）\n    * @param dy             垂直方向嵌套滑动的子控件想要变化的距离 dy<0 向下滑动 dy>0 向上滑动 （保持和 RecycleView 一致）\n    * @param consumed       父控件消耗的距离，父控件消耗完成之后，剩余的才会给子控件，子控件需要使用consumed来进行实际滑动距离的处理\n    * @param offsetInWindow 子控件在当前window的偏移量\n    * @param type           滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    * @return true    表示父控件进行了滑动消耗，需要处理 consumed 的值，false表示父控件不对滑动距离进行消耗，可以不考虑consumed数据的处理，此时consumed中两个数据都应该为0\n    */\n   boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed,\n           @Nullable int[] offsetInWindow, @NestedScrollType int type);\n}\n```\n\n## nested2机制，滚动的传递\n\n一般情况下，事件是从child的触摸事件开始的，\n\n1. 首先调用 `child.startNestedScroll()` 方法，此方法内部通过 `NestedScrollingChildHelper` 调用并返回 `parent.onStartNestedScroll()` 方法的结果，为 true，说明parent接受了嵌套滑动，同时会调用 `parent.onNestedScrollAccepted()` 方法，此时开始嵌套滑动；\n\n2. 在滑动事件中，child通过 `child.dispatchNestedPreScroll()` 方法分配滑动的距离，内部会先调用 `parent.onNestedPreScroll()` 方法，由parent先处理滑动距离。\n\n3. parent消耗完成之后，再将剩余的距离传递给child，child拿到parent使用完成之后的距离之后，自己再处理剩余的距离。\n\n4. 如果此时子控件还有未处理的距离，则将剩余的距离再次通过 `child.dispatchNestedScroll()` 方法调用 `parent.onNestedScroll()` 方法，将剩余的距离交个parent来进行处理\n\n5. 滑动结束之后，调用 child.stopNestedScroll()通知parent滑动结束，至此，触摸滑动结束\n\n触摸滑动结束之后，child会继续进行惯性滑动，惯性滑动可以通过 Scroller 实现，具体滑动可以自己来处理，在fling过程中，和触摸滑动调用流程一样，需要注意 type 参数的区分，用来通知parent两种不同的滑动流程\n\n## 一个栗子\n\n### 预期目标\n自己实现一个嵌套滚动的 parent 和 child， 满足以下效果\n1. parent 包含 top 和 content 两部分，可滚动\n2. 当 top 未完全隐藏是，滚动 content ，是外层的 parent 滚动\n3. 当 top 完全隐藏，触摸滚动 content ，content 自己滚动\n4. 当触摸 content 滚动到顶部， top 未完全漏出， 则 parent 滚动，直至 top 完全露出\n\n### xml布局\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <com.example.test2.nest2_test.CustomNestedParent\n        android:id=\"@+id/nested_parent\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <LinearLayout\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\">\n\n            <androidx.core.widget.NestedScrollView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\">\n\n                <LinearLayout\n                    android:id=\"@+id/view_top\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"wrap_content\"\n                    android:background=\"@color/colorAccent\"\n                    android:orientation=\"vertical\">\n\n                    <View\n                        android:layout_width=\"match_parent\"\n                        android:layout_height=\"200dp\" />\n                </LinearLayout>\n            </androidx.core.widget.NestedScrollView>\n\n            <com.example.test2.nest2_test.CustomNestedChild\n                android:id=\"@+id/view_list\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"1500dp\" />\n        </LinearLayout>\n    </com.example.test2.nest2_test.CustomNestedParent>\n</LinearLayout>\n```\n这里模仿 ScrollView 嵌套 ScrollView 的场景，即外部的 CustomNestedParent 嵌套 内部的 CustomNestedChild ，并解决他们的之间的滑动冲突\ntopVie2 外面包裹了一层 NestedScrollView，是为了让它支持 nested 机制\n\n```kotlin\nclass NestedTestActivity : AppCompatActivity() {\n\n    private lateinit var nestedParent: CustomNestedParent\n    private lateinit var listView: LinearLayout\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContentView(R.layout.activity_nested_test)\n\n        nestedParent = findViewById(R.id.nested_parent)\n        val topView: View = findViewById(R.id.view_top)\n        listView = findViewById(R.id.view_list)\n\n        nestedParent.init(topView, listView)\n\n        addListItems()\n    }\n\n    private fun addListItems() {\n      // 填充 child， 这里模拟 child 是一个 recyclerview\n        for (i in 0 until 100) {\n            val textView = TextView(this)\n            textView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 100)\n            textView.text = \"position $i\"\n            listView.addView(textView)\n        }\n    }\n}\n```\n\n### CustomNestedParent\n```kotlin\nclass CustomNestedParent @JvmOverloads constructor(\n    context: Context?,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingParent2 {\n\n    val TAG = \"CustomNestedParent\"\n\n    private val mNestedScrollingParentHelper = NestedScrollingParentHelper(this)\n    private lateinit var topView: View\n    private lateinit var nestedChild: View\n    private var childrenHeight = 0\n\n    override fun onFinishInflate() {\n        super.onFinishInflate()\n    }\n\n    fun init(topView: View, contentView: View) {\n        this.topView = topView\n        this.nestedChild = contentView\n    }\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n      // 模仿 NestedScrollView\n        var height = MeasureSpec.getSize(heightMeasureSpec)\n        var width = MeasureSpec.getSize(widthMeasureSpec)\n        childrenHeight = 0\n        for (i in 0 until childCount) {\n            val child = getChildAt(i)\n            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)\n            childrenHeight += child.measuredHeight\n        }\n        setMeasuredDimension(width, height)\n    }\n\n    // @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行其他操作\n    override fun onStartNestedScroll(child: View, target: View, axes: Int, type: Int): Boolean {\n        Log.i(TAG, \"onStartNestedScroll: \")\n        return axes == ViewCompat.SCROLL_AXIS_VERTICAL\n    }\n\n    // 当嵌套滑动被parent接收了，会回调这个方法\n    override fun onNestedScrollAccepted(child: View, target: View, axes: Int, type: Int) {\n        Log.i(TAG, \"onNestedScrollAccepted: \")\n        mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes, type)\n    }\n\n    /**\n     * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件\n     * 不管手势滚动还是fling都会回调这个方法\n     */\n    override fun onNestedPreScroll(target: View, dx: Int, dy: Int, consumed: IntArray, type: Int) {\n        val threshold = nestedChild.top\n        var parentScrollable = false\n\n        val hideTop = dy > 0 && scrollY < threshold\n        val showTop = dy < 0 && !target.canScrollVertically(-1)\n        Log.i(TAG, \"onNestedPreScroll-1: $dy $type\")\n        if (hideTop || showTop) {\n          // parent 提前消费的场景 \n          // 1. 向上滚动，parent滚动的距离 < topView的高度，需要隐藏topView \n          // 2. 向下滚动，且 child 已经滚动到顶部，需要漏出 topView\n            parentScrollable = true\n            consumed[1] = dy\n            scrollBy(0, dy)\n            Log.i(TAG, \"onNestedPreScroll-2: hideTop=$hideTop showTop=$showTop dy=$dy scrollY=$scrollY threshold=$threshold type=$type\")\n        } else {\n            // 反之，应该让 child 滚动，parent不应该消费滚动距离\n            parentScrollable = false\n        }\n    }\n\n    /**\n     * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，\n     * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件\n     *\n     * 孩子吃剩下的留给爸爸了\n     */\n    override fun onNestedScroll(\n        target: View,\n        dxConsumed: Int,\n        dyConsumed: Int,\n        dxUnconsumed: Int,\n        dyUnconsumed: Int,\n        type: Int\n    ) {\n        Log.i(TAG, \"onNestedScroll: $dyUnconsumed $type $scrollY\")\n        // 剩余的parent全部消费\n        scrollBy(0, dyUnconsumed)\n    }\n\n    override fun onStopNestedScroll(target: View, type: Int) {\n        mNestedScrollingParentHelper.onStopNestedScroll(target, type);\n    }\n\n    override fun getNestedScrollAxes(): Int {\n        return mNestedScrollingParentHelper.nestedScrollAxes\n    }\n\n    override fun scrollTo(x: Int, y: Int) {\n        var resY = y\n        // 限定 parnet 的上下边界，防止滚动出屏幕外\n        if (resY < 0) {\n            resY = 0\n        }\n        val max = max(childrenHeight - height, 0)\n        if (y > max) {\n            resY = max\n        }\n        Log.i(TAG, \"scrollTo: $max $y $resY\")\n        super.scrollTo(x, resY)\n    }\n}\n```\n\n### CustomNestedChild\n\n```kotlin\nclass CustomNestedChild @JvmOverloads constructor(\n    context: Context?,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingChild2 {\n\n    val TAG = \"CustomNestedChild\"\n\n    private val mScrollingChildHelper = NestedScrollingChildHelper(this)\n\n    private val viewConfiguration: ViewConfiguration = ViewConfiguration.get(context)\n    private var mVelocityTracker: VelocityTracker? = null\n\n    private val mScroller: Scroller = Scroller(context)\n\n    private var mLastX: Float = 0f\n    private var mLastY: Float = 0f\n    private var mLastFlingX: Float = 0f\n    private var mLastFlingY: Float = 0f\n\n    private val offset = IntArray(2)\n    private val consumed = IntArray(2)\n    private var fling = false //判断当前是否是可以进行惯性滑动\n\n    private var childrenHeight = 0\n\n    init {\n        orientation = VERTICAL\n        // 这里必须都设置为 true ，表明这个view是支持nested2机制的\n        isNestedScrollingEnabled = true\n        mScrollingChildHelper.isNestedScrollingEnabled = true\n    }\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        var height = MeasureSpec.getSize(heightMeasureSpec)\n        var width = MeasureSpec.getSize(widthMeasureSpec)\n        childrenHeight = 0\n        for (i in 0 until childCount) {\n            val child = getChildAt(i)\n            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)\n            childrenHeight += child.measuredHeight\n        }\n        setMeasuredDimension(width, height)\n    }\n\n    override fun startNestedScroll(axes: Int, type: Int): Boolean {\n        return mScrollingChildHelper.startNestedScroll(axes, type)\n    }\n\n    override fun stopNestedScroll(type: Int) {\n        mScrollingChildHelper.stopNestedScroll(type)\n    }\n\n    override fun hasNestedScrollingParent(type: Int): Boolean {\n        return mScrollingChildHelper.hasNestedScrollingParent()\n    }\n\n    override fun dispatchNestedPreScroll(\n        dx: Int,\n        dy: Int,\n        consumed: IntArray?,\n        offsetInWindow: IntArray?,\n        type: Int\n    ): Boolean {\n        return mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type)\n    }\n\n    override fun dispatchNestedScroll(\n        dxConsumed: Int,\n        dyConsumed: Int,\n        dxUnconsumed: Int,\n        dyUnconsumed: Int,\n        offsetInWindow: IntArray?,\n        type: Int\n    ): Boolean {\n        return mScrollingChildHelper.dispatchNestedScroll(\n            dxConsumed,\n            dyConsumed,\n            dxUnconsumed,\n            dyUnconsumed,\n            offsetInWindow,\n            type\n        )\n    }\n\n    override fun onTouchEvent(event: MotionEvent): Boolean {\n        // 处理触摸事件是，关闭fling\n        cancelFling()\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain()\n        }\n        val velocityTracker = mVelocityTracker!!\n        velocityTracker.addMovement(event)\n\n        when (event.action) {\n            MotionEvent.ACTION_DOWN -> {\n                mLastX = event.x\n                mLastY = event.y\n                // 表明开始处理嵌套滚动， TYPE_TOUCH 表明这是一个触摸场景\n                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH)\n            }\n            MotionEvent.ACTION_MOVE -> {\n                val curX = event.x\n                val curY = event.y\n                var dy = (mLastY - curY).toInt()\n                var dx = (mLastX - curX).toInt()\n                // 先交给parent处理\n                if (dispatchNestedPreScroll(dx, dy, consumed, offset, TYPE_TOUCH)) {\n                    dy -= consumed[1]\n                    dx -= consumed[0]\n                }\n                // child自己消费\n                val consumedY = childConsumeY(dy)\n                // 将消费剩下的，传递给parent\n                dispatchNestedScroll(0, consumedY, dx, dy - consumedY, null, TYPE_TOUCH)\n                mLastX = curX\n                mLastY = curY\n            }\n            MotionEvent.ACTION_UP,\n            MotionEvent.ACTION_CANCEL -> {\n              // 先结束 TYPE_TOUCH 场景的嵌套滚动\n                stopNestedScroll(TYPE_TOUCH)\n\n                // 判断是否需要惯性滑动\n                velocityTracker.computeCurrentVelocity(\n                    1000,\n                    viewConfiguration.scaledMaximumFlingVelocity.toFloat()\n                )\n                val yvel = velocityTracker.yVelocity\n                fling(yvel.toInt())\n                velocityTracker.clear()\n            }\n        }\n        return true\n    }\n\n    private fun fling(velocityY: Int) {\n        cancelFling()\n\n        //判断速度是否足够大。如果够大才执行fling\n        var dy: Int = velocityY\n        if (abs(velocityY) < viewConfiguration.scaledMinimumFlingVelocity) {\n            dy = 0\n        }\n        if (dy == 0) {\n            return\n        }\n\n        // 这步必须要有，表明开始 TYPE_NON_TOUCH 的嵌套滚动\n        // 如果不设置，后续的嵌套滚动流程都都会找不到对应的parent\n        startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_NON_TOUCH)\n\n        val maxFlingVelocity: Int = viewConfiguration.scaledMaximumFlingVelocity\n        dy = max(-maxFlingVelocity, min(dy, maxFlingVelocity))\n\n        Log.i(TAG, \"fling: $dy \")\n        fling = true\n        // 开始fling\n        mScroller.fling(\n            0,\n            0,\n            0,\n            dy,\n            Integer.MIN_VALUE,\n            Integer.MAX_VALUE,\n            Integer.MIN_VALUE,\n            Integer.MAX_VALUE\n        )\n        postInvalidate()\n    }\n\n    override fun computeScroll() {\n        if (mScroller.computeScrollOffset() && fling) {\n            val y = mScroller.currY\n            var dy = (mLastFlingY - y).toInt()\n            mLastFlingY = y.toFloat()\n            // 和触摸场景一样，优先让parent处理\n            if (dispatchNestedPreScroll(0, dy, consumed, null, TYPE_NON_TOUCH)) {\n                dy -= consumed[1]\n            }\n            Log.i(TAG, \"computeScroll: ${consumed[1]} $dy\")\n            // child 自己处理\n            val consumedY = childFling(dy)\n            // 将剩下的在传递给 parent\n            dispatchNestedScroll(0, consumedY, 0, dy - consumedY, null, TYPE_NON_TOUCH)\n            postInvalidate()\n        } else {\n            stopNestedScroll(TYPE_NON_TOUCH)\n            cancelFling()\n        }\n    }\n\n    private fun childConsumeY(dy: Int): Int {\n        var consumed = dy\n        if (consumed < 0) {\n            // 如果滑动到顶部，只处理部分，不然可能无法触达顶部边界\n            consumed = max(-scrollY, consumed)\n        } else {\n            // 如果滑动到顶部，只处理部分，不然可能会无法触达底部边界\n            val max = max(childrenHeight - height, 0)\n            if (dy + scrollY > max) {\n                consumed = max - scrollY\n            }\n        }\n        Log.i(TAG, \"childConsumeY: $dy $consumed $scrollY\")\n        scrollBy(0, consumed)\n        return consumed\n    }\n\n    private fun childFling(dy: Int): Int {\n        return childConsumeY(dy)\n    }\n\n    private fun cancelFling() {\n        fling = false\n        mLastFlingY = 0f\n        mLastFlingY = 0f\n    }\n\n    override fun scrollTo(x: Int, y: Int) {\n        var resY = y\n        if (resY < 0) {\n            resY = 0\n        }\n        val max = max(childrenHeight - height, 0)\n        if (y > max) {\n            resY = max\n        }\n        Log.i(TAG, \"scrollTo: $max $y $resY\")\n        super.scrollTo(x, resY)\n    }\n\n    override fun canScrollVertically(direction: Int): Boolean {\n        if (direction < 0 && scrollY <= 0) {\n            return false\n        } else if (direction > 0 && scrollY >= measuredHeight - height) {\n            return false\n        } else {\n            return true\n        }\n    }\n}\n```\n\n[https://juejin.cn/post/6844903960432607246#heading-1](https://juejin.cn/post/6844903960432607246#heading-1)\n\n\n\n\n","source":"_posts/Android/nested2嵌套滚动机制.md","raw":"---\ntitle: nested2嵌套滚动机制\ndate: 2021-07-24 16:36:31\ntags:\n- nested2\n---\n\n## 开头\nnested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。\n\n## NestedScrollingParent2\n\nNestedScrollingParent2 包含以下接口\n\n```java\npublic interface NestedScrollingParent2 extends NestedScrollingParent {\n/**\n    * 即将开始嵌套滑动，此时嵌套滑动尚未开始，由子控件的 startNestedScroll 方法调用\n    *\n    * @param child  嵌套滑动对应的父类的子类(因为嵌套滑动对于的父控件不一定是一级就能找到的，可能挑了两级父控件的父控件，child的辈分>=target)\n    * @param target 具体嵌套滑动的那个子类\n    * @param axes   嵌套滑动支持的滚动方向\n    * @param type   嵌套滑动的类型，有两种ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    * @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行下面的 onNestedScrollAccepted 等操作\n    */\n   boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes,\n           @NestedScrollType int type);\n\n   /**\n    * 当onStartNestedScroll返回为true时，也就是父控件接受嵌套滑动时，该方法才会调用\n    *\n    * @param child\n    * @param target\n    * @param axes\n    * @param type\n    */\n   void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes,\n           @NestedScrollType int type);\n\n   /**\n    * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件\n    * 在嵌套滑动的子View未滑动之前\n    * ，判断父view是否优先与子view处理(也就是父view可以先消耗，然后给子view消耗）\n    *\n    * @param target   具体嵌套滑动的那个子类\n    * @param dx       水平方向嵌套滑动的子View想要变化的距离\n    * @param dy       垂直方向嵌套滑动的子View想要变化的距离 dy<0向下滑动 dy>0 向上滑动\n    * @param consumed 这个参数要我们在实现这个函数的时候指定，回头告诉子View当前父View消耗的距离\n    *                 consumed[0] 水平消耗的距离，consumed[1] 垂直消耗的距离 好让子view做出相应的调整\n    * @param type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    */\n   void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed,\n           @NestedScrollType int type);\n           \n   /**\n    * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，\n    * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件\n    *\n    * @param target       具体嵌套滑动的那个子类\n    * @param dxConsumed   水平方向嵌套滑动的子控件滑动的距离(消耗的距离)\n    * @param dyConsumed   垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)\n    * @param dxUnconsumed 水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)\n    * @param dyUnconsumed 垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)\n    * @param type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    */\n   void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed,\n           int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type);\n\n    /**\n    * 停止滑动\n    *\n    * @param target\n    * @param type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    */\n void onStopNestedScroll(@NonNull View target, @NestedScrollType int type);\n}\n```\n\n## NestedScrollingChild2\n```java\npublic interface NestedScrollingChild2 extends NestedScrollingChild {\n\n   /**\n    * 开始滑动前调用，在惯性滑动和触摸滑动前都会进行调用，此方法一般在 onInterceptTouchEvent或者onTouch中，通知父类方法开始滑动\n    * 会调用父类方法的 onStartNestedScroll onNestedScrollAccepted 两个方法\n    *\n    * @param axes 滑动方向\n    * @param type 开始滑动的类型 the type of input which cause this scroll event\n    * @return 有父视图并且开始滑动，则返回true 实际上就是看parent的 onStartNestedScroll 方法\n    */\n   boolean startNestedScroll(@ScrollAxis int axes, @NestedScrollType int type);\n\n  /**\n    * 子控件停止滑动，例如手指抬起，惯性滑动结束\n    *\n    * @param type 停止滑动的类型 TYPE_TOUCH，TYPE_NON_TOUCH\n    */\n   void stopNestedScroll(@NestedScrollType int type);\n\n    /**\n    * 判断是否有父View 支持嵌套滑动\n    */\n   boolean hasNestedScrollingParent(@NestedScrollType int type);\n\n /**\n    * 在dispatchNestedPreScroll 之后进行调用\n    * 当滑动的距离父控件消耗后，父控件将剩余的距离再次交个子控件，\n    * 子控件再次消耗部分距离后，又继续将剩余的距离分发给父控件,由父控件判断是否消耗剩下的距离。\n    * 如果四个消耗的距离都是0，则表示没有神可以消耗的了，会直接返回false，否则会调用父控件的\n    * onNestedScroll 方法，父控件继续消耗剩余的距离\n    * 会调用父控件的\n    *\n    * @param dxConsumed     水平方向嵌套滑动的子控件滑动的距离(消耗的距离)    dx<0 向右滑动 dx>0 向左滑动 （保持和 RecycleView 一致）\n    * @param dyConsumed     垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)    dy<0 向下滑动 dy>0 向上滑动 （保持和 RecycleView 一致）\n    * @param dxUnconsumed   水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dx<0 向右滑动 dx>0 向左滑动 （保持和 RecycleView 一致）\n    * @param dyUnconsumed   垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dy<0 向下滑动 dy>0 向上滑动 （保持和 RecycleView 一致）\n    * @param offsetInWindow 子控件在当前window的偏移量\n    * @return 如果返回true, 表示父控件又继续消耗了\n    */\n   boolean dispatchNestedScroll(int dxConsumed, int dyConsumed,\n           int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow,\n           @NestedScrollType int type);\n\n   /**\n    * 子控件在开始滑动前，通知父控件开始滑动，同时由父控件先消耗滑动时间\n    * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离\n    * 最终会调用父view的 onNestedPreScroll 方法\n    *\n    * @param dx             水平方向嵌套滑动的子控件想要变化的距离 dx<0 向右滑动 dx>0 向左滑动 （保持和 RecycleView 一致）\n    * @param dy             垂直方向嵌套滑动的子控件想要变化的距离 dy<0 向下滑动 dy>0 向上滑动 （保持和 RecycleView 一致）\n    * @param consumed       父控件消耗的距离，父控件消耗完成之后，剩余的才会给子控件，子控件需要使用consumed来进行实际滑动距离的处理\n    * @param offsetInWindow 子控件在当前window的偏移量\n    * @param type           滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动\n    * @return true    表示父控件进行了滑动消耗，需要处理 consumed 的值，false表示父控件不对滑动距离进行消耗，可以不考虑consumed数据的处理，此时consumed中两个数据都应该为0\n    */\n   boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed,\n           @Nullable int[] offsetInWindow, @NestedScrollType int type);\n}\n```\n\n## nested2机制，滚动的传递\n\n一般情况下，事件是从child的触摸事件开始的，\n\n1. 首先调用 `child.startNestedScroll()` 方法，此方法内部通过 `NestedScrollingChildHelper` 调用并返回 `parent.onStartNestedScroll()` 方法的结果，为 true，说明parent接受了嵌套滑动，同时会调用 `parent.onNestedScrollAccepted()` 方法，此时开始嵌套滑动；\n\n2. 在滑动事件中，child通过 `child.dispatchNestedPreScroll()` 方法分配滑动的距离，内部会先调用 `parent.onNestedPreScroll()` 方法，由parent先处理滑动距离。\n\n3. parent消耗完成之后，再将剩余的距离传递给child，child拿到parent使用完成之后的距离之后，自己再处理剩余的距离。\n\n4. 如果此时子控件还有未处理的距离，则将剩余的距离再次通过 `child.dispatchNestedScroll()` 方法调用 `parent.onNestedScroll()` 方法，将剩余的距离交个parent来进行处理\n\n5. 滑动结束之后，调用 child.stopNestedScroll()通知parent滑动结束，至此，触摸滑动结束\n\n触摸滑动结束之后，child会继续进行惯性滑动，惯性滑动可以通过 Scroller 实现，具体滑动可以自己来处理，在fling过程中，和触摸滑动调用流程一样，需要注意 type 参数的区分，用来通知parent两种不同的滑动流程\n\n## 一个栗子\n\n### 预期目标\n自己实现一个嵌套滚动的 parent 和 child， 满足以下效果\n1. parent 包含 top 和 content 两部分，可滚动\n2. 当 top 未完全隐藏是，滚动 content ，是外层的 parent 滚动\n3. 当 top 完全隐藏，触摸滚动 content ，content 自己滚动\n4. 当触摸 content 滚动到顶部， top 未完全漏出， 则 parent 滚动，直至 top 完全露出\n\n### xml布局\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:orientation=\"vertical\">\n\n    <com.example.test2.nest2_test.CustomNestedParent\n        android:id=\"@+id/nested_parent\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n\n        <LinearLayout\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:orientation=\"vertical\">\n\n            <androidx.core.widget.NestedScrollView\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\">\n\n                <LinearLayout\n                    android:id=\"@+id/view_top\"\n                    android:layout_width=\"match_parent\"\n                    android:layout_height=\"wrap_content\"\n                    android:background=\"@color/colorAccent\"\n                    android:orientation=\"vertical\">\n\n                    <View\n                        android:layout_width=\"match_parent\"\n                        android:layout_height=\"200dp\" />\n                </LinearLayout>\n            </androidx.core.widget.NestedScrollView>\n\n            <com.example.test2.nest2_test.CustomNestedChild\n                android:id=\"@+id/view_list\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"1500dp\" />\n        </LinearLayout>\n    </com.example.test2.nest2_test.CustomNestedParent>\n</LinearLayout>\n```\n这里模仿 ScrollView 嵌套 ScrollView 的场景，即外部的 CustomNestedParent 嵌套 内部的 CustomNestedChild ，并解决他们的之间的滑动冲突\ntopVie2 外面包裹了一层 NestedScrollView，是为了让它支持 nested 机制\n\n```kotlin\nclass NestedTestActivity : AppCompatActivity() {\n\n    private lateinit var nestedParent: CustomNestedParent\n    private lateinit var listView: LinearLayout\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        setContentView(R.layout.activity_nested_test)\n\n        nestedParent = findViewById(R.id.nested_parent)\n        val topView: View = findViewById(R.id.view_top)\n        listView = findViewById(R.id.view_list)\n\n        nestedParent.init(topView, listView)\n\n        addListItems()\n    }\n\n    private fun addListItems() {\n      // 填充 child， 这里模拟 child 是一个 recyclerview\n        for (i in 0 until 100) {\n            val textView = TextView(this)\n            textView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 100)\n            textView.text = \"position $i\"\n            listView.addView(textView)\n        }\n    }\n}\n```\n\n### CustomNestedParent\n```kotlin\nclass CustomNestedParent @JvmOverloads constructor(\n    context: Context?,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingParent2 {\n\n    val TAG = \"CustomNestedParent\"\n\n    private val mNestedScrollingParentHelper = NestedScrollingParentHelper(this)\n    private lateinit var topView: View\n    private lateinit var nestedChild: View\n    private var childrenHeight = 0\n\n    override fun onFinishInflate() {\n        super.onFinishInflate()\n    }\n\n    fun init(topView: View, contentView: View) {\n        this.topView = topView\n        this.nestedChild = contentView\n    }\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n      // 模仿 NestedScrollView\n        var height = MeasureSpec.getSize(heightMeasureSpec)\n        var width = MeasureSpec.getSize(widthMeasureSpec)\n        childrenHeight = 0\n        for (i in 0 until childCount) {\n            val child = getChildAt(i)\n            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)\n            childrenHeight += child.measuredHeight\n        }\n        setMeasuredDimension(width, height)\n    }\n\n    // @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行其他操作\n    override fun onStartNestedScroll(child: View, target: View, axes: Int, type: Int): Boolean {\n        Log.i(TAG, \"onStartNestedScroll: \")\n        return axes == ViewCompat.SCROLL_AXIS_VERTICAL\n    }\n\n    // 当嵌套滑动被parent接收了，会回调这个方法\n    override fun onNestedScrollAccepted(child: View, target: View, axes: Int, type: Int) {\n        Log.i(TAG, \"onNestedScrollAccepted: \")\n        mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes, type)\n    }\n\n    /**\n     * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件\n     * 不管手势滚动还是fling都会回调这个方法\n     */\n    override fun onNestedPreScroll(target: View, dx: Int, dy: Int, consumed: IntArray, type: Int) {\n        val threshold = nestedChild.top\n        var parentScrollable = false\n\n        val hideTop = dy > 0 && scrollY < threshold\n        val showTop = dy < 0 && !target.canScrollVertically(-1)\n        Log.i(TAG, \"onNestedPreScroll-1: $dy $type\")\n        if (hideTop || showTop) {\n          // parent 提前消费的场景 \n          // 1. 向上滚动，parent滚动的距离 < topView的高度，需要隐藏topView \n          // 2. 向下滚动，且 child 已经滚动到顶部，需要漏出 topView\n            parentScrollable = true\n            consumed[1] = dy\n            scrollBy(0, dy)\n            Log.i(TAG, \"onNestedPreScroll-2: hideTop=$hideTop showTop=$showTop dy=$dy scrollY=$scrollY threshold=$threshold type=$type\")\n        } else {\n            // 反之，应该让 child 滚动，parent不应该消费滚动距离\n            parentScrollable = false\n        }\n    }\n\n    /**\n     * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，\n     * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件\n     *\n     * 孩子吃剩下的留给爸爸了\n     */\n    override fun onNestedScroll(\n        target: View,\n        dxConsumed: Int,\n        dyConsumed: Int,\n        dxUnconsumed: Int,\n        dyUnconsumed: Int,\n        type: Int\n    ) {\n        Log.i(TAG, \"onNestedScroll: $dyUnconsumed $type $scrollY\")\n        // 剩余的parent全部消费\n        scrollBy(0, dyUnconsumed)\n    }\n\n    override fun onStopNestedScroll(target: View, type: Int) {\n        mNestedScrollingParentHelper.onStopNestedScroll(target, type);\n    }\n\n    override fun getNestedScrollAxes(): Int {\n        return mNestedScrollingParentHelper.nestedScrollAxes\n    }\n\n    override fun scrollTo(x: Int, y: Int) {\n        var resY = y\n        // 限定 parnet 的上下边界，防止滚动出屏幕外\n        if (resY < 0) {\n            resY = 0\n        }\n        val max = max(childrenHeight - height, 0)\n        if (y > max) {\n            resY = max\n        }\n        Log.i(TAG, \"scrollTo: $max $y $resY\")\n        super.scrollTo(x, resY)\n    }\n}\n```\n\n### CustomNestedChild\n\n```kotlin\nclass CustomNestedChild @JvmOverloads constructor(\n    context: Context?,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingChild2 {\n\n    val TAG = \"CustomNestedChild\"\n\n    private val mScrollingChildHelper = NestedScrollingChildHelper(this)\n\n    private val viewConfiguration: ViewConfiguration = ViewConfiguration.get(context)\n    private var mVelocityTracker: VelocityTracker? = null\n\n    private val mScroller: Scroller = Scroller(context)\n\n    private var mLastX: Float = 0f\n    private var mLastY: Float = 0f\n    private var mLastFlingX: Float = 0f\n    private var mLastFlingY: Float = 0f\n\n    private val offset = IntArray(2)\n    private val consumed = IntArray(2)\n    private var fling = false //判断当前是否是可以进行惯性滑动\n\n    private var childrenHeight = 0\n\n    init {\n        orientation = VERTICAL\n        // 这里必须都设置为 true ，表明这个view是支持nested2机制的\n        isNestedScrollingEnabled = true\n        mScrollingChildHelper.isNestedScrollingEnabled = true\n    }\n\n    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {\n        var height = MeasureSpec.getSize(heightMeasureSpec)\n        var width = MeasureSpec.getSize(widthMeasureSpec)\n        childrenHeight = 0\n        for (i in 0 until childCount) {\n            val child = getChildAt(i)\n            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)\n            childrenHeight += child.measuredHeight\n        }\n        setMeasuredDimension(width, height)\n    }\n\n    override fun startNestedScroll(axes: Int, type: Int): Boolean {\n        return mScrollingChildHelper.startNestedScroll(axes, type)\n    }\n\n    override fun stopNestedScroll(type: Int) {\n        mScrollingChildHelper.stopNestedScroll(type)\n    }\n\n    override fun hasNestedScrollingParent(type: Int): Boolean {\n        return mScrollingChildHelper.hasNestedScrollingParent()\n    }\n\n    override fun dispatchNestedPreScroll(\n        dx: Int,\n        dy: Int,\n        consumed: IntArray?,\n        offsetInWindow: IntArray?,\n        type: Int\n    ): Boolean {\n        return mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type)\n    }\n\n    override fun dispatchNestedScroll(\n        dxConsumed: Int,\n        dyConsumed: Int,\n        dxUnconsumed: Int,\n        dyUnconsumed: Int,\n        offsetInWindow: IntArray?,\n        type: Int\n    ): Boolean {\n        return mScrollingChildHelper.dispatchNestedScroll(\n            dxConsumed,\n            dyConsumed,\n            dxUnconsumed,\n            dyUnconsumed,\n            offsetInWindow,\n            type\n        )\n    }\n\n    override fun onTouchEvent(event: MotionEvent): Boolean {\n        // 处理触摸事件是，关闭fling\n        cancelFling()\n\n        if (mVelocityTracker == null) {\n            mVelocityTracker = VelocityTracker.obtain()\n        }\n        val velocityTracker = mVelocityTracker!!\n        velocityTracker.addMovement(event)\n\n        when (event.action) {\n            MotionEvent.ACTION_DOWN -> {\n                mLastX = event.x\n                mLastY = event.y\n                // 表明开始处理嵌套滚动， TYPE_TOUCH 表明这是一个触摸场景\n                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH)\n            }\n            MotionEvent.ACTION_MOVE -> {\n                val curX = event.x\n                val curY = event.y\n                var dy = (mLastY - curY).toInt()\n                var dx = (mLastX - curX).toInt()\n                // 先交给parent处理\n                if (dispatchNestedPreScroll(dx, dy, consumed, offset, TYPE_TOUCH)) {\n                    dy -= consumed[1]\n                    dx -= consumed[0]\n                }\n                // child自己消费\n                val consumedY = childConsumeY(dy)\n                // 将消费剩下的，传递给parent\n                dispatchNestedScroll(0, consumedY, dx, dy - consumedY, null, TYPE_TOUCH)\n                mLastX = curX\n                mLastY = curY\n            }\n            MotionEvent.ACTION_UP,\n            MotionEvent.ACTION_CANCEL -> {\n              // 先结束 TYPE_TOUCH 场景的嵌套滚动\n                stopNestedScroll(TYPE_TOUCH)\n\n                // 判断是否需要惯性滑动\n                velocityTracker.computeCurrentVelocity(\n                    1000,\n                    viewConfiguration.scaledMaximumFlingVelocity.toFloat()\n                )\n                val yvel = velocityTracker.yVelocity\n                fling(yvel.toInt())\n                velocityTracker.clear()\n            }\n        }\n        return true\n    }\n\n    private fun fling(velocityY: Int) {\n        cancelFling()\n\n        //判断速度是否足够大。如果够大才执行fling\n        var dy: Int = velocityY\n        if (abs(velocityY) < viewConfiguration.scaledMinimumFlingVelocity) {\n            dy = 0\n        }\n        if (dy == 0) {\n            return\n        }\n\n        // 这步必须要有，表明开始 TYPE_NON_TOUCH 的嵌套滚动\n        // 如果不设置，后续的嵌套滚动流程都都会找不到对应的parent\n        startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_NON_TOUCH)\n\n        val maxFlingVelocity: Int = viewConfiguration.scaledMaximumFlingVelocity\n        dy = max(-maxFlingVelocity, min(dy, maxFlingVelocity))\n\n        Log.i(TAG, \"fling: $dy \")\n        fling = true\n        // 开始fling\n        mScroller.fling(\n            0,\n            0,\n            0,\n            dy,\n            Integer.MIN_VALUE,\n            Integer.MAX_VALUE,\n            Integer.MIN_VALUE,\n            Integer.MAX_VALUE\n        )\n        postInvalidate()\n    }\n\n    override fun computeScroll() {\n        if (mScroller.computeScrollOffset() && fling) {\n            val y = mScroller.currY\n            var dy = (mLastFlingY - y).toInt()\n            mLastFlingY = y.toFloat()\n            // 和触摸场景一样，优先让parent处理\n            if (dispatchNestedPreScroll(0, dy, consumed, null, TYPE_NON_TOUCH)) {\n                dy -= consumed[1]\n            }\n            Log.i(TAG, \"computeScroll: ${consumed[1]} $dy\")\n            // child 自己处理\n            val consumedY = childFling(dy)\n            // 将剩下的在传递给 parent\n            dispatchNestedScroll(0, consumedY, 0, dy - consumedY, null, TYPE_NON_TOUCH)\n            postInvalidate()\n        } else {\n            stopNestedScroll(TYPE_NON_TOUCH)\n            cancelFling()\n        }\n    }\n\n    private fun childConsumeY(dy: Int): Int {\n        var consumed = dy\n        if (consumed < 0) {\n            // 如果滑动到顶部，只处理部分，不然可能无法触达顶部边界\n            consumed = max(-scrollY, consumed)\n        } else {\n            // 如果滑动到顶部，只处理部分，不然可能会无法触达底部边界\n            val max = max(childrenHeight - height, 0)\n            if (dy + scrollY > max) {\n                consumed = max - scrollY\n            }\n        }\n        Log.i(TAG, \"childConsumeY: $dy $consumed $scrollY\")\n        scrollBy(0, consumed)\n        return consumed\n    }\n\n    private fun childFling(dy: Int): Int {\n        return childConsumeY(dy)\n    }\n\n    private fun cancelFling() {\n        fling = false\n        mLastFlingY = 0f\n        mLastFlingY = 0f\n    }\n\n    override fun scrollTo(x: Int, y: Int) {\n        var resY = y\n        if (resY < 0) {\n            resY = 0\n        }\n        val max = max(childrenHeight - height, 0)\n        if (y > max) {\n            resY = max\n        }\n        Log.i(TAG, \"scrollTo: $max $y $resY\")\n        super.scrollTo(x, resY)\n    }\n\n    override fun canScrollVertically(direction: Int): Boolean {\n        if (direction < 0 && scrollY <= 0) {\n            return false\n        } else if (direction > 0 && scrollY >= measuredHeight - height) {\n            return false\n        } else {\n            return true\n        }\n    }\n}\n```\n\n[https://juejin.cn/post/6844903960432607246#heading-1](https://juejin.cn/post/6844903960432607246#heading-1)\n\n\n\n\n","slug":"Android/nested2嵌套滚动机制","published":1,"updated":"2021-10-03T01:57:41.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8e002wg0jewwkmzw3j","content":"<h2 id=\"开头\"><a href=\"#开头\" class=\"headerlink\" title=\"开头\"></a>开头</h2><p>nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。</p><a id=\"more\"></a>\n<h2 id=\"NestedScrollingParent2\"><a href=\"#NestedScrollingParent2\" class=\"headerlink\" title=\"NestedScrollingParent2\"></a>NestedScrollingParent2</h2><p>NestedScrollingParent2 包含以下接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">NestedScrollingParent2</span> <span class=\"keyword\">extends</span> <span class=\"title\">NestedScrollingParent</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 即将开始嵌套滑动，此时嵌套滑动尚未开始，由子控件的 startNestedScroll 方法调用</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> child  嵌套滑动对应的父类的子类(因为嵌套滑动对于的父控件不一定是一级就能找到的，可能挑了两级父控件的父控件，child的辈分&gt;=target)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target 具体嵌套滑动的那个子类</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> axes   嵌套滑动支持的滚动方向</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type   嵌套滑动的类型，有两种ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> true 表示此父类开始接受嵌套滑动，只有true时候，才会执行下面的 onNestedScrollAccepted 等操作</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">onStartNestedScroll</span><span class=\"params\">(@NonNull View child, @NonNull View target, @ScrollAxis <span class=\"keyword\">int</span> axes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 当onStartNestedScroll返回为true时，也就是父控件接受嵌套滑动时，该方法才会调用</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> child</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> axes</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNestedScrollAccepted</span><span class=\"params\">(@NonNull View child, @NonNull View target, @ScrollAxis <span class=\"keyword\">int</span> axes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class=\"line\"><span class=\"comment\">    * 在嵌套滑动的子View未滑动之前</span></span><br><span class=\"line\"><span class=\"comment\">    * ，判断父view是否优先与子view处理(也就是父view可以先消耗，然后给子view消耗）</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target   具体嵌套滑动的那个子类</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dx       水平方向嵌套滑动的子View想要变化的距离</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dy       垂直方向嵌套滑动的子View想要变化的距离 dy&lt;0向下滑动 dy&gt;0 向上滑动</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> consumed 这个参数要我们在实现这个函数的时候指定，回头告诉子View当前父View消耗的距离</span></span><br><span class=\"line\"><span class=\"comment\">    *                 consumed[0] 水平消耗的距离，consumed[1] 垂直消耗的距离 好让子view做出相应的调整</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNestedPreScroll</span><span class=\"params\">(@NonNull View target, <span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy, @NonNull <span class=\"keyword\">int</span>[] consumed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\">           </span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class=\"line\"><span class=\"comment\">    * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target       具体嵌套滑动的那个子类</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dxConsumed   水平方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dyConsumed   垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dxUnconsumed 水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dyUnconsumed 垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNestedScroll</span><span class=\"params\">(@NonNull View target, <span class=\"keyword\">int</span> dxConsumed, <span class=\"keyword\">int</span> dyConsumed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           <span class=\"keyword\">int</span> dxUnconsumed, <span class=\"keyword\">int</span> dyUnconsumed, @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 停止滑动</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStopNestedScroll</span><span class=\"params\">(@NonNull View target, @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"NestedScrollingChild2\"><a href=\"#NestedScrollingChild2\" class=\"headerlink\" title=\"NestedScrollingChild2\"></a>NestedScrollingChild2</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">NestedScrollingChild2</span> <span class=\"keyword\">extends</span> <span class=\"title\">NestedScrollingChild</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 开始滑动前调用，在惯性滑动和触摸滑动前都会进行调用，此方法一般在 onInterceptTouchEvent或者onTouch中，通知父类方法开始滑动</span></span><br><span class=\"line\"><span class=\"comment\">    * 会调用父类方法的 onStartNestedScroll onNestedScrollAccepted 两个方法</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> axes 滑动方向</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type 开始滑动的类型 the type of input which cause this scroll event</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> 有父视图并且开始滑动，则返回true 实际上就是看parent的 onStartNestedScroll 方法</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">startNestedScroll</span><span class=\"params\">(@ScrollAxis <span class=\"keyword\">int</span> axes, @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 子控件停止滑动，例如手指抬起，惯性滑动结束</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type 停止滑动的类型 TYPE_TOUCH，TYPE_NON_TOUCH</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">stopNestedScroll</span><span class=\"params\">(@NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 判断是否有父View 支持嵌套滑动</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNestedScrollingParent</span><span class=\"params\">(@NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 在dispatchNestedPreScroll 之后进行调用</span></span><br><span class=\"line\"><span class=\"comment\">    * 当滑动的距离父控件消耗后，父控件将剩余的距离再次交个子控件，</span></span><br><span class=\"line\"><span class=\"comment\">    * 子控件再次消耗部分距离后，又继续将剩余的距离分发给父控件,由父控件判断是否消耗剩下的距离。</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果四个消耗的距离都是0，则表示没有神可以消耗的了，会直接返回false，否则会调用父控件的</span></span><br><span class=\"line\"><span class=\"comment\">    * onNestedScroll 方法，父控件继续消耗剩余的距离</span></span><br><span class=\"line\"><span class=\"comment\">    * 会调用父控件的</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dxConsumed     水平方向嵌套滑动的子控件滑动的距离(消耗的距离)    dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dyConsumed     垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)    dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dxUnconsumed   水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dyUnconsumed   垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> 如果返回true, 表示父控件又继续消耗了</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">dispatchNestedScroll</span><span class=\"params\">(<span class=\"keyword\">int</span> dxConsumed, <span class=\"keyword\">int</span> dyConsumed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           <span class=\"keyword\">int</span> dxUnconsumed, <span class=\"keyword\">int</span> dyUnconsumed, @Nullable <span class=\"keyword\">int</span>[] offsetInWindow,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 子控件在开始滑动前，通知父控件开始滑动，同时由父控件先消耗滑动时间</span></span><br><span class=\"line\"><span class=\"comment\">    * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离</span></span><br><span class=\"line\"><span class=\"comment\">    * 最终会调用父view的 onNestedPreScroll 方法</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dx             水平方向嵌套滑动的子控件想要变化的距离 dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dy             垂直方向嵌套滑动的子控件想要变化的距离 dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> consumed       父控件消耗的距离，父控件消耗完成之后，剩余的才会给子控件，子控件需要使用consumed来进行实际滑动距离的处理</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type           滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> true    表示父控件进行了滑动消耗，需要处理 consumed 的值，false表示父控件不对滑动距离进行消耗，可以不考虑consumed数据的处理，此时consumed中两个数据都应该为0</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">dispatchNestedPreScroll</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy, @Nullable <span class=\"keyword\">int</span>[] consumed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @Nullable <span class=\"keyword\">int</span>[] offsetInWindow, @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"nested2机制，滚动的传递\"><a href=\"#nested2机制，滚动的传递\" class=\"headerlink\" title=\"nested2机制，滚动的传递\"></a>nested2机制，滚动的传递</h2><p>一般情况下，事件是从child的触摸事件开始的，</p>\n<ol>\n<li><p>首先调用 <code>child.startNestedScroll()</code> 方法，此方法内部通过 <code>NestedScrollingChildHelper</code> 调用并返回 <code>parent.onStartNestedScroll()</code> 方法的结果，为 true，说明parent接受了嵌套滑动，同时会调用 <code>parent.onNestedScrollAccepted()</code> 方法，此时开始嵌套滑动；</p>\n</li>\n<li><p>在滑动事件中，child通过 <code>child.dispatchNestedPreScroll()</code> 方法分配滑动的距离，内部会先调用 <code>parent.onNestedPreScroll()</code> 方法，由parent先处理滑动距离。</p>\n</li>\n<li><p>parent消耗完成之后，再将剩余的距离传递给child，child拿到parent使用完成之后的距离之后，自己再处理剩余的距离。</p>\n</li>\n<li><p>如果此时子控件还有未处理的距离，则将剩余的距离再次通过 <code>child.dispatchNestedScroll()</code> 方法调用 <code>parent.onNestedScroll()</code> 方法，将剩余的距离交个parent来进行处理</p>\n</li>\n<li><p>滑动结束之后，调用 child.stopNestedScroll()通知parent滑动结束，至此，触摸滑动结束</p>\n</li>\n</ol>\n<p>触摸滑动结束之后，child会继续进行惯性滑动，惯性滑动可以通过 Scroller 实现，具体滑动可以自己来处理，在fling过程中，和触摸滑动调用流程一样，需要注意 type 参数的区分，用来通知parent两种不同的滑动流程</p>\n<h2 id=\"一个栗子\"><a href=\"#一个栗子\" class=\"headerlink\" title=\"一个栗子\"></a>一个栗子</h2><h3 id=\"预期目标\"><a href=\"#预期目标\" class=\"headerlink\" title=\"预期目标\"></a>预期目标</h3><p>自己实现一个嵌套滚动的 parent 和 child， 满足以下效果</p>\n<ol>\n<li>parent 包含 top 和 content 两部分，可滚动</li>\n<li>当 top 未完全隐藏是，滚动 content ，是外层的 parent 滚动</li>\n<li>当 top 完全隐藏，触摸滚动 content ，content 自己滚动</li>\n<li>当触摸 content 滚动到顶部， top 未完全漏出， 则 parent 滚动，直至 top 完全露出</li>\n</ol>\n<h3 id=\"xml布局\"><a href=\"#xml布局\" class=\"headerlink\" title=\"xml布局\"></a>xml布局</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">\"http://schemas.android.com/apk/res-auto\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">com.example.test2.nest2_test.CustomNestedParent</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/nested_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">androidx.core.widget.NestedScrollView</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/view_top\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:background</span>=<span class=\"string\">\"@color/colorAccent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">View</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"200dp\"</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">androidx.core.widget.NestedScrollView</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">com.example.test2.nest2_test.CustomNestedChild</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/view_list\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"1500dp\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">com.example.test2.nest2_test.CustomNestedParent</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里模仿 ScrollView 嵌套 ScrollView 的场景，即外部的 CustomNestedParent 嵌套 内部的 CustomNestedChild ，并解决他们的之间的滑动冲突<br>topVie2 外面包裹了一层 NestedScrollView，是为了让它支持 nested 机制</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedTestActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> nestedParent: CustomNestedParent</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> listView: LinearLayout</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\"></span><br><span class=\"line\">        setContentView(R.layout.activity_nested_test)</span><br><span class=\"line\"></span><br><span class=\"line\">        nestedParent = findViewById(R.id.nested_parent)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> topView: View = findViewById(R.id.view_top)</span><br><span class=\"line\">        listView = findViewById(R.id.view_list)</span><br><span class=\"line\"></span><br><span class=\"line\">        nestedParent.<span class=\"keyword\">init</span>(topView, listView)</span><br><span class=\"line\"></span><br><span class=\"line\">        addListItems()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addListItems</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 填充 child， 这里模拟 child 是一个 recyclerview</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> textView = TextView(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            textView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, <span class=\"number\">100</span>)</span><br><span class=\"line\">            textView.text = <span class=\"string\">\"position <span class=\"variable\">$i</span>\"</span></span><br><span class=\"line\">            listView.addView(textView)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CustomNestedParent\"><a href=\"#CustomNestedParent\" class=\"headerlink\" title=\"CustomNestedParent\"></a>CustomNestedParent</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomNestedParent</span> <span class=\"meta\">@JvmOverloads</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    context: Context?,</span><br><span class=\"line\">    attrs: AttributeSet? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    defStyleAttr: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingParent2 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> TAG = <span class=\"string\">\"CustomNestedParent\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mNestedScrollingParentHelper = NestedScrollingParentHelper(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> topView: View</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> nestedChild: View</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> childrenHeight = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFinishInflate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onFinishInflate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">init</span><span class=\"params\">(topView: <span class=\"type\">View</span>, contentView: <span class=\"type\">View</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.topView = topView</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nestedChild = contentView</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onMeasure</span><span class=\"params\">(widthMeasureSpec: <span class=\"type\">Int</span>, heightMeasureSpec: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 模仿 NestedScrollView</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class=\"line\">        childrenHeight = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)</span><br><span class=\"line\">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class=\"line\">            childrenHeight += child.measuredHeight</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setMeasuredDimension(width, height)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行其他操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStartNestedScroll</span><span class=\"params\">(child: <span class=\"type\">View</span>, target: <span class=\"type\">View</span>, axes: <span class=\"type\">Int</span>, type: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"onStartNestedScroll: \"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> axes == ViewCompat.SCROLL_AXIS_VERTICAL</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当嵌套滑动被parent接收了，会回调这个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNestedScrollAccepted</span><span class=\"params\">(child: <span class=\"type\">View</span>, target: <span class=\"type\">View</span>, axes: <span class=\"type\">Int</span>, type: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"onNestedScrollAccepted: \"</span>)</span><br><span class=\"line\">        mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes, type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class=\"line\"><span class=\"comment\">     * 不管手势滚动还是fling都会回调这个方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNestedPreScroll</span><span class=\"params\">(target: <span class=\"type\">View</span>, dx: <span class=\"type\">Int</span>, dy: <span class=\"type\">Int</span>, consumed: <span class=\"type\">IntArray</span>, type: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> threshold = nestedChild.top</span><br><span class=\"line\">        <span class=\"keyword\">var</span> parentScrollable = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> hideTop = dy &gt; <span class=\"number\">0</span> &amp;&amp; scrollY &lt; threshold</span><br><span class=\"line\">        <span class=\"keyword\">val</span> showTop = dy &lt; <span class=\"number\">0</span> &amp;&amp; !target.canScrollVertically(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"onNestedPreScroll-1: <span class=\"variable\">$dy</span> <span class=\"variable\">$type</span>\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hideTop || showTop) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// parent 提前消费的场景 </span></span><br><span class=\"line\">          <span class=\"comment\">// 1. 向上滚动，parent滚动的距离 &lt; topView的高度，需要隐藏topView </span></span><br><span class=\"line\">          <span class=\"comment\">// 2. 向下滚动，且 child 已经滚动到顶部，需要漏出 topView</span></span><br><span class=\"line\">            parentScrollable = <span class=\"literal\">true</span></span><br><span class=\"line\">            consumed[<span class=\"number\">1</span>] = dy</span><br><span class=\"line\">            scrollBy(<span class=\"number\">0</span>, dy)</span><br><span class=\"line\">            Log.i(TAG, <span class=\"string\">\"onNestedPreScroll-2: hideTop=<span class=\"variable\">$hideTop</span> showTop=<span class=\"variable\">$showTop</span> dy=<span class=\"variable\">$dy</span> scrollY=<span class=\"variable\">$scrollY</span> threshold=<span class=\"variable\">$threshold</span> type=<span class=\"variable\">$type</span>\"</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反之，应该让 child 滚动，parent不应该消费滚动距离</span></span><br><span class=\"line\">            parentScrollable = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class=\"line\"><span class=\"comment\">     * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 孩子吃剩下的留给爸爸了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNestedScroll</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        target: <span class=\"type\">View</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dxConsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dyConsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dxUnconsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dyUnconsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        type: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span> &#123;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"onNestedScroll: <span class=\"variable\">$dyUnconsumed</span> <span class=\"variable\">$type</span> <span class=\"variable\">$scrollY</span>\"</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 剩余的parent全部消费</span></span><br><span class=\"line\">        scrollBy(<span class=\"number\">0</span>, dyUnconsumed)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStopNestedScroll</span><span class=\"params\">(target: <span class=\"type\">View</span>, type: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        mNestedScrollingParentHelper.onStopNestedScroll(target, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getNestedScrollAxes</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mNestedScrollingParentHelper.nestedScrollAxes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollTo</span><span class=\"params\">(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> resY = y</span><br><span class=\"line\">        <span class=\"comment\">// 限定 parnet 的上下边界，防止滚动出屏幕外</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resY &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            resY = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> max = max(childrenHeight - height, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y &gt; max) &#123;</span><br><span class=\"line\">            resY = max</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"scrollTo: <span class=\"variable\">$max</span> <span class=\"variable\">$y</span> <span class=\"variable\">$resY</span>\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.scrollTo(x, resY)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CustomNestedChild\"><a href=\"#CustomNestedChild\" class=\"headerlink\" title=\"CustomNestedChild\"></a>CustomNestedChild</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomNestedChild</span> <span class=\"meta\">@JvmOverloads</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    context: Context?,</span><br><span class=\"line\">    attrs: AttributeSet? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    defStyleAttr: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingChild2 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> TAG = <span class=\"string\">\"CustomNestedChild\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mScrollingChildHelper = NestedScrollingChildHelper(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> viewConfiguration: ViewConfiguration = ViewConfiguration.<span class=\"keyword\">get</span>(context)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mVelocityTracker: VelocityTracker? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mScroller: Scroller = Scroller(context)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mLastX: <span class=\"built_in\">Float</span> = <span class=\"number\">0f</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mLastY: <span class=\"built_in\">Float</span> = <span class=\"number\">0f</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mLastFlingX: <span class=\"built_in\">Float</span> = <span class=\"number\">0f</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mLastFlingY: <span class=\"built_in\">Float</span> = <span class=\"number\">0f</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> offset = IntArray(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> consumed = IntArray(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> fling = <span class=\"literal\">false</span> <span class=\"comment\">//判断当前是否是可以进行惯性滑动</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> childrenHeight = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        orientation = VERTICAL</span><br><span class=\"line\">        <span class=\"comment\">// 这里必须都设置为 true ，表明这个view是支持nested2机制的</span></span><br><span class=\"line\">        isNestedScrollingEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">        mScrollingChildHelper.isNestedScrollingEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onMeasure</span><span class=\"params\">(widthMeasureSpec: <span class=\"type\">Int</span>, heightMeasureSpec: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class=\"line\">        childrenHeight = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)</span><br><span class=\"line\">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class=\"line\">            childrenHeight += child.measuredHeight</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setMeasuredDimension(width, height)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">startNestedScroll</span><span class=\"params\">(axes: <span class=\"type\">Int</span>, type: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mScrollingChildHelper.startNestedScroll(axes, type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">stopNestedScroll</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        mScrollingChildHelper.stopNestedScroll(type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">hasNestedScrollingParent</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mScrollingChildHelper.hasNestedScrollingParent()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">dispatchNestedPreScroll</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dx: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dy: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        consumed: <span class=\"type\">IntArray</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        offsetInWindow: <span class=\"type\">IntArray</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        type: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">dispatchNestedScroll</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dxConsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dyConsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dxUnconsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dyUnconsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        offsetInWindow: <span class=\"type\">IntArray</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        type: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mScrollingChildHelper.dispatchNestedScroll(</span><br><span class=\"line\">            dxConsumed,</span><br><span class=\"line\">            dyConsumed,</span><br><span class=\"line\">            dxUnconsumed,</span><br><span class=\"line\">            dyUnconsumed,</span><br><span class=\"line\">            offsetInWindow,</span><br><span class=\"line\">            type</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(event: <span class=\"type\">MotionEvent</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理触摸事件是，关闭fling</span></span><br><span class=\"line\">        cancelFling()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mVelocityTracker == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            mVelocityTracker = VelocityTracker.obtain()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> velocityTracker = mVelocityTracker!!</span><br><span class=\"line\">        velocityTracker.addMovement(event)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">when</span> (event.action) &#123;</span><br><span class=\"line\">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class=\"line\">                mLastX = event.x</span><br><span class=\"line\">                mLastY = event.y</span><br><span class=\"line\">                <span class=\"comment\">// 表明开始处理嵌套滚动， TYPE_TOUCH 表明这是一个触摸场景</span></span><br><span class=\"line\">                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> curX = event.x</span><br><span class=\"line\">                <span class=\"keyword\">val</span> curY = event.y</span><br><span class=\"line\">                <span class=\"keyword\">var</span> dy = (mLastY - curY).toInt()</span><br><span class=\"line\">                <span class=\"keyword\">var</span> dx = (mLastX - curX).toInt()</span><br><span class=\"line\">                <span class=\"comment\">// 先交给parent处理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dispatchNestedPreScroll(dx, dy, consumed, offset, TYPE_TOUCH)) &#123;</span><br><span class=\"line\">                    dy -= consumed[<span class=\"number\">1</span>]</span><br><span class=\"line\">                    dx -= consumed[<span class=\"number\">0</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// child自己消费</span></span><br><span class=\"line\">                <span class=\"keyword\">val</span> consumedY = childConsumeY(dy)</span><br><span class=\"line\">                <span class=\"comment\">// 将消费剩下的，传递给parent</span></span><br><span class=\"line\">                dispatchNestedScroll(<span class=\"number\">0</span>, consumedY, dx, dy - consumedY, <span class=\"literal\">null</span>, TYPE_TOUCH)</span><br><span class=\"line\">                mLastX = curX</span><br><span class=\"line\">                mLastY = curY</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MotionEvent.ACTION_UP,</span><br><span class=\"line\">            MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 先结束 TYPE_TOUCH 场景的嵌套滚动</span></span><br><span class=\"line\">                stopNestedScroll(TYPE_TOUCH)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 判断是否需要惯性滑动</span></span><br><span class=\"line\">                velocityTracker.computeCurrentVelocity(</span><br><span class=\"line\">                    <span class=\"number\">1000</span>,</span><br><span class=\"line\">                    viewConfiguration.scaledMaximumFlingVelocity.toFloat()</span><br><span class=\"line\">                )</span><br><span class=\"line\">                <span class=\"keyword\">val</span> yvel = velocityTracker.yVelocity</span><br><span class=\"line\">                fling(yvel.toInt())</span><br><span class=\"line\">                velocityTracker.clear()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fling</span><span class=\"params\">(velocityY: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        cancelFling()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//判断速度是否足够大。如果够大才执行fling</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> dy: <span class=\"built_in\">Int</span> = velocityY</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (abs(velocityY) &lt; viewConfiguration.scaledMinimumFlingVelocity) &#123;</span><br><span class=\"line\">            dy = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这步必须要有，表明开始 TYPE_NON_TOUCH 的嵌套滚动</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果不设置，后续的嵌套滚动流程都都会找不到对应的parent</span></span><br><span class=\"line\">        startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_NON_TOUCH)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> maxFlingVelocity: <span class=\"built_in\">Int</span> = viewConfiguration.scaledMaximumFlingVelocity</span><br><span class=\"line\">        dy = max(-maxFlingVelocity, min(dy, maxFlingVelocity))</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"fling: <span class=\"variable\">$dy</span> \"</span>)</span><br><span class=\"line\">        fling = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"comment\">// 开始fling</span></span><br><span class=\"line\">        mScroller.fling(</span><br><span class=\"line\">            <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0</span>,</span><br><span class=\"line\">            dy,</span><br><span class=\"line\">            Integer.MIN_VALUE,</span><br><span class=\"line\">            Integer.MAX_VALUE,</span><br><span class=\"line\">            Integer.MIN_VALUE,</span><br><span class=\"line\">            Integer.MAX_VALUE</span><br><span class=\"line\">        )</span><br><span class=\"line\">        postInvalidate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mScroller.computeScrollOffset() &amp;&amp; fling) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> y = mScroller.currY</span><br><span class=\"line\">            <span class=\"keyword\">var</span> dy = (mLastFlingY - y).toInt()</span><br><span class=\"line\">            mLastFlingY = y.toFloat()</span><br><span class=\"line\">            <span class=\"comment\">// 和触摸场景一样，优先让parent处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dispatchNestedPreScroll(<span class=\"number\">0</span>, dy, consumed, <span class=\"literal\">null</span>, TYPE_NON_TOUCH)) &#123;</span><br><span class=\"line\">                dy -= consumed[<span class=\"number\">1</span>]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Log.i(TAG, <span class=\"string\">\"computeScroll: <span class=\"subst\">$&#123;consumed[<span class=\"number\">1</span>]&#125;</span> <span class=\"variable\">$dy</span>\"</span>)</span><br><span class=\"line\">            <span class=\"comment\">// child 自己处理</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> consumedY = childFling(dy)</span><br><span class=\"line\">            <span class=\"comment\">// 将剩下的在传递给 parent</span></span><br><span class=\"line\">            dispatchNestedScroll(<span class=\"number\">0</span>, consumedY, <span class=\"number\">0</span>, dy - consumedY, <span class=\"literal\">null</span>, TYPE_NON_TOUCH)</span><br><span class=\"line\">            postInvalidate()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stopNestedScroll(TYPE_NON_TOUCH)</span><br><span class=\"line\">            cancelFling()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">childConsumeY</span><span class=\"params\">(dy: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> consumed = dy</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (consumed &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果滑动到顶部，只处理部分，不然可能无法触达顶部边界</span></span><br><span class=\"line\">            consumed = max(-scrollY, consumed)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果滑动到顶部，只处理部分，不然可能会无法触达底部边界</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> max = max(childrenHeight - height, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dy + scrollY &gt; max) &#123;</span><br><span class=\"line\">                consumed = max - scrollY</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"childConsumeY: <span class=\"variable\">$dy</span> <span class=\"variable\">$consumed</span> <span class=\"variable\">$scrollY</span>\"</span>)</span><br><span class=\"line\">        scrollBy(<span class=\"number\">0</span>, consumed)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> consumed</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">childFling</span><span class=\"params\">(dy: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> childConsumeY(dy)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">cancelFling</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        fling = <span class=\"literal\">false</span></span><br><span class=\"line\">        mLastFlingY = <span class=\"number\">0f</span></span><br><span class=\"line\">        mLastFlingY = <span class=\"number\">0f</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollTo</span><span class=\"params\">(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> resY = y</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resY &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            resY = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> max = max(childrenHeight - height, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y &gt; max) &#123;</span><br><span class=\"line\">            resY = max</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"scrollTo: <span class=\"variable\">$max</span> <span class=\"variable\">$y</span> <span class=\"variable\">$resY</span>\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.scrollTo(x, resY)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">canScrollVertically</span><span class=\"params\">(direction: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (direction &lt; <span class=\"number\">0</span> &amp;&amp; scrollY &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (direction &gt; <span class=\"number\">0</span> &amp;&amp; scrollY &gt;= measuredHeight - height) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://juejin.cn/post/6844903960432607246#heading-1\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903960432607246#heading-1</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"开头\"><a href=\"#开头\" class=\"headerlink\" title=\"开头\"></a>开头</h2><p>nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。</p>","more":"\n<h2 id=\"NestedScrollingParent2\"><a href=\"#NestedScrollingParent2\" class=\"headerlink\" title=\"NestedScrollingParent2\"></a>NestedScrollingParent2</h2><p>NestedScrollingParent2 包含以下接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">NestedScrollingParent2</span> <span class=\"keyword\">extends</span> <span class=\"title\">NestedScrollingParent</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 即将开始嵌套滑动，此时嵌套滑动尚未开始，由子控件的 startNestedScroll 方法调用</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> child  嵌套滑动对应的父类的子类(因为嵌套滑动对于的父控件不一定是一级就能找到的，可能挑了两级父控件的父控件，child的辈分&gt;=target)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target 具体嵌套滑动的那个子类</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> axes   嵌套滑动支持的滚动方向</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type   嵌套滑动的类型，有两种ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> true 表示此父类开始接受嵌套滑动，只有true时候，才会执行下面的 onNestedScrollAccepted 等操作</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">onStartNestedScroll</span><span class=\"params\">(@NonNull View child, @NonNull View target, @ScrollAxis <span class=\"keyword\">int</span> axes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 当onStartNestedScroll返回为true时，也就是父控件接受嵌套滑动时，该方法才会调用</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> child</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> axes</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNestedScrollAccepted</span><span class=\"params\">(@NonNull View child, @NonNull View target, @ScrollAxis <span class=\"keyword\">int</span> axes,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class=\"line\"><span class=\"comment\">    * 在嵌套滑动的子View未滑动之前</span></span><br><span class=\"line\"><span class=\"comment\">    * ，判断父view是否优先与子view处理(也就是父view可以先消耗，然后给子view消耗）</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target   具体嵌套滑动的那个子类</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dx       水平方向嵌套滑动的子View想要变化的距离</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dy       垂直方向嵌套滑动的子View想要变化的距离 dy&lt;0向下滑动 dy&gt;0 向上滑动</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> consumed 这个参数要我们在实现这个函数的时候指定，回头告诉子View当前父View消耗的距离</span></span><br><span class=\"line\"><span class=\"comment\">    *                 consumed[0] 水平消耗的距离，consumed[1] 垂直消耗的距离 好让子view做出相应的调整</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNestedPreScroll</span><span class=\"params\">(@NonNull View target, <span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy, @NonNull <span class=\"keyword\">int</span>[] consumed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\">           </span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class=\"line\"><span class=\"comment\">    * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target       具体嵌套滑动的那个子类</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dxConsumed   水平方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dyConsumed   垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dxUnconsumed 水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dyUnconsumed 垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onNestedScroll</span><span class=\"params\">(@NonNull View target, <span class=\"keyword\">int</span> dxConsumed, <span class=\"keyword\">int</span> dyConsumed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           <span class=\"keyword\">int</span> dxUnconsumed, <span class=\"keyword\">int</span> dyUnconsumed, @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 停止滑动</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> target</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onStopNestedScroll</span><span class=\"params\">(@NonNull View target, @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"NestedScrollingChild2\"><a href=\"#NestedScrollingChild2\" class=\"headerlink\" title=\"NestedScrollingChild2\"></a>NestedScrollingChild2</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">NestedScrollingChild2</span> <span class=\"keyword\">extends</span> <span class=\"title\">NestedScrollingChild</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 开始滑动前调用，在惯性滑动和触摸滑动前都会进行调用，此方法一般在 onInterceptTouchEvent或者onTouch中，通知父类方法开始滑动</span></span><br><span class=\"line\"><span class=\"comment\">    * 会调用父类方法的 onStartNestedScroll onNestedScrollAccepted 两个方法</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> axes 滑动方向</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type 开始滑动的类型 the type of input which cause this scroll event</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> 有父视图并且开始滑动，则返回true 实际上就是看parent的 onStartNestedScroll 方法</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">startNestedScroll</span><span class=\"params\">(@ScrollAxis <span class=\"keyword\">int</span> axes, @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 子控件停止滑动，例如手指抬起，惯性滑动结束</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type 停止滑动的类型 TYPE_TOUCH，TYPE_NON_TOUCH</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">stopNestedScroll</span><span class=\"params\">(@NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 判断是否有父View 支持嵌套滑动</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNestedScrollingParent</span><span class=\"params\">(@NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 在dispatchNestedPreScroll 之后进行调用</span></span><br><span class=\"line\"><span class=\"comment\">    * 当滑动的距离父控件消耗后，父控件将剩余的距离再次交个子控件，</span></span><br><span class=\"line\"><span class=\"comment\">    * 子控件再次消耗部分距离后，又继续将剩余的距离分发给父控件,由父控件判断是否消耗剩下的距离。</span></span><br><span class=\"line\"><span class=\"comment\">    * 如果四个消耗的距离都是0，则表示没有神可以消耗的了，会直接返回false，否则会调用父控件的</span></span><br><span class=\"line\"><span class=\"comment\">    * onNestedScroll 方法，父控件继续消耗剩余的距离</span></span><br><span class=\"line\"><span class=\"comment\">    * 会调用父控件的</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dxConsumed     水平方向嵌套滑动的子控件滑动的距离(消耗的距离)    dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dyConsumed     垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)    dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dxUnconsumed   水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dyUnconsumed   垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> 如果返回true, 表示父控件又继续消耗了</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">dispatchNestedScroll</span><span class=\"params\">(<span class=\"keyword\">int</span> dxConsumed, <span class=\"keyword\">int</span> dyConsumed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           <span class=\"keyword\">int</span> dxUnconsumed, <span class=\"keyword\">int</span> dyUnconsumed, @Nullable <span class=\"keyword\">int</span>[] offsetInWindow,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 子控件在开始滑动前，通知父控件开始滑动，同时由父控件先消耗滑动时间</span></span><br><span class=\"line\"><span class=\"comment\">    * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离</span></span><br><span class=\"line\"><span class=\"comment\">    * 最终会调用父view的 onNestedPreScroll 方法</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dx             水平方向嵌套滑动的子控件想要变化的距离 dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> dy             垂直方向嵌套滑动的子控件想要变化的距离 dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> consumed       父控件消耗的距离，父控件消耗完成之后，剩余的才会给子控件，子控件需要使用consumed来进行实际滑动距离的处理</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@param</span> type           滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class=\"line\"><span class=\"comment\">    * <span class=\"doctag\">@return</span> true    表示父控件进行了滑动消耗，需要处理 consumed 的值，false表示父控件不对滑动距离进行消耗，可以不考虑consumed数据的处理，此时consumed中两个数据都应该为0</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">dispatchNestedPreScroll</span><span class=\"params\">(<span class=\"keyword\">int</span> dx, <span class=\"keyword\">int</span> dy, @Nullable <span class=\"keyword\">int</span>[] consumed,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">           @Nullable <span class=\"keyword\">int</span>[] offsetInWindow, @NestedScrollType <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"nested2机制，滚动的传递\"><a href=\"#nested2机制，滚动的传递\" class=\"headerlink\" title=\"nested2机制，滚动的传递\"></a>nested2机制，滚动的传递</h2><p>一般情况下，事件是从child的触摸事件开始的，</p>\n<ol>\n<li><p>首先调用 <code>child.startNestedScroll()</code> 方法，此方法内部通过 <code>NestedScrollingChildHelper</code> 调用并返回 <code>parent.onStartNestedScroll()</code> 方法的结果，为 true，说明parent接受了嵌套滑动，同时会调用 <code>parent.onNestedScrollAccepted()</code> 方法，此时开始嵌套滑动；</p>\n</li>\n<li><p>在滑动事件中，child通过 <code>child.dispatchNestedPreScroll()</code> 方法分配滑动的距离，内部会先调用 <code>parent.onNestedPreScroll()</code> 方法，由parent先处理滑动距离。</p>\n</li>\n<li><p>parent消耗完成之后，再将剩余的距离传递给child，child拿到parent使用完成之后的距离之后，自己再处理剩余的距离。</p>\n</li>\n<li><p>如果此时子控件还有未处理的距离，则将剩余的距离再次通过 <code>child.dispatchNestedScroll()</code> 方法调用 <code>parent.onNestedScroll()</code> 方法，将剩余的距离交个parent来进行处理</p>\n</li>\n<li><p>滑动结束之后，调用 child.stopNestedScroll()通知parent滑动结束，至此，触摸滑动结束</p>\n</li>\n</ol>\n<p>触摸滑动结束之后，child会继续进行惯性滑动，惯性滑动可以通过 Scroller 实现，具体滑动可以自己来处理，在fling过程中，和触摸滑动调用流程一样，需要注意 type 参数的区分，用来通知parent两种不同的滑动流程</p>\n<h2 id=\"一个栗子\"><a href=\"#一个栗子\" class=\"headerlink\" title=\"一个栗子\"></a>一个栗子</h2><h3 id=\"预期目标\"><a href=\"#预期目标\" class=\"headerlink\" title=\"预期目标\"></a>预期目标</h3><p>自己实现一个嵌套滚动的 parent 和 child， 满足以下效果</p>\n<ol>\n<li>parent 包含 top 和 content 两部分，可滚动</li>\n<li>当 top 未完全隐藏是，滚动 content ，是外层的 parent 滚动</li>\n<li>当 top 完全隐藏，触摸滚动 content ，content 自己滚动</li>\n<li>当触摸 content 滚动到顶部， top 未完全漏出， 则 parent 滚动，直至 top 完全露出</li>\n</ol>\n<h3 id=\"xml布局\"><a href=\"#xml布局\" class=\"headerlink\" title=\"xml布局\"></a>xml布局</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span> <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:app</span>=<span class=\"string\">\"http://schemas.android.com/apk/res-auto\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">com.example.test2.nest2_test.CustomNestedParent</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/nested_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">androidx.core.widget.NestedScrollView</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/view_top\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"wrap_content\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:background</span>=<span class=\"string\">\"@color/colorAccent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">View</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"200dp\"</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">androidx.core.widget.NestedScrollView</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">com.example.test2.nest2_test.CustomNestedChild</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/view_list\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"1500dp\"</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">com.example.test2.nest2_test.CustomNestedParent</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里模仿 ScrollView 嵌套 ScrollView 的场景，即外部的 CustomNestedParent 嵌套 内部的 CustomNestedChild ，并解决他们的之间的滑动冲突<br>topVie2 外面包裹了一层 NestedScrollView，是为了让它支持 nested 机制</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NestedTestActivity</span> : <span class=\"type\">AppCompatActivity</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> nestedParent: CustomNestedParent</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> listView: LinearLayout</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onCreate</span><span class=\"params\">(savedInstanceState: <span class=\"type\">Bundle</span>?)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState)</span><br><span class=\"line\"></span><br><span class=\"line\">        setContentView(R.layout.activity_nested_test)</span><br><span class=\"line\"></span><br><span class=\"line\">        nestedParent = findViewById(R.id.nested_parent)</span><br><span class=\"line\">        <span class=\"keyword\">val</span> topView: View = findViewById(R.id.view_top)</span><br><span class=\"line\">        listView = findViewById(R.id.view_list)</span><br><span class=\"line\"></span><br><span class=\"line\">        nestedParent.<span class=\"keyword\">init</span>(topView, listView)</span><br><span class=\"line\"></span><br><span class=\"line\">        addListItems()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">addListItems</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 填充 child， 这里模拟 child 是一个 recyclerview</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> textView = TextView(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            textView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, <span class=\"number\">100</span>)</span><br><span class=\"line\">            textView.text = <span class=\"string\">\"position <span class=\"variable\">$i</span>\"</span></span><br><span class=\"line\">            listView.addView(textView)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CustomNestedParent\"><a href=\"#CustomNestedParent\" class=\"headerlink\" title=\"CustomNestedParent\"></a>CustomNestedParent</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomNestedParent</span> <span class=\"meta\">@JvmOverloads</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    context: Context?,</span><br><span class=\"line\">    attrs: AttributeSet? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    defStyleAttr: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingParent2 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> TAG = <span class=\"string\">\"CustomNestedParent\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mNestedScrollingParentHelper = NestedScrollingParentHelper(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> topView: View</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">lateinit</span> <span class=\"keyword\">var</span> nestedChild: View</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> childrenHeight = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onFinishInflate</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onFinishInflate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">init</span><span class=\"params\">(topView: <span class=\"type\">View</span>, contentView: <span class=\"type\">View</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.topView = topView</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nestedChild = contentView</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onMeasure</span><span class=\"params\">(widthMeasureSpec: <span class=\"type\">Int</span>, heightMeasureSpec: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 模仿 NestedScrollView</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class=\"line\">        childrenHeight = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)</span><br><span class=\"line\">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class=\"line\">            childrenHeight += child.measuredHeight</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setMeasuredDimension(width, height)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行其他操作</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStartNestedScroll</span><span class=\"params\">(child: <span class=\"type\">View</span>, target: <span class=\"type\">View</span>, axes: <span class=\"type\">Int</span>, type: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"onStartNestedScroll: \"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> axes == ViewCompat.SCROLL_AXIS_VERTICAL</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当嵌套滑动被parent接收了，会回调这个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNestedScrollAccepted</span><span class=\"params\">(child: <span class=\"type\">View</span>, target: <span class=\"type\">View</span>, axes: <span class=\"type\">Int</span>, type: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"onNestedScrollAccepted: \"</span>)</span><br><span class=\"line\">        mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes, type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class=\"line\"><span class=\"comment\">     * 不管手势滚动还是fling都会回调这个方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNestedPreScroll</span><span class=\"params\">(target: <span class=\"type\">View</span>, dx: <span class=\"type\">Int</span>, dy: <span class=\"type\">Int</span>, consumed: <span class=\"type\">IntArray</span>, type: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> threshold = nestedChild.top</span><br><span class=\"line\">        <span class=\"keyword\">var</span> parentScrollable = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> hideTop = dy &gt; <span class=\"number\">0</span> &amp;&amp; scrollY &lt; threshold</span><br><span class=\"line\">        <span class=\"keyword\">val</span> showTop = dy &lt; <span class=\"number\">0</span> &amp;&amp; !target.canScrollVertically(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"onNestedPreScroll-1: <span class=\"variable\">$dy</span> <span class=\"variable\">$type</span>\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hideTop || showTop) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// parent 提前消费的场景 </span></span><br><span class=\"line\">          <span class=\"comment\">// 1. 向上滚动，parent滚动的距离 &lt; topView的高度，需要隐藏topView </span></span><br><span class=\"line\">          <span class=\"comment\">// 2. 向下滚动，且 child 已经滚动到顶部，需要漏出 topView</span></span><br><span class=\"line\">            parentScrollable = <span class=\"literal\">true</span></span><br><span class=\"line\">            consumed[<span class=\"number\">1</span>] = dy</span><br><span class=\"line\">            scrollBy(<span class=\"number\">0</span>, dy)</span><br><span class=\"line\">            Log.i(TAG, <span class=\"string\">\"onNestedPreScroll-2: hideTop=<span class=\"variable\">$hideTop</span> showTop=<span class=\"variable\">$showTop</span> dy=<span class=\"variable\">$dy</span> scrollY=<span class=\"variable\">$scrollY</span> threshold=<span class=\"variable\">$threshold</span> type=<span class=\"variable\">$type</span>\"</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反之，应该让 child 滚动，parent不应该消费滚动距离</span></span><br><span class=\"line\">            parentScrollable = <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class=\"line\"><span class=\"comment\">     * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 孩子吃剩下的留给爸爸了</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onNestedScroll</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        target: <span class=\"type\">View</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dxConsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dyConsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dxUnconsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dyUnconsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        type: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span> &#123;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"onNestedScroll: <span class=\"variable\">$dyUnconsumed</span> <span class=\"variable\">$type</span> <span class=\"variable\">$scrollY</span>\"</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 剩余的parent全部消费</span></span><br><span class=\"line\">        scrollBy(<span class=\"number\">0</span>, dyUnconsumed)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onStopNestedScroll</span><span class=\"params\">(target: <span class=\"type\">View</span>, type: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        mNestedScrollingParentHelper.onStopNestedScroll(target, type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getNestedScrollAxes</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mNestedScrollingParentHelper.nestedScrollAxes</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollTo</span><span class=\"params\">(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> resY = y</span><br><span class=\"line\">        <span class=\"comment\">// 限定 parnet 的上下边界，防止滚动出屏幕外</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resY &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            resY = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> max = max(childrenHeight - height, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y &gt; max) &#123;</span><br><span class=\"line\">            resY = max</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"scrollTo: <span class=\"variable\">$max</span> <span class=\"variable\">$y</span> <span class=\"variable\">$resY</span>\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.scrollTo(x, resY)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CustomNestedChild\"><a href=\"#CustomNestedChild\" class=\"headerlink\" title=\"CustomNestedChild\"></a>CustomNestedChild</h3><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomNestedChild</span> <span class=\"meta\">@JvmOverloads</span> <span class=\"keyword\">constructor</span></span>(</span><br><span class=\"line\">    context: Context?,</span><br><span class=\"line\">    attrs: AttributeSet? = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    defStyleAttr: <span class=\"built_in\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingChild2 &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">val</span> TAG = <span class=\"string\">\"CustomNestedChild\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mScrollingChildHelper = NestedScrollingChildHelper(<span class=\"keyword\">this</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> viewConfiguration: ViewConfiguration = ViewConfiguration.<span class=\"keyword\">get</span>(context)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mVelocityTracker: VelocityTracker? = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mScroller: Scroller = Scroller(context)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mLastX: <span class=\"built_in\">Float</span> = <span class=\"number\">0f</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mLastY: <span class=\"built_in\">Float</span> = <span class=\"number\">0f</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mLastFlingX: <span class=\"built_in\">Float</span> = <span class=\"number\">0f</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mLastFlingY: <span class=\"built_in\">Float</span> = <span class=\"number\">0f</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> offset = IntArray(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> consumed = IntArray(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> fling = <span class=\"literal\">false</span> <span class=\"comment\">//判断当前是否是可以进行惯性滑动</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> childrenHeight = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span> &#123;</span><br><span class=\"line\">        orientation = VERTICAL</span><br><span class=\"line\">        <span class=\"comment\">// 这里必须都设置为 true ，表明这个view是支持nested2机制的</span></span><br><span class=\"line\">        isNestedScrollingEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">        mScrollingChildHelper.isNestedScrollingEnabled = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onMeasure</span><span class=\"params\">(widthMeasureSpec: <span class=\"type\">Int</span>, heightMeasureSpec: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class=\"line\">        childrenHeight = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> child = getChildAt(i)</span><br><span class=\"line\">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class=\"line\">            childrenHeight += child.measuredHeight</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setMeasuredDimension(width, height)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">startNestedScroll</span><span class=\"params\">(axes: <span class=\"type\">Int</span>, type: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mScrollingChildHelper.startNestedScroll(axes, type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">stopNestedScroll</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        mScrollingChildHelper.stopNestedScroll(type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">hasNestedScrollingParent</span><span class=\"params\">(type: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mScrollingChildHelper.hasNestedScrollingParent()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">dispatchNestedPreScroll</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dx: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dy: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        consumed: <span class=\"type\">IntArray</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        offsetInWindow: <span class=\"type\">IntArray</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        type: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">dispatchNestedScroll</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dxConsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dyConsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dxUnconsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dyUnconsumed: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        offsetInWindow: <span class=\"type\">IntArray</span>?,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        type: <span class=\"type\">Int</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mScrollingChildHelper.dispatchNestedScroll(</span><br><span class=\"line\">            dxConsumed,</span><br><span class=\"line\">            dyConsumed,</span><br><span class=\"line\">            dxUnconsumed,</span><br><span class=\"line\">            dyUnconsumed,</span><br><span class=\"line\">            offsetInWindow,</span><br><span class=\"line\">            type</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(event: <span class=\"type\">MotionEvent</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理触摸事件是，关闭fling</span></span><br><span class=\"line\">        cancelFling()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mVelocityTracker == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            mVelocityTracker = VelocityTracker.obtain()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> velocityTracker = mVelocityTracker!!</span><br><span class=\"line\">        velocityTracker.addMovement(event)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">when</span> (event.action) &#123;</span><br><span class=\"line\">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class=\"line\">                mLastX = event.x</span><br><span class=\"line\">                mLastY = event.y</span><br><span class=\"line\">                <span class=\"comment\">// 表明开始处理嵌套滚动， TYPE_TOUCH 表明这是一个触摸场景</span></span><br><span class=\"line\">                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> curX = event.x</span><br><span class=\"line\">                <span class=\"keyword\">val</span> curY = event.y</span><br><span class=\"line\">                <span class=\"keyword\">var</span> dy = (mLastY - curY).toInt()</span><br><span class=\"line\">                <span class=\"keyword\">var</span> dx = (mLastX - curX).toInt()</span><br><span class=\"line\">                <span class=\"comment\">// 先交给parent处理</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dispatchNestedPreScroll(dx, dy, consumed, offset, TYPE_TOUCH)) &#123;</span><br><span class=\"line\">                    dy -= consumed[<span class=\"number\">1</span>]</span><br><span class=\"line\">                    dx -= consumed[<span class=\"number\">0</span>]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// child自己消费</span></span><br><span class=\"line\">                <span class=\"keyword\">val</span> consumedY = childConsumeY(dy)</span><br><span class=\"line\">                <span class=\"comment\">// 将消费剩下的，传递给parent</span></span><br><span class=\"line\">                dispatchNestedScroll(<span class=\"number\">0</span>, consumedY, dx, dy - consumedY, <span class=\"literal\">null</span>, TYPE_TOUCH)</span><br><span class=\"line\">                mLastX = curX</span><br><span class=\"line\">                mLastY = curY</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MotionEvent.ACTION_UP,</span><br><span class=\"line\">            MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 先结束 TYPE_TOUCH 场景的嵌套滚动</span></span><br><span class=\"line\">                stopNestedScroll(TYPE_TOUCH)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 判断是否需要惯性滑动</span></span><br><span class=\"line\">                velocityTracker.computeCurrentVelocity(</span><br><span class=\"line\">                    <span class=\"number\">1000</span>,</span><br><span class=\"line\">                    viewConfiguration.scaledMaximumFlingVelocity.toFloat()</span><br><span class=\"line\">                )</span><br><span class=\"line\">                <span class=\"keyword\">val</span> yvel = velocityTracker.yVelocity</span><br><span class=\"line\">                fling(yvel.toInt())</span><br><span class=\"line\">                velocityTracker.clear()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fling</span><span class=\"params\">(velocityY: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        cancelFling()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//判断速度是否足够大。如果够大才执行fling</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> dy: <span class=\"built_in\">Int</span> = velocityY</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (abs(velocityY) &lt; viewConfiguration.scaledMinimumFlingVelocity) &#123;</span><br><span class=\"line\">            dy = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dy == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 这步必须要有，表明开始 TYPE_NON_TOUCH 的嵌套滚动</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果不设置，后续的嵌套滚动流程都都会找不到对应的parent</span></span><br><span class=\"line\">        startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_NON_TOUCH)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> maxFlingVelocity: <span class=\"built_in\">Int</span> = viewConfiguration.scaledMaximumFlingVelocity</span><br><span class=\"line\">        dy = max(-maxFlingVelocity, min(dy, maxFlingVelocity))</span><br><span class=\"line\"></span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"fling: <span class=\"variable\">$dy</span> \"</span>)</span><br><span class=\"line\">        fling = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"comment\">// 开始fling</span></span><br><span class=\"line\">        mScroller.fling(</span><br><span class=\"line\">            <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0</span>,</span><br><span class=\"line\">            <span class=\"number\">0</span>,</span><br><span class=\"line\">            dy,</span><br><span class=\"line\">            Integer.MIN_VALUE,</span><br><span class=\"line\">            Integer.MAX_VALUE,</span><br><span class=\"line\">            Integer.MIN_VALUE,</span><br><span class=\"line\">            Integer.MAX_VALUE</span><br><span class=\"line\">        )</span><br><span class=\"line\">        postInvalidate()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mScroller.computeScrollOffset() &amp;&amp; fling) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> y = mScroller.currY</span><br><span class=\"line\">            <span class=\"keyword\">var</span> dy = (mLastFlingY - y).toInt()</span><br><span class=\"line\">            mLastFlingY = y.toFloat()</span><br><span class=\"line\">            <span class=\"comment\">// 和触摸场景一样，优先让parent处理</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dispatchNestedPreScroll(<span class=\"number\">0</span>, dy, consumed, <span class=\"literal\">null</span>, TYPE_NON_TOUCH)) &#123;</span><br><span class=\"line\">                dy -= consumed[<span class=\"number\">1</span>]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Log.i(TAG, <span class=\"string\">\"computeScroll: <span class=\"subst\">$&#123;consumed[<span class=\"number\">1</span>]&#125;</span> <span class=\"variable\">$dy</span>\"</span>)</span><br><span class=\"line\">            <span class=\"comment\">// child 自己处理</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> consumedY = childFling(dy)</span><br><span class=\"line\">            <span class=\"comment\">// 将剩下的在传递给 parent</span></span><br><span class=\"line\">            dispatchNestedScroll(<span class=\"number\">0</span>, consumedY, <span class=\"number\">0</span>, dy - consumedY, <span class=\"literal\">null</span>, TYPE_NON_TOUCH)</span><br><span class=\"line\">            postInvalidate()</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stopNestedScroll(TYPE_NON_TOUCH)</span><br><span class=\"line\">            cancelFling()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">childConsumeY</span><span class=\"params\">(dy: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> consumed = dy</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (consumed &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果滑动到顶部，只处理部分，不然可能无法触达顶部边界</span></span><br><span class=\"line\">            consumed = max(-scrollY, consumed)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果滑动到顶部，只处理部分，不然可能会无法触达底部边界</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> max = max(childrenHeight - height, <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dy + scrollY &gt; max) &#123;</span><br><span class=\"line\">                consumed = max - scrollY</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"childConsumeY: <span class=\"variable\">$dy</span> <span class=\"variable\">$consumed</span> <span class=\"variable\">$scrollY</span>\"</span>)</span><br><span class=\"line\">        scrollBy(<span class=\"number\">0</span>, consumed)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> consumed</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">childFling</span><span class=\"params\">(dy: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> childConsumeY(dy)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">cancelFling</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        fling = <span class=\"literal\">false</span></span><br><span class=\"line\">        mLastFlingY = <span class=\"number\">0f</span></span><br><span class=\"line\">        mLastFlingY = <span class=\"number\">0f</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollTo</span><span class=\"params\">(x: <span class=\"type\">Int</span>, y: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> resY = y</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resY &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            resY = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> max = max(childrenHeight - height, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y &gt; max) &#123;</span><br><span class=\"line\">            resY = max</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"scrollTo: <span class=\"variable\">$max</span> <span class=\"variable\">$y</span> <span class=\"variable\">$resY</span>\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.scrollTo(x, resY)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">canScrollVertically</span><span class=\"params\">(direction: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (direction &lt; <span class=\"number\">0</span> &amp;&amp; scrollY &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (direction &gt; <span class=\"number\">0</span> &amp;&amp; scrollY &gt;= measuredHeight - height) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://juejin.cn/post/6844903960432607246#heading-1\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903960432607246#heading-1</a></p>\n"},{"title":"自定义ViewGroup","date":"2019-04-13T05:12:35.000Z","_content":"\n# 自定义ViewGroup\n\n### 参考文章\n[自定义LayoutParams](https://blog.csdn.net/xmxkf/article/details/51500304#3-%E6%94%AF%E6%8C%81layoutmargin%E5%B1%9E%E6%80%A7)\n[关于onMeasure过程的理解](https://blog.csdn.net/xmxkf/article/details/51490283)\n[Measure测量流程全解析（简洁）](https://juejin.im/post/5ad37c476fb9a028bc2e32af)\n### 下面是继承自ViewGroup的FlowLayout标签流式布局\n```java\npackage com.example.test;\n\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.ViewGroup;\n\npublic class FlowLayout extends ViewGroup {\n    public FlowLayout(Context context) {\n        super(context);\n    }\n\n    public FlowLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int specWidth = MeasureSpec.getSize(widthMeasureSpec);\n        int specHeight = MeasureSpec.getSize(heightMeasureSpec);\n        int specWidthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int specHeightMode = MeasureSpec.getMode(heightMeasureSpec);\n\n        int count = getChildCount();\n\n        //计算child的大小\n        for (int i = 0; i < count; i++) {\n            View child = getChildAt(i);\n            //measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0\n            //这里为了支持margin，所以用measureChildWithMargins方法\n            measureChildWithMargins(child,\n                    widthMeasureSpec, 0,\n                    heightMeasureSpec, 0);\n        }\n        //计算ViewGroup自身的大小\n        //这里只要处理height的wrap_content情况就可以了\n        int height = specHeight;\n        int width = specWidth;\n        if (specHeightMode == MeasureSpec.AT_MOST) {\n            height = getPaddingBottom() + getPaddingTop();\n            int used_width = 0;\n            int line_max_height = 0;\n            for (int i = 0; i < count; i++) {\n                View child = getChildAt(i);\n                MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams();\n                int child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;\n                int child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;\n                //在这一行可以容纳\n                if (used_width + child_width <= width - getPaddingStart() - getPaddingEnd()) {\n                    line_max_height = Math.max(line_max_height, child_height);\n                    used_width += child_width;\n                } else {\n                    //切换到下一行\n                    height += line_max_height;\n                    used_width = child_width;\n                    line_max_height = child_height;\n                }\n            }\n            //加上最后一行的最大height\n            height += line_max_height;\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    private final String TAG = \"test_log\";\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        int width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd();\n        int used_width = 0;\n        int used_height = 0;\n\n        int count = getChildCount();\n        int last_line_max_height = 0;\n        for (int i = 0; i < count; i++) {\n            View child_view = getChildAt(i);\n            MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams();\n            //用于计算是否越界时需要包含margin\n            int child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;\n            int child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;\n            //layout时的位置，必须考虑padding\n            int layout_l, layout_t, layout_r, layout_b;\n            if (used_width + child_width <= width) {\n                layout_l = getPaddingStart() + used_width + mlp.leftMargin;\n                layout_t = getPaddingTop() + used_height + mlp.topMargin;\n                layout_r = layout_l + child_view.getMeasuredWidth();\n                layout_b = layout_t + child_view.getMeasuredHeight();\n\n                used_width += child_width;\n                //记录该行height的最大值\n                last_line_max_height = Math.max(last_line_max_height, child_height);\n            } else {\n                layout_l = getPaddingStart() + mlp.leftMargin;\n                layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin;\n                layout_r = layout_l + child_view.getMeasuredWidth();\n                layout_b = layout_t + child_view.getMeasuredHeight();\n\n                used_height += last_line_max_height;\n                used_width = child_width;\n\n                last_line_max_height = child_height;\n            }\n            child_view.layout(layout_l, layout_t, layout_r, layout_b);\n        }\n    }\n\n    @Override\n    public LayoutParams generateLayoutParams(AttributeSet attrs) {\n        return new MarginLayoutParams(getContext(), attrs);\n    }\n\n    @Override\n    protected LayoutParams generateLayoutParams(LayoutParams p) {\n        return new MarginLayoutParams(p);\n    }\n\n    @Override\n    protected LayoutParams generateDefaultLayoutParams() {\n        return new MarginLayoutParams(super.generateDefaultLayoutParams());\n    }\n}\n\n```\n\n### 关于MeasureSpec\n\n父控件告诉子控件可获得的空间以及关于这个空间的约束条件\n\n#### SpecMode\n\n* EXACTLY\n  * 设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式\n* AT_MOST\n  * width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值\n* UNSPECIFIED\n  * 这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用\n\n### 关于view的Measure过程\n我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。\n    这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程：\n* **ViewRootImpl.performTraversals()->performMeasure():**\n> 这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量\n* **DecorView.measure()->onMeasure():**\n> DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量\n* **ViewGroupA.measure()->onMeasure():**\n>这是我们自定义的一个ViewGroup(继承自ViewGroup)\n假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。\n    所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，**里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。**\n* **ViewB.measure()->onMeasure():**\n> View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。\n\n### 测量子view时MeasureSpec的生成规则\n1. **当子View的宽高设置的是具体数值时**\n> 显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,**此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。**\n2. **当子View的宽高设置的是match_parent**\n> 则**不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。**（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）\n3. **当子View的宽高设置的是wrap_content,**\n> 因为这种情况父容器实在不知道子View应该多宽多高，**所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。**（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。\n    \n* 通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。**所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。**\n\n### 关于LayoutParams\n在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。**在使用中必须重写所有的generateLayoutParams()方法**\n尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams\n","source":"_posts/Android/自定义ViewGroup.md","raw":"---\ntitle: 自定义ViewGroup\ndate: 2019-04-13 13:12:35\ntags:\n- View\ncategories:\n- Android\n- View\n---\n\n# 自定义ViewGroup\n\n### 参考文章\n[自定义LayoutParams](https://blog.csdn.net/xmxkf/article/details/51500304#3-%E6%94%AF%E6%8C%81layoutmargin%E5%B1%9E%E6%80%A7)\n[关于onMeasure过程的理解](https://blog.csdn.net/xmxkf/article/details/51490283)\n[Measure测量流程全解析（简洁）](https://juejin.im/post/5ad37c476fb9a028bc2e32af)\n### 下面是继承自ViewGroup的FlowLayout标签流式布局\n```java\npackage com.example.test;\n\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.ViewGroup;\n\npublic class FlowLayout extends ViewGroup {\n    public FlowLayout(Context context) {\n        super(context);\n    }\n\n    public FlowLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public FlowLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int specWidth = MeasureSpec.getSize(widthMeasureSpec);\n        int specHeight = MeasureSpec.getSize(heightMeasureSpec);\n        int specWidthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int specHeightMode = MeasureSpec.getMode(heightMeasureSpec);\n\n        int count = getChildCount();\n\n        //计算child的大小\n        for (int i = 0; i < count; i++) {\n            View child = getChildAt(i);\n            //measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0\n            //这里为了支持margin，所以用measureChildWithMargins方法\n            measureChildWithMargins(child,\n                    widthMeasureSpec, 0,\n                    heightMeasureSpec, 0);\n        }\n        //计算ViewGroup自身的大小\n        //这里只要处理height的wrap_content情况就可以了\n        int height = specHeight;\n        int width = specWidth;\n        if (specHeightMode == MeasureSpec.AT_MOST) {\n            height = getPaddingBottom() + getPaddingTop();\n            int used_width = 0;\n            int line_max_height = 0;\n            for (int i = 0; i < count; i++) {\n                View child = getChildAt(i);\n                MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams();\n                int child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;\n                int child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;\n                //在这一行可以容纳\n                if (used_width + child_width <= width - getPaddingStart() - getPaddingEnd()) {\n                    line_max_height = Math.max(line_max_height, child_height);\n                    used_width += child_width;\n                } else {\n                    //切换到下一行\n                    height += line_max_height;\n                    used_width = child_width;\n                    line_max_height = child_height;\n                }\n            }\n            //加上最后一行的最大height\n            height += line_max_height;\n        }\n        setMeasuredDimension(width, height);\n    }\n\n    private final String TAG = \"test_log\";\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        int width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd();\n        int used_width = 0;\n        int used_height = 0;\n\n        int count = getChildCount();\n        int last_line_max_height = 0;\n        for (int i = 0; i < count; i++) {\n            View child_view = getChildAt(i);\n            MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams();\n            //用于计算是否越界时需要包含margin\n            int child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;\n            int child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;\n            //layout时的位置，必须考虑padding\n            int layout_l, layout_t, layout_r, layout_b;\n            if (used_width + child_width <= width) {\n                layout_l = getPaddingStart() + used_width + mlp.leftMargin;\n                layout_t = getPaddingTop() + used_height + mlp.topMargin;\n                layout_r = layout_l + child_view.getMeasuredWidth();\n                layout_b = layout_t + child_view.getMeasuredHeight();\n\n                used_width += child_width;\n                //记录该行height的最大值\n                last_line_max_height = Math.max(last_line_max_height, child_height);\n            } else {\n                layout_l = getPaddingStart() + mlp.leftMargin;\n                layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin;\n                layout_r = layout_l + child_view.getMeasuredWidth();\n                layout_b = layout_t + child_view.getMeasuredHeight();\n\n                used_height += last_line_max_height;\n                used_width = child_width;\n\n                last_line_max_height = child_height;\n            }\n            child_view.layout(layout_l, layout_t, layout_r, layout_b);\n        }\n    }\n\n    @Override\n    public LayoutParams generateLayoutParams(AttributeSet attrs) {\n        return new MarginLayoutParams(getContext(), attrs);\n    }\n\n    @Override\n    protected LayoutParams generateLayoutParams(LayoutParams p) {\n        return new MarginLayoutParams(p);\n    }\n\n    @Override\n    protected LayoutParams generateDefaultLayoutParams() {\n        return new MarginLayoutParams(super.generateDefaultLayoutParams());\n    }\n}\n\n```\n\n### 关于MeasureSpec\n\n父控件告诉子控件可获得的空间以及关于这个空间的约束条件\n\n#### SpecMode\n\n* EXACTLY\n  * 设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式\n* AT_MOST\n  * width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值\n* UNSPECIFIED\n  * 这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用\n\n### 关于view的Measure过程\n我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。\n    这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程：\n* **ViewRootImpl.performTraversals()->performMeasure():**\n> 这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量\n* **DecorView.measure()->onMeasure():**\n> DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量\n* **ViewGroupA.measure()->onMeasure():**\n>这是我们自定义的一个ViewGroup(继承自ViewGroup)\n假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。\n    所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，**里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。**\n* **ViewB.measure()->onMeasure():**\n> View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。\n\n### 测量子view时MeasureSpec的生成规则\n1. **当子View的宽高设置的是具体数值时**\n> 显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,**此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。**\n2. **当子View的宽高设置的是match_parent**\n> 则**不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。**（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）\n3. **当子View的宽高设置的是wrap_content,**\n> 因为这种情况父容器实在不知道子View应该多宽多高，**所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。**（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。\n    \n* 通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。**所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。**\n\n### 关于LayoutParams\n在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。**在使用中必须重写所有的generateLayoutParams()方法**\n尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams\n","slug":"Android/自定义ViewGroup","published":1,"updated":"2021-10-03T01:57:41.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8e002xg0jel5v1sb37","content":"<h1 id=\"自定义ViewGroup\"><a href=\"#自定义ViewGroup\" class=\"headerlink\" title=\"自定义ViewGroup\"></a>自定义ViewGroup</h1><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://blog.csdn.net/xmxkf/article/details/51500304#3-%E6%94%AF%E6%8C%81layoutmargin%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">自定义LayoutParams</a><br><a href=\"https://blog.csdn.net/xmxkf/article/details/51490283\" target=\"_blank\" rel=\"noopener\">关于onMeasure过程的理解</a><br><a href=\"https://juejin.im/post/5ad37c476fb9a028bc2e32af\" target=\"_blank\" rel=\"noopener\">Measure测量流程全解析（简洁）</a></p><a id=\"more\"></a>\n<h3 id=\"下面是继承自ViewGroup的FlowLayout标签流式布局\"><a href=\"#下面是继承自ViewGroup的FlowLayout标签流式布局\" class=\"headerlink\" title=\"下面是继承自ViewGroup的FlowLayout标签流式布局\"></a>下面是继承自ViewGroup的FlowLayout标签流式布局</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.View;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewGroup;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlowLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specWidthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specHeightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = getChildCount();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//计算child的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            View child = getChildAt(i);</span><br><span class=\"line\">            <span class=\"comment\">//measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0</span></span><br><span class=\"line\">            <span class=\"comment\">//这里为了支持margin，所以用measureChildWithMargins方法</span></span><br><span class=\"line\">            measureChildWithMargins(child,</span><br><span class=\"line\">                    widthMeasureSpec, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    heightMeasureSpec, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//计算ViewGroup自身的大小</span></span><br><span class=\"line\">        <span class=\"comment\">//这里只要处理height的wrap_content情况就可以了</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> height = specHeight;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = specWidth;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specHeightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class=\"line\">            height = getPaddingBottom() + getPaddingTop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> used_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> line_max_height = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">                View child = getChildAt(i);</span><br><span class=\"line\">                MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;</span><br><span class=\"line\">                <span class=\"comment\">//在这一行可以容纳</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (used_width + child_width &lt;= width - getPaddingStart() - getPaddingEnd()) &#123;</span><br><span class=\"line\">                    line_max_height = Math.max(line_max_height, child_height);</span><br><span class=\"line\">                    used_width += child_width;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//切换到下一行</span></span><br><span class=\"line\">                    height += line_max_height;</span><br><span class=\"line\">                    used_width = child_width;</span><br><span class=\"line\">                    line_max_height = child_height;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//加上最后一行的最大height</span></span><br><span class=\"line\">            height += line_max_height;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setMeasuredDimension(width, height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"test_log\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> used_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> used_height = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last_line_max_height = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            View child_view = getChildAt(i);</span><br><span class=\"line\">            MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams();</span><br><span class=\"line\">            <span class=\"comment\">//用于计算是否越界时需要包含margin</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;</span><br><span class=\"line\">            <span class=\"comment\">//layout时的位置，必须考虑padding</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> layout_l, layout_t, layout_r, layout_b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (used_width + child_width &lt;= width) &#123;</span><br><span class=\"line\">                layout_l = getPaddingStart() + used_width + mlp.leftMargin;</span><br><span class=\"line\">                layout_t = getPaddingTop() + used_height + mlp.topMargin;</span><br><span class=\"line\">                layout_r = layout_l + child_view.getMeasuredWidth();</span><br><span class=\"line\">                layout_b = layout_t + child_view.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">                used_width += child_width;</span><br><span class=\"line\">                <span class=\"comment\">//记录该行height的最大值</span></span><br><span class=\"line\">                last_line_max_height = Math.max(last_line_max_height, child_height);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                layout_l = getPaddingStart() + mlp.leftMargin;</span><br><span class=\"line\">                layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin;</span><br><span class=\"line\">                layout_r = layout_l + child_view.getMeasuredWidth();</span><br><span class=\"line\">                layout_b = layout_t + child_view.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">                used_height += last_line_max_height;</span><br><span class=\"line\">                used_width = child_width;</span><br><span class=\"line\"></span><br><span class=\"line\">                last_line_max_height = child_height;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            child_view.layout(layout_l, layout_t, layout_r, layout_b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(getContext(), attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(LayoutParams p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> LayoutParams <span class=\"title\">generateDefaultLayoutParams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(<span class=\"keyword\">super</span>.generateDefaultLayoutParams());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于MeasureSpec\"><a href=\"#关于MeasureSpec\" class=\"headerlink\" title=\"关于MeasureSpec\"></a>关于MeasureSpec</h3><p>父控件告诉子控件可获得的空间以及关于这个空间的约束条件</p>\n<h4 id=\"SpecMode\"><a href=\"#SpecMode\" class=\"headerlink\" title=\"SpecMode\"></a>SpecMode</h4><ul>\n<li>EXACTLY<ul>\n<li>设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式</li>\n</ul>\n</li>\n<li>AT_MOST<ul>\n<li>width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值</li>\n</ul>\n</li>\n<li>UNSPECIFIED<ul>\n<li>这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关于view的Measure过程\"><a href=\"#关于view的Measure过程\" class=\"headerlink\" title=\"关于view的Measure过程\"></a>关于view的Measure过程</h3><p>我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。<br>    这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程：</p>\n<ul>\n<li><strong>ViewRootImpl.performTraversals()-&gt;performMeasure():</strong><blockquote>\n<p>这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量</p>\n</blockquote>\n</li>\n<li><strong>DecorView.measure()-&gt;onMeasure():</strong><blockquote>\n<p>DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量</p>\n</blockquote>\n</li>\n<li><strong>ViewGroupA.measure()-&gt;onMeasure():</strong><blockquote>\n<p>这是我们自定义的一个ViewGroup(继承自ViewGroup)<br>假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。<br>  所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，<strong>里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。</strong></p>\n</blockquote>\n</li>\n<li><strong>ViewB.measure()-&gt;onMeasure():</strong><blockquote>\n<p>View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"测量子view时MeasureSpec的生成规则\"><a href=\"#测量子view时MeasureSpec的生成规则\" class=\"headerlink\" title=\"测量子view时MeasureSpec的生成规则\"></a>测量子view时MeasureSpec的生成规则</h3><ol>\n<li><strong>当子View的宽高设置的是具体数值时</strong><blockquote>\n<p>显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,<strong>此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。</strong></p>\n</blockquote>\n</li>\n<li><strong>当子View的宽高设置的是match_parent</strong><blockquote>\n<p>则<strong>不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。</strong>（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）</p>\n</blockquote>\n</li>\n<li><strong>当子View的宽高设置的是wrap_content,</strong><blockquote>\n<p>因为这种情况父容器实在不知道子View应该多宽多高，<strong>所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。</strong>（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。<strong>所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。</strong></li>\n</ul>\n<h3 id=\"关于LayoutParams\"><a href=\"#关于LayoutParams\" class=\"headerlink\" title=\"关于LayoutParams\"></a>关于LayoutParams</h3><p>在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。<strong>在使用中必须重写所有的generateLayoutParams()方法</strong><br>尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"自定义ViewGroup\"><a href=\"#自定义ViewGroup\" class=\"headerlink\" title=\"自定义ViewGroup\"></a>自定义ViewGroup</h1><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://blog.csdn.net/xmxkf/article/details/51500304#3-%E6%94%AF%E6%8C%81layoutmargin%E5%B1%9E%E6%80%A7\" target=\"_blank\" rel=\"noopener\">自定义LayoutParams</a><br><a href=\"https://blog.csdn.net/xmxkf/article/details/51490283\" target=\"_blank\" rel=\"noopener\">关于onMeasure过程的理解</a><br><a href=\"https://juejin.im/post/5ad37c476fb9a028bc2e32af\" target=\"_blank\" rel=\"noopener\">Measure测量流程全解析（简洁）</a></p>","more":"\n<h3 id=\"下面是继承自ViewGroup的FlowLayout标签流式布局\"><a href=\"#下面是继承自ViewGroup的FlowLayout标签流式布局\" class=\"headerlink\" title=\"下面是继承自ViewGroup的FlowLayout标签流式布局\"></a>下面是继承自ViewGroup的FlowLayout标签流式布局</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.View;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewGroup;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlowLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FlowLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specWidthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> specHeightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = getChildCount();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//计算child的大小</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            View child = getChildAt(i);</span><br><span class=\"line\">            <span class=\"comment\">//measureChildWithMargins方法在计算时已经考虑到了padding, 所以这里widthUsed参数设置为0</span></span><br><span class=\"line\">            <span class=\"comment\">//这里为了支持margin，所以用measureChildWithMargins方法</span></span><br><span class=\"line\">            measureChildWithMargins(child,</span><br><span class=\"line\">                    widthMeasureSpec, <span class=\"number\">0</span>,</span><br><span class=\"line\">                    heightMeasureSpec, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//计算ViewGroup自身的大小</span></span><br><span class=\"line\">        <span class=\"comment\">//这里只要处理height的wrap_content情况就可以了</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> height = specHeight;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = specWidth;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (specHeightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class=\"line\">            height = getPaddingBottom() + getPaddingTop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> used_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> line_max_height = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">                View child = getChildAt(i);</span><br><span class=\"line\">                MarginLayoutParams mlp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child_width = child.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> child_height = child.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;</span><br><span class=\"line\">                <span class=\"comment\">//在这一行可以容纳</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (used_width + child_width &lt;= width - getPaddingStart() - getPaddingEnd()) &#123;</span><br><span class=\"line\">                    line_max_height = Math.max(line_max_height, child_height);</span><br><span class=\"line\">                    used_width += child_width;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//切换到下一行</span></span><br><span class=\"line\">                    height += line_max_height;</span><br><span class=\"line\">                    used_width = child_width;</span><br><span class=\"line\">                    line_max_height = child_height;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//加上最后一行的最大height</span></span><br><span class=\"line\">            height += line_max_height;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setMeasuredDimension(width, height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"test_log\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> width = getMeasuredWidth() - getPaddingStart() - getPaddingEnd();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> used_width = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> used_height = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> last_line_max_height = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++) &#123;</span><br><span class=\"line\">            View child_view = getChildAt(i);</span><br><span class=\"line\">            MarginLayoutParams mlp = (MarginLayoutParams) child_view.getLayoutParams();</span><br><span class=\"line\">            <span class=\"comment\">//用于计算是否越界时需要包含margin</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> child_width = child_view.getMeasuredWidth() + mlp.leftMargin + mlp.rightMargin;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> child_height = child_view.getMeasuredHeight() + mlp.topMargin + mlp.bottomMargin;</span><br><span class=\"line\">            <span class=\"comment\">//layout时的位置，必须考虑padding</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> layout_l, layout_t, layout_r, layout_b;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (used_width + child_width &lt;= width) &#123;</span><br><span class=\"line\">                layout_l = getPaddingStart() + used_width + mlp.leftMargin;</span><br><span class=\"line\">                layout_t = getPaddingTop() + used_height + mlp.topMargin;</span><br><span class=\"line\">                layout_r = layout_l + child_view.getMeasuredWidth();</span><br><span class=\"line\">                layout_b = layout_t + child_view.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">                used_width += child_width;</span><br><span class=\"line\">                <span class=\"comment\">//记录该行height的最大值</span></span><br><span class=\"line\">                last_line_max_height = Math.max(last_line_max_height, child_height);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                layout_l = getPaddingStart() + mlp.leftMargin;</span><br><span class=\"line\">                layout_t = getPaddingTop() + used_height + last_line_max_height + mlp.topMargin;</span><br><span class=\"line\">                layout_r = layout_l + child_view.getMeasuredWidth();</span><br><span class=\"line\">                layout_b = layout_t + child_view.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">                used_height += last_line_max_height;</span><br><span class=\"line\">                used_width = child_width;</span><br><span class=\"line\"></span><br><span class=\"line\">                last_line_max_height = child_height;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            child_view.layout(layout_l, layout_t, layout_r, layout_b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(getContext(), attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> LayoutParams <span class=\"title\">generateLayoutParams</span><span class=\"params\">(LayoutParams p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> LayoutParams <span class=\"title\">generateDefaultLayoutParams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MarginLayoutParams(<span class=\"keyword\">super</span>.generateDefaultLayoutParams());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于MeasureSpec\"><a href=\"#关于MeasureSpec\" class=\"headerlink\" title=\"关于MeasureSpec\"></a>关于MeasureSpec</h3><p>父控件告诉子控件可获得的空间以及关于这个空间的约束条件</p>\n<h4 id=\"SpecMode\"><a href=\"#SpecMode\" class=\"headerlink\" title=\"SpecMode\"></a>SpecMode</h4><ul>\n<li>EXACTLY<ul>\n<li>设置了精确的宽高。如width、height设置了具体值或者设置为 match_parent，都属于这种模式</li>\n</ul>\n</li>\n<li>AT_MOST<ul>\n<li>width、height设置为wrap_content则属于这种模式。表示父容器只是限制了子view的最大值</li>\n</ul>\n</li>\n<li>UNSPECIFIED<ul>\n<li>这种模式一般用于系统， 父容器不对View有任何限制。 一般很少用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关于view的Measure过程\"><a href=\"#关于view的Measure过程\" class=\"headerlink\" title=\"关于view的Measure过程\"></a>关于view的Measure过程</h3><p>我们知道，整个绘制流程是从ViewRootImpl类中performTraversals()开始的，这里面分别执行performMeasure、performLayout、performDraw来完成整个绘制的三大流程。而三大流程都是至顶向下，今天这里只说measure的过程。<br>    这里以DecorView(根View)面放着一个ViewGroup(ViewGroupA)ViewGroup里面放着一个View(ViewB)为例来说明整个测量的流程：</p>\n<ul>\n<li><strong>ViewRootImpl.performTraversals()-&gt;performMeasure():</strong><blockquote>\n<p>这里面会调getRootMeasureSpec（）根据手机屏幕的宽高和DecorView的LayoutParams生成DecorView的MeasureSpec,然后调用DecorView的measure()开始DecorView的测量</p>\n</blockquote>\n</li>\n<li><strong>DecorView.measure()-&gt;onMeasure():</strong><blockquote>\n<p>DecorView继承自FrameLayout，所以会走到FrameLayout的onMeasure(),onMeasure()里调measureChild()来根据上面说的规则为ViewGroupA生成MeasureSpec，并通过ViewGroupA.measure（）开始ViewGroupA的测量</p>\n</blockquote>\n</li>\n<li><strong>ViewGroupA.measure()-&gt;onMeasure():</strong><blockquote>\n<p>这是我们自定义的一个ViewGroup(继承自ViewGroup)<br>假如我们没有重写onMeasure()的话，则默认调的是View.onMeasure()，则不会发起对子View的measure,它里面的子View也就不会被测量(0),而这个ViewGroup如果没有设置具体宽高的话，（wrap_content）则ViewGroup展示的就是父容器的宽高（根据上面说的MeasureSpec生成规则)。<br>  所以如果我们继承自ViewGroup来自定义一个ViewGroup的话，是肯定要重写onMeasure()的，<strong>里面要调用measureChild()来为子View生成MeasureSpec并调child.measure()开始对child的测量(getChildMeasureSpec()方法)，这样子View才能被测量显示。而如果我们要使设置的wrap_content生效，还要根据子View测量结果进行计算从而得到自己的宽高，最后通过调setMeasuredDimension(int measuredWidth, int measuredHeight)来设置自己的宽高，从而达到wrap_content的效果。</strong></p>\n</blockquote>\n</li>\n<li><strong>ViewB.measure()-&gt;onMeasure():</strong><blockquote>\n<p>View的测量相对于ViewGroup要简单点，因为不用去Measure child,但是一样的，如果要使wrap_conten生效需自己重写onMeasure()计算。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"测量子view时MeasureSpec的生成规则\"><a href=\"#测量子view时MeasureSpec的生成规则\" class=\"headerlink\" title=\"测量子view时MeasureSpec的生成规则\"></a>测量子view时MeasureSpec的生成规则</h3><ol>\n<li><strong>当子View的宽高设置的是具体数值时</strong><blockquote>\n<p>显然我们可以直接拿到子View的宽高，则子View宽高就确定了，不用再去考虑父容器的SpecMode了,<strong>此时子View的SpecMode为EXACTLY，SpecSize就是设置的宽高。</strong></p>\n</blockquote>\n</li>\n<li><strong>当子View的宽高设置的是match_parent</strong><blockquote>\n<p>则<strong>不管父容器的SpecMode是什么模式，子View的SpecSize就等于父容器的宽高，而子View的SpecMode随父容器的SpecMode。</strong>（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）</p>\n</blockquote>\n</li>\n<li><strong>当子View的宽高设置的是wrap_content,</strong><blockquote>\n<p>因为这种情况父容器实在不知道子View应该多宽多高，<strong>所以子View的SpecSize给的是父容器的宽高，也就是说只是给子View限制了一个最大宽高，而子View的SpecMode是AT_MOST模式。</strong>（这里没有考虑UNSPECIFIED模式，如果父容器是UNSPECIFIED模式，则子View SpecSize为0，SpecMode为UNSPECIFIED）。</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>通过上面的解析我们可以知道，当你给一个View/ViewGroup设置宽高为具体数值或者match_parent，它都能正确的显示，但是如果你设置的是wrap_content，则默认显示出来是其父容器的大小，如果你想要它正常的显示为wrap_content，则你就要自己重写onMeasure()来自己计算它的宽高度并设置。<strong>所以我们平常自定义View/ViewGroup的时候之所以要重写onMeasure()，就是为了能让wrap_content达到效果。</strong></li>\n</ul>\n<h3 id=\"关于LayoutParams\"><a href=\"#关于LayoutParams\" class=\"headerlink\" title=\"关于LayoutParams\"></a>关于LayoutParams</h3><p>在上面的FlowLayout代码中，为了支持margin属性，使用了MarginLayoutParams。这个MarginLayoutParams继承自LayoutParams。<strong>在使用中必须重写所有的generateLayoutParams()方法</strong><br>尝试了一下，RelativeLayoutParams等都是继承自MarginLayoutParams</p>\n"},{"title":"自定义LayoutManager","date":"2021-02-26T09:06:00.000Z","_content":"\n# LayoutManager 的常用方法\n\n### generateDefaultLayoutParams\n\n生成默认RecyclerView的LayoutParams, 没啥意义，就返回 wrap_content\n\n### isAutoMeasureEnabled 和 onMeasure\n\nisAutoMeasureEnabled()是自测量模式。 如果要支持 wrap_content ，那必须重写这两个方法中的一个。 大部分情况下，isAutoMeasureEnabled 返回 true 即可。重写onMeasure()的情况也极少，除非像我那个PickerLayoutManger一样。\n\n### canScrollHorizontally 和 canScrollVertically \n\n无需多言\n\n### onLayoutChildren \n\n当 RecyclerView 的 layout 过程中会调用这个方法，**包括第一次 layout 和 其他原因的重新 layout**，比如说键盘的升降。\n\n### scrollHorizontallyBy 和 scrollVerticallyBy\n\n```\noverride fun scrollHorizontallyBy(\n\n    dx: Int,\n    recycler: RecyclerView.Recycler,\n    state: RecyclerView.State\n): Int {\n    ...\n}\n```\n\nRecyclerView 滚动的时候回回调这个方法，但是它只是告诉你用户滑动的距离，需要你自己去实现滑动的效果。同时需要去判断滑动的边界。\n但是返回值与 RecyclerView 的 overScorll 的动画有关，返回0会有边界的波纹动画。\n\n### getPosition(View)\n\n返回 child view 在 adapter 中的位置\n\n### getDecoratedXxxx\n\n在 LayoutManager 中与布局有关的api都需要替换成带 Decorated 的api，不然无法实现对 itemDecorated 的兼容\n\n### detachAndScrapAttachedViews()\n\n从 RecyclerView 暂时移除 child 并送入临时缓存。 之前一直很奇怪，暂时移除是个什么场景。 后来想明白了，在每次布局 child 之前，都需要吧调用一次这个方法，吧所有的 child 移除到临时缓存里。否则，在布局的时候 addView(child) ，如果 child 已经 add 到了 RecyclerView 里，会造成一些麻烦。\n\n### removeAndRecycleView\n\n移除 child 并将对应的 ViewHolder 移动到 cachePool ，从 cachePool 中取出的 ViewHolder 需要重新调用 Adapter.onBindViewHolder 方法\n\n# 自定义 LayoutManager 的一般套路\n\nscrollHorizontallyBy 和 onLayoutChildren 可以服用同一个布局逻辑。\n\n1. 确定锚点 view 的 position\n2. 确定布局的左右(上下)边界\n3. 开始 addView()->measureView()->layoutView() \n4. 回收布局边界之外的 child\n\n# demo代码\n\n```kotlin\nclass CustomLinearLayoutManager : RecyclerView.LayoutManager() {\n\n    override fun generateDefaultLayoutParams(): RecyclerView.LayoutParams {\n        return RecyclerView.LayoutParams(\n            ViewGroup.LayoutParams.WRAP_CONTENT,\n            ViewGroup.LayoutParams.WRAP_CONTENT\n        )\n    }\n\n    override fun isAutoMeasureEnabled(): Boolean {\n        return true\n    }\n\n    override fun canScrollHorizontally(): Boolean {\n        return true\n    }\n\n    override fun canScrollVertically(): Boolean {\n        return false\n    }\n\n    override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) {\n        if (state.itemCount == 0) {\n            removeAndRecycleAllViews(recycler)\n            return\n        }\n\n        var left = paddingStart\n        var curPos = 0\n        if (childCount > 0) {\n            // 这里是兼容键盘升起然后重新 rebuild 的情况。\n            // 如果不做兼容，RecyclerView 会移动到列表最顶部\n            left = getDecoratedLeft(getChildAt(0)!!)\n            curPos = getPosition(getChildAt(0)!!)\n        }\n\n        detachAndScrapAttachedViews(recycler)\n\n        fill(recycler, state, curPos, left, paddingStart + getAvailableSpace(), true)\n    }\n\n    override fun scrollHorizontallyBy(\n        dx: Int,\n        recycler: RecyclerView.Recycler,\n        state: RecyclerView.State\n    ): Int {\n        val resDx = calculateOffset(recycler, state, dx)\n        if (resDx == 0 || itemCount == 0) {\n            return resDx\n        }\n\n        val d = abs(resDx)\n        if (resDx >= 0) {\n            val anchorView = getChildAt(0)\n            val anchorPos = getPosition(anchorView!!)\n            val anchorLeft = getDecoratedLeft(anchorView)\n\n            detachAndScrapAttachedViews(recycler)\n\n            fill(recycler, state, anchorPos, anchorLeft - d, getAvailableSpace() + paddingStart, true)\n        } else {\n            val anchorView = getChildAt(childCount - 1)\n            val anchorPos = getPosition(anchorView!!)\n            val anchorRight = getDecoratedRight(anchorView)\n\n            detachAndScrapAttachedViews(recycler)\n\n            fill(recycler, state, anchorPos, paddingLeft, anchorRight + d, false)\n        }\n\n        recycler(recycler, state, resDx)\n\n        return resDx\n    }\n    \n    private fun calculateOffset(recycler: RecyclerView.Recycler, state: RecyclerView.State, dx: Int): Int {\n        if (childCount == 0 || dx == 0) {\n            return 0\n        }\n\n        var fillPos = RecyclerView.NO_POSITION\n        val d = abs(dx)\n\n\n        if (dx < 0) {\n            val firstView = getChildAt(0)\n            val firstPos = getPosition(firstView!!)\n            val firstLeft = getDecoratedLeft(firstView)\n\n            fillPos = firstPos - 1\n\n            if (fillPos < 0 && firstLeft + d > paddingStart) {\n                return firstLeft - paddingStart\n            }\n            if (firstLeft + d < paddingStart) {\n                return dx\n            }\n\n        } else {\n            val lastView = getChildAt(childCount - 1)\n            val lastPos = getPosition(lastView!!)\n            val lastRight = getDecoratedRight(lastView)\n\n            fillPos = lastPos + 1\n            val endEdge = getAvailableSpace() + paddingStart\n\n            if (fillPos >= itemCount && lastRight - d < endEdge) {\n                return lastRight - endEdge\n            }\n            if (lastRight - d > endEdge) {\n                return dx\n            }\n        }\n        \n        return dx\n    }\n\n    private fun fill(recycler: RecyclerView.Recycler, state: RecyclerView.State,\n                     anchorIndex: Int, anchorLeft: Int, anchorRight: Int, isLTR: Boolean) {\n        var availableSpace = anchorRight - anchorLeft\n        var fillPos = anchorIndex\n        var left = anchorLeft\n        var right = anchorRight\n        val top = paddingTop\n\n        while (availableSpace > 0 && fillPos >= 0 && fillPos < state.itemCount) {\n            val view = recycler.getViewForPosition(fillPos)\n            if (isLTR) {\n                addView(view)\n                measureChildWithMargins(view, 0, 0)\n                right = left + getDecoratedMeasuredWidth(view)\n                val bottom = top + getDecoratedMeasuredHeight(view)\n                layoutDecoratedWithMargins(view, left, top, right, bottom)\n                fillPos++\n                left = right\n            } else {\n                addView(view, 0)\n                measureChildWithMargins(view, 0, 0)\n                left = right - getDecoratedMeasuredWidth(view)\n                val bottom = top + getDecoratedMeasuredHeight(view)\n                layoutDecoratedWithMargins(view, left, top, right, bottom)\n                fillPos--\n                right = left\n            }\n\n            availableSpace -= getDecoratedMeasuredWidth(view)\n        }\n    }\n\n    private fun recycler(recycler: RecyclerView.Recycler, state: RecyclerView.State, dx: Int) {\n        //要回收View的集合，暂存\n        val recycleViews = hashSetOf<View>()\n\n        //dx>0就是手指从右滑向左，所以要回收前面的children\n        if (dx > 0) {\n            for (i in 0 until childCount) {\n                val child = getChildAt(i)!!\n                val right = getDecoratedRight(child)\n                //itemView的right<0就是要超出屏幕要回收View\n                if (right > paddingStart) break\n                recycleViews.add(child)\n            }\n        }\n \n        //dx<0就是手指从左滑向右，所以要回收后面的children\n        if (dx < 0) {\n            for (i in childCount - 1 downTo 0) {\n                val child = getChildAt(i)!!\n                val left = getDecoratedLeft(child)\n\n                //itemView的left>recyclerView.width就是要超出屏幕要回收View\n                if (left < getAvailableSpace() + paddingStart) break\n                recycleViews.add(child)\n            }\n        }\n\n        //真正把View移除掉\n        for (view in recycleViews) {\n            removeAndRecycleView(view, recycler)\n        }\n    }\n\n    private fun getAvailableSpace(): Int {\n        return width - paddingStart - paddingEnd\n    }\n}\n```","source":"_posts/Android/自定义LayoutManager.md","raw":"---\ntitle: 自定义LayoutManager\ndate: 2021-02-26 17:06:00\ntags:\n- RecyclerView\n- Android\n---\n\n# LayoutManager 的常用方法\n\n### generateDefaultLayoutParams\n\n生成默认RecyclerView的LayoutParams, 没啥意义，就返回 wrap_content\n\n### isAutoMeasureEnabled 和 onMeasure\n\nisAutoMeasureEnabled()是自测量模式。 如果要支持 wrap_content ，那必须重写这两个方法中的一个。 大部分情况下，isAutoMeasureEnabled 返回 true 即可。重写onMeasure()的情况也极少，除非像我那个PickerLayoutManger一样。\n\n### canScrollHorizontally 和 canScrollVertically \n\n无需多言\n\n### onLayoutChildren \n\n当 RecyclerView 的 layout 过程中会调用这个方法，**包括第一次 layout 和 其他原因的重新 layout**，比如说键盘的升降。\n\n### scrollHorizontallyBy 和 scrollVerticallyBy\n\n```\noverride fun scrollHorizontallyBy(\n\n    dx: Int,\n    recycler: RecyclerView.Recycler,\n    state: RecyclerView.State\n): Int {\n    ...\n}\n```\n\nRecyclerView 滚动的时候回回调这个方法，但是它只是告诉你用户滑动的距离，需要你自己去实现滑动的效果。同时需要去判断滑动的边界。\n但是返回值与 RecyclerView 的 overScorll 的动画有关，返回0会有边界的波纹动画。\n\n### getPosition(View)\n\n返回 child view 在 adapter 中的位置\n\n### getDecoratedXxxx\n\n在 LayoutManager 中与布局有关的api都需要替换成带 Decorated 的api，不然无法实现对 itemDecorated 的兼容\n\n### detachAndScrapAttachedViews()\n\n从 RecyclerView 暂时移除 child 并送入临时缓存。 之前一直很奇怪，暂时移除是个什么场景。 后来想明白了，在每次布局 child 之前，都需要吧调用一次这个方法，吧所有的 child 移除到临时缓存里。否则，在布局的时候 addView(child) ，如果 child 已经 add 到了 RecyclerView 里，会造成一些麻烦。\n\n### removeAndRecycleView\n\n移除 child 并将对应的 ViewHolder 移动到 cachePool ，从 cachePool 中取出的 ViewHolder 需要重新调用 Adapter.onBindViewHolder 方法\n\n# 自定义 LayoutManager 的一般套路\n\nscrollHorizontallyBy 和 onLayoutChildren 可以服用同一个布局逻辑。\n\n1. 确定锚点 view 的 position\n2. 确定布局的左右(上下)边界\n3. 开始 addView()->measureView()->layoutView() \n4. 回收布局边界之外的 child\n\n# demo代码\n\n```kotlin\nclass CustomLinearLayoutManager : RecyclerView.LayoutManager() {\n\n    override fun generateDefaultLayoutParams(): RecyclerView.LayoutParams {\n        return RecyclerView.LayoutParams(\n            ViewGroup.LayoutParams.WRAP_CONTENT,\n            ViewGroup.LayoutParams.WRAP_CONTENT\n        )\n    }\n\n    override fun isAutoMeasureEnabled(): Boolean {\n        return true\n    }\n\n    override fun canScrollHorizontally(): Boolean {\n        return true\n    }\n\n    override fun canScrollVertically(): Boolean {\n        return false\n    }\n\n    override fun onLayoutChildren(recycler: RecyclerView.Recycler, state: RecyclerView.State) {\n        if (state.itemCount == 0) {\n            removeAndRecycleAllViews(recycler)\n            return\n        }\n\n        var left = paddingStart\n        var curPos = 0\n        if (childCount > 0) {\n            // 这里是兼容键盘升起然后重新 rebuild 的情况。\n            // 如果不做兼容，RecyclerView 会移动到列表最顶部\n            left = getDecoratedLeft(getChildAt(0)!!)\n            curPos = getPosition(getChildAt(0)!!)\n        }\n\n        detachAndScrapAttachedViews(recycler)\n\n        fill(recycler, state, curPos, left, paddingStart + getAvailableSpace(), true)\n    }\n\n    override fun scrollHorizontallyBy(\n        dx: Int,\n        recycler: RecyclerView.Recycler,\n        state: RecyclerView.State\n    ): Int {\n        val resDx = calculateOffset(recycler, state, dx)\n        if (resDx == 0 || itemCount == 0) {\n            return resDx\n        }\n\n        val d = abs(resDx)\n        if (resDx >= 0) {\n            val anchorView = getChildAt(0)\n            val anchorPos = getPosition(anchorView!!)\n            val anchorLeft = getDecoratedLeft(anchorView)\n\n            detachAndScrapAttachedViews(recycler)\n\n            fill(recycler, state, anchorPos, anchorLeft - d, getAvailableSpace() + paddingStart, true)\n        } else {\n            val anchorView = getChildAt(childCount - 1)\n            val anchorPos = getPosition(anchorView!!)\n            val anchorRight = getDecoratedRight(anchorView)\n\n            detachAndScrapAttachedViews(recycler)\n\n            fill(recycler, state, anchorPos, paddingLeft, anchorRight + d, false)\n        }\n\n        recycler(recycler, state, resDx)\n\n        return resDx\n    }\n    \n    private fun calculateOffset(recycler: RecyclerView.Recycler, state: RecyclerView.State, dx: Int): Int {\n        if (childCount == 0 || dx == 0) {\n            return 0\n        }\n\n        var fillPos = RecyclerView.NO_POSITION\n        val d = abs(dx)\n\n\n        if (dx < 0) {\n            val firstView = getChildAt(0)\n            val firstPos = getPosition(firstView!!)\n            val firstLeft = getDecoratedLeft(firstView)\n\n            fillPos = firstPos - 1\n\n            if (fillPos < 0 && firstLeft + d > paddingStart) {\n                return firstLeft - paddingStart\n            }\n            if (firstLeft + d < paddingStart) {\n                return dx\n            }\n\n        } else {\n            val lastView = getChildAt(childCount - 1)\n            val lastPos = getPosition(lastView!!)\n            val lastRight = getDecoratedRight(lastView)\n\n            fillPos = lastPos + 1\n            val endEdge = getAvailableSpace() + paddingStart\n\n            if (fillPos >= itemCount && lastRight - d < endEdge) {\n                return lastRight - endEdge\n            }\n            if (lastRight - d > endEdge) {\n                return dx\n            }\n        }\n        \n        return dx\n    }\n\n    private fun fill(recycler: RecyclerView.Recycler, state: RecyclerView.State,\n                     anchorIndex: Int, anchorLeft: Int, anchorRight: Int, isLTR: Boolean) {\n        var availableSpace = anchorRight - anchorLeft\n        var fillPos = anchorIndex\n        var left = anchorLeft\n        var right = anchorRight\n        val top = paddingTop\n\n        while (availableSpace > 0 && fillPos >= 0 && fillPos < state.itemCount) {\n            val view = recycler.getViewForPosition(fillPos)\n            if (isLTR) {\n                addView(view)\n                measureChildWithMargins(view, 0, 0)\n                right = left + getDecoratedMeasuredWidth(view)\n                val bottom = top + getDecoratedMeasuredHeight(view)\n                layoutDecoratedWithMargins(view, left, top, right, bottom)\n                fillPos++\n                left = right\n            } else {\n                addView(view, 0)\n                measureChildWithMargins(view, 0, 0)\n                left = right - getDecoratedMeasuredWidth(view)\n                val bottom = top + getDecoratedMeasuredHeight(view)\n                layoutDecoratedWithMargins(view, left, top, right, bottom)\n                fillPos--\n                right = left\n            }\n\n            availableSpace -= getDecoratedMeasuredWidth(view)\n        }\n    }\n\n    private fun recycler(recycler: RecyclerView.Recycler, state: RecyclerView.State, dx: Int) {\n        //要回收View的集合，暂存\n        val recycleViews = hashSetOf<View>()\n\n        //dx>0就是手指从右滑向左，所以要回收前面的children\n        if (dx > 0) {\n            for (i in 0 until childCount) {\n                val child = getChildAt(i)!!\n                val right = getDecoratedRight(child)\n                //itemView的right<0就是要超出屏幕要回收View\n                if (right > paddingStart) break\n                recycleViews.add(child)\n            }\n        }\n \n        //dx<0就是手指从左滑向右，所以要回收后面的children\n        if (dx < 0) {\n            for (i in childCount - 1 downTo 0) {\n                val child = getChildAt(i)!!\n                val left = getDecoratedLeft(child)\n\n                //itemView的left>recyclerView.width就是要超出屏幕要回收View\n                if (left < getAvailableSpace() + paddingStart) break\n                recycleViews.add(child)\n            }\n        }\n\n        //真正把View移除掉\n        for (view in recycleViews) {\n            removeAndRecycleView(view, recycler)\n        }\n    }\n\n    private fun getAvailableSpace(): Int {\n        return width - paddingStart - paddingEnd\n    }\n}\n```","slug":"Android/自定义LayoutManager","published":1,"updated":"2021-10-03T01:57:41.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8f0031g0je24uas4aj","content":"<h1 id=\"LayoutManager-的常用方法\"><a href=\"#LayoutManager-的常用方法\" class=\"headerlink\" title=\"LayoutManager 的常用方法\"></a>LayoutManager 的常用方法</h1><h3 id=\"generateDefaultLayoutParams\"><a href=\"#generateDefaultLayoutParams\" class=\"headerlink\" title=\"generateDefaultLayoutParams\"></a>generateDefaultLayoutParams</h3><a id=\"more\"></a><p>生成默认RecyclerView的LayoutParams, 没啥意义，就返回 wrap_content</p>\n<h3 id=\"isAutoMeasureEnabled-和-onMeasure\"><a href=\"#isAutoMeasureEnabled-和-onMeasure\" class=\"headerlink\" title=\"isAutoMeasureEnabled 和 onMeasure\"></a>isAutoMeasureEnabled 和 onMeasure</h3><p>isAutoMeasureEnabled()是自测量模式。 如果要支持 wrap_content ，那必须重写这两个方法中的一个。 大部分情况下，isAutoMeasureEnabled 返回 true 即可。重写onMeasure()的情况也极少，除非像我那个PickerLayoutManger一样。</p>\n<h3 id=\"canScrollHorizontally-和-canScrollVertically\"><a href=\"#canScrollHorizontally-和-canScrollVertically\" class=\"headerlink\" title=\"canScrollHorizontally 和 canScrollVertically\"></a>canScrollHorizontally 和 canScrollVertically</h3><p>无需多言</p>\n<h3 id=\"onLayoutChildren\"><a href=\"#onLayoutChildren\" class=\"headerlink\" title=\"onLayoutChildren\"></a>onLayoutChildren</h3><p>当 RecyclerView 的 layout 过程中会调用这个方法，<strong>包括第一次 layout 和 其他原因的重新 layout</strong>，比如说键盘的升降。</p>\n<h3 id=\"scrollHorizontallyBy-和-scrollVerticallyBy\"><a href=\"#scrollHorizontallyBy-和-scrollVerticallyBy\" class=\"headerlink\" title=\"scrollHorizontallyBy 和 scrollVerticallyBy\"></a>scrollHorizontallyBy 和 scrollVerticallyBy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">override fun scrollHorizontallyBy(</span><br><span class=\"line\"></span><br><span class=\"line\">    dx: Int,</span><br><span class=\"line\">    recycler: RecyclerView.Recycler,</span><br><span class=\"line\">    state: RecyclerView.State</span><br><span class=\"line\">): Int &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RecyclerView 滚动的时候回回调这个方法，但是它只是告诉你用户滑动的距离，需要你自己去实现滑动的效果。同时需要去判断滑动的边界。<br>但是返回值与 RecyclerView 的 overScorll 的动画有关，返回0会有边界的波纹动画。</p>\n<h3 id=\"getPosition-View\"><a href=\"#getPosition-View\" class=\"headerlink\" title=\"getPosition(View)\"></a>getPosition(View)</h3><p>返回 child view 在 adapter 中的位置</p>\n<h3 id=\"getDecoratedXxxx\"><a href=\"#getDecoratedXxxx\" class=\"headerlink\" title=\"getDecoratedXxxx\"></a>getDecoratedXxxx</h3><p>在 LayoutManager 中与布局有关的api都需要替换成带 Decorated 的api，不然无法实现对 itemDecorated 的兼容</p>\n<h3 id=\"detachAndScrapAttachedViews\"><a href=\"#detachAndScrapAttachedViews\" class=\"headerlink\" title=\"detachAndScrapAttachedViews()\"></a>detachAndScrapAttachedViews()</h3><p>从 RecyclerView 暂时移除 child 并送入临时缓存。 之前一直很奇怪，暂时移除是个什么场景。 后来想明白了，在每次布局 child 之前，都需要吧调用一次这个方法，吧所有的 child 移除到临时缓存里。否则，在布局的时候 addView(child) ，如果 child 已经 add 到了 RecyclerView 里，会造成一些麻烦。</p>\n<h3 id=\"removeAndRecycleView\"><a href=\"#removeAndRecycleView\" class=\"headerlink\" title=\"removeAndRecycleView\"></a>removeAndRecycleView</h3><p>移除 child 并将对应的 ViewHolder 移动到 cachePool ，从 cachePool 中取出的 ViewHolder 需要重新调用 Adapter.onBindViewHolder 方法</p>\n<h1 id=\"自定义-LayoutManager-的一般套路\"><a href=\"#自定义-LayoutManager-的一般套路\" class=\"headerlink\" title=\"自定义 LayoutManager 的一般套路\"></a>自定义 LayoutManager 的一般套路</h1><p>scrollHorizontallyBy 和 onLayoutChildren 可以服用同一个布局逻辑。</p>\n<ol>\n<li>确定锚点 view 的 position</li>\n<li>确定布局的左右(上下)边界</li>\n<li>开始 addView()-&gt;measureView()-&gt;layoutView() </li>\n<li>回收布局边界之外的 child</li>\n</ol>\n<h1 id=\"demo代码\"><a href=\"#demo代码\" class=\"headerlink\" title=\"demo代码\"></a>demo代码</h1><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLinearLayoutManager</span> : <span class=\"type\">RecyclerView.LayoutManager</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">generateDefaultLayoutParams</span><span class=\"params\">()</span></span>: RecyclerView.LayoutParams &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RecyclerView.LayoutParams(</span><br><span class=\"line\">            ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class=\"line\">            ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isAutoMeasureEnabled</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">canScrollHorizontally</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">canScrollVertically</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state.itemCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            removeAndRecycleAllViews(recycler)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> left = paddingStart</span><br><span class=\"line\">        <span class=\"keyword\">var</span> curPos = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里是兼容键盘升起然后重新 rebuild 的情况。</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果不做兼容，RecyclerView 会移动到列表最顶部</span></span><br><span class=\"line\">            left = getDecoratedLeft(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">            curPos = getPosition(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        detachAndScrapAttachedViews(recycler)</span><br><span class=\"line\"></span><br><span class=\"line\">        fill(recycler, state, curPos, left, paddingStart + getAvailableSpace(), <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollHorizontallyBy</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dx: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> resDx = calculateOffset(recycler, state, dx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resDx == <span class=\"number\">0</span> || itemCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> resDx</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> d = abs(resDx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resDx &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorView = getChildAt(<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorPos = getPosition(anchorView!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\"></span><br><span class=\"line\">            detachAndScrapAttachedViews(recycler)</span><br><span class=\"line\"></span><br><span class=\"line\">            fill(recycler, state, anchorPos, anchorLeft - d, getAvailableSpace() + paddingStart, <span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorView = getChildAt(childCount - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorPos = getPosition(anchorView!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorRight = getDecoratedRight(anchorView)</span><br><span class=\"line\"></span><br><span class=\"line\">            detachAndScrapAttachedViews(recycler)</span><br><span class=\"line\"></span><br><span class=\"line\">            fill(recycler, state, anchorPos, paddingLeft, anchorRight + d, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        recycler(recycler, state, resDx)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> resDx</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateOffset</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>, dx: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childCount == <span class=\"number\">0</span> || dx == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> fillPos = RecyclerView.NO_POSITION</span><br><span class=\"line\">        <span class=\"keyword\">val</span> d = abs(dx)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstView = getChildAt(<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstPos = getPosition(firstView!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstLeft = getDecoratedLeft(firstView)</span><br><span class=\"line\"></span><br><span class=\"line\">            fillPos = firstPos - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fillPos &lt; <span class=\"number\">0</span> &amp;&amp; firstLeft + d &gt; paddingStart) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> firstLeft - paddingStart</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstLeft + d &lt; paddingStart) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dx</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> lastView = getChildAt(childCount - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> lastPos = getPosition(lastView!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> lastRight = getDecoratedRight(lastView)</span><br><span class=\"line\"></span><br><span class=\"line\">            fillPos = lastPos + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> endEdge = getAvailableSpace() + paddingStart</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fillPos &gt;= itemCount &amp;&amp; lastRight - d &lt; endEdge) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> lastRight - endEdge</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastRight - d &gt; endEdge) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dx</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dx</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fill</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     anchorIndex: <span class=\"type\">Int</span>, anchorLeft: <span class=\"type\">Int</span>, anchorRight: <span class=\"type\">Int</span>, isLTR: <span class=\"type\">Boolean</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> availableSpace = anchorRight - anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fillPos = anchorIndex</span><br><span class=\"line\">        <span class=\"keyword\">var</span> left = anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">var</span> right = anchorRight</span><br><span class=\"line\">        <span class=\"keyword\">val</span> top = paddingTop</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (availableSpace &gt; <span class=\"number\">0</span> &amp;&amp; fillPos &gt;= <span class=\"number\">0</span> &amp;&amp; fillPos &lt; state.itemCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> view = recycler.getViewForPosition(fillPos)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isLTR) &#123;</span><br><span class=\"line\">                addView(view)</span><br><span class=\"line\">                measureChildWithMargins(view, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">                right = left + getDecoratedMeasuredWidth(view)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> bottom = top + getDecoratedMeasuredHeight(view)</span><br><span class=\"line\">                layoutDecoratedWithMargins(view, left, top, right, bottom)</span><br><span class=\"line\">                fillPos++</span><br><span class=\"line\">                left = right</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                addView(view, <span class=\"number\">0</span>)</span><br><span class=\"line\">                measureChildWithMargins(view, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">                left = right - getDecoratedMeasuredWidth(view)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> bottom = top + getDecoratedMeasuredHeight(view)</span><br><span class=\"line\">                layoutDecoratedWithMargins(view, left, top, right, bottom)</span><br><span class=\"line\">                fillPos--</span><br><span class=\"line\">                right = left</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            availableSpace -= getDecoratedMeasuredWidth(view)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">recycler</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>, dx: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//要回收View的集合，暂存</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//dx&gt;0就是手指从右滑向左，所以要回收前面的children</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dx &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">                <span class=\"keyword\">val</span> right = getDecoratedRight(child)</span><br><span class=\"line\">                <span class=\"comment\">//itemView的right&lt;0就是要超出屏幕要回收View</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right &gt; paddingStart) <span class=\"keyword\">break</span></span><br><span class=\"line\">                recycleViews.add(child)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//dx&lt;0就是手指从左滑向右，所以要回收后面的children</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> childCount - <span class=\"number\">1</span> downTo <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">                <span class=\"keyword\">val</span> left = getDecoratedLeft(child)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//itemView的left&gt;recyclerView.width就是要超出屏幕要回收View</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left &lt; getAvailableSpace() + paddingStart) <span class=\"keyword\">break</span></span><br><span class=\"line\">                recycleViews.add(child)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//真正把View移除掉</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (view <span class=\"keyword\">in</span> recycleViews) &#123;</span><br><span class=\"line\">            removeAndRecycleView(view, recycler)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAvailableSpace</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> width - paddingStart - paddingEnd</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"LayoutManager-的常用方法\"><a href=\"#LayoutManager-的常用方法\" class=\"headerlink\" title=\"LayoutManager 的常用方法\"></a>LayoutManager 的常用方法</h1><h3 id=\"generateDefaultLayoutParams\"><a href=\"#generateDefaultLayoutParams\" class=\"headerlink\" title=\"generateDefaultLayoutParams\"></a>generateDefaultLayoutParams</h3>","more":"<p>生成默认RecyclerView的LayoutParams, 没啥意义，就返回 wrap_content</p>\n<h3 id=\"isAutoMeasureEnabled-和-onMeasure\"><a href=\"#isAutoMeasureEnabled-和-onMeasure\" class=\"headerlink\" title=\"isAutoMeasureEnabled 和 onMeasure\"></a>isAutoMeasureEnabled 和 onMeasure</h3><p>isAutoMeasureEnabled()是自测量模式。 如果要支持 wrap_content ，那必须重写这两个方法中的一个。 大部分情况下，isAutoMeasureEnabled 返回 true 即可。重写onMeasure()的情况也极少，除非像我那个PickerLayoutManger一样。</p>\n<h3 id=\"canScrollHorizontally-和-canScrollVertically\"><a href=\"#canScrollHorizontally-和-canScrollVertically\" class=\"headerlink\" title=\"canScrollHorizontally 和 canScrollVertically\"></a>canScrollHorizontally 和 canScrollVertically</h3><p>无需多言</p>\n<h3 id=\"onLayoutChildren\"><a href=\"#onLayoutChildren\" class=\"headerlink\" title=\"onLayoutChildren\"></a>onLayoutChildren</h3><p>当 RecyclerView 的 layout 过程中会调用这个方法，<strong>包括第一次 layout 和 其他原因的重新 layout</strong>，比如说键盘的升降。</p>\n<h3 id=\"scrollHorizontallyBy-和-scrollVerticallyBy\"><a href=\"#scrollHorizontallyBy-和-scrollVerticallyBy\" class=\"headerlink\" title=\"scrollHorizontallyBy 和 scrollVerticallyBy\"></a>scrollHorizontallyBy 和 scrollVerticallyBy</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">override fun scrollHorizontallyBy(</span><br><span class=\"line\"></span><br><span class=\"line\">    dx: Int,</span><br><span class=\"line\">    recycler: RecyclerView.Recycler,</span><br><span class=\"line\">    state: RecyclerView.State</span><br><span class=\"line\">): Int &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RecyclerView 滚动的时候回回调这个方法，但是它只是告诉你用户滑动的距离，需要你自己去实现滑动的效果。同时需要去判断滑动的边界。<br>但是返回值与 RecyclerView 的 overScorll 的动画有关，返回0会有边界的波纹动画。</p>\n<h3 id=\"getPosition-View\"><a href=\"#getPosition-View\" class=\"headerlink\" title=\"getPosition(View)\"></a>getPosition(View)</h3><p>返回 child view 在 adapter 中的位置</p>\n<h3 id=\"getDecoratedXxxx\"><a href=\"#getDecoratedXxxx\" class=\"headerlink\" title=\"getDecoratedXxxx\"></a>getDecoratedXxxx</h3><p>在 LayoutManager 中与布局有关的api都需要替换成带 Decorated 的api，不然无法实现对 itemDecorated 的兼容</p>\n<h3 id=\"detachAndScrapAttachedViews\"><a href=\"#detachAndScrapAttachedViews\" class=\"headerlink\" title=\"detachAndScrapAttachedViews()\"></a>detachAndScrapAttachedViews()</h3><p>从 RecyclerView 暂时移除 child 并送入临时缓存。 之前一直很奇怪，暂时移除是个什么场景。 后来想明白了，在每次布局 child 之前，都需要吧调用一次这个方法，吧所有的 child 移除到临时缓存里。否则，在布局的时候 addView(child) ，如果 child 已经 add 到了 RecyclerView 里，会造成一些麻烦。</p>\n<h3 id=\"removeAndRecycleView\"><a href=\"#removeAndRecycleView\" class=\"headerlink\" title=\"removeAndRecycleView\"></a>removeAndRecycleView</h3><p>移除 child 并将对应的 ViewHolder 移动到 cachePool ，从 cachePool 中取出的 ViewHolder 需要重新调用 Adapter.onBindViewHolder 方法</p>\n<h1 id=\"自定义-LayoutManager-的一般套路\"><a href=\"#自定义-LayoutManager-的一般套路\" class=\"headerlink\" title=\"自定义 LayoutManager 的一般套路\"></a>自定义 LayoutManager 的一般套路</h1><p>scrollHorizontallyBy 和 onLayoutChildren 可以服用同一个布局逻辑。</p>\n<ol>\n<li>确定锚点 view 的 position</li>\n<li>确定布局的左右(上下)边界</li>\n<li>开始 addView()-&gt;measureView()-&gt;layoutView() </li>\n<li>回收布局边界之外的 child</li>\n</ol>\n<h1 id=\"demo代码\"><a href=\"#demo代码\" class=\"headerlink\" title=\"demo代码\"></a>demo代码</h1><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomLinearLayoutManager</span> : <span class=\"type\">RecyclerView.LayoutManager</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">generateDefaultLayoutParams</span><span class=\"params\">()</span></span>: RecyclerView.LayoutParams &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RecyclerView.LayoutParams(</span><br><span class=\"line\">            ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class=\"line\">            ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">isAutoMeasureEnabled</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">canScrollHorizontally</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">canScrollVertically</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onLayoutChildren</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state.itemCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            removeAndRecycleAllViews(recycler)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> left = paddingStart</span><br><span class=\"line\">        <span class=\"keyword\">var</span> curPos = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里是兼容键盘升起然后重新 rebuild 的情况。</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果不做兼容，RecyclerView 会移动到列表最顶部</span></span><br><span class=\"line\">            left = getDecoratedLeft(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">            curPos = getPosition(getChildAt(<span class=\"number\">0</span>)!!)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        detachAndScrapAttachedViews(recycler)</span><br><span class=\"line\"></span><br><span class=\"line\">        fill(recycler, state, curPos, left, paddingStart + getAvailableSpace(), <span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">scrollHorizontallyBy</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        dx: <span class=\"type\">Int</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> resDx = calculateOffset(recycler, state, dx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resDx == <span class=\"number\">0</span> || itemCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> resDx</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> d = abs(resDx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resDx &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorView = getChildAt(<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorPos = getPosition(anchorView!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class=\"line\"></span><br><span class=\"line\">            detachAndScrapAttachedViews(recycler)</span><br><span class=\"line\"></span><br><span class=\"line\">            fill(recycler, state, anchorPos, anchorLeft - d, getAvailableSpace() + paddingStart, <span class=\"literal\">true</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorView = getChildAt(childCount - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorPos = getPosition(anchorView!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> anchorRight = getDecoratedRight(anchorView)</span><br><span class=\"line\"></span><br><span class=\"line\">            detachAndScrapAttachedViews(recycler)</span><br><span class=\"line\"></span><br><span class=\"line\">            fill(recycler, state, anchorPos, paddingLeft, anchorRight + d, <span class=\"literal\">false</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        recycler(recycler, state, resDx)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> resDx</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">calculateOffset</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>, dx: <span class=\"type\">Int</span>)</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (childCount == <span class=\"number\">0</span> || dx == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> fillPos = RecyclerView.NO_POSITION</span><br><span class=\"line\">        <span class=\"keyword\">val</span> d = abs(dx)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstView = getChildAt(<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstPos = getPosition(firstView!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> firstLeft = getDecoratedLeft(firstView)</span><br><span class=\"line\"></span><br><span class=\"line\">            fillPos = firstPos - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fillPos &lt; <span class=\"number\">0</span> &amp;&amp; firstLeft + d &gt; paddingStart) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> firstLeft - paddingStart</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstLeft + d &lt; paddingStart) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dx</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> lastView = getChildAt(childCount - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> lastPos = getPosition(lastView!!)</span><br><span class=\"line\">            <span class=\"keyword\">val</span> lastRight = getDecoratedRight(lastView)</span><br><span class=\"line\"></span><br><span class=\"line\">            fillPos = lastPos + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> endEdge = getAvailableSpace() + paddingStart</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fillPos &gt;= itemCount &amp;&amp; lastRight - d &lt; endEdge) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> lastRight - endEdge</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastRight - d &gt; endEdge) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dx</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dx</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">fill</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     anchorIndex: <span class=\"type\">Int</span>, anchorLeft: <span class=\"type\">Int</span>, anchorRight: <span class=\"type\">Int</span>, isLTR: <span class=\"type\">Boolean</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> availableSpace = anchorRight - anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">var</span> fillPos = anchorIndex</span><br><span class=\"line\">        <span class=\"keyword\">var</span> left = anchorLeft</span><br><span class=\"line\">        <span class=\"keyword\">var</span> right = anchorRight</span><br><span class=\"line\">        <span class=\"keyword\">val</span> top = paddingTop</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (availableSpace &gt; <span class=\"number\">0</span> &amp;&amp; fillPos &gt;= <span class=\"number\">0</span> &amp;&amp; fillPos &lt; state.itemCount) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> view = recycler.getViewForPosition(fillPos)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isLTR) &#123;</span><br><span class=\"line\">                addView(view)</span><br><span class=\"line\">                measureChildWithMargins(view, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">                right = left + getDecoratedMeasuredWidth(view)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> bottom = top + getDecoratedMeasuredHeight(view)</span><br><span class=\"line\">                layoutDecoratedWithMargins(view, left, top, right, bottom)</span><br><span class=\"line\">                fillPos++</span><br><span class=\"line\">                left = right</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                addView(view, <span class=\"number\">0</span>)</span><br><span class=\"line\">                measureChildWithMargins(view, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">                left = right - getDecoratedMeasuredWidth(view)</span><br><span class=\"line\">                <span class=\"keyword\">val</span> bottom = top + getDecoratedMeasuredHeight(view)</span><br><span class=\"line\">                layoutDecoratedWithMargins(view, left, top, right, bottom)</span><br><span class=\"line\">                fillPos--</span><br><span class=\"line\">                right = left</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            availableSpace -= getDecoratedMeasuredWidth(view)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">recycler</span><span class=\"params\">(recycler: <span class=\"type\">RecyclerView</span>.<span class=\"type\">Recycler</span>, state: <span class=\"type\">RecyclerView</span>.<span class=\"type\">State</span>, dx: <span class=\"type\">Int</span>)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//要回收View的集合，暂存</span></span><br><span class=\"line\">        <span class=\"keyword\">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//dx&gt;0就是手指从右滑向左，所以要回收前面的children</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dx &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span> until childCount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">                <span class=\"keyword\">val</span> right = getDecoratedRight(child)</span><br><span class=\"line\">                <span class=\"comment\">//itemView的right&lt;0就是要超出屏幕要回收View</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right &gt; paddingStart) <span class=\"keyword\">break</span></span><br><span class=\"line\">                recycleViews.add(child)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//dx&lt;0就是手指从左滑向右，所以要回收后面的children</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dx &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> childCount - <span class=\"number\">1</span> downTo <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> child = getChildAt(i)!!</span><br><span class=\"line\">                <span class=\"keyword\">val</span> left = getDecoratedLeft(child)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//itemView的left&gt;recyclerView.width就是要超出屏幕要回收View</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left &lt; getAvailableSpace() + paddingStart) <span class=\"keyword\">break</span></span><br><span class=\"line\">                recycleViews.add(child)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//真正把View移除掉</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (view <span class=\"keyword\">in</span> recycleViews) &#123;</span><br><span class=\"line\">            removeAndRecycleView(view, recycler)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getAvailableSpace</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> width - paddingStart - paddingEnd</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"scrollBy(),scrollTo()和Scroller","date":"2019-06-16T12:26:14.000Z","_content":"# scrollBy(),scrollTo()和Scroller\n\n## 作用\n用于对View进行滚动\n<br>\n注意：\n1. **滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）**\n比如：TextView滚动的是内部的text而不是整个view\n2. **滚动的方向与坐标轴正方向相反**\n比如：scrollBy(20,0)\n最后显示，view会向左移动\n因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码)\n\n## scrollBy() 和 scrollTo()的区别\nscrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。\n\n## Scroller\n利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移\n### 使用步骤\nScroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：\n\n1. 创建Scroller的实例\n2. 调用startScroll()方法来初始化滚动数据并刷新界面\n3. 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑\n\n\n\n### 代码：实现自定义的简单ViewPager\n```java\npackage com.example.work3;\n\nimport android.content.Context;\nimport android.support.v4.view.ViewConfigurationCompat;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.widget.Scroller;\n\npublic class ScrollLayout extends ViewGroup {\n\n    private final String TAG = \"test_scroll\";\n    private Scroller mScroller;\n    // 可以判定为拖动的最小滑动距离\n    private int mTouchSlop;\n    // 落下的屏幕坐标\n    private float mXDown;\n    // 当前的屏幕坐标\n    private float mXMove;\n    // 上一次Action_MMOVE的屏幕坐标\n    private float mLastMove;\n    // 界面可滑动的左边界\n    private int mLeftBorder;\n    // 界面可滑动的右边界\n    private int mRightBorder;\n\n    public ScrollLayout(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public ScrollLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public ScrollLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context);\n    }\n\n    private void init(Context context) {\n        mScroller = new Scroller(context);\n        // 获取系统定义的mTouchSlop值\n        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context));\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        if (!changed)\n            return;\n        int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            View childView = getChildAt(i);\n            childView.layout(i * childView.getMeasuredWidth(), 0, (i + 1) * childView.getMeasuredWidth(), childView.getMeasuredHeight());\n        }\n        // 初始化左右边界\n        mLeftBorder = getChildAt(0).getLeft();\n        mRightBorder = getChildAt(childCount - 1).getRight();\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        switch (ev.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                mXDown = ev.getRawX();\n                mLastMove = mXDown;\n                break;\n            case MotionEvent.ACTION_MOVE:\n                mXMove = ev.getRawX();\n                float diff = Math.abs(mXMove - mXDown);\n                mLastMove = mXMove;\n                // 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件\n                if (diff > mTouchSlop) {\n                    return true;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                break;\n            default:\n                break;\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                break;\n            case MotionEvent.ACTION_MOVE: {\n                mXMove = event.getRawX();\n                int scrolledX = (int) (mLastMove - mXMove);\n                if (getScrollX() + scrolledX < mLeftBorder) {\n                    scrollTo(mLeftBorder, 0);\n                    return true;\n                } else if (getScrollX() + scrolledX + getWidth() > mRightBorder) {\n                    scrollTo(mRightBorder - getWidth(), 0);\n                    return true;\n                }\n                // view随着手指的拖动进行滚动\n                scrollBy(scrolledX, 0);\n                Log.i(TAG, \"onTouchEvent: \" + getChildAt(1).getLeft());\n                mLastMove = mXMove;\n                break;\n            }\n            case MotionEvent.ACTION_UP: {\n                // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面\n                int targetIndex = (getScrollX() + getWidth() / 2) / getWidth();\n                int dx = targetIndex * getWidth() - getScrollX();\n                // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面\n                mScroller.startScroll(getScrollX(), 0, dx, 0);\n                // 对view重绘\n                invalidate();\n                break;\n            }\n        }\n        return super.onTouchEvent(event);\n    }\n\n    @Override\n    public void computeScroll() {\n        // computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法\n        if (mScroller.computeScrollOffset()) {\n            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n            // 对view重绘\n            invalidate();\n        }\n    }\n}\n```\n\n## getScrollX()方法\n返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。\n原点（0，0）是初始化时内容显示的位置。\n\n## 参考\n[Android getScrollX()详解\n](https://blog.csdn.net/znouy/article/details/51338256)\n[Android Scroller完全解析，关于Scroller你所需知道的一切\n](https://blog.csdn.net/guolin_blog/article/details/48719871)","source":"_posts/Android/scrollBy-scrollTo-和Scroller.md","raw":"---\ntitle: 'scrollBy(),scrollTo()和Scroller'\ndate: 2019-06-16 20:26:14\ntags: \n- View\ncategories:\n- Android\n---\n# scrollBy(),scrollTo()和Scroller\n\n## 作用\n用于对View进行滚动\n<br>\n注意：\n1. **滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）**\n比如：TextView滚动的是内部的text而不是整个view\n2. **滚动的方向与坐标轴正方向相反**\n比如：scrollBy(20,0)\n最后显示，view会向左移动\n因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码)\n\n## scrollBy() 和 scrollTo()的区别\nscrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。\n\n## Scroller\n利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移\n### 使用步骤\nScroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：\n\n1. 创建Scroller的实例\n2. 调用startScroll()方法来初始化滚动数据并刷新界面\n3. 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑\n\n\n\n### 代码：实现自定义的简单ViewPager\n```java\npackage com.example.work3;\n\nimport android.content.Context;\nimport android.support.v4.view.ViewConfigurationCompat;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.ViewGroup;\nimport android.widget.Scroller;\n\npublic class ScrollLayout extends ViewGroup {\n\n    private final String TAG = \"test_scroll\";\n    private Scroller mScroller;\n    // 可以判定为拖动的最小滑动距离\n    private int mTouchSlop;\n    // 落下的屏幕坐标\n    private float mXDown;\n    // 当前的屏幕坐标\n    private float mXMove;\n    // 上一次Action_MMOVE的屏幕坐标\n    private float mLastMove;\n    // 界面可滑动的左边界\n    private int mLeftBorder;\n    // 界面可滑动的右边界\n    private int mRightBorder;\n\n    public ScrollLayout(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public ScrollLayout(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public ScrollLayout(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context);\n    }\n\n    private void init(Context context) {\n        mScroller = new Scroller(context);\n        // 获取系统定义的mTouchSlop值\n        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context));\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        if (!changed)\n            return;\n        int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            View childView = getChildAt(i);\n            childView.layout(i * childView.getMeasuredWidth(), 0, (i + 1) * childView.getMeasuredWidth(), childView.getMeasuredHeight());\n        }\n        // 初始化左右边界\n        mLeftBorder = getChildAt(0).getLeft();\n        mRightBorder = getChildAt(childCount - 1).getRight();\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        switch (ev.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                mXDown = ev.getRawX();\n                mLastMove = mXDown;\n                break;\n            case MotionEvent.ACTION_MOVE:\n                mXMove = ev.getRawX();\n                float diff = Math.abs(mXMove - mXDown);\n                mLastMove = mXMove;\n                // 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件\n                if (diff > mTouchSlop) {\n                    return true;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                break;\n            default:\n                break;\n        }\n        return super.onInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                break;\n            case MotionEvent.ACTION_MOVE: {\n                mXMove = event.getRawX();\n                int scrolledX = (int) (mLastMove - mXMove);\n                if (getScrollX() + scrolledX < mLeftBorder) {\n                    scrollTo(mLeftBorder, 0);\n                    return true;\n                } else if (getScrollX() + scrolledX + getWidth() > mRightBorder) {\n                    scrollTo(mRightBorder - getWidth(), 0);\n                    return true;\n                }\n                // view随着手指的拖动进行滚动\n                scrollBy(scrolledX, 0);\n                Log.i(TAG, \"onTouchEvent: \" + getChildAt(1).getLeft());\n                mLastMove = mXMove;\n                break;\n            }\n            case MotionEvent.ACTION_UP: {\n                // 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面\n                int targetIndex = (getScrollX() + getWidth() / 2) / getWidth();\n                int dx = targetIndex * getWidth() - getScrollX();\n                // 第二步，调用startScroll()方法来初始化滚动数据并刷新界面\n                mScroller.startScroll(getScrollX(), 0, dx, 0);\n                // 对view重绘\n                invalidate();\n                break;\n            }\n        }\n        return super.onTouchEvent(event);\n    }\n\n    @Override\n    public void computeScroll() {\n        // computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法\n        if (mScroller.computeScrollOffset()) {\n            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n            // 对view重绘\n            invalidate();\n        }\n    }\n}\n```\n\n## getScrollX()方法\n返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。\n原点（0，0）是初始化时内容显示的位置。\n\n## 参考\n[Android getScrollX()详解\n](https://blog.csdn.net/znouy/article/details/51338256)\n[Android Scroller完全解析，关于Scroller你所需知道的一切\n](https://blog.csdn.net/guolin_blog/article/details/48719871)","slug":"Android/scrollBy-scrollTo-和Scroller","published":1,"updated":"2021-10-03T01:57:41.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8g0033g0jeo572dtgy","content":"<h1 id=\"scrollBy-scrollTo-和Scroller\"><a href=\"#scrollBy-scrollTo-和Scroller\" class=\"headerlink\" title=\"scrollBy(),scrollTo()和Scroller\"></a>scrollBy(),scrollTo()和Scroller</h1><a id=\"more\"></a><h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>用于对View进行滚动<br><br><br>注意：</p>\n<ol>\n<li><strong>滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）</strong><br>比如：TextView滚动的是内部的text而不是整个view</li>\n<li><strong>滚动的方向与坐标轴正方向相反</strong><br>比如：scrollBy(20,0)<br>最后显示，view会向左移动<br>因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码)</li>\n</ol>\n<h2 id=\"scrollBy-和-scrollTo-的区别\"><a href=\"#scrollBy-和-scrollTo-的区别\" class=\"headerlink\" title=\"scrollBy() 和 scrollTo()的区别\"></a>scrollBy() 和 scrollTo()的区别</h2><p>scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。</p>\n<h2 id=\"Scroller\"><a href=\"#Scroller\" class=\"headerlink\" title=\"Scroller\"></a>Scroller</h2><p>利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移</p>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p>Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p>\n<ol>\n<li>创建Scroller的实例</li>\n<li>调用startScroll()方法来初始化滚动数据并刷新界面</li>\n<li>重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</li>\n</ol>\n<h3 id=\"代码：实现自定义的简单ViewPager\"><a href=\"#代码：实现自定义的简单ViewPager\" class=\"headerlink\" title=\"代码：实现自定义的简单ViewPager\"></a>代码：实现自定义的简单ViewPager</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.work3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v4.view.ViewConfigurationCompat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.MotionEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.View;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewConfiguration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.Scroller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScrollLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"test_scroll\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Scroller mScroller;</span><br><span class=\"line\">    <span class=\"comment\">// 可以判定为拖动的最小滑动距离</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mTouchSlop;</span><br><span class=\"line\">    <span class=\"comment\">// 落下的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mXDown;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mXMove;</span><br><span class=\"line\">    <span class=\"comment\">// 上一次Action_MMOVE的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mLastMove;</span><br><span class=\"line\">    <span class=\"comment\">// 界面可滑动的左边界</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mLeftBorder;</span><br><span class=\"line\">    <span class=\"comment\">// 界面可滑动的右边界</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mRightBorder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mScroller = <span class=\"keyword\">new</span> Scroller(context);</span><br><span class=\"line\">        <span class=\"comment\">// 获取系统定义的mTouchSlop值</span></span><br><span class=\"line\">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> childCount = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</span><br><span class=\"line\">            measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!changed)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> childCount = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</span><br><span class=\"line\">            View childView = getChildAt(i);</span><br><span class=\"line\">            childView.layout(i * childView.getMeasuredWidth(), <span class=\"number\">0</span>, (i + <span class=\"number\">1</span>) * childView.getMeasuredWidth(), childView.getMeasuredHeight());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化左右边界</span></span><br><span class=\"line\">        mLeftBorder = getChildAt(<span class=\"number\">0</span>).getLeft();</span><br><span class=\"line\">        mRightBorder = getChildAt(childCount - <span class=\"number\">1</span>).getRight();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (ev.getAction()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                mXDown = ev.getRawX();</span><br><span class=\"line\">                mLastMove = mXDown;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">                mXMove = ev.getRawX();</span><br><span class=\"line\">                <span class=\"keyword\">float</span> diff = Math.abs(mXMove - mXDown);</span><br><span class=\"line\">                mLastMove = mXMove;</span><br><span class=\"line\">                <span class=\"comment\">// 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (diff &gt; mTouchSlop) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class=\"line\">                mXMove = event.getRawX();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> scrolledX = (<span class=\"keyword\">int</span>) (mLastMove - mXMove);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (getScrollX() + scrolledX &lt; mLeftBorder) &#123;</span><br><span class=\"line\">                    scrollTo(mLeftBorder, <span class=\"number\">0</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (getScrollX() + scrolledX + getWidth() &gt; mRightBorder) &#123;</span><br><span class=\"line\">                    scrollTo(mRightBorder - getWidth(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// view随着手指的拖动进行滚动</span></span><br><span class=\"line\">                scrollBy(scrolledX, <span class=\"number\">0</span>);</span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">\"onTouchEvent: \"</span> + getChildAt(<span class=\"number\">1</span>).getLeft());</span><br><span class=\"line\">                mLastMove = mXMove;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> targetIndex = (getScrollX() + getWidth() / <span class=\"number\">2</span>) / getWidth();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dx = targetIndex * getWidth() - getScrollX();</span><br><span class=\"line\">                <span class=\"comment\">// 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span></span><br><span class=\"line\">                mScroller.startScroll(getScrollX(), <span class=\"number\">0</span>, dx, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 对view重绘</span></span><br><span class=\"line\">                invalidate();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class=\"line\">            <span class=\"comment\">// 对view重绘</span></span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"getScrollX-方法\"><a href=\"#getScrollX-方法\" class=\"headerlink\" title=\"getScrollX()方法\"></a>getScrollX()方法</h2><p>返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。<br>原点（0，0）是初始化时内容显示的位置。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/znouy/article/details/51338256\" target=\"_blank\" rel=\"noopener\">Android getScrollX()详解\n</a><br><a href=\"https://blog.csdn.net/guolin_blog/article/details/48719871\" target=\"_blank\" rel=\"noopener\">Android Scroller完全解析，关于Scroller你所需知道的一切\n</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"scrollBy-scrollTo-和Scroller\"><a href=\"#scrollBy-scrollTo-和Scroller\" class=\"headerlink\" title=\"scrollBy(),scrollTo()和Scroller\"></a>scrollBy(),scrollTo()和Scroller</h1>","more":"<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>用于对View进行滚动<br><br><br>注意：</p>\n<ol>\n<li><strong>滚动的是View的内容，而不是View本身（对viewd的视窗进行移动）</strong><br>比如：TextView滚动的是内部的text而不是整个view</li>\n<li><strong>滚动的方向与坐标轴正方向相反</strong><br>比如：scrollBy(20,0)<br>最后显示，view会向左移动<br>因为是视窗的移动，所以视窗右移，view相对的向左移动(可以这么理解，具体看源码)</li>\n</ol>\n<h2 id=\"scrollBy-和-scrollTo-的区别\"><a href=\"#scrollBy-和-scrollTo-的区别\" class=\"headerlink\" title=\"scrollBy() 和 scrollTo()的区别\"></a>scrollBy() 和 scrollTo()的区别</h2><p>scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。</p>\n<h2 id=\"Scroller\"><a href=\"#Scroller\" class=\"headerlink\" title=\"Scroller\"></a>Scroller</h2><p>利用Scroller可以实现有过渡动画的平滑移动，而不是突兀的瞬移</p>\n<h3 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h3><p>Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p>\n<ol>\n<li>创建Scroller的实例</li>\n<li>调用startScroll()方法来初始化滚动数据并刷新界面</li>\n<li>重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</li>\n</ol>\n<h3 id=\"代码：实现自定义的简单ViewPager\"><a href=\"#代码：实现自定义的简单ViewPager\" class=\"headerlink\" title=\"代码：实现自定义的简单ViewPager\"></a>代码：实现自定义的简单ViewPager</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.work3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> android.content.Context;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.support.v4.view.ViewConfigurationCompat;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.AttributeSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.util.Log;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.MotionEvent;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.View;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewConfiguration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.view.ViewGroup;</span><br><span class=\"line\"><span class=\"keyword\">import</span> android.widget.Scroller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScrollLayout</span> <span class=\"keyword\">extends</span> <span class=\"title\">ViewGroup</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"test_scroll\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Scroller mScroller;</span><br><span class=\"line\">    <span class=\"comment\">// 可以判定为拖动的最小滑动距离</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mTouchSlop;</span><br><span class=\"line\">    <span class=\"comment\">// 落下的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mXDown;</span><br><span class=\"line\">    <span class=\"comment\">// 当前的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mXMove;</span><br><span class=\"line\">    <span class=\"comment\">// 上一次Action_MMOVE的屏幕坐标</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mLastMove;</span><br><span class=\"line\">    <span class=\"comment\">// 界面可滑动的左边界</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mLeftBorder;</span><br><span class=\"line\">    <span class=\"comment\">// 界面可滑动的右边界</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mRightBorder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScrollLayout</span><span class=\"params\">(Context context, AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mScroller = <span class=\"keyword\">new</span> Scroller(context);</span><br><span class=\"line\">        <span class=\"comment\">// 获取系统定义的mTouchSlop值</span></span><br><span class=\"line\">        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(ViewConfiguration.get(context));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> childCount = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</span><br><span class=\"line\">            measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!changed)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> childCount = getChildCount();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; childCount; i++) &#123;</span><br><span class=\"line\">            View childView = getChildAt(i);</span><br><span class=\"line\">            childView.layout(i * childView.getMeasuredWidth(), <span class=\"number\">0</span>, (i + <span class=\"number\">1</span>) * childView.getMeasuredWidth(), childView.getMeasuredHeight());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化左右边界</span></span><br><span class=\"line\">        mLeftBorder = getChildAt(<span class=\"number\">0</span>).getLeft();</span><br><span class=\"line\">        mRightBorder = getChildAt(childCount - <span class=\"number\">1</span>).getRight();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onInterceptTouchEvent</span><span class=\"params\">(MotionEvent ev)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (ev.getAction()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                mXDown = ev.getRawX();</span><br><span class=\"line\">                mLastMove = mXDown;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE:</span><br><span class=\"line\">                mXMove = ev.getRawX();</span><br><span class=\"line\">                <span class=\"keyword\">float</span> diff = Math.abs(mXMove - mXDown);</span><br><span class=\"line\">                mLastMove = mXMove;</span><br><span class=\"line\">                <span class=\"comment\">// 手指拖动值大于TouchSlop，认为应该进行滚动，拦截事件</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (diff &gt; mTouchSlop) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">onTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (event.getAction()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_DOWN:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class=\"line\">                mXMove = event.getRawX();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> scrolledX = (<span class=\"keyword\">int</span>) (mLastMove - mXMove);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (getScrollX() + scrolledX &lt; mLeftBorder) &#123;</span><br><span class=\"line\">                    scrollTo(mLeftBorder, <span class=\"number\">0</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (getScrollX() + scrolledX + getWidth() &gt; mRightBorder) &#123;</span><br><span class=\"line\">                    scrollTo(mRightBorder - getWidth(), <span class=\"number\">0</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// view随着手指的拖动进行滚动</span></span><br><span class=\"line\">                scrollBy(scrolledX, <span class=\"number\">0</span>);</span><br><span class=\"line\">                Log.i(TAG, <span class=\"string\">\"onTouchEvent: \"</span> + getChildAt(<span class=\"number\">1</span>).getLeft());</span><br><span class=\"line\">                mLastMove = mXMove;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> targetIndex = (getScrollX() + getWidth() / <span class=\"number\">2</span>) / getWidth();</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dx = targetIndex * getWidth() - getScrollX();</span><br><span class=\"line\">                <span class=\"comment\">// 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span></span><br><span class=\"line\">                mScroller.startScroll(getScrollX(), <span class=\"number\">0</span>, dx, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 对view重绘</span></span><br><span class=\"line\">                invalidate();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">computeScroll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// computeScroll方法重写的模版代码， 如果是子View需要调用父布局的scrollTo方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class=\"line\">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class=\"line\">            <span class=\"comment\">// 对view重绘</span></span><br><span class=\"line\">            invalidate();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"getScrollX-方法\"><a href=\"#getScrollX-方法\" class=\"headerlink\" title=\"getScrollX()方法\"></a>getScrollX()方法</h2><p>返回当前滑动View左边界的位置，其实获取的值是画布在窗口左边界时的x坐标。<br>原点（0，0）是初始化时内容显示的位置。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/znouy/article/details/51338256\" target=\"_blank\" rel=\"noopener\">Android getScrollX()详解\n</a><br><a href=\"https://blog.csdn.net/guolin_blog/article/details/48719871\" target=\"_blank\" rel=\"noopener\">Android Scroller完全解析，关于Scroller你所需知道的一切\n</a></p>\n"},{"title":"自动滚播TextView","date":"2019-12-31T06:49:08.000Z","_content":"\n要实现一个自动滚播的自定义View\n\n```java\npublic class AutoSwitchView extends AppCompatTextView {\n\n    private final int DEFAULT_IDLE_TIME = 3000;\n    private final int DEFAULT_SWITCH_TIME = 1000;\n\n    private int mIdleTime = DEFAULT_IDLE_TIME;\n    private int mSwitchTime = DEFAULT_SWITCH_TIME;\n    private Paint mPaint;\n    private String mCurStr;\n    private String mNextStr;\n    private List<String> mContentList;\n    private int mCurIndex = 0;\n    private float mCurValue;\n    private boolean mIsRunning = false;\n    private ValueAnimator mAnimator;\n    private Paint.FontMetrics mFontMetrics;\n    private Runnable mRunnable;\n\n    private int mWidth;\n    private int mPaddingLeft;\n    private int mPaddingRight;\n    private int mPaddingTop;\n    private int mPaddingBottom;\n    private int mHeight;\n    private float mTextBaseY;\n\n\n    public AutoSwitchView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public AutoSwitchView(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public AutoSwitchView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context);\n    }\n\n    private void init(Context context) {\n        mPaint = new Paint();\n        mPaint.setTextAlign(Paint.Align.CENTER);\n\n        mAnimator = ValueAnimator.ofFloat(0, 1);\n        mAnimator.setStartDelay(mIdleTime);\n        mAnimator.setDuration(mSwitchTime);\n        mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                mCurValue = (float) animation.getAnimatedValue();\n                // 必须要加这个判断, 不然会出现问题\n                if (mCurValue < 1.0) {\n                    invalidate();\n                }\n            }\n        });\n        mAnimator.addListener(new AnimatorListenerAdapter() {\n\n            @Override\n            public void onAnimationEnd(Animator animation, boolean isReverse) {\n                if (!mIsRunning) {\n                    return;\n                }\n                mCurIndex = (mCurIndex + 1) % mContentList.size();\n                mCurStr = mContentList.get(mCurIndex);\n                mNextStr = mContentList.get((mCurIndex + 1) % mContentList.size());\n                if (mRunnable == null) {\n                    mRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            mAnimator.start();\n                        }\n                    };\n                }\n                postDelayed(mRunnable, mIdleTime);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                mIsRunning = false;\n            }\n        });\n    }\n\n    public void start() {\n        if (mContentList == null || mContentList.size() == 0)\n            return;\n        if (mIsRunning) {\n            return;\n        }\n        if (mContentList.size() > 1) {\n            mCurStr = mContentList.get(0);\n            mNextStr = mContentList.get(1);\n        } else {\n            mCurStr = mContentList.get(0);\n            mNextStr = mContentList.get(0);\n        }\n        mCurIndex = 0;\n        mIsRunning = true;\n        mAnimator.start();\n        mAnimator.setStartDelay(mIdleTime);\n    }\n\n    public void stop() {\n        if (mRunnable != null) {\n            removeCallbacks(mRunnable);\n        }\n        mAnimator.cancel();\n        mIsRunning = false;\n        mCurIndex = 0;\n    }\n\n    public void setContentList(List<String> contentList) {\n        if (contentList == null || contentList.size() == 0)\n            return;\n        mContentList = contentList;\n        start();\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        mWidth = MeasureSpec.getSize(widthMeasureSpec);\n        mPaddingLeft = getPaddingLeft();\n        mPaddingRight = getPaddingRight();\n        mPaddingTop = getPaddingTop();\n        mPaddingBottom = getPaddingBottom();\n\n        mPaint.setTextSize(getTextSize());\n        mFontMetrics = mPaint.getFontMetrics();\n\n        mTextBaseY = -mFontMetrics.top + mPaddingTop;\n        mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom;\n\n        setMeasuredDimension(mWidth, mHeight);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        float curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / 2;\n        float nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / 2;\n\n        float baseY = 2 * mTextBaseY * (0.5f - mCurValue);\n        if (baseY > 0) {\n            canvas.drawText(mCurStr, curStartX, baseY, mPaint);\n        } else {\n            canvas.drawText(mNextStr, nextStartX, 2 * mTextBaseY + baseY, mPaint);\n        }\n    }\n}\n\n```","source":"_posts/Android/自动滚播TextView.md","raw":"---\ntitle: 自动滚播TextView\ndate: 2019-12-31 14:49:08\ntags:\n- View\ncategories:\n- Android\n- View\n---\n\n要实现一个自动滚播的自定义View\n\n```java\npublic class AutoSwitchView extends AppCompatTextView {\n\n    private final int DEFAULT_IDLE_TIME = 3000;\n    private final int DEFAULT_SWITCH_TIME = 1000;\n\n    private int mIdleTime = DEFAULT_IDLE_TIME;\n    private int mSwitchTime = DEFAULT_SWITCH_TIME;\n    private Paint mPaint;\n    private String mCurStr;\n    private String mNextStr;\n    private List<String> mContentList;\n    private int mCurIndex = 0;\n    private float mCurValue;\n    private boolean mIsRunning = false;\n    private ValueAnimator mAnimator;\n    private Paint.FontMetrics mFontMetrics;\n    private Runnable mRunnable;\n\n    private int mWidth;\n    private int mPaddingLeft;\n    private int mPaddingRight;\n    private int mPaddingTop;\n    private int mPaddingBottom;\n    private int mHeight;\n    private float mTextBaseY;\n\n\n    public AutoSwitchView(Context context) {\n        super(context);\n        init(context);\n    }\n\n    public AutoSwitchView(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public AutoSwitchView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context);\n    }\n\n    private void init(Context context) {\n        mPaint = new Paint();\n        mPaint.setTextAlign(Paint.Align.CENTER);\n\n        mAnimator = ValueAnimator.ofFloat(0, 1);\n        mAnimator.setStartDelay(mIdleTime);\n        mAnimator.setDuration(mSwitchTime);\n        mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                mCurValue = (float) animation.getAnimatedValue();\n                // 必须要加这个判断, 不然会出现问题\n                if (mCurValue < 1.0) {\n                    invalidate();\n                }\n            }\n        });\n        mAnimator.addListener(new AnimatorListenerAdapter() {\n\n            @Override\n            public void onAnimationEnd(Animator animation, boolean isReverse) {\n                if (!mIsRunning) {\n                    return;\n                }\n                mCurIndex = (mCurIndex + 1) % mContentList.size();\n                mCurStr = mContentList.get(mCurIndex);\n                mNextStr = mContentList.get((mCurIndex + 1) % mContentList.size());\n                if (mRunnable == null) {\n                    mRunnable = new Runnable() {\n                        @Override\n                        public void run() {\n                            mAnimator.start();\n                        }\n                    };\n                }\n                postDelayed(mRunnable, mIdleTime);\n            }\n\n            @Override\n            public void onAnimationCancel(Animator animation) {\n                mIsRunning = false;\n            }\n        });\n    }\n\n    public void start() {\n        if (mContentList == null || mContentList.size() == 0)\n            return;\n        if (mIsRunning) {\n            return;\n        }\n        if (mContentList.size() > 1) {\n            mCurStr = mContentList.get(0);\n            mNextStr = mContentList.get(1);\n        } else {\n            mCurStr = mContentList.get(0);\n            mNextStr = mContentList.get(0);\n        }\n        mCurIndex = 0;\n        mIsRunning = true;\n        mAnimator.start();\n        mAnimator.setStartDelay(mIdleTime);\n    }\n\n    public void stop() {\n        if (mRunnable != null) {\n            removeCallbacks(mRunnable);\n        }\n        mAnimator.cancel();\n        mIsRunning = false;\n        mCurIndex = 0;\n    }\n\n    public void setContentList(List<String> contentList) {\n        if (contentList == null || contentList.size() == 0)\n            return;\n        mContentList = contentList;\n        start();\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n\n        mWidth = MeasureSpec.getSize(widthMeasureSpec);\n        mPaddingLeft = getPaddingLeft();\n        mPaddingRight = getPaddingRight();\n        mPaddingTop = getPaddingTop();\n        mPaddingBottom = getPaddingBottom();\n\n        mPaint.setTextSize(getTextSize());\n        mFontMetrics = mPaint.getFontMetrics();\n\n        mTextBaseY = -mFontMetrics.top + mPaddingTop;\n        mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom;\n\n        setMeasuredDimension(mWidth, mHeight);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        float curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / 2;\n        float nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / 2;\n\n        float baseY = 2 * mTextBaseY * (0.5f - mCurValue);\n        if (baseY > 0) {\n            canvas.drawText(mCurStr, curStartX, baseY, mPaint);\n        } else {\n            canvas.drawText(mNextStr, nextStartX, 2 * mTextBaseY + baseY, mPaint);\n        }\n    }\n}\n\n```","slug":"Android/自动滚播TextView","published":1,"updated":"2021-10-03T01:57:41.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8h0037g0jea9st6yj9","content":"<p>要实现一个自动滚播的自定义View</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoSwitchView</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatTextView</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_IDLE_TIME = <span class=\"number\">3000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_SWITCH_TIME = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mIdleTime = DEFAULT_IDLE_TIME;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mSwitchTime = DEFAULT_SWITCH_TIME;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mCurStr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mNextStr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; mContentList;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mCurValue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueAnimator mAnimator;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint.FontMetrics mFontMetrics;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Runnable mRunnable;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWidth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingLeft;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingRight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingTop;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingBottom;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mHeight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mTextBaseY;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint();</span><br><span class=\"line\">        mPaint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\"></span><br><span class=\"line\">        mAnimator = ValueAnimator.ofFloat(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        mAnimator.setStartDelay(mIdleTime);</span><br><span class=\"line\">        mAnimator.setDuration(mSwitchTime);</span><br><span class=\"line\">        mAnimator.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</span><br><span class=\"line\">                mCurValue = (<span class=\"keyword\">float</span>) animation.getAnimatedValue();</span><br><span class=\"line\">                <span class=\"comment\">// 必须要加这个判断, 不然会出现问题</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mCurValue &lt; <span class=\"number\">1.0</span>) &#123;</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        mAnimator.addListener(<span class=\"keyword\">new</span> AnimatorListenerAdapter() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationEnd</span><span class=\"params\">(Animator animation, <span class=\"keyword\">boolean</span> isReverse)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!mIsRunning) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mCurIndex = (mCurIndex + <span class=\"number\">1</span>) % mContentList.size();</span><br><span class=\"line\">                mCurStr = mContentList.get(mCurIndex);</span><br><span class=\"line\">                mNextStr = mContentList.get((mCurIndex + <span class=\"number\">1</span>) % mContentList.size());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mRunnable == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            mAnimator.start();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                postDelayed(mRunnable, mIdleTime);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationCancel</span><span class=\"params\">(Animator animation)</span> </span>&#123;</span><br><span class=\"line\">                mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentList == <span class=\"keyword\">null</span> || mContentList.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mIsRunning) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentList.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            mCurStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            mNextStr = mContentList.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mCurStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            mNextStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        mIsRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        mAnimator.start();</span><br><span class=\"line\">        mAnimator.setStartDelay(mIdleTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRunnable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            removeCallbacks(mRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAnimator.cancel();</span><br><span class=\"line\">        mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentList</span><span class=\"params\">(List&lt;String&gt; contentList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (contentList == <span class=\"keyword\">null</span> || contentList.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        mContentList = contentList;</span><br><span class=\"line\">        start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        mWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">        mPaddingLeft = getPaddingLeft();</span><br><span class=\"line\">        mPaddingRight = getPaddingRight();</span><br><span class=\"line\">        mPaddingTop = getPaddingTop();</span><br><span class=\"line\">        mPaddingBottom = getPaddingBottom();</span><br><span class=\"line\"></span><br><span class=\"line\">        mPaint.setTextSize(getTextSize());</span><br><span class=\"line\">        mFontMetrics = mPaint.getFontMetrics();</span><br><span class=\"line\"></span><br><span class=\"line\">        mTextBaseY = -mFontMetrics.top + mPaddingTop;</span><br><span class=\"line\">        mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom;</span><br><span class=\"line\"></span><br><span class=\"line\">        setMeasuredDimension(mWidth, mHeight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDraw(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> baseY = <span class=\"number\">2</span> * mTextBaseY * (<span class=\"number\">0.5f</span> - mCurValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            canvas.drawText(mCurStr, curStartX, baseY, mPaint);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            canvas.drawText(mNextStr, nextStartX, <span class=\"number\">2</span> * mTextBaseY + baseY, mPaint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>要实现一个自动滚播的自定义View</p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoSwitchView</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatTextView</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_IDLE_TIME = <span class=\"number\">3000</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_SWITCH_TIME = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mIdleTime = DEFAULT_IDLE_TIME;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mSwitchTime = DEFAULT_SWITCH_TIME;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mCurStr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String mNextStr;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; mContentList;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mCurValue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ValueAnimator mAnimator;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint.FontMetrics mFontMetrics;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Runnable mRunnable;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mWidth;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingLeft;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingRight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingTop;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mPaddingBottom;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mHeight;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> mTextBaseY;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AutoSwitchView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        init(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        mPaint = <span class=\"keyword\">new</span> Paint();</span><br><span class=\"line\">        mPaint.setTextAlign(Paint.Align.CENTER);</span><br><span class=\"line\"></span><br><span class=\"line\">        mAnimator = ValueAnimator.ofFloat(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        mAnimator.setStartDelay(mIdleTime);</span><br><span class=\"line\">        mAnimator.setDuration(mSwitchTime);</span><br><span class=\"line\">        mAnimator.addUpdateListener(<span class=\"keyword\">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationUpdate</span><span class=\"params\">(ValueAnimator animation)</span> </span>&#123;</span><br><span class=\"line\">                mCurValue = (<span class=\"keyword\">float</span>) animation.getAnimatedValue();</span><br><span class=\"line\">                <span class=\"comment\">// 必须要加这个判断, 不然会出现问题</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mCurValue &lt; <span class=\"number\">1.0</span>) &#123;</span><br><span class=\"line\">                    invalidate();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        mAnimator.addListener(<span class=\"keyword\">new</span> AnimatorListenerAdapter() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationEnd</span><span class=\"params\">(Animator animation, <span class=\"keyword\">boolean</span> isReverse)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!mIsRunning) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                mCurIndex = (mCurIndex + <span class=\"number\">1</span>) % mContentList.size();</span><br><span class=\"line\">                mCurStr = mContentList.get(mCurIndex);</span><br><span class=\"line\">                mNextStr = mContentList.get((mCurIndex + <span class=\"number\">1</span>) % mContentList.size());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mRunnable == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    mRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                        <span class=\"meta\">@Override</span></span><br><span class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                            mAnimator.start();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                postDelayed(mRunnable, mIdleTime);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onAnimationCancel</span><span class=\"params\">(Animator animation)</span> </span>&#123;</span><br><span class=\"line\">                mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentList == <span class=\"keyword\">null</span> || mContentList.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mIsRunning) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mContentList.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            mCurStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            mNextStr = mContentList.get(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            mCurStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">            mNextStr = mContentList.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        mIsRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        mAnimator.start();</span><br><span class=\"line\">        mAnimator.setStartDelay(mIdleTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRunnable != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            removeCallbacks(mRunnable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAnimator.cancel();</span><br><span class=\"line\">        mIsRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mCurIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentList</span><span class=\"params\">(List&lt;String&gt; contentList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (contentList == <span class=\"keyword\">null</span> || contentList.size() == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        mContentList = contentList;</span><br><span class=\"line\">        start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\"></span><br><span class=\"line\">        mWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class=\"line\">        mPaddingLeft = getPaddingLeft();</span><br><span class=\"line\">        mPaddingRight = getPaddingRight();</span><br><span class=\"line\">        mPaddingTop = getPaddingTop();</span><br><span class=\"line\">        mPaddingBottom = getPaddingBottom();</span><br><span class=\"line\"></span><br><span class=\"line\">        mPaint.setTextSize(getTextSize());</span><br><span class=\"line\">        mFontMetrics = mPaint.getFontMetrics();</span><br><span class=\"line\"></span><br><span class=\"line\">        mTextBaseY = -mFontMetrics.top + mPaddingTop;</span><br><span class=\"line\">        mHeight = Math.round(mFontMetrics.bottom - mFontMetrics.top) + mPaddingTop + mPaddingBottom;</span><br><span class=\"line\"></span><br><span class=\"line\">        setMeasuredDimension(mWidth, mHeight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDraw(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> curStartX = mPaddingLeft + mPaint.measureText(mCurStr) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> nextStartX = mPaddingLeft + mPaint.measureText(mNextStr) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">float</span> baseY = <span class=\"number\">2</span> * mTextBaseY * (<span class=\"number\">0.5f</span> - mCurValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (baseY &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            canvas.drawText(mCurStr, curStartX, baseY, mPaint);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            canvas.drawText(mNextStr, nextStartX, <span class=\"number\">2</span> * mTextBaseY + baseY, mPaint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ConcurrentHashMap","date":"2022-04-04T08:36:53.000Z","_content":"\nConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 \n\n## 1.8 之前\n将 table 数组划分为多个 segment ，对每一个 segment 单独加锁，不同的 segment 可以跨线程运算，提高并发效率。 \n\n每一个segment有一个单独的table数组，类似1.7版本的 hashmap，table数组遇到哈希冲突后，同hash值的元素使用的数据结构是链表。\n\n读是不需要加锁的，因为 segment 的 table 数组加了 volatile 修饰，HashEntry 的val和next字段也用 volatile 修饰。 一个线程改变了值，另一个线程能马上发现。\n\nput的时候需要加锁，当put时，所在的segment还没有创建，会懒加载创建segment。实例化segment之后，会通过cas插入到segment数组中，保证线程安全。\n\n下面是 1.8之前 ConcurrentHashMap 的 Segment 的 put 流程\n\n```java\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n    //尝试获取锁，获取成功，node为null，代码向下执行\n    //如果有其他线程占据锁对象，那么去做别的事情，而不是一直等待，提升效率\n    // tryLock 通过cas获取锁\n    //scanAndLockForPut 稍后分析\n    HashEntry<K,V> node = tryLock() ? null :\n        scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try {\n        HashEntry<K,V>[] tab = table;\n        //取hash的低位，计算HashEntry[]的索引\n        int index = (tab.length - 1) & hash;\n        //获取索引位的元素对象\n        HashEntry<K,V> first = entryAt(tab, index);\n        for (HashEntry<K,V> e = first;;) {\n            //获取的元素对象不为空\n            if (e != null) {\n                K k;\n                //如果是重复元素，覆盖原值\n                if ((k = e.key) == key ||\n                    (e.hash == hash && key.equals(k))) {\n                    oldValue = e.value;\n                    if (!onlyIfAbsent) {\n                        e.value = value;\n                        ++modCount;\n                    }\n                    break;\n                }\n                //如果不是重复元素，获取链表的下一个元素，继续循环遍历链表\n                e = e.next;\n            }\n            else { //如果获取到的元素为空\n                //当前添加的键值对的HashEntry对象已经创建\n                if (node != null)\n                    node.setNext(first); //头插法关联即可\n                else\n                    //创建当前添加的键值对的HashEntry对象\n                    node = new HashEntry<K,V>(hash, key, value, first);\n                //添加的元素数量递增\n                int c = count + 1;\n                //判断是否需要扩容\n                if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                    //需要扩容\n                    rehash(node);\n                else\n                    //不需要扩容\n                    //将当前添加的元素对象，存入数组角标位，完成头插法添加元素\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count = c;\n                oldValue = null;\n                break;\n            }\n        }\n    } finally {\n        //释放锁\n        unlock();\n    }\n    return oldValue;\n}\n\n/* 四：Segment的scanAndLockForPut方法\n * 该方法在线程没有获取到锁的情况下，去完成HashEntry对象的创建，提升效率\n*/\nprivate HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {\n    //获取头部元素\n    HashEntry<K,V> first = entryForHash(this, hash);\n    HashEntry<K,V> e = first;\n    HashEntry<K,V> node = null；\n    int retries = -1; // negative while locating node\n    while (!tryLock()) {\n        //获取锁失败\n        HashEntry<K,V> f; // to recheck first below\n        if (retries < 0) {\n            //没有下一个节点，并且也不是重复元素，创建HashEntry对象，不再遍历\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    node = new HashEntry<K,V>(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                //重复元素，不创建HashEntry对象，不再遍历\n                retries = 0;\n            else\n                //继续遍历下一个节点\n                e = e.next;\n        }\n        else if (++retries > MAX_SCAN_RETRIES) {\n            //如果尝试获取锁的次数过多，直接加锁\n            //MAX_SCAN_RETRIES会根据可用cpu核数来确定\n            lock();\n            break;\n        }\n        else if ((retries & 1) == 0 &&\n                 (f = entryForHash(this, hash)) != first) {\n            //如果期间有别的线程获取锁，重新遍历\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n```\n\n## 1.8 之后\n\n1.8之后ConcurrentHashMap改变了加锁策略，改为对哈希数组的每一个hash位置加锁；同时，将哈希冲突的链表替换为了和 HashMap 一样的红黑树。\n\n### sizeCtl\n* 为0，默认状态，代表数组未初始化， 且数组的初始容量为16\n* 为-1，表示数组正在进行初始化\n* 为正数，其记录的是数组的扩容阈值\n* 小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操\n\n### put时如何保证线程安全\n* 在put时对table哈希数组的每一个hash位置，如果为该位置为null，cas判断，然后在改位置添加元素；如果该位置不为null，则对该hash位置进行Synchronize加锁，将新元素加载链表or红黑树上。 \n\n```java\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    //如果有空值或者空键，直接抛异常\n    if (key == null || value == null) throw new NullPointerException();\n    //基于key计算hash值，并进行一定的扰动\n    int hash = spread(key.hashCode());\n    //记录某个桶上元素的个数，如果超过8个，会转成红黑树\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        //如果数组还未初始化，先对数组进行初始化\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n\t    //如果hash计算得到的桶位置没有元素，利用cas将元素添加\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            //cas+自旋（和外侧的for构成自旋循环），保证元素添加安全\n            //如果cas检测没过，下一次while循环就相当于在table的这个hash位置添加新元素\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        //如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            //hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加\n            V oldVal = null;\n            //对当前桶进行加锁，保证线程安全，执行元素添加操作\n            synchronized (f) {\n                // 重复判断，方式加锁之前已经有其他线程做了修改\n                if (tabAt(tab, i) == f) {\n                    //普通链表节点\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    //树节点，将元素添加到红黑树中\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                //链表长度大于/等于8，将链表转成红黑树\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                //如果是重复键，直接将旧值返回\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    //添加的是新元素，维护集合长度，并判断是否要进行扩容操作\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n### 初始化hash数组\n\n* 在初始化哈希数组的时候，会cas+自旋保证线程安全\n\n```java\n/* 初始化底层数组 */\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    //cas+自旋，保证线程安全，对数组进行初始化操作\n    while ((tab = table) == null || tab.length == 0) {\n        //如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); // lost initialization race; just spin\n        //cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    // 如果另一个线程已经初始化了数组，则不会走到这里。 会直接break\n\n                    //sizeCtl为0，取默认长度16，否则去sizeCtl的值\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    @SuppressWarnings(\"unchecked\")\n                    //基于初始长度，构建数组对象\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    //计算扩容阈值，并赋值给sc\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                //将扩容阈值，赋值给sizeCtl\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\n### 扩容\n\nConcurrentHashMap 的扩容在transfer方法中；\n需要注意的是，ConcurrentHashMap 有一个多线程协助扩容的机制。\n* 当一个线程在扩容的时候，在移动hash数组的元素到新数组的时候，会确定自己的开始位置 和 一个stride容量，hash数组stride内的元素自己负责扩容拷贝；然后确定一个 transferIndex 作为下次拷贝的起点。 同时在原数组的hash位置放置一个 ForwardingNode 。 \n* 当有新的线程想要在这个hash位置插入元素时，发现这里有一个 ForwardingNode ，会协助一起扩容，帮助将原数组的元素迁移到新数组。 以 transferIndex 作为起点，stride容量内的元素自己负责协助拷贝\n* 对于线程安全，在扩容拷贝的时候，会对hash数组要拷贝的位置进行 synchronized 加锁。在计算 transferIndex 的会使用 cas+自旋 机制保证线程安全。\n\n```java\nprivate final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n    int n = tab.length, stride;\n    //如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移\n    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n        stride = MIN_TRANSFER_STRIDE; // subdivide range\n    //如果是扩容线程，此时新数组为null\n    //如果是帮助扩容的线程，此时nextTab不为null\n    if (nextTab == null) {            // initiating\n        try {\n            @SuppressWarnings(\"unchecked\")\n            //两倍扩容创建新数组\n            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];\n            nextTab = nt;\n        } catch (Throwable ex) {      // try to cope with OOME\n            sizeCtl = Integer.MAX_VALUE;\n            return;\n        }\n        nextTable = nextTab;\n        //记录线程开始迁移的桶位，从后往前迁移，指向最右边\n        transferIndex = n;\n    }\n    //记录新数组的末尾\n    int nextn = nextTab.length;\n    //已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED）\n    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n    boolean advance = true;\n    boolean finishing = false; // to ensure sweep before committing nextTab\n    for (int i = 0, bound = 0;;) {\n        Node<K,V> f; int fh;\n        // advance：代表是否可以继续推进下一个槽位，只有当前槽位数据被迁移完成之后才可以设置为 true\n        while (advance) {\n            int nextIndex, nextBound;\n            //i记录当前正在迁移桶位的索引值\n            //bound记录下一次任务迁移的开始桶位\n\n            //--i >= bound 成立表示当前线程分配的迁移任务还没有完成\n            if (--i >= bound || finishing)\n                advance = false;\n            //没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成\n            else if ((nextIndex = transferIndex) <= 0) {\n                i = -1;\n                advance = false;\n            }\n            //计算下一次任务迁移的开始桶位，并将这个值赋值给transferIndex\n            else if (U.compareAndSwapInt\n                     (this, TRANSFERINDEX, nextIndex,\n                      nextBound = (nextIndex > stride ?\n                                   nextIndex - stride : 0))) {\n                bound = nextBound;\n                i = nextIndex - 1;\n                advance = false;\n            }\n        }\n        //如果没有更多的需要迁移的桶位，就进入该if\n        if (i < 0 || i >= n || i + n >= nextn) {\n            int sc;\n            //扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl\n            if (finishing) {\n                nextTable = null;\n                table = nextTab;\n                sizeCtl = (n << 1) - (n >>> 1);\n                return;\n            }\n\t\t    //扩容任务线程数减1\n            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                //判断当前所有扩容任务线程是否都执行完成\n                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                    return;\n                //所有扩容线程都执行完，标识结束\n                finishing = advance = true;\n                i = n; // recheck before commit\n            }\n        }\n        //当前迁移的桶位没有元素，直接在该位置添加一个fwd节点\n        else if ((f = tabAt(tab, i)) == null)\n            advance = casTabAt(tab, i, null, fwd);\n        //当前节点已经被迁移\n        else if ((fh = f.hash) == MOVED)\n            advance = true; // already processed\n        else {\n            //当前节点需要迁移，加锁迁移，保证多线程安全\n            //此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    ... // 省略代码，和 HashMap 的扩容拷贝基本一致\n                    advance = true;\n                }\n            }\n        }\n    }\n}\n\n```\n\n## 参考\nhttps://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap","source":"_posts/Java/ConcurrentHashMap.md","raw":"---\ntitle: ConcurrentHashMap\ndate: 2022-04-04 16:36:53\ntags:\n---\n\nConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 \n\n## 1.8 之前\n将 table 数组划分为多个 segment ，对每一个 segment 单独加锁，不同的 segment 可以跨线程运算，提高并发效率。 \n\n每一个segment有一个单独的table数组，类似1.7版本的 hashmap，table数组遇到哈希冲突后，同hash值的元素使用的数据结构是链表。\n\n读是不需要加锁的，因为 segment 的 table 数组加了 volatile 修饰，HashEntry 的val和next字段也用 volatile 修饰。 一个线程改变了值，另一个线程能马上发现。\n\nput的时候需要加锁，当put时，所在的segment还没有创建，会懒加载创建segment。实例化segment之后，会通过cas插入到segment数组中，保证线程安全。\n\n下面是 1.8之前 ConcurrentHashMap 的 Segment 的 put 流程\n\n```java\nfinal V put(K key, int hash, V value, boolean onlyIfAbsent) {\n    //尝试获取锁，获取成功，node为null，代码向下执行\n    //如果有其他线程占据锁对象，那么去做别的事情，而不是一直等待，提升效率\n    // tryLock 通过cas获取锁\n    //scanAndLockForPut 稍后分析\n    HashEntry<K,V> node = tryLock() ? null :\n        scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try {\n        HashEntry<K,V>[] tab = table;\n        //取hash的低位，计算HashEntry[]的索引\n        int index = (tab.length - 1) & hash;\n        //获取索引位的元素对象\n        HashEntry<K,V> first = entryAt(tab, index);\n        for (HashEntry<K,V> e = first;;) {\n            //获取的元素对象不为空\n            if (e != null) {\n                K k;\n                //如果是重复元素，覆盖原值\n                if ((k = e.key) == key ||\n                    (e.hash == hash && key.equals(k))) {\n                    oldValue = e.value;\n                    if (!onlyIfAbsent) {\n                        e.value = value;\n                        ++modCount;\n                    }\n                    break;\n                }\n                //如果不是重复元素，获取链表的下一个元素，继续循环遍历链表\n                e = e.next;\n            }\n            else { //如果获取到的元素为空\n                //当前添加的键值对的HashEntry对象已经创建\n                if (node != null)\n                    node.setNext(first); //头插法关联即可\n                else\n                    //创建当前添加的键值对的HashEntry对象\n                    node = new HashEntry<K,V>(hash, key, value, first);\n                //添加的元素数量递增\n                int c = count + 1;\n                //判断是否需要扩容\n                if (c > threshold && tab.length < MAXIMUM_CAPACITY)\n                    //需要扩容\n                    rehash(node);\n                else\n                    //不需要扩容\n                    //将当前添加的元素对象，存入数组角标位，完成头插法添加元素\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count = c;\n                oldValue = null;\n                break;\n            }\n        }\n    } finally {\n        //释放锁\n        unlock();\n    }\n    return oldValue;\n}\n\n/* 四：Segment的scanAndLockForPut方法\n * 该方法在线程没有获取到锁的情况下，去完成HashEntry对象的创建，提升效率\n*/\nprivate HashEntry<K,V> scanAndLockForPut(K key, int hash, V value) {\n    //获取头部元素\n    HashEntry<K,V> first = entryForHash(this, hash);\n    HashEntry<K,V> e = first;\n    HashEntry<K,V> node = null；\n    int retries = -1; // negative while locating node\n    while (!tryLock()) {\n        //获取锁失败\n        HashEntry<K,V> f; // to recheck first below\n        if (retries < 0) {\n            //没有下一个节点，并且也不是重复元素，创建HashEntry对象，不再遍历\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    node = new HashEntry<K,V>(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                //重复元素，不创建HashEntry对象，不再遍历\n                retries = 0;\n            else\n                //继续遍历下一个节点\n                e = e.next;\n        }\n        else if (++retries > MAX_SCAN_RETRIES) {\n            //如果尝试获取锁的次数过多，直接加锁\n            //MAX_SCAN_RETRIES会根据可用cpu核数来确定\n            lock();\n            break;\n        }\n        else if ((retries & 1) == 0 &&\n                 (f = entryForHash(this, hash)) != first) {\n            //如果期间有别的线程获取锁，重新遍历\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}\n```\n\n## 1.8 之后\n\n1.8之后ConcurrentHashMap改变了加锁策略，改为对哈希数组的每一个hash位置加锁；同时，将哈希冲突的链表替换为了和 HashMap 一样的红黑树。\n\n### sizeCtl\n* 为0，默认状态，代表数组未初始化， 且数组的初始容量为16\n* 为-1，表示数组正在进行初始化\n* 为正数，其记录的是数组的扩容阈值\n* 小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操\n\n### put时如何保证线程安全\n* 在put时对table哈希数组的每一个hash位置，如果为该位置为null，cas判断，然后在改位置添加元素；如果该位置不为null，则对该hash位置进行Synchronize加锁，将新元素加载链表or红黑树上。 \n\n```java\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    //如果有空值或者空键，直接抛异常\n    if (key == null || value == null) throw new NullPointerException();\n    //基于key计算hash值，并进行一定的扰动\n    int hash = spread(key.hashCode());\n    //记录某个桶上元素的个数，如果超过8个，会转成红黑树\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        //如果数组还未初始化，先对数组进行初始化\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n\t    //如果hash计算得到的桶位置没有元素，利用cas将元素添加\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            //cas+自旋（和外侧的for构成自旋循环），保证元素添加安全\n            //如果cas检测没过，下一次while循环就相当于在table的这个hash位置添加新元素\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        //如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            //hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加\n            V oldVal = null;\n            //对当前桶进行加锁，保证线程安全，执行元素添加操作\n            synchronized (f) {\n                // 重复判断，方式加锁之前已经有其他线程做了修改\n                if (tabAt(tab, i) == f) {\n                    //普通链表节点\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    //树节点，将元素添加到红黑树中\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            if (binCount != 0) {\n                //链表长度大于/等于8，将链表转成红黑树\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                //如果是重复键，直接将旧值返回\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    //添加的是新元素，维护集合长度，并判断是否要进行扩容操作\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n### 初始化hash数组\n\n* 在初始化哈希数组的时候，会cas+自旋保证线程安全\n\n```java\n/* 初始化底层数组 */\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    //cas+自旋，保证线程安全，对数组进行初始化操作\n    while ((tab = table) == null || tab.length == 0) {\n        //如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); // lost initialization race; just spin\n        //cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    // 如果另一个线程已经初始化了数组，则不会走到这里。 会直接break\n\n                    //sizeCtl为0，取默认长度16，否则去sizeCtl的值\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    @SuppressWarnings(\"unchecked\")\n                    //基于初始长度，构建数组对象\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    //计算扩容阈值，并赋值给sc\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                //将扩容阈值，赋值给sizeCtl\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\n### 扩容\n\nConcurrentHashMap 的扩容在transfer方法中；\n需要注意的是，ConcurrentHashMap 有一个多线程协助扩容的机制。\n* 当一个线程在扩容的时候，在移动hash数组的元素到新数组的时候，会确定自己的开始位置 和 一个stride容量，hash数组stride内的元素自己负责扩容拷贝；然后确定一个 transferIndex 作为下次拷贝的起点。 同时在原数组的hash位置放置一个 ForwardingNode 。 \n* 当有新的线程想要在这个hash位置插入元素时，发现这里有一个 ForwardingNode ，会协助一起扩容，帮助将原数组的元素迁移到新数组。 以 transferIndex 作为起点，stride容量内的元素自己负责协助拷贝\n* 对于线程安全，在扩容拷贝的时候，会对hash数组要拷贝的位置进行 synchronized 加锁。在计算 transferIndex 的会使用 cas+自旋 机制保证线程安全。\n\n```java\nprivate final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n    int n = tab.length, stride;\n    //如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移\n    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n        stride = MIN_TRANSFER_STRIDE; // subdivide range\n    //如果是扩容线程，此时新数组为null\n    //如果是帮助扩容的线程，此时nextTab不为null\n    if (nextTab == null) {            // initiating\n        try {\n            @SuppressWarnings(\"unchecked\")\n            //两倍扩容创建新数组\n            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];\n            nextTab = nt;\n        } catch (Throwable ex) {      // try to cope with OOME\n            sizeCtl = Integer.MAX_VALUE;\n            return;\n        }\n        nextTable = nextTab;\n        //记录线程开始迁移的桶位，从后往前迁移，指向最右边\n        transferIndex = n;\n    }\n    //记录新数组的末尾\n    int nextn = nextTab.length;\n    //已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED）\n    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n    boolean advance = true;\n    boolean finishing = false; // to ensure sweep before committing nextTab\n    for (int i = 0, bound = 0;;) {\n        Node<K,V> f; int fh;\n        // advance：代表是否可以继续推进下一个槽位，只有当前槽位数据被迁移完成之后才可以设置为 true\n        while (advance) {\n            int nextIndex, nextBound;\n            //i记录当前正在迁移桶位的索引值\n            //bound记录下一次任务迁移的开始桶位\n\n            //--i >= bound 成立表示当前线程分配的迁移任务还没有完成\n            if (--i >= bound || finishing)\n                advance = false;\n            //没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成\n            else if ((nextIndex = transferIndex) <= 0) {\n                i = -1;\n                advance = false;\n            }\n            //计算下一次任务迁移的开始桶位，并将这个值赋值给transferIndex\n            else if (U.compareAndSwapInt\n                     (this, TRANSFERINDEX, nextIndex,\n                      nextBound = (nextIndex > stride ?\n                                   nextIndex - stride : 0))) {\n                bound = nextBound;\n                i = nextIndex - 1;\n                advance = false;\n            }\n        }\n        //如果没有更多的需要迁移的桶位，就进入该if\n        if (i < 0 || i >= n || i + n >= nextn) {\n            int sc;\n            //扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl\n            if (finishing) {\n                nextTable = null;\n                table = nextTab;\n                sizeCtl = (n << 1) - (n >>> 1);\n                return;\n            }\n\t\t    //扩容任务线程数减1\n            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                //判断当前所有扩容任务线程是否都执行完成\n                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                    return;\n                //所有扩容线程都执行完，标识结束\n                finishing = advance = true;\n                i = n; // recheck before commit\n            }\n        }\n        //当前迁移的桶位没有元素，直接在该位置添加一个fwd节点\n        else if ((f = tabAt(tab, i)) == null)\n            advance = casTabAt(tab, i, null, fwd);\n        //当前节点已经被迁移\n        else if ((fh = f.hash) == MOVED)\n            advance = true; // already processed\n        else {\n            //当前节点需要迁移，加锁迁移，保证多线程安全\n            //此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    ... // 省略代码，和 HashMap 的扩容拷贝基本一致\n                    advance = true;\n                }\n            }\n        }\n    }\n}\n\n```\n\n## 参考\nhttps://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap","slug":"Java/ConcurrentHashMap","published":1,"updated":"2022-04-05T09:43:51.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8i003ag0jeyml198j0","content":"<p>ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 </p><a id=\"more\"></a>\n<h2 id=\"1-8-之前\"><a href=\"#1-8-之前\" class=\"headerlink\" title=\"1.8 之前\"></a>1.8 之前</h2><p>将 table 数组划分为多个 segment ，对每一个 segment 单独加锁，不同的 segment 可以跨线程运算，提高并发效率。 </p>\n<p>每一个segment有一个单独的table数组，类似1.7版本的 hashmap，table数组遇到哈希冲突后，同hash值的元素使用的数据结构是链表。</p>\n<p>读是不需要加锁的，因为 segment 的 table 数组加了 volatile 修饰，HashEntry 的val和next字段也用 volatile 修饰。 一个线程改变了值，另一个线程能马上发现。</p>\n<p>put的时候需要加锁，当put时，所在的segment还没有创建，会懒加载创建segment。实例化segment之后，会通过cas插入到segment数组中，保证线程安全。</p>\n<p>下面是 1.8之前 ConcurrentHashMap 的 Segment 的 put 流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//尝试获取锁，获取成功，node为null，代码向下执行</span></span><br><span class=\"line\">    <span class=\"comment\">//如果有其他线程占据锁对象，那么去做别的事情，而不是一直等待，提升效率</span></span><br><span class=\"line\">    <span class=\"comment\">// tryLock 通过cas获取锁</span></span><br><span class=\"line\">    <span class=\"comment\">//scanAndLockForPut 稍后分析</span></span><br><span class=\"line\">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class=\"keyword\">null</span> :</span><br><span class=\"line\">        scanAndLockForPut(key, hash, value);</span><br><span class=\"line\">    V oldValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class=\"line\">        <span class=\"comment\">//取hash的低位，计算HashEntry[]的索引</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = (tab.length - <span class=\"number\">1</span>) &amp; hash;</span><br><span class=\"line\">        <span class=\"comment\">//获取索引位的元素对象</span></span><br><span class=\"line\">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取的元素对象不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                K k;</span><br><span class=\"line\">                <span class=\"comment\">//如果是重复元素，覆盖原值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((k = e.key) == key ||</span><br><span class=\"line\">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class=\"line\">                    oldValue = e.value;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!onlyIfAbsent) &#123;</span><br><span class=\"line\">                        e.value = value;</span><br><span class=\"line\">                        ++modCount;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//如果不是重复元素，获取链表的下一个元素，继续循环遍历链表</span></span><br><span class=\"line\">                e = e.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//如果获取到的元素为空</span></span><br><span class=\"line\">                <span class=\"comment\">//当前添加的键值对的HashEntry对象已经创建</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    node.setNext(first); <span class=\"comment\">//头插法关联即可</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"comment\">//创建当前添加的键值对的HashEntry对象</span></span><br><span class=\"line\">                    node = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class=\"line\">                <span class=\"comment\">//添加的元素数量递增</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> c = count + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">                    <span class=\"comment\">//需要扩容</span></span><br><span class=\"line\">                    rehash(node);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"comment\">//不需要扩容</span></span><br><span class=\"line\">                    <span class=\"comment\">//将当前添加的元素对象，存入数组角标位，完成头插法添加元素</span></span><br><span class=\"line\">                    setEntryAt(tab, index, node);</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                count = c;</span><br><span class=\"line\">                oldValue = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">        unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 四：Segment的scanAndLockForPut方法</span></span><br><span class=\"line\"><span class=\"comment\"> * 该方法在线程没有获取到锁的情况下，去完成HashEntry对象的创建，提升效率</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> HashEntry&lt;K,V&gt; <span class=\"title\">scanAndLockForPut</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取头部元素</span></span><br><span class=\"line\">    HashEntry&lt;K,V&gt; first = entryForHash(<span class=\"keyword\">this</span>, hash);</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; e = first;</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; node = <span class=\"keyword\">null</span>；</span><br><span class=\"line\">    <span class=\"keyword\">int</span> retries = -<span class=\"number\">1</span>; <span class=\"comment\">// negative while locating node</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!tryLock()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取锁失败</span></span><br><span class=\"line\">        HashEntry&lt;K,V&gt; f; <span class=\"comment\">// to recheck first below</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retries &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//没有下一个节点，并且也不是重复元素，创建HashEntry对象，不再遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) <span class=\"comment\">// speculatively create node</span></span><br><span class=\"line\">                    node = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                retries = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.equals(e.key))</span><br><span class=\"line\">                <span class=\"comment\">//重复元素，不创建HashEntry对象，不再遍历</span></span><br><span class=\"line\">                retries = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"comment\">//继续遍历下一个节点</span></span><br><span class=\"line\">                e = e.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果尝试获取锁的次数过多，直接加锁</span></span><br><span class=\"line\">            <span class=\"comment\">//MAX_SCAN_RETRIES会根据可用cpu核数来确定</span></span><br><span class=\"line\">            lock();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((retries &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                 (f = entryForHash(<span class=\"keyword\">this</span>, hash)) != first) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果期间有别的线程获取锁，重新遍历</span></span><br><span class=\"line\">            e = first = f; <span class=\"comment\">// re-traverse if entry changed</span></span><br><span class=\"line\">            retries = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-8-之后\"><a href=\"#1-8-之后\" class=\"headerlink\" title=\"1.8 之后\"></a>1.8 之后</h2><p>1.8之后ConcurrentHashMap改变了加锁策略，改为对哈希数组的每一个hash位置加锁；同时，将哈希冲突的链表替换为了和 HashMap 一样的红黑树。</p>\n<h3 id=\"sizeCtl\"><a href=\"#sizeCtl\" class=\"headerlink\" title=\"sizeCtl\"></a>sizeCtl</h3><ul>\n<li>为0，默认状态，代表数组未初始化， 且数组的初始容量为16</li>\n<li>为-1，表示数组正在进行初始化</li>\n<li>为正数，其记录的是数组的扩容阈值</li>\n<li>小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操</li>\n</ul>\n<h3 id=\"put时如何保证线程安全\"><a href=\"#put时如何保证线程安全\" class=\"headerlink\" title=\"put时如何保证线程安全\"></a>put时如何保证线程安全</h3><ul>\n<li>在put时对table哈希数组的每一个hash位置，如果为该位置为null，cas判断，然后在改位置添加元素；如果该位置不为null，则对该hash位置进行Synchronize加锁，将新元素加载链表or红黑树上。 </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果有空值或者空键，直接抛异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">//基于key计算hash值，并进行一定的扰动</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"comment\">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">//如果数组还未初始化，先对数组进行初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">\t    <span class=\"comment\">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span></span><br><span class=\"line\">            <span class=\"comment\">//如果cas检测没过，下一次while循环就相当于在table的这个hash位置添加新元素</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                         <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span></span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重复判断，方式加锁之前已经有其他线程做了修改</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//普通链表节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//树节点，将元素添加到红黑树中</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                       value)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//链表长度大于/等于8，将链表转成红黑树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"comment\">//如果是重复键，直接将旧值返回</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作</span></span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化hash数组\"><a href=\"#初始化hash数组\" class=\"headerlink\" title=\"初始化hash数组\"></a>初始化hash数组</h3><ul>\n<li>在初始化哈希数组的时候，会cas+自旋保证线程安全</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 初始化底层数组 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">    <span class=\"comment\">//cas+自旋，保证线程安全，对数组进行初始化操作</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            Thread.yield(); <span class=\"comment\">// lost initialization race; just spin</span></span><br><span class=\"line\">        <span class=\"comment\">//cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果另一个线程已经初始化了数组，则不会走到这里。 会直接break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//sizeCtl为0，取默认长度16，否则去sizeCtl的值</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> n = (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                    <span class=\"comment\">//基于初始长度，构建数组对象</span></span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table = tab = nt;</span><br><span class=\"line\">                    <span class=\"comment\">//计算扩容阈值，并赋值给sc</span></span><br><span class=\"line\">                    sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//将扩容阈值，赋值给sizeCtl</span></span><br><span class=\"line\">                sizeCtl = sc;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><p>ConcurrentHashMap 的扩容在transfer方法中；<br>需要注意的是，ConcurrentHashMap 有一个多线程协助扩容的机制。</p>\n<ul>\n<li>当一个线程在扩容的时候，在移动hash数组的元素到新数组的时候，会确定自己的开始位置 和 一个stride容量，hash数组stride内的元素自己负责扩容拷贝；然后确定一个 transferIndex 作为下次拷贝的起点。 同时在原数组的hash位置放置一个 ForwardingNode 。 </li>\n<li>当有新的线程想要在这个hash位置插入元素时，发现这里有一个 ForwardingNode ，会协助一起扩容，帮助将原数组的元素迁移到新数组。 以 transferIndex 作为起点，stride容量内的元素自己负责协助拷贝</li>\n<li>对于线程安全，在扩容拷贝的时候，会对hash数组要拷贝的位置进行 synchronized 加锁。在计算 transferIndex 的会使用 cas+自旋 机制保证线程安全。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = tab.length, stride;</span><br><span class=\"line\">    <span class=\"comment\">//如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((stride = (NCPU &gt; <span class=\"number\">1</span>) ? (n &gt;&gt;&gt; <span class=\"number\">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class=\"line\">        stride = MIN_TRANSFER_STRIDE; <span class=\"comment\">// subdivide range</span></span><br><span class=\"line\">    <span class=\"comment\">//如果是扩容线程，此时新数组为null</span></span><br><span class=\"line\">    <span class=\"comment\">//如果是帮助扩容的线程，此时nextTab不为null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextTab == <span class=\"keyword\">null</span>) &#123;            <span class=\"comment\">// initiating</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            <span class=\"comment\">//两倍扩容创建新数组</span></span><br><span class=\"line\">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class=\"number\">1</span>];</span><br><span class=\"line\">            nextTab = nt;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;      <span class=\"comment\">// try to cope with OOME</span></span><br><span class=\"line\">            sizeCtl = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextTable = nextTab;</span><br><span class=\"line\">        <span class=\"comment\">//记录线程开始迁移的桶位，从后往前迁移，指向最右边</span></span><br><span class=\"line\">        transferIndex = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//记录新数组的末尾</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextn = nextTab.length;</span><br><span class=\"line\">    <span class=\"comment\">//已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED）</span></span><br><span class=\"line\">    ForwardingNode&lt;K,V&gt; fwd = <span class=\"keyword\">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> finishing = <span class=\"keyword\">false</span>; <span class=\"comment\">// to ensure sweep before committing nextTab</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, bound = <span class=\"number\">0</span>;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> fh;</span><br><span class=\"line\">        <span class=\"comment\">// advance：代表是否可以继续推进下一个槽位，只有当前槽位数据被迁移完成之后才可以设置为 true</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (advance) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextIndex, nextBound;</span><br><span class=\"line\">            <span class=\"comment\">//i记录当前正在迁移桶位的索引值</span></span><br><span class=\"line\">            <span class=\"comment\">//bound记录下一次任务迁移的开始桶位</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//--i &gt;= bound 成立表示当前线程分配的迁移任务还没有完成</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (--i &gt;= bound || finishing)</span><br><span class=\"line\">                advance = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((nextIndex = transferIndex) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                i = -<span class=\"number\">1</span>;</span><br><span class=\"line\">                advance = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//计算下一次任务迁移的开始桶位，并将这个值赋值给transferIndex</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt</span><br><span class=\"line\">                     (<span class=\"keyword\">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class=\"line\">                      nextBound = (nextIndex &gt; stride ?</span><br><span class=\"line\">                                   nextIndex - stride : <span class=\"number\">0</span>))) &#123;</span><br><span class=\"line\">                bound = nextBound;</span><br><span class=\"line\">                i = nextIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">                advance = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果没有更多的需要迁移的桶位，就进入该if</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">            <span class=\"comment\">//扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (finishing) &#123;</span><br><span class=\"line\">                nextTable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                table = nextTab;</span><br><span class=\"line\">                sizeCtl = (n &lt;&lt; <span class=\"number\">1</span>) - (n &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t    <span class=\"comment\">//扩容任务线程数减1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc = sizeCtl, sc - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//判断当前所有扩容任务线程是否都执行完成</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((sc - <span class=\"number\">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                <span class=\"comment\">//所有扩容线程都执行完，标识结束</span></span><br><span class=\"line\">                finishing = advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                i = n; <span class=\"comment\">// recheck before commit</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//当前迁移的桶位没有元素，直接在该位置添加一个fwd节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            advance = casTabAt(tab, i, <span class=\"keyword\">null</span>, fwd);</span><br><span class=\"line\">        <span class=\"comment\">//当前节点已经被迁移</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            advance = <span class=\"keyword\">true</span>; <span class=\"comment\">// already processed</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前节点需要迁移，加锁迁移，保证多线程安全</span></span><br><span class=\"line\">            <span class=\"comment\">//此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    ... <span class=\"comment\">// 省略代码，和 HashMap 的扩容拷贝基本一致</span></span><br><span class=\"line\">                    advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap\" target=\"_blank\" rel=\"noopener\">https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap</a></p>\n","site":{"data":{}},"excerpt":"<p>ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 </p>","more":"\n<h2 id=\"1-8-之前\"><a href=\"#1-8-之前\" class=\"headerlink\" title=\"1.8 之前\"></a>1.8 之前</h2><p>将 table 数组划分为多个 segment ，对每一个 segment 单独加锁，不同的 segment 可以跨线程运算，提高并发效率。 </p>\n<p>每一个segment有一个单独的table数组，类似1.7版本的 hashmap，table数组遇到哈希冲突后，同hash值的元素使用的数据结构是链表。</p>\n<p>读是不需要加锁的，因为 segment 的 table 数组加了 volatile 修饰，HashEntry 的val和next字段也用 volatile 修饰。 一个线程改变了值，另一个线程能马上发现。</p>\n<p>put的时候需要加锁，当put时，所在的segment还没有创建，会懒加载创建segment。实例化segment之后，会通过cas插入到segment数组中，保证线程安全。</p>\n<p>下面是 1.8之前 ConcurrentHashMap 的 Segment 的 put 流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">put</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//尝试获取锁，获取成功，node为null，代码向下执行</span></span><br><span class=\"line\">    <span class=\"comment\">//如果有其他线程占据锁对象，那么去做别的事情，而不是一直等待，提升效率</span></span><br><span class=\"line\">    <span class=\"comment\">// tryLock 通过cas获取锁</span></span><br><span class=\"line\">    <span class=\"comment\">//scanAndLockForPut 稍后分析</span></span><br><span class=\"line\">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class=\"keyword\">null</span> :</span><br><span class=\"line\">        scanAndLockForPut(key, hash, value);</span><br><span class=\"line\">    V oldValue;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class=\"line\">        <span class=\"comment\">//取hash的低位，计算HashEntry[]的索引</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = (tab.length - <span class=\"number\">1</span>) &amp; hash;</span><br><span class=\"line\">        <span class=\"comment\">//获取索引位的元素对象</span></span><br><span class=\"line\">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取的元素对象不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                K k;</span><br><span class=\"line\">                <span class=\"comment\">//如果是重复元素，覆盖原值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((k = e.key) == key ||</span><br><span class=\"line\">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class=\"line\">                    oldValue = e.value;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!onlyIfAbsent) &#123;</span><br><span class=\"line\">                        e.value = value;</span><br><span class=\"line\">                        ++modCount;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//如果不是重复元素，获取链表的下一个元素，继续循环遍历链表</span></span><br><span class=\"line\">                e = e.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//如果获取到的元素为空</span></span><br><span class=\"line\">                <span class=\"comment\">//当前添加的键值对的HashEntry对象已经创建</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    node.setNext(first); <span class=\"comment\">//头插法关联即可</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"comment\">//创建当前添加的键值对的HashEntry对象</span></span><br><span class=\"line\">                    node = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class=\"line\">                <span class=\"comment\">//添加的元素数量递增</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> c = count + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">//判断是否需要扩容</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">                    <span class=\"comment\">//需要扩容</span></span><br><span class=\"line\">                    rehash(node);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"comment\">//不需要扩容</span></span><br><span class=\"line\">                    <span class=\"comment\">//将当前添加的元素对象，存入数组角标位，完成头插法添加元素</span></span><br><span class=\"line\">                    setEntryAt(tab, index, node);</span><br><span class=\"line\">                ++modCount;</span><br><span class=\"line\">                count = c;</span><br><span class=\"line\">                oldValue = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//释放锁</span></span><br><span class=\"line\">        unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 四：Segment的scanAndLockForPut方法</span></span><br><span class=\"line\"><span class=\"comment\"> * 该方法在线程没有获取到锁的情况下，去完成HashEntry对象的创建，提升效率</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> HashEntry&lt;K,V&gt; <span class=\"title\">scanAndLockForPut</span><span class=\"params\">(K key, <span class=\"keyword\">int</span> hash, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取头部元素</span></span><br><span class=\"line\">    HashEntry&lt;K,V&gt; first = entryForHash(<span class=\"keyword\">this</span>, hash);</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; e = first;</span><br><span class=\"line\">    HashEntry&lt;K,V&gt; node = <span class=\"keyword\">null</span>；</span><br><span class=\"line\">    <span class=\"keyword\">int</span> retries = -<span class=\"number\">1</span>; <span class=\"comment\">// negative while locating node</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!tryLock()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取锁失败</span></span><br><span class=\"line\">        HashEntry&lt;K,V&gt; f; <span class=\"comment\">// to recheck first below</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retries &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//没有下一个节点，并且也不是重复元素，创建HashEntry对象，不再遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) <span class=\"comment\">// speculatively create node</span></span><br><span class=\"line\">                    node = <span class=\"keyword\">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                retries = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.equals(e.key))</span><br><span class=\"line\">                <span class=\"comment\">//重复元素，不创建HashEntry对象，不再遍历</span></span><br><span class=\"line\">                retries = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"comment\">//继续遍历下一个节点</span></span><br><span class=\"line\">                e = e.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果尝试获取锁的次数过多，直接加锁</span></span><br><span class=\"line\">            <span class=\"comment\">//MAX_SCAN_RETRIES会根据可用cpu核数来确定</span></span><br><span class=\"line\">            lock();</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((retries &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                 (f = entryForHash(<span class=\"keyword\">this</span>, hash)) != first) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果期间有别的线程获取锁，重新遍历</span></span><br><span class=\"line\">            e = first = f; <span class=\"comment\">// re-traverse if entry changed</span></span><br><span class=\"line\">            retries = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-8-之后\"><a href=\"#1-8-之后\" class=\"headerlink\" title=\"1.8 之后\"></a>1.8 之后</h2><p>1.8之后ConcurrentHashMap改变了加锁策略，改为对哈希数组的每一个hash位置加锁；同时，将哈希冲突的链表替换为了和 HashMap 一样的红黑树。</p>\n<h3 id=\"sizeCtl\"><a href=\"#sizeCtl\" class=\"headerlink\" title=\"sizeCtl\"></a>sizeCtl</h3><ul>\n<li>为0，默认状态，代表数组未初始化， 且数组的初始容量为16</li>\n<li>为-1，表示数组正在进行初始化</li>\n<li>为正数，其记录的是数组的扩容阈值</li>\n<li>小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操</li>\n</ul>\n<h3 id=\"put时如何保证线程安全\"><a href=\"#put时如何保证线程安全\" class=\"headerlink\" title=\"put时如何保证线程安全\"></a>put时如何保证线程安全</h3><ul>\n<li>在put时对table哈希数组的每一个hash位置，如果为该位置为null，cas判断，然后在改位置添加元素；如果该位置不为null，则对该hash位置进行Synchronize加锁，将新元素加载链表or红黑树上。 </li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果有空值或者空键，直接抛异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span> || value == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">//基于key计算hash值，并进行一定的扰动</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> hash = spread(key.hashCode());</span><br><span class=\"line\">    <span class=\"comment\">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> n, i, fh;</span><br><span class=\"line\">        <span class=\"comment\">//如果数组还未初始化，先对数组进行初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            tab = initTable();</span><br><span class=\"line\">\t    <span class=\"comment\">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span></span><br><span class=\"line\">            <span class=\"comment\">//如果cas检测没过，下一次while循环就相当于在table的这个hash位置添加新元素</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">                         <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key, value, <span class=\"keyword\">null</span>)))</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;                   <span class=\"comment\">// no lock when adding to empty bin</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            tab = helpTransfer(tab, f);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span></span><br><span class=\"line\">            V oldVal = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重复判断，方式加锁之前已经有其他线程做了修改</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//普通链表节点</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                            K ek;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                ((ek = e.key) == key ||</span><br><span class=\"line\">                                 (ek != <span class=\"keyword\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                oldVal = e.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    e.val = value;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                                pred.next = <span class=\"keyword\">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class=\"line\">                                                          value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//树节点，将元素添加到红黑树中</span></span><br><span class=\"line\">                    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;</span><br><span class=\"line\">                        Node&lt;K,V&gt; p;</span><br><span class=\"line\">                        binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                       value)) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            oldVal = p.val;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                p.val = value;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//链表长度大于/等于8，将链表转成红黑树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                    treeifyBin(tab, i);</span><br><span class=\"line\">                <span class=\"comment\">//如果是重复键，直接将旧值返回</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldVal != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作</span></span><br><span class=\"line\">    addCount(<span class=\"number\">1L</span>, binCount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化hash数组\"><a href=\"#初始化hash数组\" class=\"headerlink\" title=\"初始化hash数组\"></a>初始化hash数组</h3><ul>\n<li>在初始化哈希数组的时候，会cas+自旋保证线程安全</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 初始化底层数组 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">    <span class=\"comment\">//cas+自旋，保证线程安全，对数组进行初始化操作</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            Thread.yield(); <span class=\"comment\">// lost initialization race; just spin</span></span><br><span class=\"line\">        <span class=\"comment\">//cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || tab.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果另一个线程已经初始化了数组，则不会走到这里。 会直接break</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//sizeCtl为0，取默认长度16，否则去sizeCtl的值</span></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> n = (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class=\"line\">                    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                    <span class=\"comment\">//基于初始长度，构建数组对象</span></span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table = tab = nt;</span><br><span class=\"line\">                    <span class=\"comment\">//计算扩容阈值，并赋值给sc</span></span><br><span class=\"line\">                    sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//将扩容阈值，赋值给sizeCtl</span></span><br><span class=\"line\">                sizeCtl = sc;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h3><p>ConcurrentHashMap 的扩容在transfer方法中；<br>需要注意的是，ConcurrentHashMap 有一个多线程协助扩容的机制。</p>\n<ul>\n<li>当一个线程在扩容的时候，在移动hash数组的元素到新数组的时候，会确定自己的开始位置 和 一个stride容量，hash数组stride内的元素自己负责扩容拷贝；然后确定一个 transferIndex 作为下次拷贝的起点。 同时在原数组的hash位置放置一个 ForwardingNode 。 </li>\n<li>当有新的线程想要在这个hash位置插入元素时，发现这里有一个 ForwardingNode ，会协助一起扩容，帮助将原数组的元素迁移到新数组。 以 transferIndex 作为起点，stride容量内的元素自己负责协助拷贝</li>\n<li>对于线程安全，在扩容拷贝的时候，会对hash数组要拷贝的位置进行 synchronized 加锁。在计算 transferIndex 的会使用 cas+自旋 机制保证线程安全。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = tab.length, stride;</span><br><span class=\"line\">    <span class=\"comment\">//如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((stride = (NCPU &gt; <span class=\"number\">1</span>) ? (n &gt;&gt;&gt; <span class=\"number\">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class=\"line\">        stride = MIN_TRANSFER_STRIDE; <span class=\"comment\">// subdivide range</span></span><br><span class=\"line\">    <span class=\"comment\">//如果是扩容线程，此时新数组为null</span></span><br><span class=\"line\">    <span class=\"comment\">//如果是帮助扩容的线程，此时nextTab不为null</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextTab == <span class=\"keyword\">null</span>) &#123;            <span class=\"comment\">// initiating</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            <span class=\"comment\">//两倍扩容创建新数组</span></span><br><span class=\"line\">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class=\"number\">1</span>];</span><br><span class=\"line\">            nextTab = nt;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;      <span class=\"comment\">// try to cope with OOME</span></span><br><span class=\"line\">            sizeCtl = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nextTable = nextTab;</span><br><span class=\"line\">        <span class=\"comment\">//记录线程开始迁移的桶位，从后往前迁移，指向最右边</span></span><br><span class=\"line\">        transferIndex = n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//记录新数组的末尾</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextn = nextTab.length;</span><br><span class=\"line\">    <span class=\"comment\">//已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED）</span></span><br><span class=\"line\">    ForwardingNode&lt;K,V&gt; fwd = <span class=\"keyword\">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> finishing = <span class=\"keyword\">false</span>; <span class=\"comment\">// to ensure sweep before committing nextTab</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, bound = <span class=\"number\">0</span>;;) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; f; <span class=\"keyword\">int</span> fh;</span><br><span class=\"line\">        <span class=\"comment\">// advance：代表是否可以继续推进下一个槽位，只有当前槽位数据被迁移完成之后才可以设置为 true</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (advance) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextIndex, nextBound;</span><br><span class=\"line\">            <span class=\"comment\">//i记录当前正在迁移桶位的索引值</span></span><br><span class=\"line\">            <span class=\"comment\">//bound记录下一次任务迁移的开始桶位</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//--i &gt;= bound 成立表示当前线程分配的迁移任务还没有完成</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (--i &gt;= bound || finishing)</span><br><span class=\"line\">                advance = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">//没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((nextIndex = transferIndex) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                i = -<span class=\"number\">1</span>;</span><br><span class=\"line\">                advance = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//计算下一次任务迁移的开始桶位，并将这个值赋值给transferIndex</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt</span><br><span class=\"line\">                     (<span class=\"keyword\">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class=\"line\">                      nextBound = (nextIndex &gt; stride ?</span><br><span class=\"line\">                                   nextIndex - stride : <span class=\"number\">0</span>))) &#123;</span><br><span class=\"line\">                bound = nextBound;</span><br><span class=\"line\">                i = nextIndex - <span class=\"number\">1</span>;</span><br><span class=\"line\">                advance = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果没有更多的需要迁移的桶位，就进入该if</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sc;</span><br><span class=\"line\">            <span class=\"comment\">//扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (finishing) &#123;</span><br><span class=\"line\">                nextTable = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                table = nextTab;</span><br><span class=\"line\">                sizeCtl = (n &lt;&lt; <span class=\"number\">1</span>) - (n &gt;&gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t    <span class=\"comment\">//扩容任务线程数减1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"keyword\">this</span>, SIZECTL, sc = sizeCtl, sc - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//判断当前所有扩容任务线程是否都执行完成</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((sc - <span class=\"number\">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                <span class=\"comment\">//所有扩容线程都执行完，标识结束</span></span><br><span class=\"line\">                finishing = advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                i = n; <span class=\"comment\">// recheck before commit</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//当前迁移的桶位没有元素，直接在该位置添加一个fwd节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            advance = casTabAt(tab, i, <span class=\"keyword\">null</span>, fwd);</span><br><span class=\"line\">        <span class=\"comment\">//当前节点已经被迁移</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">            advance = <span class=\"keyword\">true</span>; <span class=\"comment\">// already processed</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前节点需要迁移，加锁迁移，保证多线程安全</span></span><br><span class=\"line\">            <span class=\"comment\">//此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                    ... <span class=\"comment\">// 省略代码，和 HashMap 的扩容拷贝基本一致</span></span><br><span class=\"line\">                    advance = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap\" target=\"_blank\" rel=\"noopener\">https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap</a></p>\n"},{"title":"jvm虚拟机","date":"2022-04-07T15:10:00.000Z","_content":"\n## JVM架构\n\njvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈\n\n1. 方法区\n方法区被所有线程共享。存放 类信息、类的字段信息和方法信息、常量、static类变量\n\n2. Java栈\nJava栈线程之间不共享。\nJava栈是由很多的栈帧(stack frame)或者说帧(frame)组成的，一个栈帧包含一个Java方法调用状态。用来存放方法的局部变量、被调用时传进来的参数、返回值 以及运算的中间结果等等。\n\n3. Native栈\n用来存放Native方法的调用状态\n\n4. 堆\n用于存放对象。 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。\n\n5. 程序计数器（PC寄存器）\n每一个线程有一个程序计数器。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。\n\n6. 类加载子系统\n读取class文件，加载Java类到内存。\n\n\n## 类加载器\n类加载器负责动态加载Java类到Java虚拟机的内存空间中。\n\n* 双亲委托机制\n“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类 路径中查找并装载目标类。这一点是从安全角度考虑的\n\n## GC垃圾回收机制\n\n### 如何判断对象是否可以被回收\n* 引用计数法\n* 根搜索算法：\n  * 从GC root出发查找引用链，无法触及到的对象可以被回收。 \n  * GC-root包括：虚拟机栈中引用的对象、类静态属性引用的对象、常量引用的对象\n\n### 强引用、弱引用、软引用、虚引用\n\n### GC算法\njvm将对象分为三个区域， 新生代（Young Generation） 、 老年代（Old Generation） 和 持久代（Permanent Generation）。\n* 持久代：\n  * 存放java类的类信息，存放静态文件，如final常量，static常量，常量池等。几乎不回收\n* 新生代：\n  * 新生代使用拷贝算法：新生代中存在一个Eden区和两个Survivor区，其中一个Survivor始终为空。 eden区gc时，存活的对象会复制到其中一个survivor区。 Survivor区gc时，会拷贝到另一个空闲的Survivor区。 当对象多次gc存活一定次数之后，会移动到老年代\n  * jvm中 eden区和Survivor区的大小为8：1\n* 老年代：\n  * 使用标记整理算法。标记需要清除对象，将存活的对象往内存的一端移动，再将需要清除要回收的对象。这样的算法可以避免内存碎片的产生\n","source":"_posts/Java/jvm虚拟机.md","raw":"---\ntitle: jvm虚拟机\ndate: 2022-04-07 23:10:00\ntags:\n---\n\n## JVM架构\n\njvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈\n\n1. 方法区\n方法区被所有线程共享。存放 类信息、类的字段信息和方法信息、常量、static类变量\n\n2. Java栈\nJava栈线程之间不共享。\nJava栈是由很多的栈帧(stack frame)或者说帧(frame)组成的，一个栈帧包含一个Java方法调用状态。用来存放方法的局部变量、被调用时传进来的参数、返回值 以及运算的中间结果等等。\n\n3. Native栈\n用来存放Native方法的调用状态\n\n4. 堆\n用于存放对象。 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。\n\n5. 程序计数器（PC寄存器）\n每一个线程有一个程序计数器。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。\n\n6. 类加载子系统\n读取class文件，加载Java类到内存。\n\n\n## 类加载器\n类加载器负责动态加载Java类到Java虚拟机的内存空间中。\n\n* 双亲委托机制\n“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类 路径中查找并装载目标类。这一点是从安全角度考虑的\n\n## GC垃圾回收机制\n\n### 如何判断对象是否可以被回收\n* 引用计数法\n* 根搜索算法：\n  * 从GC root出发查找引用链，无法触及到的对象可以被回收。 \n  * GC-root包括：虚拟机栈中引用的对象、类静态属性引用的对象、常量引用的对象\n\n### 强引用、弱引用、软引用、虚引用\n\n### GC算法\njvm将对象分为三个区域， 新生代（Young Generation） 、 老年代（Old Generation） 和 持久代（Permanent Generation）。\n* 持久代：\n  * 存放java类的类信息，存放静态文件，如final常量，static常量，常量池等。几乎不回收\n* 新生代：\n  * 新生代使用拷贝算法：新生代中存在一个Eden区和两个Survivor区，其中一个Survivor始终为空。 eden区gc时，存活的对象会复制到其中一个survivor区。 Survivor区gc时，会拷贝到另一个空闲的Survivor区。 当对象多次gc存活一定次数之后，会移动到老年代\n  * jvm中 eden区和Survivor区的大小为8：1\n* 老年代：\n  * 使用标记整理算法。标记需要清除对象，将存活的对象往内存的一端移动，再将需要清除要回收的对象。这样的算法可以避免内存碎片的产生\n","slug":"Java/jvm虚拟机","published":1,"updated":"2022-04-07T16:57:54.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8j003dg0jeob0v9ek5","content":"<h2 id=\"JVM架构\"><a href=\"#JVM架构\" class=\"headerlink\" title=\"JVM架构\"></a>JVM架构</h2><p>jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈</p><a id=\"more\"></a>\n<ol>\n<li><p>方法区<br>方法区被所有线程共享。存放 类信息、类的字段信息和方法信息、常量、static类变量</p>\n</li>\n<li><p>Java栈<br>Java栈线程之间不共享。<br>Java栈是由很多的栈帧(stack frame)或者说帧(frame)组成的，一个栈帧包含一个Java方法调用状态。用来存放方法的局部变量、被调用时传进来的参数、返回值 以及运算的中间结果等等。</p>\n</li>\n<li><p>Native栈<br>用来存放Native方法的调用状态</p>\n</li>\n<li><p>堆<br>用于存放对象。 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。</p>\n</li>\n<li><p>程序计数器（PC寄存器）<br>每一个线程有一个程序计数器。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。</p>\n</li>\n<li><p>类加载子系统<br>读取class文件，加载Java类到内存。</p>\n</li>\n</ol>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>类加载器负责动态加载Java类到Java虚拟机的内存空间中。</p>\n<ul>\n<li>双亲委托机制<br>“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类 路径中查找并装载目标类。这一点是从安全角度考虑的</li>\n</ul>\n<h2 id=\"GC垃圾回收机制\"><a href=\"#GC垃圾回收机制\" class=\"headerlink\" title=\"GC垃圾回收机制\"></a>GC垃圾回收机制</h2><h3 id=\"如何判断对象是否可以被回收\"><a href=\"#如何判断对象是否可以被回收\" class=\"headerlink\" title=\"如何判断对象是否可以被回收\"></a>如何判断对象是否可以被回收</h3><ul>\n<li>引用计数法</li>\n<li>根搜索算法：<ul>\n<li>从GC root出发查找引用链，无法触及到的对象可以被回收。 </li>\n<li>GC-root包括：虚拟机栈中引用的对象、类静态属性引用的对象、常量引用的对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"强引用、弱引用、软引用、虚引用\"><a href=\"#强引用、弱引用、软引用、虚引用\" class=\"headerlink\" title=\"强引用、弱引用、软引用、虚引用\"></a>强引用、弱引用、软引用、虚引用</h3><h3 id=\"GC算法\"><a href=\"#GC算法\" class=\"headerlink\" title=\"GC算法\"></a>GC算法</h3><p>jvm将对象分为三个区域， 新生代（Young Generation） 、 老年代（Old Generation） 和 持久代（Permanent Generation）。</p>\n<ul>\n<li>持久代：<ul>\n<li>存放java类的类信息，存放静态文件，如final常量，static常量，常量池等。几乎不回收</li>\n</ul>\n</li>\n<li>新生代：<ul>\n<li>新生代使用拷贝算法：新生代中存在一个Eden区和两个Survivor区，其中一个Survivor始终为空。 eden区gc时，存活的对象会复制到其中一个survivor区。 Survivor区gc时，会拷贝到另一个空闲的Survivor区。 当对象多次gc存活一定次数之后，会移动到老年代</li>\n<li>jvm中 eden区和Survivor区的大小为8：1</li>\n</ul>\n</li>\n<li>老年代：<ul>\n<li>使用标记整理算法。标记需要清除对象，将存活的对象往内存的一端移动，再将需要清除要回收的对象。这样的算法可以避免内存碎片的产生</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"JVM架构\"><a href=\"#JVM架构\" class=\"headerlink\" title=\"JVM架构\"></a>JVM架构</h2><p>jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈</p>","more":"\n<ol>\n<li><p>方法区<br>方法区被所有线程共享。存放 类信息、类的字段信息和方法信息、常量、static类变量</p>\n</li>\n<li><p>Java栈<br>Java栈线程之间不共享。<br>Java栈是由很多的栈帧(stack frame)或者说帧(frame)组成的，一个栈帧包含一个Java方法调用状态。用来存放方法的局部变量、被调用时传进来的参数、返回值 以及运算的中间结果等等。</p>\n</li>\n<li><p>Native栈<br>用来存放Native方法的调用状态</p>\n</li>\n<li><p>堆<br>用于存放对象。 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。</p>\n</li>\n<li><p>程序计数器（PC寄存器）<br>每一个线程有一个程序计数器。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。</p>\n</li>\n<li><p>类加载子系统<br>读取class文件，加载Java类到内存。</p>\n</li>\n</ol>\n<h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><p>类加载器负责动态加载Java类到Java虚拟机的内存空间中。</p>\n<ul>\n<li>双亲委托机制<br>“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类 路径中查找并装载目标类。这一点是从安全角度考虑的</li>\n</ul>\n<h2 id=\"GC垃圾回收机制\"><a href=\"#GC垃圾回收机制\" class=\"headerlink\" title=\"GC垃圾回收机制\"></a>GC垃圾回收机制</h2><h3 id=\"如何判断对象是否可以被回收\"><a href=\"#如何判断对象是否可以被回收\" class=\"headerlink\" title=\"如何判断对象是否可以被回收\"></a>如何判断对象是否可以被回收</h3><ul>\n<li>引用计数法</li>\n<li>根搜索算法：<ul>\n<li>从GC root出发查找引用链，无法触及到的对象可以被回收。 </li>\n<li>GC-root包括：虚拟机栈中引用的对象、类静态属性引用的对象、常量引用的对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"强引用、弱引用、软引用、虚引用\"><a href=\"#强引用、弱引用、软引用、虚引用\" class=\"headerlink\" title=\"强引用、弱引用、软引用、虚引用\"></a>强引用、弱引用、软引用、虚引用</h3><h3 id=\"GC算法\"><a href=\"#GC算法\" class=\"headerlink\" title=\"GC算法\"></a>GC算法</h3><p>jvm将对象分为三个区域， 新生代（Young Generation） 、 老年代（Old Generation） 和 持久代（Permanent Generation）。</p>\n<ul>\n<li>持久代：<ul>\n<li>存放java类的类信息，存放静态文件，如final常量，static常量，常量池等。几乎不回收</li>\n</ul>\n</li>\n<li>新生代：<ul>\n<li>新生代使用拷贝算法：新生代中存在一个Eden区和两个Survivor区，其中一个Survivor始终为空。 eden区gc时，存活的对象会复制到其中一个survivor区。 Survivor区gc时，会拷贝到另一个空闲的Survivor区。 当对象多次gc存活一定次数之后，会移动到老年代</li>\n<li>jvm中 eden区和Survivor区的大小为8：1</li>\n</ul>\n</li>\n<li>老年代：<ul>\n<li>使用标记整理算法。标记需要清除对象，将存活的对象往内存的一端移动，再将需要清除要回收的对象。这样的算法可以避免内存碎片的产生</li>\n</ul>\n</li>\n</ul>\n"},{"title":"redux源码","date":"2021-01-24T13:40:51.000Z","_content":"\n\nRedux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux\n\n# 被观察者 Store/State\n\n被观察者 明显是 Store 和 State 。 State 是状态的 model类 。 Store 是 State 的持有者。\n\n```dart\nclass Store<State> {\n  Reducer<State> reducer;\n\n  final StreamController<State> _changeController;\n  State _state;\n  List<NextDispatcher> _dispatchers;\n\n  Store(\n    this.reducer, {\n    State initialState,\n    List<Middleware<State>> middleware = const [],\n    bool syncStream = false,\n    bool distinct = false,\n  }) : _changeController = StreamController.broadcast(sync: syncStream) {\n    _state = initialState;\n    _dispatchers = _createDispatchers(\n      middleware,\n      _createReduceAndNotify(distinct),\n    );\n  }\n\n  NextDispatcher _createReduceAndNotify(bool distinct) {\n    return (dynamic action) {\n      final state = reducer(_state, action);\n\n      if (distinct && state == _state) return;\n\n      _state = state;\n      _changeController.add(state);\n    };\n  }\n\n  dynamic dispatch(dynamic action) {\n    return _dispatchers[0](action);\n  }\n\n  Stream<State> get onChange => _changeController.stream;\n}\n```\n\n当一个 Store 创建时，会实例化一个 _changeController ，并将 middleware 和 reducer 打包合并成 _dispatchers 集合。\n注意看 _createReduceAndNotify 方法， 当每一个 action 发送到 Store 时，会交给 reducer 处理，并将新的 state 给 add 到 _changeController 里。这样就完成了状态的更新。。\n\n是不是很简单。。。\n\n# 观察者\n\nRedux 里观察者是 StoreConnector 。\n但是得先提一下 StoreProvider ， StoreProvider 是初始化和存储 Store 的 Widget 。\n\n```dart \nclass StoreProvider<S> extends InheritedWidget {\n  final Store<S> _store;\n\n  /// Create a [StoreProvider] by passing in the required [store] and [child]\n  /// parameters.\n  const StoreProvider({\n    Key key,\n    @required Store<S> store,\n    @required Widget child,\n  })  : assert(store != null),\n        assert(child != null),\n        _store = store,\n        super(key: key, child: child);\n\n  static Store<S> of<S>(BuildContext context, {bool listen = true}) {\n    final type = _typeOf<StoreProvider<S>>();\n    final provider = (listen\n        ? context.inheritFromWidgetOfExactType(type)\n        : context\n            .ancestorInheritedElementForWidgetOfExactType(type)\n            ?.widget) as StoreProvider<S>;\n\n    if (provider == null) throw StoreProviderError(type);\n\n    return provider._store;\n  }\n\n  // Workaround to capture generics\n  static Type _typeOf<T>() => T;\n\n  @override\n  bool updateShouldNotify(StoreProvider<S> oldWidget) =>\n      _store != oldWidget._store;\n}\n```\n\nStoreProvider 也很简单，就是一个典型的 InheritedWidget 。\n\n现在来看 StoreConnector ，\n\n```dart\nclass StoreConnector<S, ViewModel> extends StatelessWidget {\n  const StoreConnector({\n    Key key,\n    @required this.builder,\n    @required this.converter,\n    this.distinct = false,\n    this.onInit,\n    this.onDispose,\n    this.rebuildOnChange = true,\n    this.ignoreChange,\n    this.onWillChange,\n    this.onDidChange,\n    this.onInitialBuild,\n  })  : assert(builder != null),\n        assert(converter != null),\n        super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return _StoreStreamListener<S, ViewModel>(\n      store: StoreProvider.of<S>(context),\n      builder: builder,\n      converter: converter,\n      distinct: distinct,\n      onInit: onInit,\n      onDispose: onDispose,\n      rebuildOnChange: rebuildOnChange,\n      ignoreChange: ignoreChange,\n      onWillChange: onWillChange,\n      onDidChange: onDidChange,\n      onInitialBuild: onInitialBuild,\n    );\n  }\n}\n```\n\n可以看出来，StoreConnector 只是一个壳，实际的工作者是 _StoreStreamListener 。 StoreConnect 唯一做的工作就是调用 `StoreProvider.of<S>(context)` 给 _StoreStreamListener 的 store 赋值。\n\n_StoreStreamListener 是一个 StatefulWidget\n\n```dart\nclass _StoreStreamListenerState<S, ViewModel>\n    extends State<_StoreStreamListener<S, ViewModel>> {\n\n  @override\n  void initState() {\n    ...\n\n    latestValue = widget.converter(widget.store);\n    _createStream();\n\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return widget.rebuildOnChange\n        ? StreamBuilder<ViewModel>(\n            stream: stream,\n            builder: (context, snapshot) => widget.builder(\n              context,\n              latestValue,\n            ),\n          )\n        : widget.builder(context, latestValue);\n  }\n\n  void _createStream() {\n    stream = widget.store.onChange\n        .where(_ignoreChange)\n        .map(_mapConverter)\n        .where(_whereDistinct)\n        .transform(StreamTransformer.fromHandlers(handleData: _handleChange));\n  }\n\n  ViewModel _mapConverter(S state) {\n    return widget.converter(widget.store);\n  }\n\n  bool _whereDistinct(ViewModel vm) {\n    if (widget.distinct) {\n      return vm != latestValue;\n    }\n\n    return true;\n  }\n\n  void _handleChange(ViewModel vm, EventSink<ViewModel> sink) {\n    ...\n    latestValue = vm;\n    ...\n    sink.add(vm);\n  }\n}\n```\n\n在 build 方法中 widget.rebuildOnChange 默认为 true 。 \nStreamBuilder 将 stream 转化为 widget 。\nstream 就是对 widget.store.onChange (Store 里的 _changeController) 的监听。\n\n需要说明的是， StoreConnector 只是在 Flutter Framework 基础上添加的额外的监听机制。\n之前自己一直有个误区： 当 StoreConnector 的外部 Widget 执行 rebuild 之后， StoreConnector 可以控制 child 不 rebuild ，只要 vm 没有发生改变。\n这显然不正确。有空可以看看 StreamBuilder 的源码。\n\n# Action 事件的执行\n\n```dart\nclass Store {\n  dynamic dispatch(dynamic action) {\n    return _dispatchers[0](action);\n  }\n}\n```\n\n。。。很简单， Store.dispath 从 _dispatchers 的第一个位置开始分发事件。。\n\n\n\n\n","source":"_posts/Flutter/redux源码.md","raw":"---\ntitle: redux源码\ndate: 2021-01-24 21:40:51\ntags: \n- Flutter\n- Redux\n---\n\n\nRedux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux\n\n# 被观察者 Store/State\n\n被观察者 明显是 Store 和 State 。 State 是状态的 model类 。 Store 是 State 的持有者。\n\n```dart\nclass Store<State> {\n  Reducer<State> reducer;\n\n  final StreamController<State> _changeController;\n  State _state;\n  List<NextDispatcher> _dispatchers;\n\n  Store(\n    this.reducer, {\n    State initialState,\n    List<Middleware<State>> middleware = const [],\n    bool syncStream = false,\n    bool distinct = false,\n  }) : _changeController = StreamController.broadcast(sync: syncStream) {\n    _state = initialState;\n    _dispatchers = _createDispatchers(\n      middleware,\n      _createReduceAndNotify(distinct),\n    );\n  }\n\n  NextDispatcher _createReduceAndNotify(bool distinct) {\n    return (dynamic action) {\n      final state = reducer(_state, action);\n\n      if (distinct && state == _state) return;\n\n      _state = state;\n      _changeController.add(state);\n    };\n  }\n\n  dynamic dispatch(dynamic action) {\n    return _dispatchers[0](action);\n  }\n\n  Stream<State> get onChange => _changeController.stream;\n}\n```\n\n当一个 Store 创建时，会实例化一个 _changeController ，并将 middleware 和 reducer 打包合并成 _dispatchers 集合。\n注意看 _createReduceAndNotify 方法， 当每一个 action 发送到 Store 时，会交给 reducer 处理，并将新的 state 给 add 到 _changeController 里。这样就完成了状态的更新。。\n\n是不是很简单。。。\n\n# 观察者\n\nRedux 里观察者是 StoreConnector 。\n但是得先提一下 StoreProvider ， StoreProvider 是初始化和存储 Store 的 Widget 。\n\n```dart \nclass StoreProvider<S> extends InheritedWidget {\n  final Store<S> _store;\n\n  /// Create a [StoreProvider] by passing in the required [store] and [child]\n  /// parameters.\n  const StoreProvider({\n    Key key,\n    @required Store<S> store,\n    @required Widget child,\n  })  : assert(store != null),\n        assert(child != null),\n        _store = store,\n        super(key: key, child: child);\n\n  static Store<S> of<S>(BuildContext context, {bool listen = true}) {\n    final type = _typeOf<StoreProvider<S>>();\n    final provider = (listen\n        ? context.inheritFromWidgetOfExactType(type)\n        : context\n            .ancestorInheritedElementForWidgetOfExactType(type)\n            ?.widget) as StoreProvider<S>;\n\n    if (provider == null) throw StoreProviderError(type);\n\n    return provider._store;\n  }\n\n  // Workaround to capture generics\n  static Type _typeOf<T>() => T;\n\n  @override\n  bool updateShouldNotify(StoreProvider<S> oldWidget) =>\n      _store != oldWidget._store;\n}\n```\n\nStoreProvider 也很简单，就是一个典型的 InheritedWidget 。\n\n现在来看 StoreConnector ，\n\n```dart\nclass StoreConnector<S, ViewModel> extends StatelessWidget {\n  const StoreConnector({\n    Key key,\n    @required this.builder,\n    @required this.converter,\n    this.distinct = false,\n    this.onInit,\n    this.onDispose,\n    this.rebuildOnChange = true,\n    this.ignoreChange,\n    this.onWillChange,\n    this.onDidChange,\n    this.onInitialBuild,\n  })  : assert(builder != null),\n        assert(converter != null),\n        super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return _StoreStreamListener<S, ViewModel>(\n      store: StoreProvider.of<S>(context),\n      builder: builder,\n      converter: converter,\n      distinct: distinct,\n      onInit: onInit,\n      onDispose: onDispose,\n      rebuildOnChange: rebuildOnChange,\n      ignoreChange: ignoreChange,\n      onWillChange: onWillChange,\n      onDidChange: onDidChange,\n      onInitialBuild: onInitialBuild,\n    );\n  }\n}\n```\n\n可以看出来，StoreConnector 只是一个壳，实际的工作者是 _StoreStreamListener 。 StoreConnect 唯一做的工作就是调用 `StoreProvider.of<S>(context)` 给 _StoreStreamListener 的 store 赋值。\n\n_StoreStreamListener 是一个 StatefulWidget\n\n```dart\nclass _StoreStreamListenerState<S, ViewModel>\n    extends State<_StoreStreamListener<S, ViewModel>> {\n\n  @override\n  void initState() {\n    ...\n\n    latestValue = widget.converter(widget.store);\n    _createStream();\n\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return widget.rebuildOnChange\n        ? StreamBuilder<ViewModel>(\n            stream: stream,\n            builder: (context, snapshot) => widget.builder(\n              context,\n              latestValue,\n            ),\n          )\n        : widget.builder(context, latestValue);\n  }\n\n  void _createStream() {\n    stream = widget.store.onChange\n        .where(_ignoreChange)\n        .map(_mapConverter)\n        .where(_whereDistinct)\n        .transform(StreamTransformer.fromHandlers(handleData: _handleChange));\n  }\n\n  ViewModel _mapConverter(S state) {\n    return widget.converter(widget.store);\n  }\n\n  bool _whereDistinct(ViewModel vm) {\n    if (widget.distinct) {\n      return vm != latestValue;\n    }\n\n    return true;\n  }\n\n  void _handleChange(ViewModel vm, EventSink<ViewModel> sink) {\n    ...\n    latestValue = vm;\n    ...\n    sink.add(vm);\n  }\n}\n```\n\n在 build 方法中 widget.rebuildOnChange 默认为 true 。 \nStreamBuilder 将 stream 转化为 widget 。\nstream 就是对 widget.store.onChange (Store 里的 _changeController) 的监听。\n\n需要说明的是， StoreConnector 只是在 Flutter Framework 基础上添加的额外的监听机制。\n之前自己一直有个误区： 当 StoreConnector 的外部 Widget 执行 rebuild 之后， StoreConnector 可以控制 child 不 rebuild ，只要 vm 没有发生改变。\n这显然不正确。有空可以看看 StreamBuilder 的源码。\n\n# Action 事件的执行\n\n```dart\nclass Store {\n  dynamic dispatch(dynamic action) {\n    return _dispatchers[0](action);\n  }\n}\n```\n\n。。。很简单， Store.dispath 从 _dispatchers 的第一个位置开始分发事件。。\n\n\n\n\n","slug":"Flutter/redux源码","published":1,"updated":"2021-10-03T01:57:41.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8k003gg0jemvoxksm4","content":"<p>Redux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux</p><a id=\"more\"></a>\n<h1 id=\"被观察者-Store-State\"><a href=\"#被观察者-Store-State\" class=\"headerlink\" title=\"被观察者 Store/State\"></a>被观察者 Store/State</h1><p>被观察者 明显是 Store 和 State 。 State 是状态的 model类 。 Store 是 State 的持有者。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Store</span>&lt;<span class=\"title\">State</span>&gt; </span>&#123;</span><br><span class=\"line\">  Reducer&lt;State&gt; reducer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> StreamController&lt;State&gt; _changeController;</span><br><span class=\"line\">  State _state;</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;NextDispatcher&gt; _dispatchers;</span><br><span class=\"line\"></span><br><span class=\"line\">  Store(</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.reducer, &#123;</span><br><span class=\"line\">    State initialState,</span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Middleware&lt;State&gt;&gt; middleware = <span class=\"keyword\">const</span> [],</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> syncStream = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> distinct = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  &#125;) : _changeController = StreamController.broadcast(<span class=\"keyword\">sync</span>: syncStream) &#123;</span><br><span class=\"line\">    _state = initialState;</span><br><span class=\"line\">    _dispatchers = _createDispatchers(</span><br><span class=\"line\">      middleware,</span><br><span class=\"line\">      _createReduceAndNotify(distinct),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  NextDispatcher _createReduceAndNotify(<span class=\"built_in\">bool</span> distinct) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">dynamic</span> action) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> state = reducer(_state, action);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (distinct &amp;&amp; state == _state) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      _state = state;</span><br><span class=\"line\">      _changeController.add(state);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">dynamic</span> dispatch(<span class=\"keyword\">dynamic</span> action) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _dispatchers[<span class=\"number\">0</span>](action);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Stream&lt;State&gt; <span class=\"keyword\">get</span> onChange =&gt; _changeController.stream;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当一个 Store 创建时，会实例化一个 _changeController ，并将 middleware 和 reducer 打包合并成 _dispatchers 集合。<br>注意看 _createReduceAndNotify 方法， 当每一个 action 发送到 Store 时，会交给 reducer 处理，并将新的 state 给 add 到 _changeController 里。这样就完成了状态的更新。。</p>\n<p>是不是很简单。。。</p>\n<h1 id=\"观察者\"><a href=\"#观察者\" class=\"headerlink\" title=\"观察者\"></a>观察者</h1><p>Redux 里观察者是 StoreConnector 。<br>但是得先提一下 StoreProvider ， StoreProvider 是初始化和存储 Store 的 Widget 。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoreProvider</span>&lt;<span class=\"title\">S</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">InheritedWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Store&lt;S&gt; _store;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// Create a [StoreProvider] by passing in the required [store] and [child]</span></span><br><span class=\"line\">  <span class=\"comment\">/// parameters.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> StoreProvider(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> Store&lt;S&gt; store,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> Widget child,</span><br><span class=\"line\">  &#125;)  : <span class=\"keyword\">assert</span>(store != <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        <span class=\"keyword\">assert</span>(child != <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        _store = store,</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(key: key, child: child);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> Store&lt;S&gt; of&lt;S&gt;(BuildContext context, &#123;<span class=\"built_in\">bool</span> listen = <span class=\"keyword\">true</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> type = _typeOf&lt;StoreProvider&lt;S&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> provider = (listen</span><br><span class=\"line\">        ? context.inheritFromWidgetOfExactType(type)</span><br><span class=\"line\">        : context</span><br><span class=\"line\">            .ancestorInheritedElementForWidgetOfExactType(type)</span><br><span class=\"line\">            ?.widget) <span class=\"keyword\">as</span> StoreProvider&lt;S&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> StoreProviderError(type);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> provider._store;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Workaround to capture generics</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> updateShouldNotify(StoreProvider&lt;S&gt; oldWidget) =&gt;</span><br><span class=\"line\">      _store != oldWidget._store;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>StoreProvider 也很简单，就是一个典型的 InheritedWidget 。</p>\n<p>现在来看 StoreConnector ，</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoreConnector</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">ViewModel</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> StoreConnector(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.builder,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.converter,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.distinct = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onInit,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onDispose,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.rebuildOnChange = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.ignoreChange,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onWillChange,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onDidChange,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onInitialBuild,</span><br><span class=\"line\">  &#125;)  : <span class=\"keyword\">assert</span>(builder != <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        <span class=\"keyword\">assert</span>(converter != <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _StoreStreamListener&lt;S, ViewModel&gt;(</span><br><span class=\"line\">      store: StoreProvider.of&lt;S&gt;(context),</span><br><span class=\"line\">      builder: builder,</span><br><span class=\"line\">      converter: converter,</span><br><span class=\"line\">      distinct: distinct,</span><br><span class=\"line\">      onInit: onInit,</span><br><span class=\"line\">      onDispose: onDispose,</span><br><span class=\"line\">      rebuildOnChange: rebuildOnChange,</span><br><span class=\"line\">      ignoreChange: ignoreChange,</span><br><span class=\"line\">      onWillChange: onWillChange,</span><br><span class=\"line\">      onDidChange: onDidChange,</span><br><span class=\"line\">      onInitialBuild: onInitialBuild,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出来，StoreConnector 只是一个壳，实际的工作者是 _StoreStreamListener 。 StoreConnect 唯一做的工作就是调用 <code>StoreProvider.of&lt;S&gt;(context)</code> 给 _StoreStreamListener 的 store 赋值。</p>\n<p>_StoreStreamListener 是一个 StatefulWidget</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_StoreStreamListenerState</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">ViewModel</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">_StoreStreamListener</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">ViewModel</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    latestValue = widget.converter(widget.store);</span><br><span class=\"line\">    _createStream();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widget.rebuildOnChange</span><br><span class=\"line\">        ? StreamBuilder&lt;ViewModel&gt;(</span><br><span class=\"line\">            stream: stream,</span><br><span class=\"line\">            builder: (context, snapshot) =&gt; widget.builder(</span><br><span class=\"line\">              context,</span><br><span class=\"line\">              latestValue,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          )</span><br><span class=\"line\">        : widget.builder(context, latestValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> _createStream() &#123;</span><br><span class=\"line\">    stream = widget.store.onChange</span><br><span class=\"line\">        .where(_ignoreChange)</span><br><span class=\"line\">        .map(_mapConverter)</span><br><span class=\"line\">        .where(_whereDistinct)</span><br><span class=\"line\">        .transform(StreamTransformer.fromHandlers(handleData: _handleChange));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ViewModel _mapConverter(S state) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widget.converter(widget.store);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> _whereDistinct(ViewModel vm) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (widget.distinct) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> vm != latestValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> _handleChange(ViewModel vm, EventSink&lt;ViewModel&gt; sink) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    latestValue = vm;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    sink.add(vm);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 build 方法中 widget.rebuildOnChange 默认为 true 。<br>StreamBuilder 将 stream 转化为 widget 。<br>stream 就是对 widget.store.onChange (Store 里的 _changeController) 的监听。</p>\n<p>需要说明的是， StoreConnector 只是在 Flutter Framework 基础上添加的额外的监听机制。<br>之前自己一直有个误区： 当 StoreConnector 的外部 Widget 执行 rebuild 之后， StoreConnector 可以控制 child 不 rebuild ，只要 vm 没有发生改变。<br>这显然不正确。有空可以看看 StreamBuilder 的源码。</p>\n<h1 id=\"Action-事件的执行\"><a href=\"#Action-事件的执行\" class=\"headerlink\" title=\"Action 事件的执行\"></a>Action 事件的执行</h1><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Store</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">dynamic</span> dispatch(<span class=\"keyword\">dynamic</span> action) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _dispatchers[<span class=\"number\">0</span>](action);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>。。。很简单， Store.dispath 从 _dispatchers 的第一个位置开始分发事件。。</p>\n","site":{"data":{}},"excerpt":"<p>Redux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux</p>","more":"\n<h1 id=\"被观察者-Store-State\"><a href=\"#被观察者-Store-State\" class=\"headerlink\" title=\"被观察者 Store/State\"></a>被观察者 Store/State</h1><p>被观察者 明显是 Store 和 State 。 State 是状态的 model类 。 Store 是 State 的持有者。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Store</span>&lt;<span class=\"title\">State</span>&gt; </span>&#123;</span><br><span class=\"line\">  Reducer&lt;State&gt; reducer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> StreamController&lt;State&gt; _changeController;</span><br><span class=\"line\">  State _state;</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;NextDispatcher&gt; _dispatchers;</span><br><span class=\"line\"></span><br><span class=\"line\">  Store(</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.reducer, &#123;</span><br><span class=\"line\">    State initialState,</span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Middleware&lt;State&gt;&gt; middleware = <span class=\"keyword\">const</span> [],</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> syncStream = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> distinct = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  &#125;) : _changeController = StreamController.broadcast(<span class=\"keyword\">sync</span>: syncStream) &#123;</span><br><span class=\"line\">    _state = initialState;</span><br><span class=\"line\">    _dispatchers = _createDispatchers(</span><br><span class=\"line\">      middleware,</span><br><span class=\"line\">      _createReduceAndNotify(distinct),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  NextDispatcher _createReduceAndNotify(<span class=\"built_in\">bool</span> distinct) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">dynamic</span> action) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> state = reducer(_state, action);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (distinct &amp;&amp; state == _state) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      _state = state;</span><br><span class=\"line\">      _changeController.add(state);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">dynamic</span> dispatch(<span class=\"keyword\">dynamic</span> action) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _dispatchers[<span class=\"number\">0</span>](action);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Stream&lt;State&gt; <span class=\"keyword\">get</span> onChange =&gt; _changeController.stream;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当一个 Store 创建时，会实例化一个 _changeController ，并将 middleware 和 reducer 打包合并成 _dispatchers 集合。<br>注意看 _createReduceAndNotify 方法， 当每一个 action 发送到 Store 时，会交给 reducer 处理，并将新的 state 给 add 到 _changeController 里。这样就完成了状态的更新。。</p>\n<p>是不是很简单。。。</p>\n<h1 id=\"观察者\"><a href=\"#观察者\" class=\"headerlink\" title=\"观察者\"></a>观察者</h1><p>Redux 里观察者是 StoreConnector 。<br>但是得先提一下 StoreProvider ， StoreProvider 是初始化和存储 Store 的 Widget 。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoreProvider</span>&lt;<span class=\"title\">S</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">InheritedWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Store&lt;S&gt; _store;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/// Create a [StoreProvider] by passing in the required [store] and [child]</span></span><br><span class=\"line\">  <span class=\"comment\">/// parameters.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> StoreProvider(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> Store&lt;S&gt; store,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> Widget child,</span><br><span class=\"line\">  &#125;)  : <span class=\"keyword\">assert</span>(store != <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        <span class=\"keyword\">assert</span>(child != <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        _store = store,</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(key: key, child: child);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> Store&lt;S&gt; of&lt;S&gt;(BuildContext context, &#123;<span class=\"built_in\">bool</span> listen = <span class=\"keyword\">true</span>&#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> type = _typeOf&lt;StoreProvider&lt;S&gt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> provider = (listen</span><br><span class=\"line\">        ? context.inheritFromWidgetOfExactType(type)</span><br><span class=\"line\">        : context</span><br><span class=\"line\">            .ancestorInheritedElementForWidgetOfExactType(type)</span><br><span class=\"line\">            ?.widget) <span class=\"keyword\">as</span> StoreProvider&lt;S&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (provider == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> StoreProviderError(type);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> provider._store;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Workaround to capture generics</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> updateShouldNotify(StoreProvider&lt;S&gt; oldWidget) =&gt;</span><br><span class=\"line\">      _store != oldWidget._store;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>StoreProvider 也很简单，就是一个典型的 InheritedWidget 。</p>\n<p>现在来看 StoreConnector ，</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StoreConnector</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">ViewModel</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> StoreConnector(&#123;</span><br><span class=\"line\">    Key key,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.builder,</span><br><span class=\"line\">    <span class=\"meta\">@required</span> <span class=\"keyword\">this</span>.converter,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.distinct = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onInit,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onDispose,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.rebuildOnChange = <span class=\"keyword\">true</span>,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.ignoreChange,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onWillChange,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onDidChange,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onInitialBuild,</span><br><span class=\"line\">  &#125;)  : <span class=\"keyword\">assert</span>(builder != <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        <span class=\"keyword\">assert</span>(converter != <span class=\"keyword\">null</span>),</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _StoreStreamListener&lt;S, ViewModel&gt;(</span><br><span class=\"line\">      store: StoreProvider.of&lt;S&gt;(context),</span><br><span class=\"line\">      builder: builder,</span><br><span class=\"line\">      converter: converter,</span><br><span class=\"line\">      distinct: distinct,</span><br><span class=\"line\">      onInit: onInit,</span><br><span class=\"line\">      onDispose: onDispose,</span><br><span class=\"line\">      rebuildOnChange: rebuildOnChange,</span><br><span class=\"line\">      ignoreChange: ignoreChange,</span><br><span class=\"line\">      onWillChange: onWillChange,</span><br><span class=\"line\">      onDidChange: onDidChange,</span><br><span class=\"line\">      onInitialBuild: onInitialBuild,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出来，StoreConnector 只是一个壳，实际的工作者是 _StoreStreamListener 。 StoreConnect 唯一做的工作就是调用 <code>StoreProvider.of&lt;S&gt;(context)</code> 给 _StoreStreamListener 的 store 赋值。</p>\n<p>_StoreStreamListener 是一个 StatefulWidget</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_StoreStreamListenerState</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">ViewModel</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">_StoreStreamListener</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">ViewModel</span>&gt;&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    latestValue = widget.converter(widget.store);</span><br><span class=\"line\">    _createStream();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widget.rebuildOnChange</span><br><span class=\"line\">        ? StreamBuilder&lt;ViewModel&gt;(</span><br><span class=\"line\">            stream: stream,</span><br><span class=\"line\">            builder: (context, snapshot) =&gt; widget.builder(</span><br><span class=\"line\">              context,</span><br><span class=\"line\">              latestValue,</span><br><span class=\"line\">            ),</span><br><span class=\"line\">          )</span><br><span class=\"line\">        : widget.builder(context, latestValue);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> _createStream() &#123;</span><br><span class=\"line\">    stream = widget.store.onChange</span><br><span class=\"line\">        .where(_ignoreChange)</span><br><span class=\"line\">        .map(_mapConverter)</span><br><span class=\"line\">        .where(_whereDistinct)</span><br><span class=\"line\">        .transform(StreamTransformer.fromHandlers(handleData: _handleChange));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ViewModel _mapConverter(S state) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widget.converter(widget.store);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> _whereDistinct(ViewModel vm) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (widget.distinct) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> vm != latestValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> _handleChange(ViewModel vm, EventSink&lt;ViewModel&gt; sink) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    latestValue = vm;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    sink.add(vm);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 build 方法中 widget.rebuildOnChange 默认为 true 。<br>StreamBuilder 将 stream 转化为 widget 。<br>stream 就是对 widget.store.onChange (Store 里的 _changeController) 的监听。</p>\n<p>需要说明的是， StoreConnector 只是在 Flutter Framework 基础上添加的额外的监听机制。<br>之前自己一直有个误区： 当 StoreConnector 的外部 Widget 执行 rebuild 之后， StoreConnector 可以控制 child 不 rebuild ，只要 vm 没有发生改变。<br>这显然不正确。有空可以看看 StreamBuilder 的源码。</p>\n<h1 id=\"Action-事件的执行\"><a href=\"#Action-事件的执行\" class=\"headerlink\" title=\"Action 事件的执行\"></a>Action 事件的执行</h1><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Store</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">dynamic</span> dispatch(<span class=\"keyword\">dynamic</span> action) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _dispatchers[<span class=\"number\">0</span>](action);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>。。。很简单， Store.dispath 从 _dispatchers 的第一个位置开始分发事件。。</p>\n"},{"title":"HashMap","date":"2022-04-04T06:23:14.000Z","_content":"\n## 1. 基本数据结构\n\nNode<K, V> 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。\n如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小\n如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树\n\n## 2. 加入的元素如何确定在数组中的 index\n\n```java\nstatic int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的\n     return h & (length-1);  //第三步 取模运算\n}\n```\n\n要把新加入的元素均匀分布到数组中，我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的. 但是jdk通过h & (table.length -1)来得到该对象的保存位，这样运算会加快。\n\n## 3. 如何扩容\n\n将数组的容量扩大为原来的两倍，原数组长度为oldCap，下标j的元素会被分散到 数组j 和 j+oldCap 的位置。 \n\n```java\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                    // 数组下表位置如果是 红黑树，逻辑和下面的链表差不多\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                    // 数组下表位置如果是 链表\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            // 因为 oldCap 始终为2的倍数。 (e.hash & oldCap) 只会有0或1两个值，由此决定是位置 j 还是 j+oldCap\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n\n```\n\n## 4. 扩容的时机\n\n```java\nif (++size > threshold)\n    resize();\n```\n当size大于一个阈值的时候，就会开始扩容。 `threshold = length * loadFactor` 是数组长度*负载因子。 负载因子默认是0.75 ，注意这个length是table数组的长度而不是HashMap的整体size（为了保证获取元素的时间复杂度接近1）。\n\nloadFactor 是时间复杂度和空间复杂度的权衡。 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。\n\n## 5. HashMap是线程不安全的。HashTable是线程安全的。\nHashTable的线程安全很粗暴，将所有的map操作加一个synchronized修饰。\n\n\n参考：\nhttps://tech.meituan.com/2016/06/24/java-hashmap.html\n\n\n\n\n\n","source":"_posts/Java/HashMap.md","raw":"---\ntitle: HashMap\ndate: 2022-04-04 14:23:14\ntags:\n---\n\n## 1. 基本数据结构\n\nNode<K, V> 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。\n如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小\n如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树\n\n## 2. 加入的元素如何确定在数组中的 index\n\n```java\nstatic int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的\n     return h & (length-1);  //第三步 取模运算\n}\n```\n\n要把新加入的元素均匀分布到数组中，我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的. 但是jdk通过h & (table.length -1)来得到该对象的保存位，这样运算会加快。\n\n## 3. 如何扩容\n\n将数组的容量扩大为原来的两倍，原数组长度为oldCap，下标j的元素会被分散到 数组j 和 j+oldCap 的位置。 \n\n```java\n        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null)\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode)\n                    // 数组下表位置如果是 红黑树，逻辑和下面的链表差不多\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // preserve order\n                    // 数组下表位置如果是 链表\n                        Node<K,V> loHead = null, loTail = null;\n                        Node<K,V> hiHead = null, hiTail = null;\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            // 因为 oldCap 始终为2的倍数。 (e.hash & oldCap) 只会有0或1两个值，由此决定是位置 j 还是 j+oldCap\n                            if ((e.hash & oldCap) == 0) {\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n\n```\n\n## 4. 扩容的时机\n\n```java\nif (++size > threshold)\n    resize();\n```\n当size大于一个阈值的时候，就会开始扩容。 `threshold = length * loadFactor` 是数组长度*负载因子。 负载因子默认是0.75 ，注意这个length是table数组的长度而不是HashMap的整体size（为了保证获取元素的时间复杂度接近1）。\n\nloadFactor 是时间复杂度和空间复杂度的权衡。 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。\n\n## 5. HashMap是线程不安全的。HashTable是线程安全的。\nHashTable的线程安全很粗暴，将所有的map操作加一个synchronized修饰。\n\n\n参考：\nhttps://tech.meituan.com/2016/06/24/java-hashmap.html\n\n\n\n\n\n","slug":"Java/HashMap","published":1,"updated":"2022-04-04T08:39:37.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8l003jg0je4ehjb8bu","content":"<h2 id=\"1-基本数据结构\"><a href=\"#1-基本数据结构\" class=\"headerlink\" title=\"1. 基本数据结构\"></a>1. 基本数据结构</h2><p>Node&lt;K, V&gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。<br>如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小<br>如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树</p><a id=\"more\"></a>\n<h2 id=\"2-加入的元素如何确定在数组中的-index\"><a href=\"#2-加入的元素如何确定在数组中的-index\" class=\"headerlink\" title=\"2. 加入的元素如何确定在数组中的 index\"></a>2. 加入的元素如何确定在数组中的 index</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  <span class=\"comment\">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  <span class=\"comment\">//第三步 取模运算</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要把新加入的元素均匀分布到数组中，我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的. 但是jdk通过h &amp; (table.length -1)来得到该对象的保存位，这样运算会加快。</p>\n<h2 id=\"3-如何扩容\"><a href=\"#3-如何扩容\" class=\"headerlink\" title=\"3. 如何扩容\"></a>3. 如何扩容</h2><p>将数组的容量扩大为原来的两倍，原数组长度为oldCap，下标j的元素会被分散到 数组j 和 j+oldCap 的位置。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">table = newTab;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 数组下表位置如果是 红黑树，逻辑和下面的链表差不多</span></span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">            <span class=\"comment\">// 数组下表位置如果是 链表</span></span><br><span class=\"line\">                Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                Node&lt;K,V&gt; next;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    next = e.next;</span><br><span class=\"line\">                    <span class=\"comment\">// 因为 oldCap 始终为2的倍数。 (e.hash &amp; oldCap) 只会有0或1两个值，由此决定是位置 j 还是 j+oldCap</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            loHead = e;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            loTail.next = e;</span><br><span class=\"line\">                        loTail = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            hiHead = e;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            hiTail.next = e;</span><br><span class=\"line\">                        hiTail = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    newTab[j] = loHead;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-扩容的时机\"><a href=\"#4-扩容的时机\" class=\"headerlink\" title=\"4. 扩容的时机\"></a>4. 扩容的时机</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">    resize();</span><br></pre></td></tr></table></figure>\n<p>当size大于一个阈值的时候，就会开始扩容。 <code>threshold = length * loadFactor</code> 是数组长度*负载因子。 负载因子默认是0.75 ，注意这个length是table数组的长度而不是HashMap的整体size（为了保证获取元素的时间复杂度接近1）。</p>\n<p>loadFactor 是时间复杂度和空间复杂度的权衡。 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>\n<h2 id=\"5-HashMap是线程不安全的。HashTable是线程安全的。\"><a href=\"#5-HashMap是线程不安全的。HashTable是线程安全的。\" class=\"headerlink\" title=\"5. HashMap是线程不安全的。HashTable是线程安全的。\"></a>5. HashMap是线程不安全的。HashTable是线程安全的。</h2><p>HashTable的线程安全很粗暴，将所有的map操作加一个synchronized修饰。</p>\n<p>参考：<br><a href=\"https://tech.meituan.com/2016/06/24/java-hashmap.html\" target=\"_blank\" rel=\"noopener\">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-基本数据结构\"><a href=\"#1-基本数据结构\" class=\"headerlink\" title=\"1. 基本数据结构\"></a>1. 基本数据结构</h2><p>Node&lt;K, V&gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。<br>如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小<br>如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树</p>","more":"\n<h2 id=\"2-加入的元素如何确定在数组中的-index\"><a href=\"#2-加入的元素如何确定在数组中的-index\" class=\"headerlink\" title=\"2. 加入的元素如何确定在数组中的 index\"></a>2. 加入的元素如何确定在数组中的 index</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexFor</span><span class=\"params\">(<span class=\"keyword\">int</span> h, <span class=\"keyword\">int</span> length)</span> </span>&#123;  <span class=\"comment\">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> h &amp; (length-<span class=\"number\">1</span>);  <span class=\"comment\">//第三步 取模运算</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要把新加入的元素均匀分布到数组中，我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的. 但是jdk通过h &amp; (table.length -1)来得到该对象的保存位，这样运算会加快。</p>\n<h2 id=\"3-如何扩容\"><a href=\"#3-如何扩容\" class=\"headerlink\" title=\"3. 如何扩容\"></a>3. 如何扩容</h2><p>将数组的容量扩大为原来的两倍，原数组长度为oldCap，下标j的元素会被分散到 数组j 和 j+oldCap 的位置。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">table = newTab;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt; e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 数组下表位置如果是 红黑树，逻辑和下面的链表差不多</span></span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">            <span class=\"comment\">// 数组下表位置如果是 链表</span></span><br><span class=\"line\">                Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                Node&lt;K,V&gt; next;</span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    next = e.next;</span><br><span class=\"line\">                    <span class=\"comment\">// 因为 oldCap 始终为2的倍数。 (e.hash &amp; oldCap) 只会有0或1两个值，由此决定是位置 j 还是 j+oldCap</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            loHead = e;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            loTail.next = e;</span><br><span class=\"line\">                        loTail = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                            hiHead = e;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span></span><br><span class=\"line\">                            hiTail.next = e;</span><br><span class=\"line\">                        hiTail = e;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    newTab[j] = loHead;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-扩容的时机\"><a href=\"#4-扩容的时机\" class=\"headerlink\" title=\"4. 扩容的时机\"></a>4. 扩容的时机</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">    resize();</span><br></pre></td></tr></table></figure>\n<p>当size大于一个阈值的时候，就会开始扩容。 <code>threshold = length * loadFactor</code> 是数组长度*负载因子。 负载因子默认是0.75 ，注意这个length是table数组的长度而不是HashMap的整体size（为了保证获取元素的时间复杂度接近1）。</p>\n<p>loadFactor 是时间复杂度和空间复杂度的权衡。 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>\n<h2 id=\"5-HashMap是线程不安全的。HashTable是线程安全的。\"><a href=\"#5-HashMap是线程不安全的。HashTable是线程安全的。\" class=\"headerlink\" title=\"5. HashMap是线程不安全的。HashTable是线程安全的。\"></a>5. HashMap是线程不安全的。HashTable是线程安全的。</h2><p>HashTable的线程安全很粗暴，将所有的map操作加一个synchronized修饰。</p>\n<p>参考：<br><a href=\"https://tech.meituan.com/2016/06/24/java-hashmap.html\" target=\"_blank\" rel=\"noopener\">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p>\n"},{"title":"apt常用命令","date":"2019-05-02T11:49:35.000Z","categroies":["Linux"],"_content":"\n# apt常用命令\n参考：\n[apt命令安装指定版本](https://www.centos.bz/2017/07/ubuntu-apt-cache-version-list-install-specify-version/)\n## 更新\n> sudo apt-get update     //更新源\nsudo apt-get upgrade    //更新已安装的包\nsudo apt-get dist-upgrade       //升级系统\nsudo apt-get dselect-upgrade    //使用 dselect 升级\n\n## 查询\n> apt-cache search package      \n> //搜索包　　\napt-cache show package          \n//获取包的相关信息，如说明、大小、版本等　\napt-cache depends package       \n//了解使用依赖\napt-cache rdepends package      \n//是查看该包被哪些包依赖\n\n```shell\napt-cache madison <package name>  //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。\n\napt-cache policy <<package name>>  /*将列出所有来源的版本。信息会比上面详细一点*/\n\napt-show-versions -a <<package name>> //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u <>来查询是否有升级版本。\n```\n\n## 安装\n> sudo apt-get install package      \n> //安装包　　\nsudo apt-get install package - - reinstall      \n//重新安装包　　\nsudo apt-get -f install         \n//修复安装   (\"-f = ——fix-missing\")\n\n## 删除\nsudo apt-get remove package \n删除包　　\nsudo apt-get remove package - - purge \n删除包，包括删除配置文件等\nsudo apt-get clean && sudo apt-get autoclean \n清理无用的包\nsudo apt-get check \n检查是否有损坏的依赖\n\n## 其他\n> sudo apt-get build-dep package \n> 安装相关的编译环境\napt-get source package \n下载该包的源代码\n\n\n\n","source":"_posts/Linux/apt常用命令.md","raw":"---\ntitle: apt常用命令\ndate: 2019-05-02 19:49:35\ntags: \n- Linux\ncategroies:\n- Linux\n---\n\n# apt常用命令\n参考：\n[apt命令安装指定版本](https://www.centos.bz/2017/07/ubuntu-apt-cache-version-list-install-specify-version/)\n## 更新\n> sudo apt-get update     //更新源\nsudo apt-get upgrade    //更新已安装的包\nsudo apt-get dist-upgrade       //升级系统\nsudo apt-get dselect-upgrade    //使用 dselect 升级\n\n## 查询\n> apt-cache search package      \n> //搜索包　　\napt-cache show package          \n//获取包的相关信息，如说明、大小、版本等　\napt-cache depends package       \n//了解使用依赖\napt-cache rdepends package      \n//是查看该包被哪些包依赖\n\n```shell\napt-cache madison <package name>  //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。\n\napt-cache policy <<package name>>  /*将列出所有来源的版本。信息会比上面详细一点*/\n\napt-show-versions -a <<package name>> //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u <>来查询是否有升级版本。\n```\n\n## 安装\n> sudo apt-get install package      \n> //安装包　　\nsudo apt-get install package - - reinstall      \n//重新安装包　　\nsudo apt-get -f install         \n//修复安装   (\"-f = ——fix-missing\")\n\n## 删除\nsudo apt-get remove package \n删除包　　\nsudo apt-get remove package - - purge \n删除包，包括删除配置文件等\nsudo apt-get clean && sudo apt-get autoclean \n清理无用的包\nsudo apt-get check \n检查是否有损坏的依赖\n\n## 其他\n> sudo apt-get build-dep package \n> 安装相关的编译环境\napt-get source package \n下载该包的源代码\n\n\n\n","slug":"Linux/apt常用命令","published":1,"updated":"2021-10-03T01:57:41.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8m003ng0jecy3eqy1v","content":"<h1 id=\"apt常用命令\"><a href=\"#apt常用命令\" class=\"headerlink\" title=\"apt常用命令\"></a>apt常用命令</h1><p>参考：<br><a href=\"https://www.centos.bz/2017/07/ubuntu-apt-cache-version-list-install-specify-version/\" target=\"_blank\" rel=\"noopener\">apt命令安装指定版本</a></p><a id=\"more\"></a>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><blockquote>\n<p>sudo apt-get update     //更新源<br>sudo apt-get upgrade    //更新已安装的包<br>sudo apt-get dist-upgrade       //升级系统<br>sudo apt-get dselect-upgrade    //使用 dselect 升级</p>\n</blockquote>\n<h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><blockquote>\n<p>apt-cache search package<br>//搜索包　　<br>apt-cache show package<br>//获取包的相关信息，如说明、大小、版本等　<br>apt-cache depends package<br>//了解使用依赖<br>apt-cache rdepends package<br>//是查看该包被哪些包依赖</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-cache madison &lt;package name&gt;  //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。</span><br><span class=\"line\"></span><br><span class=\"line\">apt-cache policy &lt;&lt;package name&gt;&gt;  /*将列出所有来源的版本。信息会比上面详细一点*/</span><br><span class=\"line\"></span><br><span class=\"line\">apt-show-versions -a &lt;&lt;package name&gt;&gt; //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u &lt;&gt;来查询是否有升级版本。</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>sudo apt-get install package<br>//安装包　　<br>sudo apt-get install package - - reinstall<br>//重新安装包　　<br>sudo apt-get -f install<br>//修复安装   (“-f = ——fix-missing”)</p>\n</blockquote>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>sudo apt-get remove package<br>删除包　　<br>sudo apt-get remove package - - purge<br>删除包，包括删除配置文件等<br>sudo apt-get clean &amp;&amp; sudo apt-get autoclean<br>清理无用的包<br>sudo apt-get check<br>检查是否有损坏的依赖</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><blockquote>\n<p>sudo apt-get build-dep package<br>安装相关的编译环境<br>apt-get source package<br>下载该包的源代码</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"apt常用命令\"><a href=\"#apt常用命令\" class=\"headerlink\" title=\"apt常用命令\"></a>apt常用命令</h1><p>参考：<br><a href=\"https://www.centos.bz/2017/07/ubuntu-apt-cache-version-list-install-specify-version/\" target=\"_blank\" rel=\"noopener\">apt命令安装指定版本</a></p>","more":"\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><blockquote>\n<p>sudo apt-get update     //更新源<br>sudo apt-get upgrade    //更新已安装的包<br>sudo apt-get dist-upgrade       //升级系统<br>sudo apt-get dselect-upgrade    //使用 dselect 升级</p>\n</blockquote>\n<h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><blockquote>\n<p>apt-cache search package<br>//搜索包　　<br>apt-cache show package<br>//获取包的相关信息，如说明、大小、版本等　<br>apt-cache depends package<br>//了解使用依赖<br>apt-cache rdepends package<br>//是查看该包被哪些包依赖</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-cache madison &lt;package name&gt;  //列出所有来源的版本...madison是一个apt-cache子命令，可以通过man apt-cache查询更多用法。</span><br><span class=\"line\"></span><br><span class=\"line\">apt-cache policy &lt;&lt;package name&gt;&gt;  /*将列出所有来源的版本。信息会比上面详细一点*/</span><br><span class=\"line\"></span><br><span class=\"line\">apt-show-versions -a &lt;&lt;package name&gt;&gt; //列举出所有版本，且能查看是否已经安装。还可以通过apt-show-versions -u &lt;&gt;来查询是否有升级版本。</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><blockquote>\n<p>sudo apt-get install package<br>//安装包　　<br>sudo apt-get install package - - reinstall<br>//重新安装包　　<br>sudo apt-get -f install<br>//修复安装   (“-f = ——fix-missing”)</p>\n</blockquote>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><p>sudo apt-get remove package<br>删除包　　<br>sudo apt-get remove package - - purge<br>删除包，包括删除配置文件等<br>sudo apt-get clean &amp;&amp; sudo apt-get autoclean<br>清理无用的包<br>sudo apt-get check<br>检查是否有损坏的依赖</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><blockquote>\n<p>sudo apt-get build-dep package<br>安装相关的编译环境<br>apt-get source package<br>下载该包的源代码</p>\n</blockquote>\n"},{"title":"flutter ui源码 初步","date":"2020-08-14T12:30:42.000Z","_content":"\n## Widget, Element, RanderObject 三者之间的关系\n\nWidget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。\n\n## Widget\n\nWidget类和Element类一一对应。Element是通过Widget生成的\nWidget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。\n\n**Widget.createElement()**\n\n创建Element对象\n\n**Widget.canUpdate(..)**\n```dart\nstatic bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n}\n```\n\n主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；\n通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。\n\n### State\n一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.\n\n**createState()**\n\n用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，**所以，本质上就是一个StatefulElement对应一个State实例。**\n\n**widget和context**\n- widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但**State实例只会在第一次插入到树中时被创建**，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 \n\n- context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext\n\n**State如何被Widget复用**\n只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(...)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。\n\n## Element\n\n最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。\n\n下面从Element的 **挂载、更新、卸载**过程来描述Element\n\n### mount\n\n**根Element的mount**\n\n```\n- main() \n    - runApp(..)\n    - WidgetsFlutterBinding.attachRootWidget(app)\n        - RenderObjectToWidgetAdapter<RenderBox>.attachToRenderTree(buildOwner, renderViewElement);\n            - createElement()\n            - BuildOwner.buildScope(element, () {\n                element.mount(null, null);\n            })\n```\n\n以上是根Element的mount过程，其中rederViewElement是根Elemet\n\n** Element的mount过程\n\n首先来看一下常用的StatelessElement，StatefulElement的继承关系\n\n```\nElement -> ComponentElement -> StatelessElement\n                            -> StatefulElement\n```\n\n```\n- mount()\n    - Element.updateInheritance()\n    - ComponentElement.firstBuild()\n        - Element.rebuild()\n        - ComponentElement.performRebuild()\n            - built = build()\n                -Widget.build()\n            - Element.updateChild(child, built, _)\n```\n\nElement.updateChild方法非常重要\n\n```dart\n@protected\nElement updateChild(Element child, Widget newWidget, dynamic newSlot) {\n    if (newWidget == null) {\n      if (child != null)\n        deactivateChild(child);\n      return null;\n    }\n    if (child != null) {\n      if (child.widget == newWidget) {\n        return child;\n      }\n      if (Widget.canUpdate(child.widget, newWidget)) {\n        child.update(newWidget);\n        return child;\n      }\n      deactivateChild(child);\n    }\n    return inflateWidget(newWidget, newSlot);\n}\n\nstatic bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n}\n```\n\n根据上面的代码，总结各种case\n\n* child != null && newWidget == null :\n    newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element\n* child == null && newWidget != null : \n    第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)\n* child != null && newWidget != null :\n    更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建\n* child == null && newWidget == null :\n    do nothing\n\n在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)\n\n```dart\n@protected\nElement inflateWidget(Widget newWidget, dynamic newSlot) {\n    ...\n\n    final Element newChild = newWidget.createElement();\n    newChild.mount(this, newSlot);\n    return newChild;\n}\n```\n\n```dart\nabstract class StatefulWidget extends Widget {\n  const StatefulWidget({ Key key }) : super(key: key);\n\n  @override\n  StatefulElement createElement() => StatefulElement(this);\n\n  State createState();\n}\n\nclass StatefulElement extends ComponentElement {\n\n  StatefulElement(StatefulWidget widget)\n      : _state = widget.createState(),\n        super(widget) {\n    _state._element = this;\n    _state._widget = widget;\n  }\n\n  @override\n  Widget build() => state.build(this);\n}\n```\nStatefulWidget，State，StatefulElement的调用关系： \nWidget.createElement() -> Element.build() -> State.build()\n\n### 更新Element\n\n```dart\nWidget.setState\n    - Element.markNeedsBuild()\n        - Element._dirty = true\n        - BuildOwner.scheduleBuildFor(this)\n            - BuildOwner._dirtyElements.add(element)\n```\n\n当调用statState之后，会将element标脏，并加入到_dirtyElements列表中\n\n```dart\n- WidgetsBinding.drawFrame()\n    - BuildOwner.buildScope(renderViewElement)\n        - BuildOwner._dirtyElements[index].rebuild()\n```\n\n每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。\n可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的\n\n### 卸载Element\n\n在Element的updateChild方法中，在 `child != null && newWidget == null` 时，会调用deactivateChild()\n\n```dart\n  @protected\n  void deactivateChild(Element child) {\n    child._parent = null;\n    child.detachRenderObject();\n    owner._inactiveElements.add(child); // this eventually calls child.deactivate()\n  }\n```\ndeactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。\n\n还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount\n\n```dart\nvoid finalizeTree() {\n    Timeline.startSync('Finalize tree', arguments: timelineWhitelistArguments);\n    try {\n      lockState(() {\n        _inactiveElements._unmountAll(); // this unregisters the GlobalKeys\n      });\n    }\n    ...\n}\n\nvoid _unmountAll() {\n    _locked = true;\n    final List<Element> elements = _elements.toList()..sort(Element._sort);\n    _elements.clear();\n    try {\n      elements.reversed.forEach(_unmount);\n    } finally {\n      _locked = false;\n    }\n}\n\nvoid _unmount(Element element) {\n    element.visitChildren((Element child) {\n      _unmount(child);\n    });\n    element.unmount();\n}\n```\n\n## RenderObject\n\n### RenderObjectElement\n\nRenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。**不是所有的Element都有对应的RenderObject**\n\nRenderObjectElement有三个常用的子类：\n\n* LeafRenderObjectElement：Leaf render objects, with no children\n* SingleChildRenderObjectElement：A single child\n* MultiChildRenderObjectElement：A linked list of children.\n\nRenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。\n\n**mmount、update、unmount**\n\n```dart\n  @override\n  void mount(Element parent, dynamic newSlot) {\n    super.mount(parent, newSlot);\n    _renderObject = widget.createRenderObject(this);\n    attachRenderObject(newSlot);\n    _dirty = false;\n  }\n\n  @override\n  void attachRenderObject(dynamic newSlot) {\n    _slot = newSlot;\n    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();\n    _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);\n    final ParentDataElement<RenderObjectWidget> parentDataElement = _findAncestorParentDataElement();\n    if (parentDataElement != null)\n      _updateParentData(parentDataElement.widget);\n  }\n\n  @override\n  void update(covariant RenderObjectWidget newWidget) {\n    super.update(newWidget);\n    widget.updateRenderObject(this, renderObject);\n    _dirty = false;\n  }\n```\n\n### RenderObject的更新\n\n我们从render树的insert过程类分析RenderObject的更新\n从RenderObjectElement.insertChildRenderObject开始\n\n```dart\n  @override\n  void insertChildRenderObject(RenderObject child, Element slot) {\n    final ContainerRenderObjectMixin<RenderObject, ContainerParentDataMixin<RenderObject>> renderObject = this.renderObject;\n    renderObject.insert(child, after: slot?.renderObject);\n  }\n```\n\n这里调用了ContainerRenderObjectMixin的insert方法，\n\n```dart\n  void insert(ChildType child, { ChildType after }) {\n    adoptChild(child);\n    _insertIntoChildList(child, after: after);\n  }\n\n  @override\n  void adoptChild(RenderObject child) {\n    setupParentData(child);\n    markNeedsLayout();\n    markNeedsCompositingBitsUpdate();\n    markNeedsSemanticsUpdate();\n    super.adoptChild(child);\n  }\n\n  void markNeedsLayout() {\n    if (_relayoutBoundary != this) {\n      markParentNeedsLayout();\n    } else {\n      _needsLayout = true;\n      if (owner != null) {\n        owner._nodesNeedingLayout.add(this);\n        owner.requestVisualUpdate();\n      }\n    }\n  }\n\n  @protected\n  void markParentNeedsLayout() {\n    _needsLayout = true;\n    final RenderObject parent = this.parent;\n    if (!_doingThisLayoutWithCallback) {\n      parent.markNeedsLayout();\n    } else {\n      assert(parent._debugDoingThisLayout);\n    }\n  }\n```\n\n和element的build流程不同，RenderObject的标脏会向上标脏。\n找到 _relayoutBoundary 节点，触发`owner._nodesNeedingLayout.add( this )`与`owner.requestVisualUpdate()` 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner\n\nPiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。\n(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)\n来看一下PiplelineOwner.requestVisualUpdate\n\n```dart\n  void requestVisualUpdate() {\n    if (onNeedVisualUpdate != null)\n      onNeedVisualUpdate();\n  }\n```\nonNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里\n\n```dart\n  void initInstances() {\n    super.initInstances();\n    _instance = this;\n    _pipelineOwner = PipelineOwner(\n      onNeedVisualUpdate: ensureVisualUpdate,\n      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,\n      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,\n    );\n    window\n      ..onMetricsChanged = handleMetricsChanged\n      ..onTextScaleFactorChanged = handleTextScaleFactorChanged\n      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged\n      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged\n      ..onSemanticsAction = _handleSemanticsAction;\n    initRenderView();\n    _handleSemanticsEnabledChanged();\n    assert(renderView != null);\n    addPersistentFrameCallback(_handlePersistentFrameCallback);\n    initMouseTracker();\n  }\n\n  void _handlePersistentFrameCallback(Duration timeStamp) {\n    drawFrame();\n  }\n```\n\nensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制\n\n\n### layout\n\n**RendererBinding.drawFrame**\n\n```dart\n  @protected\n  void drawFrame() {\n    ...\n    pipelineOwner.flushLayout();\n    pipelineOwner.flushCompositingBits();\n    pipelineOwner.flushPaint();\n    renderView.compositeFrame(); // this sends the bits to the GPU\n    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.\n  }\n```\n\n**pipelineOwner.flushLayout()**\n```dart\n  void flushLayout() {\n    try {\n      while (_nodesNeedingLayout.isNotEmpty) {\n        final List<RenderObject> dirtyNodes = _nodesNeedingLayout;\n        _nodesNeedingLayout = <RenderObject>[];\n        for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => a.depth - b.depth)) {\n          if (node._needsLayout && node.owner == this)\n            node._layoutWithoutResize();\n        }\n      }\n    } finally {\n      ...\n    }\n  }\n```\n\n***RendererObject._layoutWithoutResize**\n\n```dart\n  void _layoutWithoutResize() {\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, stack) {\n      _debugReportException('performLayout', e, stack);\n    }\n    _needsLayout = false;\n    markNeedsPaint();\n  }\n```\n\n这里调用performLayout()进行layout，并标记需要paint\n\n### paint\n\n之前说到过，layout过程中会对paint进行标脏\n\n**markNeedsPaint()**\n```dart\n  void markNeedsPaint() {\n    if (_needsPaint)\n      return;\n    _needsPaint = true;\n    if (isRepaintBoundary) {\n      if (owner != null) {\n        owner._nodesNeedingPaint.add(this);\n        owner.requestVisualUpdate();\n      }\n    } else if (parent is RenderObject) {\n      final RenderObject parent = this.parent;\n      parent.markNeedsPaint();\n    } else {\n      // If we're the root of the render tree (probably a RenderView),\n      // then we have to paint ourselves, since nobody else can paint\n      // us. We don't add ourselves to _nodesNeedingPaint in this\n      // case, because the root is always told to paint regardless.\n      if (owner != null)\n        owner.requestVisualUpdate();\n    }\n  }\n```\n\n和layout的标脏过程类似，一直向上标脏，直到 isRepaintBoundary 为true。**注意，这里只有 RepaintBoundary 才加入到了 PiplineOwner 的_nodesNeedingPaint中，即最终是以 RepaintBoundary 单位进行刷新的**\n需要说明的是，我们可以 RepaintBoundary 是一个widget，我们可以手动添加，来终止paint的向上标脏过程，来达到局部重绘，提升性能。 LayoutBoundary 则是只是一个标记位，framework层帮我们判断的，我们不需要手动处理。\n\n**pipelineOwner.flushLayout()**\n\n```dart\n  void flushPaint() {\n    try {\n      final List<RenderObject> dirtyNodes = _nodesNeedingPaint;\n      _nodesNeedingPaint = <RenderObject>[];\n      // Sort the dirty nodes in reverse order (deepest first).\n      for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => b.depth - a.depth)) {\n        if (node._needsPaint && node.owner == this) {\n          if (node._layer.attached) {\n            PaintingContext.repaintCompositedChild(node);\n          } else {\n            node._skippedPaintingOnLayer();\n          }\n        }\n      }\n    } finally {\n      ...\n    }\n  }\n```\n\n与layout不同的是这里的 sort 规则是相反的，最深的节点先重绘。并且，多了判断 `node._layer.attached`, 如果为true，重绘，并且重绘逻辑交给了PaintContext；如果为false，则执行 `node._skippedPaintingOnLayer();`\n\n**node._skippedPaintingOnLayer()**\n\n```dart\n  void _skippedPaintingOnLayer() {\n    AbstractNode ancestor = parent;\n    while (ancestor is RenderObject) {\n      final RenderObject node = ancestor;\n      if (node.isRepaintBoundary) {\n        if (node._layer == null)\n          break; // looks like the subtree here has never been painted. let it handle itself.\n        if (node._layer.attached)\n          break; // it's the one that detached us, so it's the one that will decide to repaint us.\n        node._needsPaint = true;\n      }\n      ancestor = node.parent;\n    }\n  }\n```\n\n我的理解是，该节点的 layer 被 detached 了，需要对该节点及其父节点行重新标脏，保证该节点的 layer 被重新 attach 之后能够重绘。 \n\n**PaintingContext.repaintCompositedChild(node);**\n\n```dart\n  static void repaintCompositedChild(RenderObject child, { bool debugAlsoPaintedParent = false }) {\n    _repaintCompositedChild(\n      child,\n      debugAlsoPaintedParent: debugAlsoPaintedParent,\n    );\n  }\n\n  static void _repaintCompositedChild(\n    RenderObject child, {\n    bool debugAlsoPaintedParent = false,\n    PaintingContext childContext,\n  }) {\n    OffsetLayer childLayer = child._layer;\n    if (childLayer == null) {\n      child._layer = childLayer = OffsetLayer();\n    } else {\n      childLayer.removeAllChildren();\n    }\n    childContext ??= PaintingContext(child._layer, child.paintBounds);\n    child._paintWithContext(childContext, Offset.zero);\n\n    childContext.stopRecordingIfNeeded();\n  }\n```\n\n又是 PaintContext 和 layer。。。先跳过这两个，最终重绘的逻辑在 `child._paintWithContext(childContext, Offset.zero);`中\n\n**child._paintWithContext(childContext, Offset.zero);**\n\n```dart\n  void _paintWithContext(PaintingContext context, Offset offset) {\n    // 一堆注释解释了为啥在paint的时候 _needsLayout 还可能为true 。。。\n    // 英文注释没咋看懂\n    if (_needsLayout)\n      return;\n    RenderObject debugLastActivePaint;\n    _needsPaint = false;\n    try {\n      // 最终的重绘交给具体的 RenderObject 子类\n      paint(context, offset);\n    } catch (e, stack) {\n      _debugReportException('paint', e, stack);\n    }\n  }\n```\n\n","source":"_posts/Flutter/flutter-ui源码-初步.md","raw":"---\ntitle: flutter ui源码 初步\ndate: 2020-08-14 20:30:42\ntags:\n- Flutter\n---\n\n## Widget, Element, RanderObject 三者之间的关系\n\nWidget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。\n\n## Widget\n\nWidget类和Element类一一对应。Element是通过Widget生成的\nWidget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。\n\n**Widget.createElement()**\n\n创建Element对象\n\n**Widget.canUpdate(..)**\n```dart\nstatic bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n}\n```\n\n主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；\n通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。\n\n### State\n一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.\n\n**createState()**\n\n用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，**所以，本质上就是一个StatefulElement对应一个State实例。**\n\n**widget和context**\n- widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但**State实例只会在第一次插入到树中时被创建**，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 \n\n- context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext\n\n**State如何被Widget复用**\n只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(...)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。\n\n## Element\n\n最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。\n\n下面从Element的 **挂载、更新、卸载**过程来描述Element\n\n### mount\n\n**根Element的mount**\n\n```\n- main() \n    - runApp(..)\n    - WidgetsFlutterBinding.attachRootWidget(app)\n        - RenderObjectToWidgetAdapter<RenderBox>.attachToRenderTree(buildOwner, renderViewElement);\n            - createElement()\n            - BuildOwner.buildScope(element, () {\n                element.mount(null, null);\n            })\n```\n\n以上是根Element的mount过程，其中rederViewElement是根Elemet\n\n** Element的mount过程\n\n首先来看一下常用的StatelessElement，StatefulElement的继承关系\n\n```\nElement -> ComponentElement -> StatelessElement\n                            -> StatefulElement\n```\n\n```\n- mount()\n    - Element.updateInheritance()\n    - ComponentElement.firstBuild()\n        - Element.rebuild()\n        - ComponentElement.performRebuild()\n            - built = build()\n                -Widget.build()\n            - Element.updateChild(child, built, _)\n```\n\nElement.updateChild方法非常重要\n\n```dart\n@protected\nElement updateChild(Element child, Widget newWidget, dynamic newSlot) {\n    if (newWidget == null) {\n      if (child != null)\n        deactivateChild(child);\n      return null;\n    }\n    if (child != null) {\n      if (child.widget == newWidget) {\n        return child;\n      }\n      if (Widget.canUpdate(child.widget, newWidget)) {\n        child.update(newWidget);\n        return child;\n      }\n      deactivateChild(child);\n    }\n    return inflateWidget(newWidget, newSlot);\n}\n\nstatic bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n}\n```\n\n根据上面的代码，总结各种case\n\n* child != null && newWidget == null :\n    newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element\n* child == null && newWidget != null : \n    第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)\n* child != null && newWidget != null :\n    更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建\n* child == null && newWidget == null :\n    do nothing\n\n在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)\n\n```dart\n@protected\nElement inflateWidget(Widget newWidget, dynamic newSlot) {\n    ...\n\n    final Element newChild = newWidget.createElement();\n    newChild.mount(this, newSlot);\n    return newChild;\n}\n```\n\n```dart\nabstract class StatefulWidget extends Widget {\n  const StatefulWidget({ Key key }) : super(key: key);\n\n  @override\n  StatefulElement createElement() => StatefulElement(this);\n\n  State createState();\n}\n\nclass StatefulElement extends ComponentElement {\n\n  StatefulElement(StatefulWidget widget)\n      : _state = widget.createState(),\n        super(widget) {\n    _state._element = this;\n    _state._widget = widget;\n  }\n\n  @override\n  Widget build() => state.build(this);\n}\n```\nStatefulWidget，State，StatefulElement的调用关系： \nWidget.createElement() -> Element.build() -> State.build()\n\n### 更新Element\n\n```dart\nWidget.setState\n    - Element.markNeedsBuild()\n        - Element._dirty = true\n        - BuildOwner.scheduleBuildFor(this)\n            - BuildOwner._dirtyElements.add(element)\n```\n\n当调用statState之后，会将element标脏，并加入到_dirtyElements列表中\n\n```dart\n- WidgetsBinding.drawFrame()\n    - BuildOwner.buildScope(renderViewElement)\n        - BuildOwner._dirtyElements[index].rebuild()\n```\n\n每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。\n可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的\n\n### 卸载Element\n\n在Element的updateChild方法中，在 `child != null && newWidget == null` 时，会调用deactivateChild()\n\n```dart\n  @protected\n  void deactivateChild(Element child) {\n    child._parent = null;\n    child.detachRenderObject();\n    owner._inactiveElements.add(child); // this eventually calls child.deactivate()\n  }\n```\ndeactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。\n\n还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount\n\n```dart\nvoid finalizeTree() {\n    Timeline.startSync('Finalize tree', arguments: timelineWhitelistArguments);\n    try {\n      lockState(() {\n        _inactiveElements._unmountAll(); // this unregisters the GlobalKeys\n      });\n    }\n    ...\n}\n\nvoid _unmountAll() {\n    _locked = true;\n    final List<Element> elements = _elements.toList()..sort(Element._sort);\n    _elements.clear();\n    try {\n      elements.reversed.forEach(_unmount);\n    } finally {\n      _locked = false;\n    }\n}\n\nvoid _unmount(Element element) {\n    element.visitChildren((Element child) {\n      _unmount(child);\n    });\n    element.unmount();\n}\n```\n\n## RenderObject\n\n### RenderObjectElement\n\nRenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。**不是所有的Element都有对应的RenderObject**\n\nRenderObjectElement有三个常用的子类：\n\n* LeafRenderObjectElement：Leaf render objects, with no children\n* SingleChildRenderObjectElement：A single child\n* MultiChildRenderObjectElement：A linked list of children.\n\nRenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。\n\n**mmount、update、unmount**\n\n```dart\n  @override\n  void mount(Element parent, dynamic newSlot) {\n    super.mount(parent, newSlot);\n    _renderObject = widget.createRenderObject(this);\n    attachRenderObject(newSlot);\n    _dirty = false;\n  }\n\n  @override\n  void attachRenderObject(dynamic newSlot) {\n    _slot = newSlot;\n    _ancestorRenderObjectElement = _findAncestorRenderObjectElement();\n    _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);\n    final ParentDataElement<RenderObjectWidget> parentDataElement = _findAncestorParentDataElement();\n    if (parentDataElement != null)\n      _updateParentData(parentDataElement.widget);\n  }\n\n  @override\n  void update(covariant RenderObjectWidget newWidget) {\n    super.update(newWidget);\n    widget.updateRenderObject(this, renderObject);\n    _dirty = false;\n  }\n```\n\n### RenderObject的更新\n\n我们从render树的insert过程类分析RenderObject的更新\n从RenderObjectElement.insertChildRenderObject开始\n\n```dart\n  @override\n  void insertChildRenderObject(RenderObject child, Element slot) {\n    final ContainerRenderObjectMixin<RenderObject, ContainerParentDataMixin<RenderObject>> renderObject = this.renderObject;\n    renderObject.insert(child, after: slot?.renderObject);\n  }\n```\n\n这里调用了ContainerRenderObjectMixin的insert方法，\n\n```dart\n  void insert(ChildType child, { ChildType after }) {\n    adoptChild(child);\n    _insertIntoChildList(child, after: after);\n  }\n\n  @override\n  void adoptChild(RenderObject child) {\n    setupParentData(child);\n    markNeedsLayout();\n    markNeedsCompositingBitsUpdate();\n    markNeedsSemanticsUpdate();\n    super.adoptChild(child);\n  }\n\n  void markNeedsLayout() {\n    if (_relayoutBoundary != this) {\n      markParentNeedsLayout();\n    } else {\n      _needsLayout = true;\n      if (owner != null) {\n        owner._nodesNeedingLayout.add(this);\n        owner.requestVisualUpdate();\n      }\n    }\n  }\n\n  @protected\n  void markParentNeedsLayout() {\n    _needsLayout = true;\n    final RenderObject parent = this.parent;\n    if (!_doingThisLayoutWithCallback) {\n      parent.markNeedsLayout();\n    } else {\n      assert(parent._debugDoingThisLayout);\n    }\n  }\n```\n\n和element的build流程不同，RenderObject的标脏会向上标脏。\n找到 _relayoutBoundary 节点，触发`owner._nodesNeedingLayout.add( this )`与`owner.requestVisualUpdate()` 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner\n\nPiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。\n(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)\n来看一下PiplelineOwner.requestVisualUpdate\n\n```dart\n  void requestVisualUpdate() {\n    if (onNeedVisualUpdate != null)\n      onNeedVisualUpdate();\n  }\n```\nonNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里\n\n```dart\n  void initInstances() {\n    super.initInstances();\n    _instance = this;\n    _pipelineOwner = PipelineOwner(\n      onNeedVisualUpdate: ensureVisualUpdate,\n      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,\n      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,\n    );\n    window\n      ..onMetricsChanged = handleMetricsChanged\n      ..onTextScaleFactorChanged = handleTextScaleFactorChanged\n      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged\n      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged\n      ..onSemanticsAction = _handleSemanticsAction;\n    initRenderView();\n    _handleSemanticsEnabledChanged();\n    assert(renderView != null);\n    addPersistentFrameCallback(_handlePersistentFrameCallback);\n    initMouseTracker();\n  }\n\n  void _handlePersistentFrameCallback(Duration timeStamp) {\n    drawFrame();\n  }\n```\n\nensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制\n\n\n### layout\n\n**RendererBinding.drawFrame**\n\n```dart\n  @protected\n  void drawFrame() {\n    ...\n    pipelineOwner.flushLayout();\n    pipelineOwner.flushCompositingBits();\n    pipelineOwner.flushPaint();\n    renderView.compositeFrame(); // this sends the bits to the GPU\n    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.\n  }\n```\n\n**pipelineOwner.flushLayout()**\n```dart\n  void flushLayout() {\n    try {\n      while (_nodesNeedingLayout.isNotEmpty) {\n        final List<RenderObject> dirtyNodes = _nodesNeedingLayout;\n        _nodesNeedingLayout = <RenderObject>[];\n        for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => a.depth - b.depth)) {\n          if (node._needsLayout && node.owner == this)\n            node._layoutWithoutResize();\n        }\n      }\n    } finally {\n      ...\n    }\n  }\n```\n\n***RendererObject._layoutWithoutResize**\n\n```dart\n  void _layoutWithoutResize() {\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, stack) {\n      _debugReportException('performLayout', e, stack);\n    }\n    _needsLayout = false;\n    markNeedsPaint();\n  }\n```\n\n这里调用performLayout()进行layout，并标记需要paint\n\n### paint\n\n之前说到过，layout过程中会对paint进行标脏\n\n**markNeedsPaint()**\n```dart\n  void markNeedsPaint() {\n    if (_needsPaint)\n      return;\n    _needsPaint = true;\n    if (isRepaintBoundary) {\n      if (owner != null) {\n        owner._nodesNeedingPaint.add(this);\n        owner.requestVisualUpdate();\n      }\n    } else if (parent is RenderObject) {\n      final RenderObject parent = this.parent;\n      parent.markNeedsPaint();\n    } else {\n      // If we're the root of the render tree (probably a RenderView),\n      // then we have to paint ourselves, since nobody else can paint\n      // us. We don't add ourselves to _nodesNeedingPaint in this\n      // case, because the root is always told to paint regardless.\n      if (owner != null)\n        owner.requestVisualUpdate();\n    }\n  }\n```\n\n和layout的标脏过程类似，一直向上标脏，直到 isRepaintBoundary 为true。**注意，这里只有 RepaintBoundary 才加入到了 PiplineOwner 的_nodesNeedingPaint中，即最终是以 RepaintBoundary 单位进行刷新的**\n需要说明的是，我们可以 RepaintBoundary 是一个widget，我们可以手动添加，来终止paint的向上标脏过程，来达到局部重绘，提升性能。 LayoutBoundary 则是只是一个标记位，framework层帮我们判断的，我们不需要手动处理。\n\n**pipelineOwner.flushLayout()**\n\n```dart\n  void flushPaint() {\n    try {\n      final List<RenderObject> dirtyNodes = _nodesNeedingPaint;\n      _nodesNeedingPaint = <RenderObject>[];\n      // Sort the dirty nodes in reverse order (deepest first).\n      for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => b.depth - a.depth)) {\n        if (node._needsPaint && node.owner == this) {\n          if (node._layer.attached) {\n            PaintingContext.repaintCompositedChild(node);\n          } else {\n            node._skippedPaintingOnLayer();\n          }\n        }\n      }\n    } finally {\n      ...\n    }\n  }\n```\n\n与layout不同的是这里的 sort 规则是相反的，最深的节点先重绘。并且，多了判断 `node._layer.attached`, 如果为true，重绘，并且重绘逻辑交给了PaintContext；如果为false，则执行 `node._skippedPaintingOnLayer();`\n\n**node._skippedPaintingOnLayer()**\n\n```dart\n  void _skippedPaintingOnLayer() {\n    AbstractNode ancestor = parent;\n    while (ancestor is RenderObject) {\n      final RenderObject node = ancestor;\n      if (node.isRepaintBoundary) {\n        if (node._layer == null)\n          break; // looks like the subtree here has never been painted. let it handle itself.\n        if (node._layer.attached)\n          break; // it's the one that detached us, so it's the one that will decide to repaint us.\n        node._needsPaint = true;\n      }\n      ancestor = node.parent;\n    }\n  }\n```\n\n我的理解是，该节点的 layer 被 detached 了，需要对该节点及其父节点行重新标脏，保证该节点的 layer 被重新 attach 之后能够重绘。 \n\n**PaintingContext.repaintCompositedChild(node);**\n\n```dart\n  static void repaintCompositedChild(RenderObject child, { bool debugAlsoPaintedParent = false }) {\n    _repaintCompositedChild(\n      child,\n      debugAlsoPaintedParent: debugAlsoPaintedParent,\n    );\n  }\n\n  static void _repaintCompositedChild(\n    RenderObject child, {\n    bool debugAlsoPaintedParent = false,\n    PaintingContext childContext,\n  }) {\n    OffsetLayer childLayer = child._layer;\n    if (childLayer == null) {\n      child._layer = childLayer = OffsetLayer();\n    } else {\n      childLayer.removeAllChildren();\n    }\n    childContext ??= PaintingContext(child._layer, child.paintBounds);\n    child._paintWithContext(childContext, Offset.zero);\n\n    childContext.stopRecordingIfNeeded();\n  }\n```\n\n又是 PaintContext 和 layer。。。先跳过这两个，最终重绘的逻辑在 `child._paintWithContext(childContext, Offset.zero);`中\n\n**child._paintWithContext(childContext, Offset.zero);**\n\n```dart\n  void _paintWithContext(PaintingContext context, Offset offset) {\n    // 一堆注释解释了为啥在paint的时候 _needsLayout 还可能为true 。。。\n    // 英文注释没咋看懂\n    if (_needsLayout)\n      return;\n    RenderObject debugLastActivePaint;\n    _needsPaint = false;\n    try {\n      // 最终的重绘交给具体的 RenderObject 子类\n      paint(context, offset);\n    } catch (e, stack) {\n      _debugReportException('paint', e, stack);\n    }\n  }\n```\n\n","slug":"Flutter/flutter-ui源码-初步","published":1,"updated":"2021-10-03T01:57:41.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8m003og0jeb72uwsxo","content":"<h2 id=\"Widget-Element-RanderObject-三者之间的关系\"><a href=\"#Widget-Element-RanderObject-三者之间的关系\" class=\"headerlink\" title=\"Widget, Element, RanderObject 三者之间的关系\"></a>Widget, Element, RanderObject 三者之间的关系</h2><a id=\"more\"></a><p>Widget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。</p>\n<h2 id=\"Widget\"><a href=\"#Widget\" class=\"headerlink\" title=\"Widget\"></a>Widget</h2><p>Widget类和Element类一一对应。Element是通过Widget生成的<br>Widget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。</p>\n<p><strong>Widget.createElement()</strong></p>\n<p>创建Element对象</p>\n<p><strong>Widget.canUpdate(..)</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；<br>通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.</p>\n<p><strong>createState()</strong></p>\n<p>用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，<strong>所以，本质上就是一个StatefulElement对应一个State实例。</strong></p>\n<p><strong>widget和context</strong></p>\n<ul>\n<li><p>widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但<strong>State实例只会在第一次插入到树中时被创建</strong>，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 </p>\n</li>\n<li><p>context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext</p>\n</li>\n</ul>\n<p><strong>State如何被Widget复用</strong><br>只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(…)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。</p>\n<h2 id=\"Element\"><a href=\"#Element\" class=\"headerlink\" title=\"Element\"></a>Element</h2><p>最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。</p>\n<p>下面从Element的 <strong>挂载、更新、卸载</strong>过程来描述Element</p>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><p><strong>根Element的mount</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- main() </span><br><span class=\"line\">    - runApp(..)</span><br><span class=\"line\">    - WidgetsFlutterBinding.attachRootWidget(app)</span><br><span class=\"line\">        - RenderObjectToWidgetAdapter&lt;RenderBox&gt;.attachToRenderTree(buildOwner, renderViewElement);</span><br><span class=\"line\">            - createElement()</span><br><span class=\"line\">            - BuildOwner.buildScope(element, () &#123;</span><br><span class=\"line\">                element.mount(null, null);</span><br><span class=\"line\">            &#125;)</span><br></pre></td></tr></table></figure>\n<p>以上是根Element的mount过程，其中rederViewElement是根Elemet</p>\n<p>** Element的mount过程</p>\n<p>首先来看一下常用的StatelessElement，StatefulElement的继承关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element -&gt; ComponentElement -&gt; StatelessElement</span><br><span class=\"line\">                            -&gt; StatefulElement</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- mount()</span><br><span class=\"line\">    - Element.updateInheritance()</span><br><span class=\"line\">    - ComponentElement.firstBuild()</span><br><span class=\"line\">        - Element.rebuild()</span><br><span class=\"line\">        - ComponentElement.performRebuild()</span><br><span class=\"line\">            - built = build()</span><br><span class=\"line\">                -Widget.build()</span><br><span class=\"line\">            - Element.updateChild(child, built, _)</span><br></pre></td></tr></table></figure>\n<p>Element.updateChild方法非常重要</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> updateChild(<span class=\"built_in\">Element</span> child, Widget newWidget, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newWidget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        deactivateChild(child);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (child.widget == newWidget) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class=\"line\">        child.update(newWidget);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      deactivateChild(child);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inflateWidget(newWidget, newSlot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，总结各种case</p>\n<ul>\n<li>child != null &amp;&amp; newWidget == null :<br>  newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element</li>\n<li>child == null &amp;&amp; newWidget != null :<br>  第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)</li>\n<li>child != null &amp;&amp; newWidget != null :<br>  更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建</li>\n<li>child == null &amp;&amp; newWidget == null :<br>  do nothing</li>\n</ul>\n<p>在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> inflateWidget(Widget newWidget, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">Element</span> newChild = newWidget.createElement();</span><br><span class=\"line\">    newChild.mount(<span class=\"keyword\">this</span>, newSlot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newChild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulWidget</span> <span class=\"keyword\">extends</span> <span class=\"title\">Widget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> StatefulWidget(&#123; Key key &#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  StatefulElement createElement() =&gt; StatefulElement(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  State createState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComponentElement</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  StatefulElement(StatefulWidget widget)</span><br><span class=\"line\">      : _state = widget.createState(),</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(widget) &#123;</span><br><span class=\"line\">    _state._element = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    _state._widget = widget;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build() =&gt; state.build(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>StatefulWidget，State，StatefulElement的调用关系：<br>Widget.createElement() -&gt; Element.build() -&gt; State.build()</p>\n<h3 id=\"更新Element\"><a href=\"#更新Element\" class=\"headerlink\" title=\"更新Element\"></a>更新Element</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget.setState</span><br><span class=\"line\">    - <span class=\"built_in\">Element</span>.markNeedsBuild()</span><br><span class=\"line\">        - <span class=\"built_in\">Element</span>._dirty = <span class=\"keyword\">true</span></span><br><span class=\"line\">        - BuildOwner.scheduleBuildFor(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            - BuildOwner._dirtyElements.add(element)</span><br></pre></td></tr></table></figure>\n<p>当调用statState之后，会将element标脏，并加入到_dirtyElements列表中</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- WidgetsBinding.drawFrame()</span><br><span class=\"line\">    - BuildOwner.buildScope(renderViewElement)</span><br><span class=\"line\">        - BuildOwner._dirtyElements[index].rebuild()</span><br></pre></td></tr></table></figure>\n<p>每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。<br>可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的</p>\n<h3 id=\"卸载Element\"><a href=\"#卸载Element\" class=\"headerlink\" title=\"卸载Element\"></a>卸载Element</h3><p>在Element的updateChild方法中，在 <code>child != null &amp;&amp; newWidget == null</code> 时，会调用deactivateChild()</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> deactivateChild(<span class=\"built_in\">Element</span> child) &#123;</span><br><span class=\"line\">  child._parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  child.detachRenderObject();</span><br><span class=\"line\">  owner._inactiveElements.add(child); <span class=\"comment\">// this eventually calls child.deactivate()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>deactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。</p>\n<p>还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> finalizeTree() &#123;</span><br><span class=\"line\">    Timeline.startSync(<span class=\"string\">'Finalize tree'</span>, arguments: timelineWhitelistArguments);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      lockState(() &#123;</span><br><span class=\"line\">        _inactiveElements._unmountAll(); <span class=\"comment\">// this unregisters the GlobalKeys</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _unmountAll() &#123;</span><br><span class=\"line\">    _locked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">Element</span>&gt; elements = _elements.toList()..sort(<span class=\"built_in\">Element</span>._sort);</span><br><span class=\"line\">    _elements.clear();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      elements.reversed.forEach(_unmount);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      _locked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _unmount(<span class=\"built_in\">Element</span> element) &#123;</span><br><span class=\"line\">    element.visitChildren((<span class=\"built_in\">Element</span> child) &#123;</span><br><span class=\"line\">      _unmount(child);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    element.unmount();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RenderObject\"><a href=\"#RenderObject\" class=\"headerlink\" title=\"RenderObject\"></a>RenderObject</h2><h3 id=\"RenderObjectElement\"><a href=\"#RenderObjectElement\" class=\"headerlink\" title=\"RenderObjectElement\"></a>RenderObjectElement</h3><p>RenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。<strong>不是所有的Element都有对应的RenderObject</strong></p>\n<p>RenderObjectElement有三个常用的子类：</p>\n<ul>\n<li>LeafRenderObjectElement：Leaf render objects, with no children</li>\n<li>SingleChildRenderObjectElement：A single child</li>\n<li>MultiChildRenderObjectElement：A linked list of children.</li>\n</ul>\n<p>RenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。</p>\n<p><strong>mmount、update、unmount</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> mount(<span class=\"built_in\">Element</span> parent, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.mount(parent, newSlot);</span><br><span class=\"line\">  _renderObject = widget.createRenderObject(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  attachRenderObject(newSlot);</span><br><span class=\"line\">  _dirty = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> attachRenderObject(<span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">  _slot = newSlot;</span><br><span class=\"line\">  _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class=\"line\">  _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parentDataElement != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    _updateParentData(parentDataElement.widget);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> update(covariant RenderObjectWidget newWidget) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.update(newWidget);</span><br><span class=\"line\">  widget.updateRenderObject(<span class=\"keyword\">this</span>, renderObject);</span><br><span class=\"line\">  _dirty = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RenderObject的更新\"><a href=\"#RenderObject的更新\" class=\"headerlink\" title=\"RenderObject的更新\"></a>RenderObject的更新</h3><p>我们从render树的insert过程类分析RenderObject的更新<br>从RenderObjectElement.insertChildRenderObject开始</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> insertChildRenderObject(RenderObject child, <span class=\"built_in\">Element</span> slot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt; renderObject = <span class=\"keyword\">this</span>.renderObject;</span><br><span class=\"line\">  renderObject.insert(child, after: slot?.renderObject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用了ContainerRenderObjectMixin的insert方法，</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> insert(ChildType child, &#123; ChildType after &#125;) &#123;</span><br><span class=\"line\">  adoptChild(child);</span><br><span class=\"line\">  _insertIntoChildList(child, after: after);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> adoptChild(RenderObject child) &#123;</span><br><span class=\"line\">  setupParentData(child);</span><br><span class=\"line\">  markNeedsLayout();</span><br><span class=\"line\">  markNeedsCompositingBitsUpdate();</span><br><span class=\"line\">  markNeedsSemanticsUpdate();</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.adoptChild(child);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> markNeedsLayout() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_relayoutBoundary != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    markParentNeedsLayout();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    _needsLayout = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      owner._nodesNeedingLayout.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      owner.requestVisualUpdate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> markParentNeedsLayout() &#123;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> RenderObject parent = <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_doingThisLayoutWithCallback) &#123;</span><br><span class=\"line\">    parent.markNeedsLayout();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(parent._debugDoingThisLayout);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和element的build流程不同，RenderObject的标脏会向上标脏。<br>找到 _relayoutBoundary 节点，触发<code>owner._nodesNeedingLayout.add( this )</code>与<code>owner.requestVisualUpdate()</code> 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner</p>\n<p>PiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。<br>(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)<br>来看一下PiplelineOwner.requestVisualUpdate</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> requestVisualUpdate() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (onNeedVisualUpdate != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    onNeedVisualUpdate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>onNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> initInstances() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.initInstances();</span><br><span class=\"line\">  _instance = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  _pipelineOwner = PipelineOwner(</span><br><span class=\"line\">    onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class=\"line\">    onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class=\"line\">    onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"built_in\">window</span></span><br><span class=\"line\">    ..onMetricsChanged = handleMetricsChanged</span><br><span class=\"line\">    ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class=\"line\">    ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class=\"line\">    ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class=\"line\">    ..onSemanticsAction = _handleSemanticsAction;</span><br><span class=\"line\">  initRenderView();</span><br><span class=\"line\">  _handleSemanticsEnabledChanged();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(renderView != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class=\"line\">  initMouseTracker();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _handlePersistentFrameCallback(<span class=\"built_in\">Duration</span> timeStamp) &#123;</span><br><span class=\"line\">  drawFrame();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制</p>\n<h3 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h3><p><strong>RendererBinding.drawFrame</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> drawFrame() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  pipelineOwner.flushLayout();</span><br><span class=\"line\">  pipelineOwner.flushCompositingBits();</span><br><span class=\"line\">  pipelineOwner.flushPaint();</span><br><span class=\"line\">  renderView.compositeFrame(); <span class=\"comment\">// this sends the bits to the GPU</span></span><br><span class=\"line\">  pipelineOwner.flushSemantics(); <span class=\"comment\">// this also sends the semantics to the OS.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>pipelineOwner.flushLayout()</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> flushLayout() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class=\"line\">      _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (RenderObject node <span class=\"keyword\">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node._needsLayout &amp;&amp; node.owner == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">          node._layoutWithoutResize();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>*RendererObject._layoutWithoutResize</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _layoutWithoutResize() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    performLayout();</span><br><span class=\"line\">    markNeedsSemanticsUpdate();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'performLayout'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  markNeedsPaint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用performLayout()进行layout，并标记需要paint</p>\n<h3 id=\"paint\"><a href=\"#paint\" class=\"headerlink\" title=\"paint\"></a>paint</h3><p>之前说到过，layout过程中会对paint进行标脏</p>\n<p><strong>markNeedsPaint()</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> markNeedsPaint() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_needsPaint)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  _needsPaint = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isRepaintBoundary) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      owner._nodesNeedingPaint.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      owner.requestVisualUpdate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent <span class=\"keyword\">is</span> RenderObject) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> RenderObject parent = <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">    parent.markNeedsPaint();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If we're the root of the render tree (probably a RenderView),</span></span><br><span class=\"line\">    <span class=\"comment\">// then we have to paint ourselves, since nobody else can paint</span></span><br><span class=\"line\">    <span class=\"comment\">// us. We don't add ourselves to _nodesNeedingPaint in this</span></span><br><span class=\"line\">    <span class=\"comment\">// case, because the root is always told to paint regardless.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      owner.requestVisualUpdate();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>和layout的标脏过程类似，一直向上标脏，直到 isRepaintBoundary 为true。<strong>注意，这里只有 RepaintBoundary 才加入到了 PiplineOwner 的_nodesNeedingPaint中，即最终是以 RepaintBoundary 单位进行刷新的</strong><br>需要说明的是，我们可以 RepaintBoundary 是一个widget，我们可以手动添加，来终止paint的向上标脏过程，来达到局部重绘，提升性能。 LayoutBoundary 则是只是一个标记位，framework层帮我们判断的，我们不需要手动处理。</p>\n<p><strong>pipelineOwner.flushLayout()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> flushPaint() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class=\"line\">    _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class=\"line\">    <span class=\"comment\">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RenderObject node <span class=\"keyword\">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node._needsPaint &amp;&amp; node.owner == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node._layer.attached) &#123;</span><br><span class=\"line\">          PaintingContext.repaintCompositedChild(node);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          node._skippedPaintingOnLayer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与layout不同的是这里的 sort 规则是相反的，最深的节点先重绘。并且，多了判断 <code>node._layer.attached</code>, 如果为true，重绘，并且重绘逻辑交给了PaintContext；如果为false，则执行 <code>node._skippedPaintingOnLayer();</code></p>\n<p><strong>node._skippedPaintingOnLayer()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _skippedPaintingOnLayer() &#123;</span><br><span class=\"line\">  AbstractNode ancestor = parent;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ancestor <span class=\"keyword\">is</span> RenderObject) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> RenderObject node = ancestor;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.isRepaintBoundary) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node._layer == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// looks like the subtree here has never been painted. let it handle itself.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node._layer.attached)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// it's the one that detached us, so it's the one that will decide to repaint us.</span></span><br><span class=\"line\">      node._needsPaint = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ancestor = node.parent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我的理解是，该节点的 layer 被 detached 了，需要对该节点及其父节点行重新标脏，保证该节点的 layer 被重新 attach 之后能够重绘。 </p>\n<p><strong>PaintingContext.repaintCompositedChild(node);</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> repaintCompositedChild(RenderObject child, &#123; <span class=\"built_in\">bool</span> debugAlsoPaintedParent = <span class=\"keyword\">false</span> &#125;) &#123;</span><br><span class=\"line\">  _repaintCompositedChild(</span><br><span class=\"line\">    child,</span><br><span class=\"line\">    debugAlsoPaintedParent: debugAlsoPaintedParent,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _repaintCompositedChild(</span><br><span class=\"line\">  RenderObject child, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> debugAlsoPaintedParent = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  PaintingContext childContext,</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  OffsetLayer childLayer = child._layer;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childLayer == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    child._layer = childLayer = OffsetLayer();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    childLayer.removeAllChildren();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class=\"line\">  child._paintWithContext(childContext, Offset.zero);</span><br><span class=\"line\"></span><br><span class=\"line\">  childContext.stopRecordingIfNeeded();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>又是 PaintContext 和 layer。。。先跳过这两个，最终重绘的逻辑在 <code>child._paintWithContext(childContext, Offset.zero);</code>中</p>\n<p><strong>child._paintWithContext(childContext, Offset.zero);</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 一堆注释解释了为啥在paint的时候 _needsLayout 还可能为true 。。。</span></span><br><span class=\"line\">  <span class=\"comment\">// 英文注释没咋看懂</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_needsLayout)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  RenderObject debugLastActivePaint;</span><br><span class=\"line\">  _needsPaint = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最终的重绘交给具体的 RenderObject 子类</span></span><br><span class=\"line\">    paint(context, offset);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'paint'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Widget-Element-RanderObject-三者之间的关系\"><a href=\"#Widget-Element-RanderObject-三者之间的关系\" class=\"headerlink\" title=\"Widget, Element, RanderObject 三者之间的关系\"></a>Widget, Element, RanderObject 三者之间的关系</h2>","more":"<p>Widget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。</p>\n<h2 id=\"Widget\"><a href=\"#Widget\" class=\"headerlink\" title=\"Widget\"></a>Widget</h2><p>Widget类和Element类一一对应。Element是通过Widget生成的<br>Widget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。</p>\n<p><strong>Widget.createElement()</strong></p>\n<p>创建Element对象</p>\n<p><strong>Widget.canUpdate(..)</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；<br>通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.</p>\n<p><strong>createState()</strong></p>\n<p>用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，<strong>所以，本质上就是一个StatefulElement对应一个State实例。</strong></p>\n<p><strong>widget和context</strong></p>\n<ul>\n<li><p>widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但<strong>State实例只会在第一次插入到树中时被创建</strong>，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 </p>\n</li>\n<li><p>context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext</p>\n</li>\n</ul>\n<p><strong>State如何被Widget复用</strong><br>只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(…)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。</p>\n<h2 id=\"Element\"><a href=\"#Element\" class=\"headerlink\" title=\"Element\"></a>Element</h2><p>最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。</p>\n<p>下面从Element的 <strong>挂载、更新、卸载</strong>过程来描述Element</p>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><p><strong>根Element的mount</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- main() </span><br><span class=\"line\">    - runApp(..)</span><br><span class=\"line\">    - WidgetsFlutterBinding.attachRootWidget(app)</span><br><span class=\"line\">        - RenderObjectToWidgetAdapter&lt;RenderBox&gt;.attachToRenderTree(buildOwner, renderViewElement);</span><br><span class=\"line\">            - createElement()</span><br><span class=\"line\">            - BuildOwner.buildScope(element, () &#123;</span><br><span class=\"line\">                element.mount(null, null);</span><br><span class=\"line\">            &#125;)</span><br></pre></td></tr></table></figure>\n<p>以上是根Element的mount过程，其中rederViewElement是根Elemet</p>\n<p>** Element的mount过程</p>\n<p>首先来看一下常用的StatelessElement，StatefulElement的继承关系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Element -&gt; ComponentElement -&gt; StatelessElement</span><br><span class=\"line\">                            -&gt; StatefulElement</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- mount()</span><br><span class=\"line\">    - Element.updateInheritance()</span><br><span class=\"line\">    - ComponentElement.firstBuild()</span><br><span class=\"line\">        - Element.rebuild()</span><br><span class=\"line\">        - ComponentElement.performRebuild()</span><br><span class=\"line\">            - built = build()</span><br><span class=\"line\">                -Widget.build()</span><br><span class=\"line\">            - Element.updateChild(child, built, _)</span><br></pre></td></tr></table></figure>\n<p>Element.updateChild方法非常重要</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> updateChild(<span class=\"built_in\">Element</span> child, Widget newWidget, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newWidget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        deactivateChild(child);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (child.widget == newWidget) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class=\"line\">        child.update(newWidget);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      deactivateChild(child);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inflateWidget(newWidget, newSlot);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class=\"line\">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据上面的代码，总结各种case</p>\n<ul>\n<li>child != null &amp;&amp; newWidget == null :<br>  newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element</li>\n<li>child == null &amp;&amp; newWidget != null :<br>  第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)</li>\n<li>child != null &amp;&amp; newWidget != null :<br>  更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建</li>\n<li>child == null &amp;&amp; newWidget == null :<br>  do nothing</li>\n</ul>\n<p>在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"built_in\">Element</span> inflateWidget(Widget newWidget, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">Element</span> newChild = newWidget.createElement();</span><br><span class=\"line\">    newChild.mount(<span class=\"keyword\">this</span>, newSlot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newChild;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulWidget</span> <span class=\"keyword\">extends</span> <span class=\"title\">Widget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> StatefulWidget(&#123; Key key &#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  StatefulElement createElement() =&gt; StatefulElement(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  State createState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatefulElement</span> <span class=\"keyword\">extends</span> <span class=\"title\">ComponentElement</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  StatefulElement(StatefulWidget widget)</span><br><span class=\"line\">      : _state = widget.createState(),</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(widget) &#123;</span><br><span class=\"line\">    _state._element = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    _state._widget = widget;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build() =&gt; state.build(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>StatefulWidget，State，StatefulElement的调用关系：<br>Widget.createElement() -&gt; Element.build() -&gt; State.build()</p>\n<h3 id=\"更新Element\"><a href=\"#更新Element\" class=\"headerlink\" title=\"更新Element\"></a>更新Element</h3><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Widget.setState</span><br><span class=\"line\">    - <span class=\"built_in\">Element</span>.markNeedsBuild()</span><br><span class=\"line\">        - <span class=\"built_in\">Element</span>._dirty = <span class=\"keyword\">true</span></span><br><span class=\"line\">        - BuildOwner.scheduleBuildFor(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">            - BuildOwner._dirtyElements.add(element)</span><br></pre></td></tr></table></figure>\n<p>当调用statState之后，会将element标脏，并加入到_dirtyElements列表中</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- WidgetsBinding.drawFrame()</span><br><span class=\"line\">    - BuildOwner.buildScope(renderViewElement)</span><br><span class=\"line\">        - BuildOwner._dirtyElements[index].rebuild()</span><br></pre></td></tr></table></figure>\n<p>每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。<br>可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的</p>\n<h3 id=\"卸载Element\"><a href=\"#卸载Element\" class=\"headerlink\" title=\"卸载Element\"></a>卸载Element</h3><p>在Element的updateChild方法中，在 <code>child != null &amp;&amp; newWidget == null</code> 时，会调用deactivateChild()</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> deactivateChild(<span class=\"built_in\">Element</span> child) &#123;</span><br><span class=\"line\">  child._parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  child.detachRenderObject();</span><br><span class=\"line\">  owner._inactiveElements.add(child); <span class=\"comment\">// this eventually calls child.deactivate()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>deactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。</p>\n<p>还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> finalizeTree() &#123;</span><br><span class=\"line\">    Timeline.startSync(<span class=\"string\">'Finalize tree'</span>, arguments: timelineWhitelistArguments);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      lockState(() &#123;</span><br><span class=\"line\">        _inactiveElements._unmountAll(); <span class=\"comment\">// this unregisters the GlobalKeys</span></span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _unmountAll() &#123;</span><br><span class=\"line\">    _locked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;<span class=\"built_in\">Element</span>&gt; elements = _elements.toList()..sort(<span class=\"built_in\">Element</span>._sort);</span><br><span class=\"line\">    _elements.clear();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      elements.reversed.forEach(_unmount);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      _locked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _unmount(<span class=\"built_in\">Element</span> element) &#123;</span><br><span class=\"line\">    element.visitChildren((<span class=\"built_in\">Element</span> child) &#123;</span><br><span class=\"line\">      _unmount(child);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    element.unmount();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RenderObject\"><a href=\"#RenderObject\" class=\"headerlink\" title=\"RenderObject\"></a>RenderObject</h2><h3 id=\"RenderObjectElement\"><a href=\"#RenderObjectElement\" class=\"headerlink\" title=\"RenderObjectElement\"></a>RenderObjectElement</h3><p>RenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。<strong>不是所有的Element都有对应的RenderObject</strong></p>\n<p>RenderObjectElement有三个常用的子类：</p>\n<ul>\n<li>LeafRenderObjectElement：Leaf render objects, with no children</li>\n<li>SingleChildRenderObjectElement：A single child</li>\n<li>MultiChildRenderObjectElement：A linked list of children.</li>\n</ul>\n<p>RenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。</p>\n<p><strong>mmount、update、unmount</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> mount(<span class=\"built_in\">Element</span> parent, <span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.mount(parent, newSlot);</span><br><span class=\"line\">  _renderObject = widget.createRenderObject(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  attachRenderObject(newSlot);</span><br><span class=\"line\">  _dirty = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> attachRenderObject(<span class=\"keyword\">dynamic</span> newSlot) &#123;</span><br><span class=\"line\">  _slot = newSlot;</span><br><span class=\"line\">  _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class=\"line\">  _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</span><br><span class=\"line\">  <span class=\"keyword\">final</span> ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (parentDataElement != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    _updateParentData(parentDataElement.widget);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> update(covariant RenderObjectWidget newWidget) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.update(newWidget);</span><br><span class=\"line\">  widget.updateRenderObject(<span class=\"keyword\">this</span>, renderObject);</span><br><span class=\"line\">  _dirty = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RenderObject的更新\"><a href=\"#RenderObject的更新\" class=\"headerlink\" title=\"RenderObject的更新\"></a>RenderObject的更新</h3><p>我们从render树的insert过程类分析RenderObject的更新<br>从RenderObjectElement.insertChildRenderObject开始</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> insertChildRenderObject(RenderObject child, <span class=\"built_in\">Element</span> slot) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt; renderObject = <span class=\"keyword\">this</span>.renderObject;</span><br><span class=\"line\">  renderObject.insert(child, after: slot?.renderObject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用了ContainerRenderObjectMixin的insert方法，</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> insert(ChildType child, &#123; ChildType after &#125;) &#123;</span><br><span class=\"line\">  adoptChild(child);</span><br><span class=\"line\">  _insertIntoChildList(child, after: after);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> adoptChild(RenderObject child) &#123;</span><br><span class=\"line\">  setupParentData(child);</span><br><span class=\"line\">  markNeedsLayout();</span><br><span class=\"line\">  markNeedsCompositingBitsUpdate();</span><br><span class=\"line\">  markNeedsSemanticsUpdate();</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.adoptChild(child);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> markNeedsLayout() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_relayoutBoundary != <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    markParentNeedsLayout();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    _needsLayout = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      owner._nodesNeedingLayout.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      owner.requestVisualUpdate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> markParentNeedsLayout() &#123;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> RenderObject parent = <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_doingThisLayoutWithCallback) &#123;</span><br><span class=\"line\">    parent.markNeedsLayout();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span>(parent._debugDoingThisLayout);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和element的build流程不同，RenderObject的标脏会向上标脏。<br>找到 _relayoutBoundary 节点，触发<code>owner._nodesNeedingLayout.add( this )</code>与<code>owner.requestVisualUpdate()</code> 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner</p>\n<p>PiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。<br>(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)<br>来看一下PiplelineOwner.requestVisualUpdate</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> requestVisualUpdate() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (onNeedVisualUpdate != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    onNeedVisualUpdate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>onNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> initInstances() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.initInstances();</span><br><span class=\"line\">  _instance = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  _pipelineOwner = PipelineOwner(</span><br><span class=\"line\">    onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class=\"line\">    onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class=\"line\">    onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class=\"line\">  );</span><br><span class=\"line\">  <span class=\"built_in\">window</span></span><br><span class=\"line\">    ..onMetricsChanged = handleMetricsChanged</span><br><span class=\"line\">    ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class=\"line\">    ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class=\"line\">    ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class=\"line\">    ..onSemanticsAction = _handleSemanticsAction;</span><br><span class=\"line\">  initRenderView();</span><br><span class=\"line\">  _handleSemanticsEnabledChanged();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(renderView != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class=\"line\">  initMouseTracker();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _handlePersistentFrameCallback(<span class=\"built_in\">Duration</span> timeStamp) &#123;</span><br><span class=\"line\">  drawFrame();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制</p>\n<h3 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h3><p><strong>RendererBinding.drawFrame</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> drawFrame() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  pipelineOwner.flushLayout();</span><br><span class=\"line\">  pipelineOwner.flushCompositingBits();</span><br><span class=\"line\">  pipelineOwner.flushPaint();</span><br><span class=\"line\">  renderView.compositeFrame(); <span class=\"comment\">// this sends the bits to the GPU</span></span><br><span class=\"line\">  pipelineOwner.flushSemantics(); <span class=\"comment\">// this also sends the semantics to the OS.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>pipelineOwner.flushLayout()</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> flushLayout() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class=\"line\">      _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (RenderObject node <span class=\"keyword\">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node._needsLayout &amp;&amp; node.owner == <span class=\"keyword\">this</span>)</span><br><span class=\"line\">          node._layoutWithoutResize();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>*RendererObject._layoutWithoutResize</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _layoutWithoutResize() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    performLayout();</span><br><span class=\"line\">    markNeedsSemanticsUpdate();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'performLayout'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  markNeedsPaint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里调用performLayout()进行layout，并标记需要paint</p>\n<h3 id=\"paint\"><a href=\"#paint\" class=\"headerlink\" title=\"paint\"></a>paint</h3><p>之前说到过，layout过程中会对paint进行标脏</p>\n<p><strong>markNeedsPaint()</strong><br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> markNeedsPaint() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_needsPaint)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  _needsPaint = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isRepaintBoundary) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      owner._nodesNeedingPaint.add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      owner.requestVisualUpdate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parent <span class=\"keyword\">is</span> RenderObject) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> RenderObject parent = <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">    parent.markNeedsPaint();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// If we're the root of the render tree (probably a RenderView),</span></span><br><span class=\"line\">    <span class=\"comment\">// then we have to paint ourselves, since nobody else can paint</span></span><br><span class=\"line\">    <span class=\"comment\">// us. We don't add ourselves to _nodesNeedingPaint in this</span></span><br><span class=\"line\">    <span class=\"comment\">// case, because the root is always told to paint regardless.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (owner != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      owner.requestVisualUpdate();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>和layout的标脏过程类似，一直向上标脏，直到 isRepaintBoundary 为true。<strong>注意，这里只有 RepaintBoundary 才加入到了 PiplineOwner 的_nodesNeedingPaint中，即最终是以 RepaintBoundary 单位进行刷新的</strong><br>需要说明的是，我们可以 RepaintBoundary 是一个widget，我们可以手动添加，来终止paint的向上标脏过程，来达到局部重绘，提升性能。 LayoutBoundary 则是只是一个标记位，framework层帮我们判断的，我们不需要手动处理。</p>\n<p><strong>pipelineOwner.flushLayout()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> flushPaint() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class=\"line\">    _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class=\"line\">    <span class=\"comment\">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RenderObject node <span class=\"keyword\">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node._needsPaint &amp;&amp; node.owner == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node._layer.attached) &#123;</span><br><span class=\"line\">          PaintingContext.repaintCompositedChild(node);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          node._skippedPaintingOnLayer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与layout不同的是这里的 sort 规则是相反的，最深的节点先重绘。并且，多了判断 <code>node._layer.attached</code>, 如果为true，重绘，并且重绘逻辑交给了PaintContext；如果为false，则执行 <code>node._skippedPaintingOnLayer();</code></p>\n<p><strong>node._skippedPaintingOnLayer()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _skippedPaintingOnLayer() &#123;</span><br><span class=\"line\">  AbstractNode ancestor = parent;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (ancestor <span class=\"keyword\">is</span> RenderObject) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> RenderObject node = ancestor;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.isRepaintBoundary) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node._layer == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// looks like the subtree here has never been painted. let it handle itself.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node._layer.attached)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>; <span class=\"comment\">// it's the one that detached us, so it's the one that will decide to repaint us.</span></span><br><span class=\"line\">      node._needsPaint = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ancestor = node.parent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我的理解是，该节点的 layer 被 detached 了，需要对该节点及其父节点行重新标脏，保证该节点的 layer 被重新 attach 之后能够重绘。 </p>\n<p><strong>PaintingContext.repaintCompositedChild(node);</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> repaintCompositedChild(RenderObject child, &#123; <span class=\"built_in\">bool</span> debugAlsoPaintedParent = <span class=\"keyword\">false</span> &#125;) &#123;</span><br><span class=\"line\">  _repaintCompositedChild(</span><br><span class=\"line\">    child,</span><br><span class=\"line\">    debugAlsoPaintedParent: debugAlsoPaintedParent,</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _repaintCompositedChild(</span><br><span class=\"line\">  RenderObject child, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> debugAlsoPaintedParent = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  PaintingContext childContext,</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  OffsetLayer childLayer = child._layer;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childLayer == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    child._layer = childLayer = OffsetLayer();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    childLayer.removeAllChildren();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class=\"line\">  child._paintWithContext(childContext, Offset.zero);</span><br><span class=\"line\"></span><br><span class=\"line\">  childContext.stopRecordingIfNeeded();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>又是 PaintContext 和 layer。。。先跳过这两个，最终重绘的逻辑在 <code>child._paintWithContext(childContext, Offset.zero);</code>中</p>\n<p><strong>child._paintWithContext(childContext, Offset.zero);</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 一堆注释解释了为啥在paint的时候 _needsLayout 还可能为true 。。。</span></span><br><span class=\"line\">  <span class=\"comment\">// 英文注释没咋看懂</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_needsLayout)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  RenderObject debugLastActivePaint;</span><br><span class=\"line\">  _needsPaint = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最终的重绘交给具体的 RenderObject 子类</span></span><br><span class=\"line\">    paint(context, offset);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'paint'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Flutter中常用布局和Android的对应关系","date":"2020-02-26T07:49:51.000Z","_content":"\n![图片](/images/flutter相关属性和android的对应关系.webp)\n\n\n\n\n","source":"_posts/Flutter/Flutter中常用布局和Android的对应关系.md","raw":"---\ntitle: Flutter中常用布局和Android的对应关系\ndate: 2020-02-26 15:49:51\ntags:\n- Flutter\ncategories:\n- Flutter\n---\n\n![图片](/images/flutter相关属性和android的对应关系.webp)\n\n\n\n\n","slug":"Flutter/Flutter中常用布局和Android的对应关系","published":1,"updated":"2021-10-03T01:57:41.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8n003pg0je3skro1zq","content":"<p><img src=\"/images/flutter相关属性和android的对应关系.webp\" alt=\"图片\"></p>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/images/flutter相关属性和android的对应关系.webp\" alt=\"图片\"></p>"},{"title":"通知铃声的自定义遇到的问题-根据uri读取文件","date":"2019-08-28T15:07:53.000Z","Categories":["Android"],"_content":"\n# 通知铃声自定义遇到的问题: 根据uri读取文件 \n\n## 问题：\n在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音\n\n## 问题根源：\n### 1.从系统文件管理器中获取文件，从得到的uri中获取原始路径\n\n**所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的**\n\n网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。\n\n正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。\n\n```\nInputStream fis = getContentResolver().openInputStream(uri);\n```\n\n### 2. 将拷贝的文件转化为uri\n\n**失败的尝试：使用Uri.fromFile():**\n首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。\n\n在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法.\n\n### 3. grantUriPermission()\n\n在某些机型中，使用file自定义notification的声音，仍然不能正常工作。\n**设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning**\n为什么要选择No Filter选项才会看到这个warning。\n是因为，弹出notification是系统服务，和我们的APP项目不是一个包名\n在file转uri之后添加一个授权的语句就可以了：\n```\ngetApplicationContext().grantUriPermission(\"com.android.systemui\",\n                Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION);\n```\n包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作\n\n到这里问题就解决了\n","source":"_posts/Android/通知铃声的自定义遇到的问题-根据uri读取文件.md","raw":"---\ntitle: 通知铃声的自定义遇到的问题-根据uri读取文件\ndate: 2019-08-28 23:07:53\ntags:\n- Android\n- Notification\n- Uri\nCategories:\n- Android\n---\n\n# 通知铃声自定义遇到的问题: 根据uri读取文件 \n\n## 问题：\n在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音\n\n## 问题根源：\n### 1.从系统文件管理器中获取文件，从得到的uri中获取原始路径\n\n**所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的**\n\n网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。\n\n正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。\n\n```\nInputStream fis = getContentResolver().openInputStream(uri);\n```\n\n### 2. 将拷贝的文件转化为uri\n\n**失败的尝试：使用Uri.fromFile():**\n首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。\n\n在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法.\n\n### 3. grantUriPermission()\n\n在某些机型中，使用file自定义notification的声音，仍然不能正常工作。\n**设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning**\n为什么要选择No Filter选项才会看到这个warning。\n是因为，弹出notification是系统服务，和我们的APP项目不是一个包名\n在file转uri之后添加一个授权的语句就可以了：\n```\ngetApplicationContext().grantUriPermission(\"com.android.systemui\",\n                Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION);\n```\n包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作\n\n到这里问题就解决了\n","slug":"Android/通知铃声的自定义遇到的问题-根据uri读取文件","published":1,"updated":"2021-10-03T02:27:00.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8p003sg0je0gn86x1z","content":"<h1 id=\"通知铃声自定义遇到的问题-根据uri读取文件\"><a href=\"#通知铃声自定义遇到的问题-根据uri读取文件\" class=\"headerlink\" title=\"通知铃声自定义遇到的问题: 根据uri读取文件\"></a>通知铃声自定义遇到的问题: 根据uri读取文件</h1><a id=\"more\"></a><h2 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h2><p>在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音</p>\n<h2 id=\"问题根源：\"><a href=\"#问题根源：\" class=\"headerlink\" title=\"问题根源：\"></a>问题根源：</h2><h3 id=\"1-从系统文件管理器中获取文件，从得到的uri中获取原始路径\"><a href=\"#1-从系统文件管理器中获取文件，从得到的uri中获取原始路径\" class=\"headerlink\" title=\"1.从系统文件管理器中获取文件，从得到的uri中获取原始路径\"></a>1.从系统文件管理器中获取文件，从得到的uri中获取原始路径</h3><p><strong>所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的</strong></p>\n<p>网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。</p>\n<p>正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream fis = getContentResolver().openInputStream(uri);</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-将拷贝的文件转化为uri\"><a href=\"#2-将拷贝的文件转化为uri\" class=\"headerlink\" title=\"2. 将拷贝的文件转化为uri\"></a>2. 将拷贝的文件转化为uri</h3><p><strong>失败的尝试：使用Uri.fromFile():</strong><br>首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。</p>\n<p>在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法.</p>\n<h3 id=\"3-grantUriPermission\"><a href=\"#3-grantUriPermission\" class=\"headerlink\" title=\"3. grantUriPermission()\"></a>3. grantUriPermission()</h3><p>在某些机型中，使用file自定义notification的声音，仍然不能正常工作。<br><strong>设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning</strong><br>为什么要选择No Filter选项才会看到这个warning。<br>是因为，弹出notification是系统服务，和我们的APP项目不是一个包名<br>在file转uri之后添加一个授权的语句就可以了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getApplicationContext().grantUriPermission(&quot;com.android.systemui&quot;,</span><br><span class=\"line\">                Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br></pre></td></tr></table></figure></p>\n<p>包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作</p>\n<p>到这里问题就解决了</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"通知铃声自定义遇到的问题-根据uri读取文件\"><a href=\"#通知铃声自定义遇到的问题-根据uri读取文件\" class=\"headerlink\" title=\"通知铃声自定义遇到的问题: 根据uri读取文件\"></a>通知铃声自定义遇到的问题: 根据uri读取文件</h1>","more":"<h2 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h2><p>在自定义通知铃声是，当铃声的uri来自本地文件，或者是项目的资源文件，当通知弹出时，没有声音</p>\n<h2 id=\"问题根源：\"><a href=\"#问题根源：\" class=\"headerlink\" title=\"问题根源：\"></a>问题根源：</h2><h3 id=\"1-从系统文件管理器中获取文件，从得到的uri中获取原始路径\"><a href=\"#1-从系统文件管理器中获取文件，从得到的uri中获取原始路径\" class=\"headerlink\" title=\"1.从系统文件管理器中获取文件，从得到的uri中获取原始路径\"></a>1.从系统文件管理器中获取文件，从得到的uri中获取原始路径</h3><p><strong>所有尝试从Uri中获取原始路径的方法，都是不推荐和不可靠的</strong></p>\n<p>网上大部分的方法都是解析Uri，使用cursor读取对应的字段，然后获取到文件的路径，但是，经过尝试后发现，大部分机型中，cursor并没有那个字段，当然也就得不到对应的路径。</p>\n<p>正确的做法应当是，使用ContentResolver获取到对应的文件流，拷问文件到App的目录中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStream fis = getContentResolver().openInputStream(uri);</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-将拷贝的文件转化为uri\"><a href=\"#2-将拷贝的文件转化为uri\" class=\"headerlink\" title=\"2. 将拷贝的文件转化为uri\"></a>2. 将拷贝的文件转化为uri</h3><p><strong>失败的尝试：使用Uri.fromFile():</strong><br>首先，App将自己的铃声文件设置到notificaiton中，系统要弹出一个notification时，会调用我们的项目目录的铃声文件。</p>\n<p>在Android7.0以上的版本中，对这种行为进行了限制，获取文件的Uri一定要使用FileProvider，而不能直接调用fromFile()方法.</p>\n<h3 id=\"3-grantUriPermission\"><a href=\"#3-grantUriPermission\" class=\"headerlink\" title=\"3. grantUriPermission()\"></a>3. grantUriPermission()</h3><p>在某些机型中，使用file自定义notification的声音，仍然不能正常工作。<br><strong>设置logcat的Filter选项为No Filter, 会出现FileProvider Permission denial 的 warning</strong><br>为什么要选择No Filter选项才会看到这个warning。<br>是因为，弹出notification是系统服务，和我们的APP项目不是一个包名<br>在file转uri之后添加一个授权的语句就可以了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getApplicationContext().grantUriPermission(&quot;com.android.systemui&quot;,</span><br><span class=\"line\">                Uri.parse(info.uri), Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br></pre></td></tr></table></figure></p>\n<p>包名com.android.systemui是系统服务的一个包名，负责notification、StatusBar等的相关操作</p>\n<p>到这里问题就解决了</p>\n"},{"title":"kotlin-flow","date":"2021-10-04T06:58:00.000Z","_content":"\n# 基础的流\n\n## demo\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n              \nfun simple(): Flow<Int> = flow { // 流构建器\n    for (i in 1..3) {\n        delay(100) // 假装我们在这里做了一些有用的事情\n        emit(i) // 发送下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // 启动并发的协程以验证主线程并未阻塞\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // 收集这个流\n    simple().collect { value -> println(value) } \n}\n```\n\n## flow 是 ”冷流“\n\n- 冷流的定义：  flow 构建器中的代码直到流被调用 collect 的时候才运行。\n\n```kotlin\npublic fun <T> flow(@BuilderInference block: suspend FlowCollector<T>.() -> Unit): Flow<T> = SafeFlow(block)\n\nprivate class SafeFlow<T>(private val block: suspend FlowCollector<T>.() -> Unit) : AbstractFlow<T>() {\n    override suspend fun collectSafely(collector: FlowCollector<T>) {\n        collector.block()\n    }\n}\n\npublic interface FlowCollector<in T> {\n    public suspend fun emit(value: T)\n}\n```\n\nflow 的实现如上，只不过是传入了 代码块作为 FlowCollector 的拓展函数。\n当 流开始收集 （调用collect），会执行这个 flow 的代码块。 \n在 collect 中传入的代码块， 实际上是一个 FlowCollector 匿名对象，当 flow 的代码块调用 emit 的时候，就直接调用了 collect 后的代码块。\n\n用一个例子体现这一点：\n\n```kotlin\nfun simple(): Flow<Int> = flow {\n    for (i in 1..1) {\n        log(\"Emit start $i\")\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n        log(\"Emit end $i\")\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .collect { value ->\n            log(\"Collected start $value\")\n            delay(300)\n            log(\"Collected end $value\")\n        }\n}\n```\n\n最终输出：\n\n```shell\n[main] Emit start 1\n[main] Collected start 1\n[main] Collected end 1\n[main] Emit end 1\n```\n\n## 流的上下文保存\n\n- 上下文保存： **flow { ... } 构建器中的代码运行在相应流的收集器提供的上下文中**\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \nfun simple(): Flow<Int> = flow {\n    log(\"Started simple flow\")\n    for (i in 1..3) {\n        emit(i)\n    }\n}  \n\nfun main() = runBlocking<Unit> {\n    simple().collect { value -> log(\"Collected $value\") } \n} \n```\n\n```shell\n[main @coroutine#1] Started simple flow\n[main @coroutine#1] Collected 1\n[main @coroutine#1] Collected 2\n[main @coroutine#1] Collected 3\n```\n\n由于 simple().collect 是在主线程调用的，那么 simple 的流主体也是在主线程调用的。 \n**如果在 调用`emit`时切换协程上下文，会直接抛出异常**\n\n- flowOn: 正确的切换 flow 的上下文\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        Thread.sleep(100) // 假装我们以消耗 CPU 的方式进行计算\n        log(\"Emitting $i\")\n        emit(i) // 发射下一个值\n    }\n}.flowOn(Dispatchers.Default) // 在流构建器中改变协程上下文的正确方式\n\nfun main() = runBlocking<Unit> {\n    simple().collect { value ->\n        log(\"Collected $value\") \n    } \n} \n```\n\n## 解决 背压问题\n\n名词解释：**背压： 假设有一个快的数据生产者和一个慢的数据消费者，背压就是一种 \"倒逼 \"生产者而使自己不被数据淹没的机制**\n\n### buffer\n并发运行这个 流中发射元素的代码以及收集的代码， 而不是顺序运行它们； buffer() 会给切换 flow 的协程，保证 发送端 是不阻塞的 。 可以设置 buffer 容量和策略\n\n\n```kotlin\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple()\n            .buffer() // 缓冲发射项，无需等待\n            .collect { value -> \n                delay(300) // 假装我们花费 300 毫秒来处理它\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n}\n```\n\n### conflate\n\n一种特殊 buffer 策略 新数据会覆盖老数据\n\n### collectLatest\n\n它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple()\n            .collectLatest { value -> // 取消并重新发射最后一个值\n                println(\"Collecting $value\") \n                delay(300) // 假装我们花费 300 毫秒来处理它\n                println(\"Done $value\") \n            } \n    }   \n    println(\"Collected in $time ms\")\n}\n```\n\n```shell\nCollecting 1\nCollecting 2\nCollecting 3\nDone 3\nCollected in 741 ms\n```\n\n\n# StateFlow \n\n## demo\n\n```kotlin\n    val flow = MutableStateFlow(2)\n\n    private suspend fun produce() {\n        for (i in 0..5) {\n            val success = flow.tryEmit(i)\n            println(\"tryEmit $i $success\")\n//            delay(200)\n        }\n    }\n\n    @JvmStatic\n    fun main(args: Array<String>): Unit = runBlocking {\n        launch(Dispatchers.IO) {\n            delay(1000)\n            produce()\n        }\n\n        launch(Dispatchers.IO){\n\n            flow.onEach {\n                println(\"receive-1 $it\")\n                delay(500)\n            }.launchIn(this)\n        }\n    }\n```\n\n## StateFlow 是一个 \"流\"\n\n不同于普通的 flow ， StateFlow 是一个热数据流。 不需要主动调动 collect{...} , 就能 emit 数据\n\n## StateFlow 的 collect 是阻塞的，需要在单独的协程中运行\n\n在demo中调用了 launchIn ，而不是直接 collect 。 看一下源码\n\n```kotlin\n// StateFlow \n\n    private val _state = atomic(initialState)\n\n    override suspend fun collect(collector: FlowCollector<T>) {\n        val slot = allocateSlot()\n        try {\n            if (collector is SubscribedFlowCollector) collector.onSubscription()\n            val collectorJob = currentCoroutineContext()[Job]\n            var oldState: Any? = null \n            while (true) {\n                val newState = _state.value\n                collectorJob?.ensureActive()\n                if (oldState == null || oldState != newState) {\n                    collector.emit(NULL.unbox(newState))\n                    oldState = newState\n                }\n                if (!slot.takePending()) { // try fast-path without suspending first\n                    slot.awaitPending() // only suspend for new values when needed\n                }\n            }\n        } finally {\n            freeSlot(slot)\n        }\n    }\n```\n\n可以看到，在 collec 中，一个 while 死循环，开始不断读取 _state.value 的值\nsolt 可以看做是 collector 的一个封装。 这里调用了 slot.awaitPending() 来挂起当前协程，让出cpu时间. 看一下 StateFlowSlot 是如何挂起的 \n\n```kotlin\n    suspend fun awaitPending(): Unit = suspendCancellableCoroutine sc@ { cont ->\n        // 如果 _state 是 None ，就设置为 cont \n        // cont 的类型 CancellableContinuation ，只用调用 resume 或 fail 等，才会结束，否则挂起当前协程\n        if (_state.compareAndSet(NONE, cont)) return@sc\n        cont.resume(Unit)\n    }\n```\n\n在 StateFlow 的 emit 被调用的时候， 会获取到 solt 中的 CancellableContinuation 对象，调用其 resume ，将协程进行唤醒\n\n# ShareFlow\n\n## demo \n\n```kotlin \nval flow = MutableSharedFlow<Int>(\n    replay = 0, \n    extraBufferCapacity = 100, \n    onBufferOverflow = BufferOverflow.DROP_OLDEST\n)\n\nprivate suspend fun produce() {\n    for (i in 0..5) {\n        val success = flow.tryEmit(i)\n        println(\"tryEmit $i $success\")\n//            delay(200)\n    }\n}\n\n@JvmStatic\nfun main(args: Array<String>): Unit = runBlocking {\n    launch(Dispatchers.IO) {\n        delay(1000)\n        produce()\n    }\n\n    launch(Dispatchers.IO){\n\n        flow.onEach {\n            println(\"receive-1 $it\")\n            delay(500)\n        }.launchIn(this)\n    }\n}\n```\n\nMutableShareFlow 的三个参数：\n- 通过 replay ，您可以针对新订阅者重新发送多个之前已发出的值\n- extraBufferCapacity: 除了 replay 值以外的缓冲区容量。 extraBufferCapacity + replay 是缓冲区buffer的容量\n- 通过 onBufferOverflow，您可以指定相关政策来处理缓冲区中已存满要发送的数据项的情况。默认值为 BufferOverflow.SUSPEND，这会使调用方挂起。其他选项包括 DROP_LATEST 或 DROP_OLDEST\n\nShareFlow 在收集侧 和 StateFlow 基本一致。 都是 while 死循环，然后将 solt 挂起。 这里不再赘述\n\n<!-- ## BufferOverflow.SUSPEND, tryEmit 和 Emit\n\n当  -->\n\n\n\n\n\n\n\n","source":"_posts/Kotlin/kotlin-flow.md","raw":"---\ntitle: kotlin-flow\ndate: 2021-10-04 14:58:00\ntags: Kotlin\n---\n\n# 基础的流\n\n## demo\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\n              \nfun simple(): Flow<Int> = flow { // 流构建器\n    for (i in 1..3) {\n        delay(100) // 假装我们在这里做了一些有用的事情\n        emit(i) // 发送下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    // 启动并发的协程以验证主线程并未阻塞\n    launch {\n        for (k in 1..3) {\n            println(\"I'm not blocked $k\")\n            delay(100)\n        }\n    }\n    // 收集这个流\n    simple().collect { value -> println(value) } \n}\n```\n\n## flow 是 ”冷流“\n\n- 冷流的定义：  flow 构建器中的代码直到流被调用 collect 的时候才运行。\n\n```kotlin\npublic fun <T> flow(@BuilderInference block: suspend FlowCollector<T>.() -> Unit): Flow<T> = SafeFlow(block)\n\nprivate class SafeFlow<T>(private val block: suspend FlowCollector<T>.() -> Unit) : AbstractFlow<T>() {\n    override suspend fun collectSafely(collector: FlowCollector<T>) {\n        collector.block()\n    }\n}\n\npublic interface FlowCollector<in T> {\n    public suspend fun emit(value: T)\n}\n```\n\nflow 的实现如上，只不过是传入了 代码块作为 FlowCollector 的拓展函数。\n当 流开始收集 （调用collect），会执行这个 flow 的代码块。 \n在 collect 中传入的代码块， 实际上是一个 FlowCollector 匿名对象，当 flow 的代码块调用 emit 的时候，就直接调用了 collect 后的代码块。\n\n用一个例子体现这一点：\n\n```kotlin\nfun simple(): Flow<Int> = flow {\n    for (i in 1..1) {\n        log(\"Emit start $i\")\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n        log(\"Emit end $i\")\n    }\n}\n\nfun main() = runBlocking<Unit> {\n    simple()\n        .collect { value ->\n            log(\"Collected start $value\")\n            delay(300)\n            log(\"Collected end $value\")\n        }\n}\n```\n\n最终输出：\n\n```shell\n[main] Emit start 1\n[main] Collected start 1\n[main] Collected end 1\n[main] Emit end 1\n```\n\n## 流的上下文保存\n\n- 上下文保存： **flow { ... } 构建器中的代码运行在相应流的收集器提供的上下文中**\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \nfun simple(): Flow<Int> = flow {\n    log(\"Started simple flow\")\n    for (i in 1..3) {\n        emit(i)\n    }\n}  \n\nfun main() = runBlocking<Unit> {\n    simple().collect { value -> log(\"Collected $value\") } \n} \n```\n\n```shell\n[main @coroutine#1] Started simple flow\n[main @coroutine#1] Collected 1\n[main @coroutine#1] Collected 2\n[main @coroutine#1] Collected 3\n```\n\n由于 simple().collect 是在主线程调用的，那么 simple 的流主体也是在主线程调用的。 \n**如果在 调用`emit`时切换协程上下文，会直接抛出异常**\n\n- flowOn: 正确的切换 flow 的上下文\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\n\nfun log(msg: String) = println(\"[${Thread.currentThread().name}] $msg\")\n           \nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        Thread.sleep(100) // 假装我们以消耗 CPU 的方式进行计算\n        log(\"Emitting $i\")\n        emit(i) // 发射下一个值\n    }\n}.flowOn(Dispatchers.Default) // 在流构建器中改变协程上下文的正确方式\n\nfun main() = runBlocking<Unit> {\n    simple().collect { value ->\n        log(\"Collected $value\") \n    } \n} \n```\n\n## 解决 背压问题\n\n名词解释：**背压： 假设有一个快的数据生产者和一个慢的数据消费者，背压就是一种 \"倒逼 \"生产者而使自己不被数据淹没的机制**\n\n### buffer\n并发运行这个 流中发射元素的代码以及收集的代码， 而不是顺序运行它们； buffer() 会给切换 flow 的协程，保证 发送端 是不阻塞的 。 可以设置 buffer 容量和策略\n\n\n```kotlin\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple()\n            .buffer() // 缓冲发射项，无需等待\n            .collect { value -> \n                delay(300) // 假装我们花费 300 毫秒来处理它\n                println(value) \n            } \n    }   \n    println(\"Collected in $time ms\")\n}\n```\n\n### conflate\n\n一种特殊 buffer 策略 新数据会覆盖老数据\n\n### collectLatest\n\n它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。\n\n```kotlin\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport kotlin.system.*\n\nfun simple(): Flow<Int> = flow {\n    for (i in 1..3) {\n        delay(100) // 假装我们异步等待了 100 毫秒\n        emit(i) // 发射下一个值\n    }\n}\n\nfun main() = runBlocking<Unit> { \n    val time = measureTimeMillis {\n        simple()\n            .collectLatest { value -> // 取消并重新发射最后一个值\n                println(\"Collecting $value\") \n                delay(300) // 假装我们花费 300 毫秒来处理它\n                println(\"Done $value\") \n            } \n    }   \n    println(\"Collected in $time ms\")\n}\n```\n\n```shell\nCollecting 1\nCollecting 2\nCollecting 3\nDone 3\nCollected in 741 ms\n```\n\n\n# StateFlow \n\n## demo\n\n```kotlin\n    val flow = MutableStateFlow(2)\n\n    private suspend fun produce() {\n        for (i in 0..5) {\n            val success = flow.tryEmit(i)\n            println(\"tryEmit $i $success\")\n//            delay(200)\n        }\n    }\n\n    @JvmStatic\n    fun main(args: Array<String>): Unit = runBlocking {\n        launch(Dispatchers.IO) {\n            delay(1000)\n            produce()\n        }\n\n        launch(Dispatchers.IO){\n\n            flow.onEach {\n                println(\"receive-1 $it\")\n                delay(500)\n            }.launchIn(this)\n        }\n    }\n```\n\n## StateFlow 是一个 \"流\"\n\n不同于普通的 flow ， StateFlow 是一个热数据流。 不需要主动调动 collect{...} , 就能 emit 数据\n\n## StateFlow 的 collect 是阻塞的，需要在单独的协程中运行\n\n在demo中调用了 launchIn ，而不是直接 collect 。 看一下源码\n\n```kotlin\n// StateFlow \n\n    private val _state = atomic(initialState)\n\n    override suspend fun collect(collector: FlowCollector<T>) {\n        val slot = allocateSlot()\n        try {\n            if (collector is SubscribedFlowCollector) collector.onSubscription()\n            val collectorJob = currentCoroutineContext()[Job]\n            var oldState: Any? = null \n            while (true) {\n                val newState = _state.value\n                collectorJob?.ensureActive()\n                if (oldState == null || oldState != newState) {\n                    collector.emit(NULL.unbox(newState))\n                    oldState = newState\n                }\n                if (!slot.takePending()) { // try fast-path without suspending first\n                    slot.awaitPending() // only suspend for new values when needed\n                }\n            }\n        } finally {\n            freeSlot(slot)\n        }\n    }\n```\n\n可以看到，在 collec 中，一个 while 死循环，开始不断读取 _state.value 的值\nsolt 可以看做是 collector 的一个封装。 这里调用了 slot.awaitPending() 来挂起当前协程，让出cpu时间. 看一下 StateFlowSlot 是如何挂起的 \n\n```kotlin\n    suspend fun awaitPending(): Unit = suspendCancellableCoroutine sc@ { cont ->\n        // 如果 _state 是 None ，就设置为 cont \n        // cont 的类型 CancellableContinuation ，只用调用 resume 或 fail 等，才会结束，否则挂起当前协程\n        if (_state.compareAndSet(NONE, cont)) return@sc\n        cont.resume(Unit)\n    }\n```\n\n在 StateFlow 的 emit 被调用的时候， 会获取到 solt 中的 CancellableContinuation 对象，调用其 resume ，将协程进行唤醒\n\n# ShareFlow\n\n## demo \n\n```kotlin \nval flow = MutableSharedFlow<Int>(\n    replay = 0, \n    extraBufferCapacity = 100, \n    onBufferOverflow = BufferOverflow.DROP_OLDEST\n)\n\nprivate suspend fun produce() {\n    for (i in 0..5) {\n        val success = flow.tryEmit(i)\n        println(\"tryEmit $i $success\")\n//            delay(200)\n    }\n}\n\n@JvmStatic\nfun main(args: Array<String>): Unit = runBlocking {\n    launch(Dispatchers.IO) {\n        delay(1000)\n        produce()\n    }\n\n    launch(Dispatchers.IO){\n\n        flow.onEach {\n            println(\"receive-1 $it\")\n            delay(500)\n        }.launchIn(this)\n    }\n}\n```\n\nMutableShareFlow 的三个参数：\n- 通过 replay ，您可以针对新订阅者重新发送多个之前已发出的值\n- extraBufferCapacity: 除了 replay 值以外的缓冲区容量。 extraBufferCapacity + replay 是缓冲区buffer的容量\n- 通过 onBufferOverflow，您可以指定相关政策来处理缓冲区中已存满要发送的数据项的情况。默认值为 BufferOverflow.SUSPEND，这会使调用方挂起。其他选项包括 DROP_LATEST 或 DROP_OLDEST\n\nShareFlow 在收集侧 和 StateFlow 基本一致。 都是 while 死循环，然后将 solt 挂起。 这里不再赘述\n\n<!-- ## BufferOverflow.SUSPEND, tryEmit 和 Emit\n\n当  -->\n\n\n\n\n\n\n\n","slug":"Kotlin/kotlin-flow","published":1,"updated":"2022-04-11T06:46:20.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8q003vg0je5p2d78cn","content":"<h1 id=\"基础的流\"><a href=\"#基础的流\" class=\"headerlink\" title=\"基础的流\"></a>基础的流</h1><h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\">              </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123; <span class=\"comment\">// 流构建器</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们在这里做了一些有用的事情</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发送下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class=\"line\">    launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (k <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"I'm not blocked <span class=\"variable\">$k</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 收集这个流</span></span><br><span class=\"line\">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<h2 id=\"flow-是-”冷流“\"><a href=\"#flow-是-”冷流“\" class=\"headerlink\" title=\"flow 是 ”冷流“\"></a>flow 是 ”冷流“</h2><ul>\n<li>冷流的定义：  flow 构建器中的代码直到流被调用 collect 的时候才运行。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">flow</span><span class=\"params\">(<span class=\"meta\">@BuilderInference</span> block: <span class=\"type\">suspend</span> <span class=\"type\">FlowCollector</span>&lt;<span class=\"type\">T</span>&gt;.()</span></span> -&gt; <span class=\"built_in\">Unit</span>): Flow&lt;T&gt; = SafeFlow(block)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SafeFlow</span>&lt;<span class=\"type\">T</span>&gt;</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> block: <span class=\"keyword\">suspend</span> FlowCollector&lt;T&gt;.() -&gt; <span class=\"built_in\">Unit</span>) : AbstractFlow&lt;T&gt;() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">collectSafely</span><span class=\"params\">(collector: <span class=\"type\">FlowCollector</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        collector.block()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FlowCollector</span>&lt;<span class=\"type\">in T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">emit</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>flow 的实现如上，只不过是传入了 代码块作为 FlowCollector 的拓展函数。<br>当 流开始收集 （调用collect），会执行这个 flow 的代码块。<br>在 collect 中传入的代码块， 实际上是一个 FlowCollector 匿名对象，当 flow 的代码块调用 emit 的时候，就直接调用了 collect 后的代码块。</p>\n<p>用一个例子体现这一点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">\"Emit start <span class=\"variable\">$i</span>\"</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们异步等待了 100 毫秒</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发射下一个值</span></span><br><span class=\"line\">        log(<span class=\"string\">\"Emit end <span class=\"variable\">$i</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    simple()</span><br><span class=\"line\">        .collect &#123; value -&gt;</span><br><span class=\"line\">            log(<span class=\"string\">\"Collected start <span class=\"variable\">$value</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">300</span>)</span><br><span class=\"line\">            log(<span class=\"string\">\"Collected end <span class=\"variable\">$value</span>\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[main] Emit start 1</span><br><span class=\"line\">[main] Collected start 1</span><br><span class=\"line\">[main] Collected end 1</span><br><span class=\"line\">[main] Emit end 1</span><br></pre></td></tr></table></figure>\n<h2 id=\"流的上下文保存\"><a href=\"#流的上下文保存\" class=\"headerlink\" title=\"流的上下文保存\"></a>流的上下文保存</h2><ul>\n<li>上下文保存： <strong>flow { … } 构建器中的代码运行在相应流的收集器提供的上下文中</strong></li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">log</span><span class=\"params\">(msg: <span class=\"type\">String</span>)</span></span> = println(<span class=\"string\">\"[<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>] <span class=\"variable\">$msg</span>\"</span>)</span><br><span class=\"line\">           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    log(<span class=\"string\">\"Started simple flow\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        emit(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    simple().collect &#123; value -&gt; log(<span class=\"string\">\"Collected <span class=\"variable\">$value</span>\"</span>) &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[main @coroutine#1] Started simple flow</span><br><span class=\"line\">[main @coroutine#1] Collected 1</span><br><span class=\"line\">[main @coroutine#1] Collected 2</span><br><span class=\"line\">[main @coroutine#1] Collected 3</span><br></pre></td></tr></table></figure>\n<p>由于 simple().collect 是在主线程调用的，那么 simple 的流主体也是在主线程调用的。<br><strong>如果在 调用<code>emit</code>时切换协程上下文，会直接抛出异常</strong></p>\n<ul>\n<li>flowOn: 正确的切换 flow 的上下文</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">log</span><span class=\"params\">(msg: <span class=\"type\">String</span>)</span></span> = println(<span class=\"string\">\"[<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>] <span class=\"variable\">$msg</span>\"</span>)</span><br><span class=\"line\">           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们以消耗 CPU 的方式进行计算</span></span><br><span class=\"line\">        log(<span class=\"string\">\"Emitting <span class=\"variable\">$i</span>\"</span>)</span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发射下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;.flowOn(Dispatchers.Default) <span class=\"comment\">// 在流构建器中改变协程上下文的正确方式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    simple().collect &#123; value -&gt;</span><br><span class=\"line\">        log(<span class=\"string\">\"Collected <span class=\"variable\">$value</span>\"</span>) </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决-背压问题\"><a href=\"#解决-背压问题\" class=\"headerlink\" title=\"解决 背压问题\"></a>解决 背压问题</h2><p>名词解释：<strong>背压： 假设有一个快的数据生产者和一个慢的数据消费者，背压就是一种 “倒逼 “生产者而使自己不被数据淹没的机制</strong></p>\n<h3 id=\"buffer\"><a href=\"#buffer\" class=\"headerlink\" title=\"buffer\"></a>buffer</h3><p>并发运行这个 流中发射元素的代码以及收集的代码， 而不是顺序运行它们； buffer() 会给切换 flow 的协程，保证 发送端 是不阻塞的 。 可以设置 buffer 容量和策略</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们异步等待了 100 毫秒</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发射下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123; </span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        simple()</span><br><span class=\"line\">            .buffer() <span class=\"comment\">// 缓冲发射项，无需等待</span></span><br><span class=\"line\">            .collect &#123; value -&gt; </span><br><span class=\"line\">                delay(<span class=\"number\">300</span>) <span class=\"comment\">// 假装我们花费 300 毫秒来处理它</span></span><br><span class=\"line\">                println(value) </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    println(<span class=\"string\">\"Collected in <span class=\"variable\">$time</span> ms\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"conflate\"><a href=\"#conflate\" class=\"headerlink\" title=\"conflate\"></a>conflate</h3><p>一种特殊 buffer 策略 新数据会覆盖老数据</p>\n<h3 id=\"collectLatest\"><a href=\"#collectLatest\" class=\"headerlink\" title=\"collectLatest\"></a>collectLatest</h3><p>它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们异步等待了 100 毫秒</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发射下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123; </span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        simple()</span><br><span class=\"line\">            .collectLatest &#123; value -&gt; <span class=\"comment\">// 取消并重新发射最后一个值</span></span><br><span class=\"line\">                println(<span class=\"string\">\"Collecting <span class=\"variable\">$value</span>\"</span>) </span><br><span class=\"line\">                delay(<span class=\"number\">300</span>) <span class=\"comment\">// 假装我们花费 300 毫秒来处理它</span></span><br><span class=\"line\">                println(<span class=\"string\">\"Done <span class=\"variable\">$value</span>\"</span>) </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    println(<span class=\"string\">\"Collected in <span class=\"variable\">$time</span> ms\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collecting 1</span><br><span class=\"line\">Collecting 2</span><br><span class=\"line\">Collecting 3</span><br><span class=\"line\">Done 3</span><br><span class=\"line\">Collected in 741 ms</span><br></pre></td></tr></table></figure>\n<h1 id=\"StateFlow\"><a href=\"#StateFlow\" class=\"headerlink\" title=\"StateFlow\"></a>StateFlow</h1><h2 id=\"demo-1\"><a href=\"#demo-1\" class=\"headerlink\" title=\"demo\"></a>demo</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">val</span> flow = MutableStateFlow(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> success = flow.tryEmit(i)</span><br><span class=\"line\">            println(<span class=\"string\">\"tryEmit <span class=\"variable\">$i</span> <span class=\"variable\">$success</span>\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//            delay(200)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@JvmStatic</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span>: <span class=\"built_in\">Unit</span> = runBlocking &#123;</span><br><span class=\"line\">        launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            produce()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        launch(Dispatchers.IO)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            flow.onEach &#123;</span><br><span class=\"line\">                println(<span class=\"string\">\"receive-1 <span class=\"variable\">$it</span>\"</span>)</span><br><span class=\"line\">                delay(<span class=\"number\">500</span>)</span><br><span class=\"line\">            &#125;.launchIn(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"StateFlow-是一个-“流”\"><a href=\"#StateFlow-是一个-“流”\" class=\"headerlink\" title=\"StateFlow 是一个 “流”\"></a>StateFlow 是一个 “流”</h2><p>不同于普通的 flow ， StateFlow 是一个热数据流。 不需要主动调动 collect{…} , 就能 emit 数据</p>\n<h2 id=\"StateFlow-的-collect-是阻塞的，需要在单独的协程中运行\"><a href=\"#StateFlow-的-collect-是阻塞的，需要在单独的协程中运行\" class=\"headerlink\" title=\"StateFlow 的 collect 是阻塞的，需要在单独的协程中运行\"></a>StateFlow 的 collect 是阻塞的，需要在单独的协程中运行</h2><p>在demo中调用了 launchIn ，而不是直接 collect 。 看一下源码</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// StateFlow </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> _state = atomic(initialState)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">collect</span><span class=\"params\">(collector: <span class=\"type\">FlowCollector</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> slot = allocateSlot()</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (collector <span class=\"keyword\">is</span> SubscribedFlowCollector) collector.onSubscription()</span><br><span class=\"line\">            <span class=\"keyword\">val</span> collectorJob = currentCoroutineContext()[Job]</span><br><span class=\"line\">            <span class=\"keyword\">var</span> oldState: Any? = <span class=\"literal\">null</span> </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> newState = _state.value</span><br><span class=\"line\">                collectorJob?.ensureActive()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldState == <span class=\"literal\">null</span> || oldState != newState) &#123;</span><br><span class=\"line\">                    collector.emit(NULL.unbox(newState))</span><br><span class=\"line\">                    oldState = newState</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!slot.takePending()) &#123; <span class=\"comment\">// try fast-path without suspending first</span></span><br><span class=\"line\">                    slot.awaitPending() <span class=\"comment\">// only suspend for new values when needed</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            freeSlot(slot)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，在 collec 中，一个 while 死循环，开始不断读取 _state.value 的值<br>solt 可以看做是 collector 的一个封装。 这里调用了 slot.awaitPending() 来挂起当前协程，让出cpu时间. 看一下 StateFlowSlot 是如何挂起的 </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">awaitPending</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Unit</span> = suspendCancellableCoroutine <span class=\"symbol\">sc@</span> &#123; cont -&gt;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 _state 是 None ，就设置为 cont </span></span><br><span class=\"line\">    <span class=\"comment\">// cont 的类型 CancellableContinuation ，只用调用 resume 或 fail 等，才会结束，否则挂起当前协程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_state.compareAndSet(NONE, cont)) <span class=\"keyword\">return</span><span class=\"symbol\">@sc</span></span><br><span class=\"line\">    cont.resume(<span class=\"built_in\">Unit</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 StateFlow 的 emit 被调用的时候， 会获取到 solt 中的 CancellableContinuation 对象，调用其 resume ，将协程进行唤醒</p>\n<h1 id=\"ShareFlow\"><a href=\"#ShareFlow\" class=\"headerlink\" title=\"ShareFlow\"></a>ShareFlow</h1><h2 id=\"demo-2\"><a href=\"#demo-2\" class=\"headerlink\" title=\"demo\"></a>demo</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> flow = MutableSharedFlow&lt;<span class=\"built_in\">Int</span>&gt;(</span><br><span class=\"line\">    replay = <span class=\"number\">0</span>, </span><br><span class=\"line\">    extraBufferCapacity = <span class=\"number\">100</span>, </span><br><span class=\"line\">    onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> success = flow.tryEmit(i)</span><br><span class=\"line\">        println(<span class=\"string\">\"tryEmit <span class=\"variable\">$i</span> <span class=\"variable\">$success</span>\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//            delay(200)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@JvmStatic</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span>: <span class=\"built_in\">Unit</span> = runBlocking &#123;</span><br><span class=\"line\">    launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        produce()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    launch(Dispatchers.IO)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        flow.onEach &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"receive-1 <span class=\"variable\">$it</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">500</span>)</span><br><span class=\"line\">        &#125;.launchIn(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MutableShareFlow 的三个参数：</p>\n<ul>\n<li>通过 replay ，您可以针对新订阅者重新发送多个之前已发出的值</li>\n<li>extraBufferCapacity: 除了 replay 值以外的缓冲区容量。 extraBufferCapacity + replay 是缓冲区buffer的容量</li>\n<li>通过 onBufferOverflow，您可以指定相关政策来处理缓冲区中已存满要发送的数据项的情况。默认值为 BufferOverflow.SUSPEND，这会使调用方挂起。其他选项包括 DROP_LATEST 或 DROP_OLDEST</li>\n</ul>\n<p>ShareFlow 在收集侧 和 StateFlow 基本一致。 都是 while 死循环，然后将 solt 挂起。 这里不再赘述</p>\n<!-- ## BufferOverflow.SUSPEND, tryEmit 和 Emit\n\n当  -->\n","site":{"data":{}},"excerpt":"<h1 id=\"基础的流\"><a href=\"#基础的流\" class=\"headerlink\" title=\"基础的流\"></a>基础的流</h1><h2 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\">              </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123; <span class=\"comment\">// 流构建器</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们在这里做了一些有用的事情</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发送下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class=\"line\">    launch &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (k <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"I'm not blocked <span class=\"variable\">$k</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">100</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 收集这个流</span></span><br><span class=\"line\">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"\n<h2 id=\"flow-是-”冷流“\"><a href=\"#flow-是-”冷流“\" class=\"headerlink\" title=\"flow 是 ”冷流“\"></a>flow 是 ”冷流“</h2><ul>\n<li>冷流的定义：  flow 构建器中的代码直到流被调用 collect 的时候才运行。</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"type\">&lt;T&gt;</span> <span class=\"title\">flow</span><span class=\"params\">(<span class=\"meta\">@BuilderInference</span> block: <span class=\"type\">suspend</span> <span class=\"type\">FlowCollector</span>&lt;<span class=\"type\">T</span>&gt;.()</span></span> -&gt; <span class=\"built_in\">Unit</span>): Flow&lt;T&gt; = SafeFlow(block)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SafeFlow</span>&lt;<span class=\"type\">T</span>&gt;</span>(<span class=\"keyword\">private</span> <span class=\"keyword\">val</span> block: <span class=\"keyword\">suspend</span> FlowCollector&lt;T&gt;.() -&gt; <span class=\"built_in\">Unit</span>) : AbstractFlow&lt;T&gt;() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">collectSafely</span><span class=\"params\">(collector: <span class=\"type\">FlowCollector</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        collector.block()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FlowCollector</span>&lt;<span class=\"type\">in T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">emit</span><span class=\"params\">(value: <span class=\"type\">T</span>)</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>flow 的实现如上，只不过是传入了 代码块作为 FlowCollector 的拓展函数。<br>当 流开始收集 （调用collect），会执行这个 flow 的代码块。<br>在 collect 中传入的代码块， 实际上是一个 FlowCollector 匿名对象，当 flow 的代码块调用 emit 的时候，就直接调用了 collect 后的代码块。</p>\n<p>用一个例子体现这一点：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        log(<span class=\"string\">\"Emit start <span class=\"variable\">$i</span>\"</span>)</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们异步等待了 100 毫秒</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发射下一个值</span></span><br><span class=\"line\">        log(<span class=\"string\">\"Emit end <span class=\"variable\">$i</span>\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    simple()</span><br><span class=\"line\">        .collect &#123; value -&gt;</span><br><span class=\"line\">            log(<span class=\"string\">\"Collected start <span class=\"variable\">$value</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">300</span>)</span><br><span class=\"line\">            log(<span class=\"string\">\"Collected end <span class=\"variable\">$value</span>\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[main] Emit start 1</span><br><span class=\"line\">[main] Collected start 1</span><br><span class=\"line\">[main] Collected end 1</span><br><span class=\"line\">[main] Emit end 1</span><br></pre></td></tr></table></figure>\n<h2 id=\"流的上下文保存\"><a href=\"#流的上下文保存\" class=\"headerlink\" title=\"流的上下文保存\"></a>流的上下文保存</h2><ul>\n<li>上下文保存： <strong>flow { … } 构建器中的代码运行在相应流的收集器提供的上下文中</strong></li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">log</span><span class=\"params\">(msg: <span class=\"type\">String</span>)</span></span> = println(<span class=\"string\">\"[<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>] <span class=\"variable\">$msg</span>\"</span>)</span><br><span class=\"line\">           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    log(<span class=\"string\">\"Started simple flow\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        emit(i)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    simple().collect &#123; value -&gt; log(<span class=\"string\">\"Collected <span class=\"variable\">$value</span>\"</span>) &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[main @coroutine#1] Started simple flow</span><br><span class=\"line\">[main @coroutine#1] Collected 1</span><br><span class=\"line\">[main @coroutine#1] Collected 2</span><br><span class=\"line\">[main @coroutine#1] Collected 3</span><br></pre></td></tr></table></figure>\n<p>由于 simple().collect 是在主线程调用的，那么 simple 的流主体也是在主线程调用的。<br><strong>如果在 调用<code>emit</code>时切换协程上下文，会直接抛出异常</strong></p>\n<ul>\n<li>flowOn: 正确的切换 flow 的上下文</li>\n</ul>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">log</span><span class=\"params\">(msg: <span class=\"type\">String</span>)</span></span> = println(<span class=\"string\">\"[<span class=\"subst\">$&#123;Thread.currentThread().name&#125;</span>] <span class=\"variable\">$msg</span>\"</span>)</span><br><span class=\"line\">           </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们以消耗 CPU 的方式进行计算</span></span><br><span class=\"line\">        log(<span class=\"string\">\"Emitting <span class=\"variable\">$i</span>\"</span>)</span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发射下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;.flowOn(Dispatchers.Default) <span class=\"comment\">// 在流构建器中改变协程上下文的正确方式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123;</span><br><span class=\"line\">    simple().collect &#123; value -&gt;</span><br><span class=\"line\">        log(<span class=\"string\">\"Collected <span class=\"variable\">$value</span>\"</span>) </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决-背压问题\"><a href=\"#解决-背压问题\" class=\"headerlink\" title=\"解决 背压问题\"></a>解决 背压问题</h2><p>名词解释：<strong>背压： 假设有一个快的数据生产者和一个慢的数据消费者，背压就是一种 “倒逼 “生产者而使自己不被数据淹没的机制</strong></p>\n<h3 id=\"buffer\"><a href=\"#buffer\" class=\"headerlink\" title=\"buffer\"></a>buffer</h3><p>并发运行这个 流中发射元素的代码以及收集的代码， 而不是顺序运行它们； buffer() 会给切换 flow 的协程，保证 发送端 是不阻塞的 。 可以设置 buffer 容量和策略</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们异步等待了 100 毫秒</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发射下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123; </span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        simple()</span><br><span class=\"line\">            .buffer() <span class=\"comment\">// 缓冲发射项，无需等待</span></span><br><span class=\"line\">            .collect &#123; value -&gt; </span><br><span class=\"line\">                delay(<span class=\"number\">300</span>) <span class=\"comment\">// 假装我们花费 300 毫秒来处理它</span></span><br><span class=\"line\">                println(value) </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    println(<span class=\"string\">\"Collected in <span class=\"variable\">$time</span> ms\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"conflate\"><a href=\"#conflate\" class=\"headerlink\" title=\"conflate\"></a>conflate</h3><p>一种特殊 buffer 策略 新数据会覆盖老数据</p>\n<h3 id=\"collectLatest\"><a href=\"#collectLatest\" class=\"headerlink\" title=\"collectLatest\"></a>collectLatest</h3><p>它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlinx.coroutines.flow.*</span><br><span class=\"line\"><span class=\"keyword\">import</span> kotlin.system.*</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">simple</span><span class=\"params\">()</span></span>: Flow&lt;<span class=\"built_in\">Int</span>&gt; = flow &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">100</span>) <span class=\"comment\">// 假装我们异步等待了 100 毫秒</span></span><br><span class=\"line\">        emit(i) <span class=\"comment\">// 发射下一个值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> = runBlocking&lt;<span class=\"built_in\">Unit</span>&gt; &#123; </span><br><span class=\"line\">    <span class=\"keyword\">val</span> time = measureTimeMillis &#123;</span><br><span class=\"line\">        simple()</span><br><span class=\"line\">            .collectLatest &#123; value -&gt; <span class=\"comment\">// 取消并重新发射最后一个值</span></span><br><span class=\"line\">                println(<span class=\"string\">\"Collecting <span class=\"variable\">$value</span>\"</span>) </span><br><span class=\"line\">                delay(<span class=\"number\">300</span>) <span class=\"comment\">// 假装我们花费 300 毫秒来处理它</span></span><br><span class=\"line\">                println(<span class=\"string\">\"Done <span class=\"variable\">$value</span>\"</span>) </span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    println(<span class=\"string\">\"Collected in <span class=\"variable\">$time</span> ms\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collecting 1</span><br><span class=\"line\">Collecting 2</span><br><span class=\"line\">Collecting 3</span><br><span class=\"line\">Done 3</span><br><span class=\"line\">Collected in 741 ms</span><br></pre></td></tr></table></figure>\n<h1 id=\"StateFlow\"><a href=\"#StateFlow\" class=\"headerlink\" title=\"StateFlow\"></a>StateFlow</h1><h2 id=\"demo-1\"><a href=\"#demo-1\" class=\"headerlink\" title=\"demo\"></a>demo</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">val</span> flow = MutableStateFlow(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> success = flow.tryEmit(i)</span><br><span class=\"line\">            println(<span class=\"string\">\"tryEmit <span class=\"variable\">$i</span> <span class=\"variable\">$success</span>\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//            delay(200)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@JvmStatic</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span>: <span class=\"built_in\">Unit</span> = runBlocking &#123;</span><br><span class=\"line\">        launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">            delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">            produce()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        launch(Dispatchers.IO)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            flow.onEach &#123;</span><br><span class=\"line\">                println(<span class=\"string\">\"receive-1 <span class=\"variable\">$it</span>\"</span>)</span><br><span class=\"line\">                delay(<span class=\"number\">500</span>)</span><br><span class=\"line\">            &#125;.launchIn(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"StateFlow-是一个-“流”\"><a href=\"#StateFlow-是一个-“流”\" class=\"headerlink\" title=\"StateFlow 是一个 “流”\"></a>StateFlow 是一个 “流”</h2><p>不同于普通的 flow ， StateFlow 是一个热数据流。 不需要主动调动 collect{…} , 就能 emit 数据</p>\n<h2 id=\"StateFlow-的-collect-是阻塞的，需要在单独的协程中运行\"><a href=\"#StateFlow-的-collect-是阻塞的，需要在单独的协程中运行\" class=\"headerlink\" title=\"StateFlow 的 collect 是阻塞的，需要在单独的协程中运行\"></a>StateFlow 的 collect 是阻塞的，需要在单独的协程中运行</h2><p>在demo中调用了 launchIn ，而不是直接 collect 。 看一下源码</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// StateFlow </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> _state = atomic(initialState)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">collect</span><span class=\"params\">(collector: <span class=\"type\">FlowCollector</span>&lt;<span class=\"type\">T</span>&gt;)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> slot = allocateSlot()</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (collector <span class=\"keyword\">is</span> SubscribedFlowCollector) collector.onSubscription()</span><br><span class=\"line\">            <span class=\"keyword\">val</span> collectorJob = currentCoroutineContext()[Job]</span><br><span class=\"line\">            <span class=\"keyword\">var</span> oldState: Any? = <span class=\"literal\">null</span> </span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">val</span> newState = _state.value</span><br><span class=\"line\">                collectorJob?.ensureActive()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (oldState == <span class=\"literal\">null</span> || oldState != newState) &#123;</span><br><span class=\"line\">                    collector.emit(NULL.unbox(newState))</span><br><span class=\"line\">                    oldState = newState</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!slot.takePending()) &#123; <span class=\"comment\">// try fast-path without suspending first</span></span><br><span class=\"line\">                    slot.awaitPending() <span class=\"comment\">// only suspend for new values when needed</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            freeSlot(slot)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，在 collec 中，一个 while 死循环，开始不断读取 _state.value 的值<br>solt 可以看做是 collector 的一个封装。 这里调用了 slot.awaitPending() 来挂起当前协程，让出cpu时间. 看一下 StateFlowSlot 是如何挂起的 </p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">awaitPending</span><span class=\"params\">()</span></span>: <span class=\"built_in\">Unit</span> = suspendCancellableCoroutine <span class=\"symbol\">sc@</span> &#123; cont -&gt;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 _state 是 None ，就设置为 cont </span></span><br><span class=\"line\">    <span class=\"comment\">// cont 的类型 CancellableContinuation ，只用调用 resume 或 fail 等，才会结束，否则挂起当前协程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_state.compareAndSet(NONE, cont)) <span class=\"keyword\">return</span><span class=\"symbol\">@sc</span></span><br><span class=\"line\">    cont.resume(<span class=\"built_in\">Unit</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 StateFlow 的 emit 被调用的时候， 会获取到 solt 中的 CancellableContinuation 对象，调用其 resume ，将协程进行唤醒</p>\n<h1 id=\"ShareFlow\"><a href=\"#ShareFlow\" class=\"headerlink\" title=\"ShareFlow\"></a>ShareFlow</h1><h2 id=\"demo-2\"><a href=\"#demo-2\" class=\"headerlink\" title=\"demo\"></a>demo</h2><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">val</span> flow = MutableSharedFlow&lt;<span class=\"built_in\">Int</span>&gt;(</span><br><span class=\"line\">    replay = <span class=\"number\">0</span>, </span><br><span class=\"line\">    extraBufferCapacity = <span class=\"number\">100</span>, </span><br><span class=\"line\">    onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">suspend</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">produce</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">val</span> success = flow.tryEmit(i)</span><br><span class=\"line\">        println(<span class=\"string\">\"tryEmit <span class=\"variable\">$i</span> <span class=\"variable\">$success</span>\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//            delay(200)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@JvmStatic</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">main</span><span class=\"params\">(args: <span class=\"type\">Array</span>&lt;<span class=\"type\">String</span>&gt;)</span></span>: <span class=\"built_in\">Unit</span> = runBlocking &#123;</span><br><span class=\"line\">    launch(Dispatchers.IO) &#123;</span><br><span class=\"line\">        delay(<span class=\"number\">1000</span>)</span><br><span class=\"line\">        produce()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    launch(Dispatchers.IO)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        flow.onEach &#123;</span><br><span class=\"line\">            println(<span class=\"string\">\"receive-1 <span class=\"variable\">$it</span>\"</span>)</span><br><span class=\"line\">            delay(<span class=\"number\">500</span>)</span><br><span class=\"line\">        &#125;.launchIn(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MutableShareFlow 的三个参数：</p>\n<ul>\n<li>通过 replay ，您可以针对新订阅者重新发送多个之前已发出的值</li>\n<li>extraBufferCapacity: 除了 replay 值以外的缓冲区容量。 extraBufferCapacity + replay 是缓冲区buffer的容量</li>\n<li>通过 onBufferOverflow，您可以指定相关政策来处理缓冲区中已存满要发送的数据项的情况。默认值为 BufferOverflow.SUSPEND，这会使调用方挂起。其他选项包括 DROP_LATEST 或 DROP_OLDEST</li>\n</ul>\n<p>ShareFlow 在收集侧 和 StateFlow 基本一致。 都是 while 死循环，然后将 solt 挂起。 这里不再赘述</p>\n<!-- ## BufferOverflow.SUSPEND, tryEmit 和 Emit\n\n当  -->\n"},{"title":"docker的使用","date":"2019-11-12T08:09:50.000Z","_content":"\n# docker 的使用\n\n## Docker 和 虚拟机的区别:\n\n- 实现资源隔离的方式不同:\n  - 虚拟机:\n    利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行\n  - Docker:\n    应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值\n- 隔离性:\n  虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker\n- 性能:\n  docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化\n\n## Docker Toolbox\n\n因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版.\n\n## Docker Toolbox 添加镜像加速\n\n可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题.\n\n可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好\n\n具体的配置修改, 参考:\n[http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox]()\n\n## image, container\n\n### image:\n\n镜像. 是一个包含有文件系统的面向 Docker 引擎的**只读模板**. 可以是从远端拉取的, 也可以是自己制作的\n\n### container:\n\n容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. **注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。**\n\n## 常用操作\n\n### [https://www.runoob.com/docker/docker-container-usage.html]()\n\n很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方\n\n### docker container run\n\n```shell\ndocker run -it --name string ubuntu:latest /bin/bash\n```\n\n参数说明:\n\n- -i: 交互式操作。\n- -t: 终端。\n- ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。\n- /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。\n- --name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字\n\n**注意**\n**image 每一次 docker run 之后, 都会启动一个不同的 container**, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令\n\n### 将容器转化为一个镜像\n\n```shell\ndocker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2\n```\n\n- -m: 提交的描述信息\n- -a: 指定镜像作者\n- e218edb10161：容器 ID\n- runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag\n\n**注意** 如果要制作的 image 打包上传到自己 docker hub, ' / ' 前面的用户名需要和自己 docker hub 的用户名保持一致\n\n### 使用 Dockerfile 创建镜像\n\n没试过... 以后有机会再写上\n","source":"_posts/Linux/docker的使用.md","raw":"---\ntitle: docker的使用\ndate: 2019-11-12 16:09:50\ntags:\n- Linux\n- Docker\ncategories:\n- Linux\n---\n\n# docker 的使用\n\n## Docker 和 虚拟机的区别:\n\n- 实现资源隔离的方式不同:\n  - 虚拟机:\n    利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行\n  - Docker:\n    应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值\n- 隔离性:\n  虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker\n- 性能:\n  docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化\n\n## Docker Toolbox\n\n因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版.\n\n## Docker Toolbox 添加镜像加速\n\n可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题.\n\n可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好\n\n具体的配置修改, 参考:\n[http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox]()\n\n## image, container\n\n### image:\n\n镜像. 是一个包含有文件系统的面向 Docker 引擎的**只读模板**. 可以是从远端拉取的, 也可以是自己制作的\n\n### container:\n\n容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. **注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。**\n\n## 常用操作\n\n### [https://www.runoob.com/docker/docker-container-usage.html]()\n\n很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方\n\n### docker container run\n\n```shell\ndocker run -it --name string ubuntu:latest /bin/bash\n```\n\n参数说明:\n\n- -i: 交互式操作。\n- -t: 终端。\n- ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。\n- /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。\n- --name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字\n\n**注意**\n**image 每一次 docker run 之后, 都会启动一个不同的 container**, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令\n\n### 将容器转化为一个镜像\n\n```shell\ndocker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2\n```\n\n- -m: 提交的描述信息\n- -a: 指定镜像作者\n- e218edb10161：容器 ID\n- runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag\n\n**注意** 如果要制作的 image 打包上传到自己 docker hub, ' / ' 前面的用户名需要和自己 docker hub 的用户名保持一致\n\n### 使用 Dockerfile 创建镜像\n\n没试过... 以后有机会再写上\n","slug":"Linux/docker的使用","published":1,"updated":"2021-10-03T01:57:41.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8r003xg0jex91yx54z","content":"<h1 id=\"docker-的使用\"><a href=\"#docker-的使用\" class=\"headerlink\" title=\"docker 的使用\"></a>docker 的使用</h1><h2 id=\"Docker-和-虚拟机的区别\"><a href=\"#Docker-和-虚拟机的区别\" class=\"headerlink\" title=\"Docker 和 虚拟机的区别:\"></a>Docker 和 虚拟机的区别:</h2><a id=\"more\"></a><ul>\n<li>实现资源隔离的方式不同:<ul>\n<li>虚拟机:<br>利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行</li>\n<li>Docker:<br>应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值</li>\n</ul>\n</li>\n<li>隔离性:<br>虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker</li>\n<li>性能:<br>docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化</li>\n</ul>\n<h2 id=\"Docker-Toolbox\"><a href=\"#Docker-Toolbox\" class=\"headerlink\" title=\"Docker Toolbox\"></a>Docker Toolbox</h2><p>因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版.</p>\n<h2 id=\"Docker-Toolbox-添加镜像加速\"><a href=\"#Docker-Toolbox-添加镜像加速\" class=\"headerlink\" title=\"Docker Toolbox 添加镜像加速\"></a>Docker Toolbox 添加镜像加速</h2><p>可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题.</p>\n<p>可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好</p>\n<p>具体的配置修改, 参考:<br><a href>http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox</a></p>\n<h2 id=\"image-container\"><a href=\"#image-container\" class=\"headerlink\" title=\"image, container\"></a>image, container</h2><h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image:\"></a>image:</h3><p>镜像. 是一个包含有文件系统的面向 Docker 引擎的<strong>只读模板</strong>. 可以是从远端拉取的, 也可以是自己制作的</p>\n<h3 id=\"container\"><a href=\"#container\" class=\"headerlink\" title=\"container:\"></a>container:</h3><p>容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. <strong>注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。</strong></p>\n<h2 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h2><h3 id=\"https-www-runoob-com-docker-docker-container-usage-html\"><a href=\"#https-www-runoob-com-docker-docker-container-usage-html\" class=\"headerlink\" title=\"https://www.runoob.com/docker/docker-container-usage.html\"></a><a href>https://www.runoob.com/docker/docker-container-usage.html</a></h3><p>很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方</p>\n<h3 id=\"docker-container-run\"><a href=\"#docker-container-run\" class=\"headerlink\" title=\"docker container run\"></a>docker container run</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --name string ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>\n<p>参数说明:</p>\n<ul>\n<li>-i: 交互式操作。</li>\n<li>-t: 终端。</li>\n<li>ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。</li>\n<li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>\n<li>–name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字</li>\n</ul>\n<p><strong>注意</strong><br><strong>image 每一次 docker run 之后, 都会启动一个不同的 container</strong>, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令</p>\n<h3 id=\"将容器转化为一个镜像\"><a href=\"#将容器转化为一个镜像\" class=\"headerlink\" title=\"将容器转化为一个镜像\"></a>将容器转化为一个镜像</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-m: 提交的描述信息</li>\n<li>-a: 指定镜像作者</li>\n<li>e218edb10161：容器 ID</li>\n<li>runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag</li>\n</ul>\n<p><strong>注意</strong> 如果要制作的 image 打包上传到自己 docker hub, ‘ / ‘ 前面的用户名需要和自己 docker hub 的用户名保持一致</p>\n<h3 id=\"使用-Dockerfile-创建镜像\"><a href=\"#使用-Dockerfile-创建镜像\" class=\"headerlink\" title=\"使用 Dockerfile 创建镜像\"></a>使用 Dockerfile 创建镜像</h3><p>没试过… 以后有机会再写上</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"docker-的使用\"><a href=\"#docker-的使用\" class=\"headerlink\" title=\"docker 的使用\"></a>docker 的使用</h1><h2 id=\"Docker-和-虚拟机的区别\"><a href=\"#Docker-和-虚拟机的区别\" class=\"headerlink\" title=\"Docker 和 虚拟机的区别:\"></a>Docker 和 虚拟机的区别:</h2>","more":"<ul>\n<li>实现资源隔离的方式不同:<ul>\n<li>虚拟机:<br>利用独立的 guest os, 并利用 Hypervisor 虚拟化硬件设备. 应用及其依赖在各自的 Guest Os 上运行</li>\n<li>Docker:<br>应用运行在各自的容器之中. 容器只是宿主机中的一个应用进程. Docker 利用 Linux 内核特性实现的隔离, 和宿主机共享资源, 共用一个内核. 使用到的 Linux 内核特性包括: 1. 使用 Namespace 机制实现系统环境的隔离. Namespaces 允许一个进程以及它的子进程从共享的宿主机内核资源里获得一个仅自己可见的隔离区域 2. 使用 CGroups 机制限制每个容器进程能够消耗资源的最大值</li>\n</ul>\n</li>\n<li>隔离性:<br>虚拟机的隔离性强于 docker, docker 属于进程级别的隔离, 虚拟机可以实现系统级别的隔离. 由此也造成了虚拟机的安全性要强于 docker</li>\n<li>性能:<br>docker 容器和内核交互，几乎没有性能损耗，性能优于虚拟机通过 Hypervisor 层与内核层的虚拟化</li>\n</ul>\n<h2 id=\"Docker-Toolbox\"><a href=\"#Docker-Toolbox\" class=\"headerlink\" title=\"Docker Toolbox\"></a>Docker Toolbox</h2><p>因为我目前使用的 Windows 系统, 所以使用 Docker Toolbox for windows 版本的. 虽然有更好的 Docker for Windows 版本, 但是, 那个只支持 Windows 企业版和专业版. 我的系统是 Windows 家庭版.</p>\n<h2 id=\"Docker-Toolbox-添加镜像加速\"><a href=\"#Docker-Toolbox-添加镜像加速\" class=\"headerlink\" title=\"Docker Toolbox 添加镜像加速\"></a>Docker Toolbox 添加镜像加速</h2><p>可能是因为墙的关系, 安装之后从官方源 pull 容器时, 总是 timeout, 后来使用加速器可以解决这个问题.</p>\n<p>可以使用阿里云和 DaoCloud 镜像加速, 感觉 DaoCloud 效果更好</p>\n<p>具体的配置修改, 参考:<br><a href>http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox</a></p>\n<h2 id=\"image-container\"><a href=\"#image-container\" class=\"headerlink\" title=\"image, container\"></a>image, container</h2><h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image:\"></a>image:</h3><p>镜像. 是一个包含有文件系统的面向 Docker 引擎的<strong>只读模板</strong>. 可以是从远端拉取的, 也可以是自己制作的</p>\n<h3 id=\"container\"><a href=\"#container\" class=\"headerlink\" title=\"container:\"></a>container:</h3><p>容器. 类似于一个轻量级的沙盒，可以将其看作一个极简的 Linux 系统环境（包括 root 权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序. 容器是镜像创建的应用实例. <strong>注意：镜像本身是只读的，容器从镜像启动时，Docker 在镜像的上层创建一个可写层，镜像本身不变。</strong></p>\n<h2 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h2><h3 id=\"https-www-runoob-com-docker-docker-container-usage-html\"><a href=\"#https-www-runoob-com-docker-docker-container-usage-html\" class=\"headerlink\" title=\"https://www.runoob.com/docker/docker-container-usage.html\"></a><a href>https://www.runoob.com/docker/docker-container-usage.html</a></h3><p>很多常用操作都可以在上面的链接上找到, 我就不写了. 下面介绍一些操作中需要注意的地方</p>\n<h3 id=\"docker-container-run\"><a href=\"#docker-container-run\" class=\"headerlink\" title=\"docker container run\"></a>docker container run</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --name string ubuntu:latest /bin/bash</span><br></pre></td></tr></table></figure>\n<p>参数说明:</p>\n<ul>\n<li>-i: 交互式操作。</li>\n<li>-t: 终端。</li>\n<li>ubuntu:latest: 名称为 ubuntu, tag 为 latest 的镜像。</li>\n<li>/bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>\n<li>–name: 重命名. 最好重命名, 如果没有这个参数, docker 会自动为容器创建一个很奇怪的名字</li>\n</ul>\n<p><strong>注意</strong><br><strong>image 每一次 docker run 之后, 都会启动一个不同的 container</strong>, 并且创建出的不同的 container 都会是 image 的初始状态. 如果想要在上一次的 container 的修改上继续操作, 需要执行 container start 命令</p>\n<h3 id=\"将容器转化为一个镜像\"><a href=\"#将容器转化为一个镜像\" class=\"headerlink\" title=\"将容器转化为一个镜像\"></a>将容器转化为一个镜像</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit -m=\"has update\" -a=\"runoob\" e218edb10161 runoob/ubuntu:v2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>-m: 提交的描述信息</li>\n<li>-a: 指定镜像作者</li>\n<li>e218edb10161：容器 ID</li>\n<li>runoob/ubuntu:v2: 指定要创建的目标镜像名, runoob 为用户名, v2 为 tag</li>\n</ul>\n<p><strong>注意</strong> 如果要制作的 image 打包上传到自己 docker hub, ‘ / ‘ 前面的用户名需要和自己 docker hub 的用户名保持一致</p>\n<h3 id=\"使用-Dockerfile-创建镜像\"><a href=\"#使用-Dockerfile-创建镜像\" class=\"headerlink\" title=\"使用 Dockerfile 创建镜像\"></a>使用 Dockerfile 创建镜像</h3><p>没试过… 以后有机会再写上</p>\n"},{"title":"mysql配置相关","date":"2019-05-04T03:04:44.000Z","_content":"\n## 1. 尽量使用MariaDB而不是mysql\n\n之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0\n但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为**mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码**\n于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了\n\n而且，mysql的命令行终端很明显有bug，没有MariaDB好用\n\n## 2. MariaDB更新密码\nmariadb的安装可以查看官网，上面有yum安装的教程。\n安装之后默认是没有密码的。需要更新密码。\n另外，**发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的**\n\n中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ''@'localhost'之类的报错。没有找到原因和解决办法，最后是直接重置了vps\n\n#### 1. mysql_secure_installation 命令\n安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码\n\n#### 2. 登陆mysql更改密码\n\n```shell\n# 2.1 更新 mysql 库中 user 表的字段：\nuse mysql;  \nUPDATE user SET password=password('newpassword') WHERE user='root';  \nflush privileges;  \nexit;\n \n# 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法\nSET password for 'root'@'localhost'=password('newpassword');  \n\n```\n\n\n## 3. mysql配置远程登录\n\n#### 1. 给用户远程登录权限：\n```sql\nuse mysql\nupdate user set host='%' where user ='root';\nFLUSH PRIVILEGES;\ngrant all privileges  on *.* to root@'%' identified by \"password\";\nFLUSH PRIVILEGES;\n```\n\nroot可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码\n\n使用以下命令可以查看用户的登录权限\n\n```shell\nselect host,user,password,plugin from user;\n```\n\n**注意**\nroot密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。\n可以使用如下命令更改加密方式：\n\n```sql\nupdate user set plugin='mysql_native_password' where user='root';\n```\n\n#### 2. lnmp环境配置iptables\n\nlnmp一键安装环境默认是禁用iptables远程登录的，\n\n* 查看iptables规则：\n```shell\niptables -L -n --line-numbers\n```\n输入样例如下：\n![图片](/images/mysql_iptables.png)\n可以看到3306端口的target为drop\n\n* 删除对应的drop规则\n\n```shell\niptables -D INPUT 5\n```\n\n\niptables的使用参考：\n[https://www.vpser.net/security/linux-iptables.html]()\n\n#### 3.非集成centos环境开放3306端口\n\n##### centos-7以上\n\nfirewalld 防火墙（centos-7）运行命令,并重启：\n\n```shell\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\nfirewall-cmd --reload\n```\n\n##### centos-7以前\niptables 防火墙（centos6.5及其以前）运行命令\n\n```shell\nvim /etc/sysconfig/iptables\n```\n\n在文件内添加下面命令行，然后重启\n\n```shell\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\n```\n\n```shell\nservice iptables restart\n```\n\n\n","source":"_posts/Linux/mysql配置相关.md","raw":"---\ntitle: mysql配置相关\ndate: 2019-05-04 11:04:44\ntags:\n- mysql\n- Linux\ncategories:\n- Linux\n---\n\n## 1. 尽量使用MariaDB而不是mysql\n\n之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0\n但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为**mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码**\n于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了\n\n而且，mysql的命令行终端很明显有bug，没有MariaDB好用\n\n## 2. MariaDB更新密码\nmariadb的安装可以查看官网，上面有yum安装的教程。\n安装之后默认是没有密码的。需要更新密码。\n另外，**发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的**\n\n中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ''@'localhost'之类的报错。没有找到原因和解决办法，最后是直接重置了vps\n\n#### 1. mysql_secure_installation 命令\n安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码\n\n#### 2. 登陆mysql更改密码\n\n```shell\n# 2.1 更新 mysql 库中 user 表的字段：\nuse mysql;  \nUPDATE user SET password=password('newpassword') WHERE user='root';  \nflush privileges;  \nexit;\n \n# 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法\nSET password for 'root'@'localhost'=password('newpassword');  \n\n```\n\n\n## 3. mysql配置远程登录\n\n#### 1. 给用户远程登录权限：\n```sql\nuse mysql\nupdate user set host='%' where user ='root';\nFLUSH PRIVILEGES;\ngrant all privileges  on *.* to root@'%' identified by \"password\";\nFLUSH PRIVILEGES;\n```\n\nroot可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码\n\n使用以下命令可以查看用户的登录权限\n\n```shell\nselect host,user,password,plugin from user;\n```\n\n**注意**\nroot密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。\n可以使用如下命令更改加密方式：\n\n```sql\nupdate user set plugin='mysql_native_password' where user='root';\n```\n\n#### 2. lnmp环境配置iptables\n\nlnmp一键安装环境默认是禁用iptables远程登录的，\n\n* 查看iptables规则：\n```shell\niptables -L -n --line-numbers\n```\n输入样例如下：\n![图片](/images/mysql_iptables.png)\n可以看到3306端口的target为drop\n\n* 删除对应的drop规则\n\n```shell\niptables -D INPUT 5\n```\n\n\niptables的使用参考：\n[https://www.vpser.net/security/linux-iptables.html]()\n\n#### 3.非集成centos环境开放3306端口\n\n##### centos-7以上\n\nfirewalld 防火墙（centos-7）运行命令,并重启：\n\n```shell\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\nfirewall-cmd --reload\n```\n\n##### centos-7以前\niptables 防火墙（centos6.5及其以前）运行命令\n\n```shell\nvim /etc/sysconfig/iptables\n```\n\n在文件内添加下面命令行，然后重启\n\n```shell\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\n```\n\n```shell\nservice iptables restart\n```\n\n\n","slug":"Linux/mysql配置相关","published":1,"updated":"2021-10-03T01:57:41.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8s003zg0jeybeyaba9","content":"<h2 id=\"1-尽量使用MariaDB而不是mysql\"><a href=\"#1-尽量使用MariaDB而不是mysql\" class=\"headerlink\" title=\"1. 尽量使用MariaDB而不是mysql\"></a>1. 尽量使用MariaDB而不是mysql</h2><a id=\"more\"></a><p>之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0<br>但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为<strong>mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码</strong><br>于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了</p>\n<p>而且，mysql的命令行终端很明显有bug，没有MariaDB好用</p>\n<h2 id=\"2-MariaDB更新密码\"><a href=\"#2-MariaDB更新密码\" class=\"headerlink\" title=\"2. MariaDB更新密码\"></a>2. MariaDB更新密码</h2><p>mariadb的安装可以查看官网，上面有yum安装的教程。<br>安装之后默认是没有密码的。需要更新密码。<br>另外，<strong>发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的</strong></p>\n<p>中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ‘‘@’localhost’之类的报错。没有找到原因和解决办法，最后是直接重置了vps</p>\n<h4 id=\"1-mysql-secure-installation-命令\"><a href=\"#1-mysql-secure-installation-命令\" class=\"headerlink\" title=\"1. mysql_secure_installation 命令\"></a>1. mysql_secure_installation 命令</h4><p>安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码</p>\n<h4 id=\"2-登陆mysql更改密码\"><a href=\"#2-登陆mysql更改密码\" class=\"headerlink\" title=\"2. 登陆mysql更改密码\"></a>2. 登陆mysql更改密码</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 2.1 更新 mysql 库中 user 表的字段：</span><br><span class=\"line\">use mysql;  </span><br><span class=\"line\">UPDATE user SET password=password('newpassword') WHERE user='root';  </span><br><span class=\"line\">flush privileges;  </span><br><span class=\"line\">exit;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span> 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法</span><br><span class=\"line\">SET password for 'root'@'localhost'=password('newpassword');</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-mysql配置远程登录\"><a href=\"#3-mysql配置远程登录\" class=\"headerlink\" title=\"3. mysql配置远程登录\"></a>3. mysql配置远程登录</h2><h4 id=\"1-给用户远程登录权限：\"><a href=\"#1-给用户远程登录权限：\" class=\"headerlink\" title=\"1. 给用户远程登录权限：\"></a>1. 给用户远程登录权限：</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> mysql</span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> host=<span class=\"string\">'%'</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span> =<span class=\"string\">'root'</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">all</span> <span class=\"keyword\">privileges</span>  <span class=\"keyword\">on</span> *.* <span class=\"keyword\">to</span> root@<span class=\"string\">'%'</span> <span class=\"keyword\">identified</span> <span class=\"keyword\">by</span> <span class=\"string\">\"password\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>\n<p>root可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码</p>\n<p>使用以下命令可以查看用户的登录权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select host,user,password,plugin from user;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong><br>root密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。<br>可以使用如下命令更改加密方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> <span class=\"keyword\">plugin</span>=<span class=\"string\">'mysql_native_password'</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span>=<span class=\"string\">'root'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-lnmp环境配置iptables\"><a href=\"#2-lnmp环境配置iptables\" class=\"headerlink\" title=\"2. lnmp环境配置iptables\"></a>2. lnmp环境配置iptables</h4><p>lnmp一键安装环境默认是禁用iptables远程登录的，</p>\n<ul>\n<li>查看iptables规则：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -L -n --line-numbers</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入样例如下：<br><img src=\"/images/mysql_iptables.png\" alt=\"图片\"><br>可以看到3306端口的target为drop</p>\n<ul>\n<li>删除对应的drop规则</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -D INPUT 5</span><br></pre></td></tr></table></figure>\n<p>iptables的使用参考：<br><a href>https://www.vpser.net/security/linux-iptables.html</a></p>\n<h4 id=\"3-非集成centos环境开放3306端口\"><a href=\"#3-非集成centos环境开放3306端口\" class=\"headerlink\" title=\"3.非集成centos环境开放3306端口\"></a>3.非集成centos环境开放3306端口</h4><h5 id=\"centos-7以上\"><a href=\"#centos-7以上\" class=\"headerlink\" title=\"centos-7以上\"></a>centos-7以上</h5><p>firewalld 防火墙（centos-7）运行命令,并重启：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<h5 id=\"centos-7以前\"><a href=\"#centos-7以前\" class=\"headerlink\" title=\"centos-7以前\"></a>centos-7以前</h5><p>iptables 防火墙（centos6.5及其以前）运行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>\n<p>在文件内添加下面命令行，然后重启</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service iptables restart</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-尽量使用MariaDB而不是mysql\"><a href=\"#1-尽量使用MariaDB而不是mysql\" class=\"headerlink\" title=\"1. 尽量使用MariaDB而不是mysql\"></a>1. 尽量使用MariaDB而不是mysql</h2>","more":"<p>之前有配置过mycat，刚开始使用的mysql，使用yum安装的，默认版本为8.0<br>但是安装之后mycat始终无法登陆，输入密码后总是显示密码错误。后来google了一下，发现是因为<strong>mysql8.0的加密方式发生了编码，导致mycat无法正确识别密码</strong><br>于是尝试切换到5.7版本，但是使用yum安装无论如何都无法切换到我想要的版本。重装为MariaDB后没有这个问题了</p>\n<p>而且，mysql的命令行终端很明显有bug，没有MariaDB好用</p>\n<h2 id=\"2-MariaDB更新密码\"><a href=\"#2-MariaDB更新密码\" class=\"headerlink\" title=\"2. MariaDB更新密码\"></a>2. MariaDB更新密码</h2><p>mariadb的安装可以查看官网，上面有yum安装的教程。<br>安装之后默认是没有密码的。需要更新密码。<br>另外，<strong>发现mariadb在本机是可以不需要密码直接登陆的，不知道原因。但是远程登陆是一定要密码的</strong></p>\n<p>中间出现过很奇怪的现象：一同不知道啥的操作之后，输入root密码总是显示密码错误。跳过密码直接回车可以登陆，但是use mysql;命令之后出现access deny ‘‘@’localhost’之类的报错。没有找到原因和解决办法，最后是直接重置了vps</p>\n<h4 id=\"1-mysql-secure-installation-命令\"><a href=\"#1-mysql-secure-installation-命令\" class=\"headerlink\" title=\"1. mysql_secure_installation 命令\"></a>1. mysql_secure_installation 命令</h4><p>安装之后调用mysql_secure_installation 命令，进入到mariadb的初始化，可以设置密码</p>\n<h4 id=\"2-登陆mysql更改密码\"><a href=\"#2-登陆mysql更改密码\" class=\"headerlink\" title=\"2. 登陆mysql更改密码\"></a>2. 登陆mysql更改密码</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span> 2.1 更新 mysql 库中 user 表的字段：</span><br><span class=\"line\">use mysql;  </span><br><span class=\"line\">UPDATE user SET password=password('newpassword') WHERE user='root';  </span><br><span class=\"line\">flush privileges;  </span><br><span class=\"line\">exit;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#</span> 2.2 或者，使用 set 指令设置root密码：在mariadb 10.4之后的版本只能使用该方法</span><br><span class=\"line\">SET password for 'root'@'localhost'=password('newpassword');</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-mysql配置远程登录\"><a href=\"#3-mysql配置远程登录\" class=\"headerlink\" title=\"3. mysql配置远程登录\"></a>3. mysql配置远程登录</h2><h4 id=\"1-给用户远程登录权限：\"><a href=\"#1-给用户远程登录权限：\" class=\"headerlink\" title=\"1. 给用户远程登录权限：\"></a>1. 给用户远程登录权限：</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> mysql</span><br><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> host=<span class=\"string\">'%'</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span> =<span class=\"string\">'root'</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">all</span> <span class=\"keyword\">privileges</span>  <span class=\"keyword\">on</span> *.* <span class=\"keyword\">to</span> root@<span class=\"string\">'%'</span> <span class=\"keyword\">identified</span> <span class=\"keyword\">by</span> <span class=\"string\">\"password\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">FLUSH</span> <span class=\"keyword\">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure>\n<p>root可以替换为其他用户名， %表示任意ip， 也可以换成指定的ip， password替换成密码</p>\n<p>使用以下命令可以查看用户的登录权限</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select host,user,password,plugin from user;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong><br>root密码的加密方式最好为mysql_native_password，这样子使用中间件登陆才不会出问题。<br>可以使用如下命令更改加密方式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">update</span> <span class=\"keyword\">user</span> <span class=\"keyword\">set</span> <span class=\"keyword\">plugin</span>=<span class=\"string\">'mysql_native_password'</span> <span class=\"keyword\">where</span> <span class=\"keyword\">user</span>=<span class=\"string\">'root'</span>;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-lnmp环境配置iptables\"><a href=\"#2-lnmp环境配置iptables\" class=\"headerlink\" title=\"2. lnmp环境配置iptables\"></a>2. lnmp环境配置iptables</h4><p>lnmp一键安装环境默认是禁用iptables远程登录的，</p>\n<ul>\n<li>查看iptables规则：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -L -n --line-numbers</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>输入样例如下：<br><img src=\"/images/mysql_iptables.png\" alt=\"图片\"><br>可以看到3306端口的target为drop</p>\n<ul>\n<li>删除对应的drop规则</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iptables -D INPUT 5</span><br></pre></td></tr></table></figure>\n<p>iptables的使用参考：<br><a href>https://www.vpser.net/security/linux-iptables.html</a></p>\n<h4 id=\"3-非集成centos环境开放3306端口\"><a href=\"#3-非集成centos环境开放3306端口\" class=\"headerlink\" title=\"3.非集成centos环境开放3306端口\"></a>3.非集成centos环境开放3306端口</h4><h5 id=\"centos-7以上\"><a href=\"#centos-7以上\" class=\"headerlink\" title=\"centos-7以上\"></a>centos-7以上</h5><p>firewalld 防火墙（centos-7）运行命令,并重启：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class=\"line\">firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<h5 id=\"centos-7以前\"><a href=\"#centos-7以前\" class=\"headerlink\" title=\"centos-7以前\"></a>centos-7以前</h5><p>iptables 防火墙（centos6.5及其以前）运行命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure>\n<p>在文件内添加下面命令行，然后重启</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service iptables restart</span><br></pre></td></tr></table></figure>\n"},{"title":"RenderObject 原理","date":"2020-09-22T08:28:21.000Z","cateogries":["Flutter"],"_content":"\n\n## ParentData 和各种 Mixin\n\n``` \n@startuml\nBoxParentData --|> ParentData\nContainerParentDataMixin --|> ParentData\nContainerBoxParentData --|> BoxParentData\nContainerBoxParentData --|> ContainerParentDataMixin\n\nRenderObject *-- ParentData\nRenderObjectWithChildMixin --|> RenderObject\nContainerRenderObjectMixin --|> RenderObject\n\n\nclass ContainerParentDataMixin{\n+ previousSlibling\n+ nextSibling\n}\n\nclass ContainerRenderObjectMixin {\n+ firstChild *-- ContainerParentDataMixin\n+ lastChild\n+ childCount\n}\n\nclass BoxParentData{\n+ offset\n}\n\nclass RenderObject{\n+ parentData\n}\n@enduml\n```\n\n* ParentData\n在 Flutter 的布局系统中，该类负责存储父节点所需要的子节点的布局信息\n    * BoxParentData\n    -- offset\n    包含有一个 offset 属性，该属性用于存储 child 的布局信息，也就是 child 应该被摆在哪个位置。与 Android 不同，Flutter并不是以父View为坐标基础进行绘制的，所以需要带上 offset 参数，得到一个累加的偏移值。至于偏移的参考点在哪里，可以看下面的绘制阶段的原理解析。\n    * ContainerParentDataMixin\n    -- previousSibling\n    -- nextSibling\n    该类使用频率很高，基本上所有父节点的 ParentData 都混入了该类，该类需要与ContainerRenderObjectMixin 共同使用，主要解决了对 child 的管理，previousSibling nextSibling 都是child RenderObject, 从而组成把父节点的所有 child 组成了一个双链表\n    * ContainerBoxParentData\n    空类，继承了 BoxParentData 并且混入了 ContainerParentDataMixin， 使其拥有二者的能力\n* RenderObject\nFlutter 中真正实现布局和绘制的类\n    * RenderObjectWithChildMixin\n    实现对只有一个child的管理\n    * ContainerRenderObjectMixin\n    -- firstChild\n    -- lastChild\n    -- childCount\n    实现对多child的管理，firstChild、lastChild、childCount，用来获取首末 child，child的个数，配合使用 ContainerParentDataMixin 中的 previousSibling、nextSibling就可以对 child 进行遍历了。\n    child 的insert、remove、move等操作都在这个Mixin中实现\n\n除了以上的类，Flutter 还提供了 RenderBoxContainerDefaultsMixin，该类提供了一些 RenderBox 默认的行为方法，如上面绘制 child 的流程调用该类中的 defaultPaint(PaintingContext context, Offset offset) 就可以了，可以简化一些模板代码。\n\n## layout\n\n在 RenderBox 中，控件大小的值为 _size 成员，它只包含宽高两个属性值，我们可以通过该成员的 set 和 get 方法访问或修改它的值。在测量时( layout 方法中)，parent 会传给当前 RenderBox 一个大小的限制，为 BoxConstraints 类型，最后测量得到的 size 必须满足这个限制，在 Flutter 的 debug 模式下对 size 是否满足 constraints 做了 assert 检查，如果检查未通过就会布局失败。所以测量上我们要做的是下面两点：\n\n* 如果没有 child，那么根据自身的属性计算出满足 constraints 的 size.\n* 如果有 child，那么综合自身的属性和 child 的测量结果计算出满足 constraints 的 size.\n\n测量和布局都在layout方法中完成\n\n```dart\n  void layout(Constraints constraints, { bool parentUsesSize = false }) {\n    RenderObject relayoutBoundary;\n    if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) {\n      relayoutBoundary = this;\n    } else {\n      final RenderObject parent = this.parent;\n      relayoutBoundary = parent._relayoutBoundary;\n    }\n    if (!_needsLayout && constraints == _constraints && relayoutBoundary == _relayoutBoundary) {\n      return;\n    }\n    _constraints = constraints;\n    if (_relayoutBoundary != null && relayoutBoundary != _relayoutBoundary) {\n      visitChildren((RenderObject child) {\n        child._cleanRelayoutBoundary();\n      });\n    }\n    _relayoutBoundary = relayoutBoundary;\n    if (sizedByParent) {\n      try {\n        performResize();\n      } catch (e, stack) {\n        _debugReportException('performResize', e, stack);\n      }\n    }\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, stack) {\n      _debugReportException('performLayout', e, stack);\n    }\n    _needsLayout = false;\n    markNeedsPaint();\n  }\n```\n\n* parentUsesSize\n    layout 方法中由父节点传入，表示父节点的 size 依赖当前节点的 size \n* constraints\n    layout 方法中从父节点传入，当前节点会从更新到自己的变量中保存\n* relayoutBoundary \n    relayoutBoundary 是framework层自动设置的，如果满足 \n    `(!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject)` 则该节点是一个 relayoutBoundary, 否则会从父节点寻找。\n* sizedByParent & performResize()\n    **这两个必须成对配置，performResize() 方法如果被重写，sizedByParent 也必须重写为true，并且你不应该在 perfromLayout() 方法中对 size 重新赋值。** \n    sizedByParent 意为该控件的大小是否能仅通过 parent 赋予它的 constraints 就可以被确定下来了，即该控件的大小与它自身的属性和与它的 child 都无关，比如如果一个控件永远充满 parent 的大小，那么 sizedByParent 就应该返回 true。\n    **这个操作不是必须的**\n    官方文档中说这是一个优化项，如果完全不care这个，sizedByParent = false，那始终是正确的。 我的理解是，把 size 的计算单独抽出，避免每次 relayout 时对 size 重新计算。\n    performResize() 这个方法名字可能会造成误会，认为测量必须放在这里，其实大多是情况下，测量和布局都在 performLayout() 中\n* performLayout()\n    上面已经说得差不多了\n\n如果是在标脏后，在一帧绘制的回调中刷新布局，不会调用layout方法，而是调用_layoutWithoutSize \n\n```dart\n  void _layoutWithoutResize() {\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, stack) {\n      _debugReportException('performLayout', e, stack);\n    }\n    _needsLayout = false;\n    markNeedsPaint();\n  }\n```\n\n## paint\n\n父节点绘制子节点的入口\n\n**paintContext.paintChild()**\n\n```dart\n  void paintChild(RenderObject child, Offset offset) {\n    if (child.isRepaintBoundary) {\n      stopRecordingIfNeeded();\n      _compositeChild(child, offset);\n    } else {\n      child._paintWithContext(this, offset);\n    }\n  }\n\n  void _compositeChild(RenderObject child, Offset offset) {\n    // Create a layer for our child, and paint the child into it.\n    if (child._needsPaint) {\n      // 这个方法会创建layer，然后再调用 child._paintWithContext 方法\n      repaintCompositedChild(child, debugAlsoPaintedParent: true);\n    } else {\n    }\n    final OffsetLayer childOffsetLayer = child._layer;\n    childOffsetLayer.offset = offset;\n    appendLayer(child._layer);\n  }\n\n  static void _repaintCompositedChild(\n    RenderObject child, {\n    bool debugAlsoPaintedParent = false,\n    PaintingContext childContext,\n  }) {\n    OffsetLayer childLayer = child._layer;\n    if (childLayer == null) {\n      child._layer = childLayer = OffsetLayer();\n    } else {\n      childLayer.removeAllChildren();\n    }\n    childContext ??= PaintingContext(child._layer, child.paintBounds);\n    child._paintWithContext(childContext, Offset.zero);\n    childContext.stopRecordingIfNeeded();\n  }\n\n  @protected\n  void appendLayer(Layer layer) {\n    layer.remove();\n    _containerLayer.append(layer);\n  }\n```\n\n在 paintChild 方法中，若 child 是一个 repaintBoundary ，会为 child 创建一个 layer ，然后再调用 child._paintWithContext(this, offset) ；如果 isRepaintBoundary 为false，则直接调用 child._paintWithContext(this, offset)。。\n所以这个layer又是怎样？？？ \n\n在drawFrame()中，paint 标脏节点刷新时会直接执行 PaintContext.repaintCompositeChild() \n\n**_paintWithContext(..) & paint()**\n\n```dart\n  void _paintWithContext(PaintingContext context, Offset offset) {\n    if (_needsLayout)\n      return;\n    RenderObject debugLastActivePaint;\n    _needsPaint = false;\n    try {\n      paint(context, offset);\n    } catch (e, stack) {\n      _debugReportException('paint', e, stack);\n    }\n  }\n\n  void paint(PaintingContext context, Offset offset) { }\n\n```\n\nRenderObject 中的 paint 是一个空方法，交给子类来实现。 以 RenderFlex 为例： \n\n```dart\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    if (!_hasOverflow) {\n      defaultPaint(context, offset);\n      return;\n    }\n\n    ...\n  }\n\n  void defaultPaint(PaintingContext context, Offset offset) {\n    ChildType child = firstChild;\n    while (child != null) {\n      final ParentDataType childParentData = child.parentData;\n      context.paintChild(child, childParentData.offset + offset);\n      child = childParentData.nextSibling;\n    }\n  }\n```\n\n因为Flex没有要绘制的内容，所以调用 RenderBoxContainerDefaultsMixin 提供的默认实现。在 defaultPaint 中遍历child，绘制child时将 childParentData.offset累加到offset中。所以，这个 offset 的基准到底是个啥？？？？\n\n## PaintingContext 和 Layer\n\n### drawFrame()\nPaintContext 可以类比于 BuildContext，Layer 和 Element 最终会组成一个 Layer树，最终渲染是在C++的engine层完成的。在flutter的framework层构成了一颗Layer树，传送到engine进行绘制。\n\n回过头来看，在 drawFrame() 中对需要paint的节点是如何处理的。\n\n```dart\n  void drawFrame() {\n    // BD ADD:\n    Boost.resetIdleCallbacks();\n    assert(renderView != null);\n    pipelineOwner.flushLayout();\n    pipelineOwner.flushCompositingBits();\n    pipelineOwner.flushPaint();\n    renderView.compositeFrame(); // this sends the bits to the GPU\n    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.\n  }\n```\n\n先直接来看 pipelineOwner.flushPaint(); 和里面调用到的 PaintContext._repaintCompositedChild \n\n```dart\n  void flushPaint() {\n    try {\n      final List<RenderObject> dirtyNodes = _nodesNeedingPaint;\n      _nodesNeedingPaint = <RenderObject>[];\n      // Sort the dirty nodes in reverse order (deepest first).\n      for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => b.depth - a.depth)) {\n        if (node._needsPaint && node.owner == this) {\n          if (node._layer.attached) {\n            PaintingContext.repaintCompositedChild(node);\n          } else {\n            node._skippedPaintingOnLayer();\n          }\n        }\n      }\n    } finally {\n    }\n  }\n```\n\n**PaintingContext._repaintCompositedChild(...)**\n\n```dart\n  static void _repaintCompositedChild(\n    RenderObject child, {\n    bool debugAlsoPaintedParent = false,\n    PaintingContext childContext,\n  }) {\n    // 关注这个 assert，证明了最终需要 paint 的都是 RepaintBoundary 节点\n    assert(child.isRepaintBoundary);\n    OffsetLayer childLayer = child._layer;\n    if (childLayer == null) {\n      // 为 repaint boundaries 创建layer\n      child._layer = childLayer = OffsetLayer();\n    } else {\n      childLayer.removeAllChildren();\n    }\n    // 为 RepaintBoundary 创建 PaintContext\n    childContext ??= PaintingContext(child._layer, child.paintBounds);\n    // 初始化了Offset，说明offset的值是以layer为参考依据的\n    child._paintWithContext(childContext, Offset.zero);\n\n    childContext.stopRecordingIfNeeded();\n  }\n```\n\n再次回顾 PaintingContext._repaintCompositedChild 方法，我们发现，它为 RepaintBoundary ，创建了PaintingContext 和 layer。 说明 RepaintBoundary 、PaintingContext 、layer 是一一对应的， **即 layer 是绘制的基本单位，只有 RepaintBoundary 极其子 RenderObject 共享一个layer， 每次绘制会创建都会为 layer 创建一个 PaintingContext**。而 paint 过程中的offset的参考点，就是layer的左上角的坐标原点。\n\n**renderView.compositeFrame();**\n\n```dart\n  void compositeFrame() {\n    Timeline.startSync('Compositing', arguments: timelineWhitelistArguments);\n    try {\n      final ui.SceneBuilder builder = ui.SceneBuilder();\n      final ui.Scene scene = layer.buildScene(builder);\n      if (automaticSystemUiAdjustment)\n        _updateSystemChrome();\n      _window.render(scene);\n      scene.dispose();\n    } finally {\n      Timeline.finishSync();\n    }\n  }\n```\n\nrenderView 是页面的根RenderObject，renderView.layer 是页面的根layer。 调用 `layer.buildScene(builder);` 生成了一个scene， 调用_window.render(scene) 发送给engine层进行渲染\n\n### Layer的标脏和局部刷新\n\n**layer.buildScene**\n\n```dart\n  ui.Scene buildScene(ui.SceneBuilder builder) {\n    List<PictureLayer> temporaryLayers;\n    updateSubtreeNeedsAddToScene();\n    addToScene(builder);\n    _needsAddToScene = false;\n    final ui.Scene scene = builder.build();\n    return scene;\n  }\n\n  @override\n  void updateSubtreeNeedsAddToScene() {\n    super.updateSubtreeNeedsAddToScene();\n    Layer child = firstChild;\n    while (child != null) {\n      child.updateSubtreeNeedsAddToScene();\n      _needsAddToScene = _needsAddToScene || child._needsAddToScene;\n      // child.nextSibling 是下一个子layer， 这里显然是一个树的 层序遍历\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * 这是 ContainerLayer 的实现， 没有子Layer的叶子 Layer 实现各不相同\n  **/\n  @override\n  void addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) {\n    addChildrenToScene(builder, layerOffset);\n  }\n\n  void addChildrenToScene(ui.SceneBuilder builder, [ Offset childOffset = Offset.zero ]) {\n    Layer child = firstChild;\n    while (child != null) {\n      if (childOffset == Offset.zero) {\n        child._addToSceneWithRetainedRendering(builder);\n      } else {\n        child.addToScene(builder, childOffset);\n      }\n      child = child.nextSibling;\n    }\n  }\n```\n\nrenderView 的 layer 是一个 OffsetLayer ，继承自 ContainerLayer 。 \nLayer.buildScene(...) 这个方法在framework调用的地方很少，可以认为只有 renderView 的 layer 会调用 buildScene 方法创建创建一个 scene ， 即 scene 包含了页面的完整 layer 树。\n\n首先会调用 updateSubtreeNeedsAddToScene ， 需要update的原因是， 如果子layer标脏， 那显然父layer 也需要标脏\n\n**_addToSceneWithRetainedRendering**\n\n```dart\n  void markNeedsAddToScene() {\n    // Already marked. Short-circuit.\n    if (_needsAddToScene) {\n      return;\n    }\n\n    _needsAddToScene = true;\n  }\n\n  void _addToSceneWithRetainedRendering(ui.SceneBuilder builder) {\n    if (!_needsAddToScene && _engineLayer != null) {\n      builder.addRetained(_engineLayer);\n      return;\n    }\n    addToScene(builder);\n    _needsAddToScene = false;\n  }\n\n  \n```\n\nmarkNeedAddToScene() 对 layer 节点进行标脏。在layer属性发生改变时会进行标脏；当子layer添加到父layer时也会进行标脏。\n\n这个方法是唯一用到使用到 _needsAddToScene 标脏flag值的地方。 如果 _needsAddToScene 为false ，调用 builder.addRetained(_engineLayer); 这个 _engineLayer\n\n_eingineLayer 是 layer.addToScene(...) 返回的engine生成的图层（ContainerLayer例外，没有engineLayer）\n\n```dart\n  /**\n   * 这是 OpacityLayer 的addToScene方法，生成了一个 engineLayer ，\n   * 然后调用addChildrenToScene(builder);\n  **/\n  @override\n  void addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) {\n    bool enabled = firstChild != null;  // don't add this layer if there's no child\n    if (enabled)\n      engineLayer = builder.pushOpacity(alpha, offset: offset + layerOffset, oldLayer: _engineLayer);\n    else\n      engineLayer = null;\n    addChildrenToScene(builder);\n    if (enabled)\n      builder.pop();\n  }\n```\n\n**SceneBuilder.addRetained()**\n\n```dart\n  void addRetained(EngineLayer retainedLayer) {\n    final _EngineLayerWrapper wrapper = retainedLayer;\n    _addRetained(wrapper._nativeLayer);\n  }\n\n  void _addRetained(EngineLayer retainedLayer) native 'SceneBuilder_addRetained';\n```\n\naddRetained 直接调用了engine层的代码，对layer进行复用。。。\n\n### 直接使用 layer 进行UI绘制\n\nflutter最终是绘制在layer上的，那样的话，实际上，可以脱离 Widget、Element、RenderObject ，直接操作 layer 进行UI的绘制\n\n```dart\nimport 'dart:ui';\nimport 'dart:math';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n\nvoid main(){\n    final OffsetLayer rootLayer = new OffsetLayer();\n    final PictureLayer pictureLayer = new PictureLayer(Rect.zero);\n    rootLayer.append(pictureLayer);\n\n    PictureRecorder recorder = PictureRecorder();\n    Canvas canvas = Canvas(recorder);\n\n    Paint paint = Paint();\n    paint.color = Colors.primaries[Random().nextInt(Colors.primaries.length)];\n\n    canvas.drawRect(Rect.fromLTWH(0, 0, 300, 300), paint);\n    pictureLayer.picture = recorder.endRecording();\n    \n    SceneBuilder sceneBuilder = SceneBuilder();\n    rootLayer.addToScene(sceneBuilder);\n\n    Scene scene = sceneBuilder.build();\n    window.onDrawFrame = (){\n      window.render(scene);\n      // window.scheduleFrame();\n      // 在onDrawFrame回调最后加上scheduleFrame，可以使UI不断刷新，进行动画操作\n      // 不是很懂那vsync的作用是什么。。。\n    };\n    window.scheduleFrame();\n}\n```\n\n## 参考\n\n在 main.dart 中添加 `debugRepaintRainbowEnabled = true;` ，或者通过 devtools 可以观察到App的layer树\n\n[Flutter Framework 源码解析（ 2 ）—— 图层详解](https://xieguanglei.github.io/blog/post/flutter-code-chapter-02.html)\n\n[从源码看flutter（四）：Layer篇](https://juejin.im/post/6844904133728665614#heading-10)\n\n[Flutter画面渲染全面解析](https://guoshuyu.cn/home/wx/Flutter-21.html)\n\n\n\n","source":"_posts/Flutter/RenderObject-原理.md","raw":"---\ntitle: RenderObject 原理\ndate: 2020-09-22 16:28:21\ntags:\n- Flutter\n- RenderObject\ncateogries:\n- Flutter\n---\n\n\n## ParentData 和各种 Mixin\n\n``` \n@startuml\nBoxParentData --|> ParentData\nContainerParentDataMixin --|> ParentData\nContainerBoxParentData --|> BoxParentData\nContainerBoxParentData --|> ContainerParentDataMixin\n\nRenderObject *-- ParentData\nRenderObjectWithChildMixin --|> RenderObject\nContainerRenderObjectMixin --|> RenderObject\n\n\nclass ContainerParentDataMixin{\n+ previousSlibling\n+ nextSibling\n}\n\nclass ContainerRenderObjectMixin {\n+ firstChild *-- ContainerParentDataMixin\n+ lastChild\n+ childCount\n}\n\nclass BoxParentData{\n+ offset\n}\n\nclass RenderObject{\n+ parentData\n}\n@enduml\n```\n\n* ParentData\n在 Flutter 的布局系统中，该类负责存储父节点所需要的子节点的布局信息\n    * BoxParentData\n    -- offset\n    包含有一个 offset 属性，该属性用于存储 child 的布局信息，也就是 child 应该被摆在哪个位置。与 Android 不同，Flutter并不是以父View为坐标基础进行绘制的，所以需要带上 offset 参数，得到一个累加的偏移值。至于偏移的参考点在哪里，可以看下面的绘制阶段的原理解析。\n    * ContainerParentDataMixin\n    -- previousSibling\n    -- nextSibling\n    该类使用频率很高，基本上所有父节点的 ParentData 都混入了该类，该类需要与ContainerRenderObjectMixin 共同使用，主要解决了对 child 的管理，previousSibling nextSibling 都是child RenderObject, 从而组成把父节点的所有 child 组成了一个双链表\n    * ContainerBoxParentData\n    空类，继承了 BoxParentData 并且混入了 ContainerParentDataMixin， 使其拥有二者的能力\n* RenderObject\nFlutter 中真正实现布局和绘制的类\n    * RenderObjectWithChildMixin\n    实现对只有一个child的管理\n    * ContainerRenderObjectMixin\n    -- firstChild\n    -- lastChild\n    -- childCount\n    实现对多child的管理，firstChild、lastChild、childCount，用来获取首末 child，child的个数，配合使用 ContainerParentDataMixin 中的 previousSibling、nextSibling就可以对 child 进行遍历了。\n    child 的insert、remove、move等操作都在这个Mixin中实现\n\n除了以上的类，Flutter 还提供了 RenderBoxContainerDefaultsMixin，该类提供了一些 RenderBox 默认的行为方法，如上面绘制 child 的流程调用该类中的 defaultPaint(PaintingContext context, Offset offset) 就可以了，可以简化一些模板代码。\n\n## layout\n\n在 RenderBox 中，控件大小的值为 _size 成员，它只包含宽高两个属性值，我们可以通过该成员的 set 和 get 方法访问或修改它的值。在测量时( layout 方法中)，parent 会传给当前 RenderBox 一个大小的限制，为 BoxConstraints 类型，最后测量得到的 size 必须满足这个限制，在 Flutter 的 debug 模式下对 size 是否满足 constraints 做了 assert 检查，如果检查未通过就会布局失败。所以测量上我们要做的是下面两点：\n\n* 如果没有 child，那么根据自身的属性计算出满足 constraints 的 size.\n* 如果有 child，那么综合自身的属性和 child 的测量结果计算出满足 constraints 的 size.\n\n测量和布局都在layout方法中完成\n\n```dart\n  void layout(Constraints constraints, { bool parentUsesSize = false }) {\n    RenderObject relayoutBoundary;\n    if (!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject) {\n      relayoutBoundary = this;\n    } else {\n      final RenderObject parent = this.parent;\n      relayoutBoundary = parent._relayoutBoundary;\n    }\n    if (!_needsLayout && constraints == _constraints && relayoutBoundary == _relayoutBoundary) {\n      return;\n    }\n    _constraints = constraints;\n    if (_relayoutBoundary != null && relayoutBoundary != _relayoutBoundary) {\n      visitChildren((RenderObject child) {\n        child._cleanRelayoutBoundary();\n      });\n    }\n    _relayoutBoundary = relayoutBoundary;\n    if (sizedByParent) {\n      try {\n        performResize();\n      } catch (e, stack) {\n        _debugReportException('performResize', e, stack);\n      }\n    }\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, stack) {\n      _debugReportException('performLayout', e, stack);\n    }\n    _needsLayout = false;\n    markNeedsPaint();\n  }\n```\n\n* parentUsesSize\n    layout 方法中由父节点传入，表示父节点的 size 依赖当前节点的 size \n* constraints\n    layout 方法中从父节点传入，当前节点会从更新到自己的变量中保存\n* relayoutBoundary \n    relayoutBoundary 是framework层自动设置的，如果满足 \n    `(!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject)` 则该节点是一个 relayoutBoundary, 否则会从父节点寻找。\n* sizedByParent & performResize()\n    **这两个必须成对配置，performResize() 方法如果被重写，sizedByParent 也必须重写为true，并且你不应该在 perfromLayout() 方法中对 size 重新赋值。** \n    sizedByParent 意为该控件的大小是否能仅通过 parent 赋予它的 constraints 就可以被确定下来了，即该控件的大小与它自身的属性和与它的 child 都无关，比如如果一个控件永远充满 parent 的大小，那么 sizedByParent 就应该返回 true。\n    **这个操作不是必须的**\n    官方文档中说这是一个优化项，如果完全不care这个，sizedByParent = false，那始终是正确的。 我的理解是，把 size 的计算单独抽出，避免每次 relayout 时对 size 重新计算。\n    performResize() 这个方法名字可能会造成误会，认为测量必须放在这里，其实大多是情况下，测量和布局都在 performLayout() 中\n* performLayout()\n    上面已经说得差不多了\n\n如果是在标脏后，在一帧绘制的回调中刷新布局，不会调用layout方法，而是调用_layoutWithoutSize \n\n```dart\n  void _layoutWithoutResize() {\n    try {\n      performLayout();\n      markNeedsSemanticsUpdate();\n    } catch (e, stack) {\n      _debugReportException('performLayout', e, stack);\n    }\n    _needsLayout = false;\n    markNeedsPaint();\n  }\n```\n\n## paint\n\n父节点绘制子节点的入口\n\n**paintContext.paintChild()**\n\n```dart\n  void paintChild(RenderObject child, Offset offset) {\n    if (child.isRepaintBoundary) {\n      stopRecordingIfNeeded();\n      _compositeChild(child, offset);\n    } else {\n      child._paintWithContext(this, offset);\n    }\n  }\n\n  void _compositeChild(RenderObject child, Offset offset) {\n    // Create a layer for our child, and paint the child into it.\n    if (child._needsPaint) {\n      // 这个方法会创建layer，然后再调用 child._paintWithContext 方法\n      repaintCompositedChild(child, debugAlsoPaintedParent: true);\n    } else {\n    }\n    final OffsetLayer childOffsetLayer = child._layer;\n    childOffsetLayer.offset = offset;\n    appendLayer(child._layer);\n  }\n\n  static void _repaintCompositedChild(\n    RenderObject child, {\n    bool debugAlsoPaintedParent = false,\n    PaintingContext childContext,\n  }) {\n    OffsetLayer childLayer = child._layer;\n    if (childLayer == null) {\n      child._layer = childLayer = OffsetLayer();\n    } else {\n      childLayer.removeAllChildren();\n    }\n    childContext ??= PaintingContext(child._layer, child.paintBounds);\n    child._paintWithContext(childContext, Offset.zero);\n    childContext.stopRecordingIfNeeded();\n  }\n\n  @protected\n  void appendLayer(Layer layer) {\n    layer.remove();\n    _containerLayer.append(layer);\n  }\n```\n\n在 paintChild 方法中，若 child 是一个 repaintBoundary ，会为 child 创建一个 layer ，然后再调用 child._paintWithContext(this, offset) ；如果 isRepaintBoundary 为false，则直接调用 child._paintWithContext(this, offset)。。\n所以这个layer又是怎样？？？ \n\n在drawFrame()中，paint 标脏节点刷新时会直接执行 PaintContext.repaintCompositeChild() \n\n**_paintWithContext(..) & paint()**\n\n```dart\n  void _paintWithContext(PaintingContext context, Offset offset) {\n    if (_needsLayout)\n      return;\n    RenderObject debugLastActivePaint;\n    _needsPaint = false;\n    try {\n      paint(context, offset);\n    } catch (e, stack) {\n      _debugReportException('paint', e, stack);\n    }\n  }\n\n  void paint(PaintingContext context, Offset offset) { }\n\n```\n\nRenderObject 中的 paint 是一个空方法，交给子类来实现。 以 RenderFlex 为例： \n\n```dart\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    if (!_hasOverflow) {\n      defaultPaint(context, offset);\n      return;\n    }\n\n    ...\n  }\n\n  void defaultPaint(PaintingContext context, Offset offset) {\n    ChildType child = firstChild;\n    while (child != null) {\n      final ParentDataType childParentData = child.parentData;\n      context.paintChild(child, childParentData.offset + offset);\n      child = childParentData.nextSibling;\n    }\n  }\n```\n\n因为Flex没有要绘制的内容，所以调用 RenderBoxContainerDefaultsMixin 提供的默认实现。在 defaultPaint 中遍历child，绘制child时将 childParentData.offset累加到offset中。所以，这个 offset 的基准到底是个啥？？？？\n\n## PaintingContext 和 Layer\n\n### drawFrame()\nPaintContext 可以类比于 BuildContext，Layer 和 Element 最终会组成一个 Layer树，最终渲染是在C++的engine层完成的。在flutter的framework层构成了一颗Layer树，传送到engine进行绘制。\n\n回过头来看，在 drawFrame() 中对需要paint的节点是如何处理的。\n\n```dart\n  void drawFrame() {\n    // BD ADD:\n    Boost.resetIdleCallbacks();\n    assert(renderView != null);\n    pipelineOwner.flushLayout();\n    pipelineOwner.flushCompositingBits();\n    pipelineOwner.flushPaint();\n    renderView.compositeFrame(); // this sends the bits to the GPU\n    pipelineOwner.flushSemantics(); // this also sends the semantics to the OS.\n  }\n```\n\n先直接来看 pipelineOwner.flushPaint(); 和里面调用到的 PaintContext._repaintCompositedChild \n\n```dart\n  void flushPaint() {\n    try {\n      final List<RenderObject> dirtyNodes = _nodesNeedingPaint;\n      _nodesNeedingPaint = <RenderObject>[];\n      // Sort the dirty nodes in reverse order (deepest first).\n      for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) => b.depth - a.depth)) {\n        if (node._needsPaint && node.owner == this) {\n          if (node._layer.attached) {\n            PaintingContext.repaintCompositedChild(node);\n          } else {\n            node._skippedPaintingOnLayer();\n          }\n        }\n      }\n    } finally {\n    }\n  }\n```\n\n**PaintingContext._repaintCompositedChild(...)**\n\n```dart\n  static void _repaintCompositedChild(\n    RenderObject child, {\n    bool debugAlsoPaintedParent = false,\n    PaintingContext childContext,\n  }) {\n    // 关注这个 assert，证明了最终需要 paint 的都是 RepaintBoundary 节点\n    assert(child.isRepaintBoundary);\n    OffsetLayer childLayer = child._layer;\n    if (childLayer == null) {\n      // 为 repaint boundaries 创建layer\n      child._layer = childLayer = OffsetLayer();\n    } else {\n      childLayer.removeAllChildren();\n    }\n    // 为 RepaintBoundary 创建 PaintContext\n    childContext ??= PaintingContext(child._layer, child.paintBounds);\n    // 初始化了Offset，说明offset的值是以layer为参考依据的\n    child._paintWithContext(childContext, Offset.zero);\n\n    childContext.stopRecordingIfNeeded();\n  }\n```\n\n再次回顾 PaintingContext._repaintCompositedChild 方法，我们发现，它为 RepaintBoundary ，创建了PaintingContext 和 layer。 说明 RepaintBoundary 、PaintingContext 、layer 是一一对应的， **即 layer 是绘制的基本单位，只有 RepaintBoundary 极其子 RenderObject 共享一个layer， 每次绘制会创建都会为 layer 创建一个 PaintingContext**。而 paint 过程中的offset的参考点，就是layer的左上角的坐标原点。\n\n**renderView.compositeFrame();**\n\n```dart\n  void compositeFrame() {\n    Timeline.startSync('Compositing', arguments: timelineWhitelistArguments);\n    try {\n      final ui.SceneBuilder builder = ui.SceneBuilder();\n      final ui.Scene scene = layer.buildScene(builder);\n      if (automaticSystemUiAdjustment)\n        _updateSystemChrome();\n      _window.render(scene);\n      scene.dispose();\n    } finally {\n      Timeline.finishSync();\n    }\n  }\n```\n\nrenderView 是页面的根RenderObject，renderView.layer 是页面的根layer。 调用 `layer.buildScene(builder);` 生成了一个scene， 调用_window.render(scene) 发送给engine层进行渲染\n\n### Layer的标脏和局部刷新\n\n**layer.buildScene**\n\n```dart\n  ui.Scene buildScene(ui.SceneBuilder builder) {\n    List<PictureLayer> temporaryLayers;\n    updateSubtreeNeedsAddToScene();\n    addToScene(builder);\n    _needsAddToScene = false;\n    final ui.Scene scene = builder.build();\n    return scene;\n  }\n\n  @override\n  void updateSubtreeNeedsAddToScene() {\n    super.updateSubtreeNeedsAddToScene();\n    Layer child = firstChild;\n    while (child != null) {\n      child.updateSubtreeNeedsAddToScene();\n      _needsAddToScene = _needsAddToScene || child._needsAddToScene;\n      // child.nextSibling 是下一个子layer， 这里显然是一个树的 层序遍历\n      child = child.nextSibling;\n    }\n  }\n\n  /**\n   * 这是 ContainerLayer 的实现， 没有子Layer的叶子 Layer 实现各不相同\n  **/\n  @override\n  void addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) {\n    addChildrenToScene(builder, layerOffset);\n  }\n\n  void addChildrenToScene(ui.SceneBuilder builder, [ Offset childOffset = Offset.zero ]) {\n    Layer child = firstChild;\n    while (child != null) {\n      if (childOffset == Offset.zero) {\n        child._addToSceneWithRetainedRendering(builder);\n      } else {\n        child.addToScene(builder, childOffset);\n      }\n      child = child.nextSibling;\n    }\n  }\n```\n\nrenderView 的 layer 是一个 OffsetLayer ，继承自 ContainerLayer 。 \nLayer.buildScene(...) 这个方法在framework调用的地方很少，可以认为只有 renderView 的 layer 会调用 buildScene 方法创建创建一个 scene ， 即 scene 包含了页面的完整 layer 树。\n\n首先会调用 updateSubtreeNeedsAddToScene ， 需要update的原因是， 如果子layer标脏， 那显然父layer 也需要标脏\n\n**_addToSceneWithRetainedRendering**\n\n```dart\n  void markNeedsAddToScene() {\n    // Already marked. Short-circuit.\n    if (_needsAddToScene) {\n      return;\n    }\n\n    _needsAddToScene = true;\n  }\n\n  void _addToSceneWithRetainedRendering(ui.SceneBuilder builder) {\n    if (!_needsAddToScene && _engineLayer != null) {\n      builder.addRetained(_engineLayer);\n      return;\n    }\n    addToScene(builder);\n    _needsAddToScene = false;\n  }\n\n  \n```\n\nmarkNeedAddToScene() 对 layer 节点进行标脏。在layer属性发生改变时会进行标脏；当子layer添加到父layer时也会进行标脏。\n\n这个方法是唯一用到使用到 _needsAddToScene 标脏flag值的地方。 如果 _needsAddToScene 为false ，调用 builder.addRetained(_engineLayer); 这个 _engineLayer\n\n_eingineLayer 是 layer.addToScene(...) 返回的engine生成的图层（ContainerLayer例外，没有engineLayer）\n\n```dart\n  /**\n   * 这是 OpacityLayer 的addToScene方法，生成了一个 engineLayer ，\n   * 然后调用addChildrenToScene(builder);\n  **/\n  @override\n  void addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) {\n    bool enabled = firstChild != null;  // don't add this layer if there's no child\n    if (enabled)\n      engineLayer = builder.pushOpacity(alpha, offset: offset + layerOffset, oldLayer: _engineLayer);\n    else\n      engineLayer = null;\n    addChildrenToScene(builder);\n    if (enabled)\n      builder.pop();\n  }\n```\n\n**SceneBuilder.addRetained()**\n\n```dart\n  void addRetained(EngineLayer retainedLayer) {\n    final _EngineLayerWrapper wrapper = retainedLayer;\n    _addRetained(wrapper._nativeLayer);\n  }\n\n  void _addRetained(EngineLayer retainedLayer) native 'SceneBuilder_addRetained';\n```\n\naddRetained 直接调用了engine层的代码，对layer进行复用。。。\n\n### 直接使用 layer 进行UI绘制\n\nflutter最终是绘制在layer上的，那样的话，实际上，可以脱离 Widget、Element、RenderObject ，直接操作 layer 进行UI的绘制\n\n```dart\nimport 'dart:ui';\nimport 'dart:math';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n\nvoid main(){\n    final OffsetLayer rootLayer = new OffsetLayer();\n    final PictureLayer pictureLayer = new PictureLayer(Rect.zero);\n    rootLayer.append(pictureLayer);\n\n    PictureRecorder recorder = PictureRecorder();\n    Canvas canvas = Canvas(recorder);\n\n    Paint paint = Paint();\n    paint.color = Colors.primaries[Random().nextInt(Colors.primaries.length)];\n\n    canvas.drawRect(Rect.fromLTWH(0, 0, 300, 300), paint);\n    pictureLayer.picture = recorder.endRecording();\n    \n    SceneBuilder sceneBuilder = SceneBuilder();\n    rootLayer.addToScene(sceneBuilder);\n\n    Scene scene = sceneBuilder.build();\n    window.onDrawFrame = (){\n      window.render(scene);\n      // window.scheduleFrame();\n      // 在onDrawFrame回调最后加上scheduleFrame，可以使UI不断刷新，进行动画操作\n      // 不是很懂那vsync的作用是什么。。。\n    };\n    window.scheduleFrame();\n}\n```\n\n## 参考\n\n在 main.dart 中添加 `debugRepaintRainbowEnabled = true;` ，或者通过 devtools 可以观察到App的layer树\n\n[Flutter Framework 源码解析（ 2 ）—— 图层详解](https://xieguanglei.github.io/blog/post/flutter-code-chapter-02.html)\n\n[从源码看flutter（四）：Layer篇](https://juejin.im/post/6844904133728665614#heading-10)\n\n[Flutter画面渲染全面解析](https://guoshuyu.cn/home/wx/Flutter-21.html)\n\n\n\n","slug":"Flutter/RenderObject-原理","published":1,"updated":"2021-10-03T01:57:41.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8t0043g0je2u8r9kn9","content":"<h2 id=\"ParentData-和各种-Mixin\"><a href=\"#ParentData-和各种-Mixin\" class=\"headerlink\" title=\"ParentData 和各种 Mixin\"></a>ParentData 和各种 Mixin</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@startuml</span><br><span class=\"line\">BoxParentData --|&gt; ParentData</span><br><span class=\"line\">ContainerParentDataMixin --|&gt; ParentData</span><br><span class=\"line\">ContainerBoxParentData --|&gt; BoxParentData</span><br><span class=\"line\">ContainerBoxParentData --|&gt; ContainerParentDataMixin</span><br><span class=\"line\"></span><br><span class=\"line\">RenderObject *-- ParentData</span><br><span class=\"line\">RenderObjectWithChildMixin --|&gt; RenderObject</span><br><span class=\"line\">ContainerRenderObjectMixin --|&gt; RenderObject</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class ContainerParentDataMixin&#123;</span><br><span class=\"line\">+ previousSlibling</span><br><span class=\"line\">+ nextSibling</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ContainerRenderObjectMixin &#123;</span><br><span class=\"line\">+ firstChild *-- ContainerParentDataMixin</span><br><span class=\"line\">+ lastChild</span><br><span class=\"line\">+ childCount</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class BoxParentData&#123;</span><br><span class=\"line\">+ offset</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class RenderObject&#123;</span><br><span class=\"line\">+ parentData</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@enduml</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<ul>\n<li>ParentData<br>在 Flutter 的布局系统中，该类负责存储父节点所需要的子节点的布局信息<ul>\n<li>BoxParentData<br>– offset<br>包含有一个 offset 属性，该属性用于存储 child 的布局信息，也就是 child 应该被摆在哪个位置。与 Android 不同，Flutter并不是以父View为坐标基础进行绘制的，所以需要带上 offset 参数，得到一个累加的偏移值。至于偏移的参考点在哪里，可以看下面的绘制阶段的原理解析。</li>\n<li>ContainerParentDataMixin<br>– previousSibling<br>– nextSibling<br>该类使用频率很高，基本上所有父节点的 ParentData 都混入了该类，该类需要与ContainerRenderObjectMixin 共同使用，主要解决了对 child 的管理，previousSibling nextSibling 都是child RenderObject, 从而组成把父节点的所有 child 组成了一个双链表</li>\n<li>ContainerBoxParentData<br>空类，继承了 BoxParentData 并且混入了 ContainerParentDataMixin， 使其拥有二者的能力</li>\n</ul>\n</li>\n<li>RenderObject<br>Flutter 中真正实现布局和绘制的类<ul>\n<li>RenderObjectWithChildMixin<br>实现对只有一个child的管理</li>\n<li>ContainerRenderObjectMixin<br>– firstChild<br>– lastChild<br>– childCount<br>实现对多child的管理，firstChild、lastChild、childCount，用来获取首末 child，child的个数，配合使用 ContainerParentDataMixin 中的 previousSibling、nextSibling就可以对 child 进行遍历了。<br>child 的insert、remove、move等操作都在这个Mixin中实现</li>\n</ul>\n</li>\n</ul>\n<p>除了以上的类，Flutter 还提供了 RenderBoxContainerDefaultsMixin，该类提供了一些 RenderBox 默认的行为方法，如上面绘制 child 的流程调用该类中的 defaultPaint(PaintingContext context, Offset offset) 就可以了，可以简化一些模板代码。</p>\n<h2 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h2><p>在 RenderBox 中，控件大小的值为 _size 成员，它只包含宽高两个属性值，我们可以通过该成员的 set 和 get 方法访问或修改它的值。在测量时( layout 方法中)，parent 会传给当前 RenderBox 一个大小的限制，为 BoxConstraints 类型，最后测量得到的 size 必须满足这个限制，在 Flutter 的 debug 模式下对 size 是否满足 constraints 做了 assert 检查，如果检查未通过就会布局失败。所以测量上我们要做的是下面两点：</p>\n<ul>\n<li>如果没有 child，那么根据自身的属性计算出满足 constraints 的 size.</li>\n<li>如果有 child，那么综合自身的属性和 child 的测量结果计算出满足 constraints 的 size.</li>\n</ul>\n<p>测量和布局都在layout方法中完成</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> layout(Constraints constraints, &#123; <span class=\"built_in\">bool</span> parentUsesSize = <span class=\"keyword\">false</span> &#125;) &#123;</span><br><span class=\"line\">  RenderObject relayoutBoundary;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class=\"keyword\">is</span>! RenderObject) &#123;</span><br><span class=\"line\">    relayoutBoundary = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> RenderObject parent = <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">    relayoutBoundary = parent._relayoutBoundary;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _constraints = constraints;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_relayoutBoundary != <span class=\"keyword\">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class=\"line\">    visitChildren((RenderObject child) &#123;</span><br><span class=\"line\">      child._cleanRelayoutBoundary();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _relayoutBoundary = relayoutBoundary;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sizedByParent) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      performResize();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">      _debugReportException(<span class=\"string\">'performResize'</span>, e, stack);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    performLayout();</span><br><span class=\"line\">    markNeedsSemanticsUpdate();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'performLayout'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  markNeedsPaint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>parentUsesSize<br>  layout 方法中由父节点传入，表示父节点的 size 依赖当前节点的 size </li>\n<li>constraints<br>  layout 方法中从父节点传入，当前节点会从更新到自己的变量中保存</li>\n<li>relayoutBoundary<br>  relayoutBoundary 是framework层自动设置的，如果满足<br>  <code>(!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject)</code> 则该节点是一个 relayoutBoundary, 否则会从父节点寻找。</li>\n<li>sizedByParent &amp; performResize()<br>  <strong>这两个必须成对配置，performResize() 方法如果被重写，sizedByParent 也必须重写为true，并且你不应该在 perfromLayout() 方法中对 size 重新赋值。</strong><br>  sizedByParent 意为该控件的大小是否能仅通过 parent 赋予它的 constraints 就可以被确定下来了，即该控件的大小与它自身的属性和与它的 child 都无关，比如如果一个控件永远充满 parent 的大小，那么 sizedByParent 就应该返回 true。<br>  <strong>这个操作不是必须的</strong><br>  官方文档中说这是一个优化项，如果完全不care这个，sizedByParent = false，那始终是正确的。 我的理解是，把 size 的计算单独抽出，避免每次 relayout 时对 size 重新计算。<br>  performResize() 这个方法名字可能会造成误会，认为测量必须放在这里，其实大多是情况下，测量和布局都在 performLayout() 中</li>\n<li>performLayout()<br>  上面已经说得差不多了</li>\n</ul>\n<p>如果是在标脏后，在一帧绘制的回调中刷新布局，不会调用layout方法，而是调用_layoutWithoutSize </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _layoutWithoutResize() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    performLayout();</span><br><span class=\"line\">    markNeedsSemanticsUpdate();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'performLayout'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  markNeedsPaint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"paint\"><a href=\"#paint\" class=\"headerlink\" title=\"paint\"></a>paint</h2><p>父节点绘制子节点的入口</p>\n<p><strong>paintContext.paintChild()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (child.isRepaintBoundary) &#123;</span><br><span class=\"line\">    stopRecordingIfNeeded();</span><br><span class=\"line\">    _compositeChild(child, offset);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    child._paintWithContext(<span class=\"keyword\">this</span>, offset);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create a layer for our child, and paint the child into it.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (child._needsPaint) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法会创建layer，然后再调用 child._paintWithContext 方法</span></span><br><span class=\"line\">    repaintCompositedChild(child, debugAlsoPaintedParent: <span class=\"keyword\">true</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> OffsetLayer childOffsetLayer = child._layer;</span><br><span class=\"line\">  childOffsetLayer.offset = offset;</span><br><span class=\"line\">  appendLayer(child._layer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _repaintCompositedChild(</span><br><span class=\"line\">  RenderObject child, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> debugAlsoPaintedParent = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  PaintingContext childContext,</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  OffsetLayer childLayer = child._layer;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childLayer == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    child._layer = childLayer = OffsetLayer();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    childLayer.removeAllChildren();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class=\"line\">  child._paintWithContext(childContext, Offset.zero);</span><br><span class=\"line\">  childContext.stopRecordingIfNeeded();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> appendLayer(Layer layer) &#123;</span><br><span class=\"line\">  layer.remove();</span><br><span class=\"line\">  _containerLayer.append(layer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 paintChild 方法中，若 child 是一个 repaintBoundary ，会为 child 创建一个 layer ，然后再调用 child._paintWithContext(this, offset) ；如果 isRepaintBoundary 为false，则直接调用 child._paintWithContext(this, offset)。。<br>所以这个layer又是怎样？？？ </p>\n<p>在drawFrame()中，paint 标脏节点刷新时会直接执行 PaintContext.repaintCompositeChild() </p>\n<p><strong>_paintWithContext(..) &amp; paint()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_needsLayout)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  RenderObject debugLastActivePaint;</span><br><span class=\"line\">  _needsPaint = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    paint(context, offset);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'paint'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>RenderObject 中的 paint 是一个空方法，交给子类来实现。 以 RenderFlex 为例： </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_hasOverflow) &#123;</span><br><span class=\"line\">    defaultPaint(context, offset);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> defaultPaint(PaintingContext context, Offset offset) &#123;</span><br><span class=\"line\">  ChildType child = firstChild;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ParentDataType childParentData = child.parentData;</span><br><span class=\"line\">    context.paintChild(child, childParentData.offset + offset);</span><br><span class=\"line\">    child = childParentData.nextSibling;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为Flex没有要绘制的内容，所以调用 RenderBoxContainerDefaultsMixin 提供的默认实现。在 defaultPaint 中遍历child，绘制child时将 childParentData.offset累加到offset中。所以，这个 offset 的基准到底是个啥？？？？</p>\n<h2 id=\"PaintingContext-和-Layer\"><a href=\"#PaintingContext-和-Layer\" class=\"headerlink\" title=\"PaintingContext 和 Layer\"></a>PaintingContext 和 Layer</h2><h3 id=\"drawFrame\"><a href=\"#drawFrame\" class=\"headerlink\" title=\"drawFrame()\"></a>drawFrame()</h3><p>PaintContext 可以类比于 BuildContext，Layer 和 Element 最终会组成一个 Layer树，最终渲染是在C++的engine层完成的。在flutter的framework层构成了一颗Layer树，传送到engine进行绘制。</p>\n<p>回过头来看，在 drawFrame() 中对需要paint的节点是如何处理的。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> drawFrame() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// BD ADD:</span></span><br><span class=\"line\">  Boost.resetIdleCallbacks();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(renderView != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  pipelineOwner.flushLayout();</span><br><span class=\"line\">  pipelineOwner.flushCompositingBits();</span><br><span class=\"line\">  pipelineOwner.flushPaint();</span><br><span class=\"line\">  renderView.compositeFrame(); <span class=\"comment\">// this sends the bits to the GPU</span></span><br><span class=\"line\">  pipelineOwner.flushSemantics(); <span class=\"comment\">// this also sends the semantics to the OS.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先直接来看 pipelineOwner.flushPaint(); 和里面调用到的 PaintContext._repaintCompositedChild </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> flushPaint() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class=\"line\">    _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class=\"line\">    <span class=\"comment\">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RenderObject node <span class=\"keyword\">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node._needsPaint &amp;&amp; node.owner == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node._layer.attached) &#123;</span><br><span class=\"line\">          PaintingContext.repaintCompositedChild(node);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          node._skippedPaintingOnLayer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>PaintingContext._repaintCompositedChild(…)</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _repaintCompositedChild(</span><br><span class=\"line\">  RenderObject child, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> debugAlsoPaintedParent = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  PaintingContext childContext,</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 关注这个 assert，证明了最终需要 paint 的都是 RepaintBoundary 节点</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(child.isRepaintBoundary);</span><br><span class=\"line\">  OffsetLayer childLayer = child._layer;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childLayer == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为 repaint boundaries 创建layer</span></span><br><span class=\"line\">    child._layer = childLayer = OffsetLayer();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    childLayer.removeAllChildren();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 为 RepaintBoundary 创建 PaintContext</span></span><br><span class=\"line\">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class=\"line\">  <span class=\"comment\">// 初始化了Offset，说明offset的值是以layer为参考依据的</span></span><br><span class=\"line\">  child._paintWithContext(childContext, Offset.zero);</span><br><span class=\"line\"></span><br><span class=\"line\">  childContext.stopRecordingIfNeeded();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次回顾 PaintingContext._repaintCompositedChild 方法，我们发现，它为 RepaintBoundary ，创建了PaintingContext 和 layer。 说明 RepaintBoundary 、PaintingContext 、layer 是一一对应的， <strong>即 layer 是绘制的基本单位，只有 RepaintBoundary 极其子 RenderObject 共享一个layer， 每次绘制会创建都会为 layer 创建一个 PaintingContext</strong>。而 paint 过程中的offset的参考点，就是layer的左上角的坐标原点。</p>\n<p><strong>renderView.compositeFrame();</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> compositeFrame() &#123;</span><br><span class=\"line\">  Timeline.startSync(<span class=\"string\">'Compositing'</span>, arguments: timelineWhitelistArguments);</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ui.SceneBuilder builder = ui.SceneBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ui.Scene scene = layer.buildScene(builder);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (automaticSystemUiAdjustment)</span><br><span class=\"line\">      _updateSystemChrome();</span><br><span class=\"line\">    _window.render(scene);</span><br><span class=\"line\">    scene.dispose();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    Timeline.finishSync();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>renderView 是页面的根RenderObject，renderView.layer 是页面的根layer。 调用 <code>layer.buildScene(builder);</code> 生成了一个scene， 调用_window.render(scene) 发送给engine层进行渲染</p>\n<h3 id=\"Layer的标脏和局部刷新\"><a href=\"#Layer的标脏和局部刷新\" class=\"headerlink\" title=\"Layer的标脏和局部刷新\"></a>Layer的标脏和局部刷新</h3><p><strong>layer.buildScene</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui.Scene buildScene(ui.SceneBuilder builder) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;PictureLayer&gt; temporaryLayers;</span><br><span class=\"line\">  updateSubtreeNeedsAddToScene();</span><br><span class=\"line\">  addToScene(builder);</span><br><span class=\"line\">  _needsAddToScene = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> ui.Scene scene = builder.build();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> scene;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> updateSubtreeNeedsAddToScene() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.updateSubtreeNeedsAddToScene();</span><br><span class=\"line\">  Layer child = firstChild;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    child.updateSubtreeNeedsAddToScene();</span><br><span class=\"line\">    _needsAddToScene = _needsAddToScene || child._needsAddToScene;</span><br><span class=\"line\">    <span class=\"comment\">// child.nextSibling 是下一个子layer， 这里显然是一个树的 层序遍历</span></span><br><span class=\"line\">    child = child.nextSibling;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是 ContainerLayer 的实现， 没有子Layer的叶子 Layer 实现各不相同</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</span><br><span class=\"line\">  addChildrenToScene(builder, layerOffset);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> addChildrenToScene(ui.SceneBuilder builder, [ Offset childOffset = Offset.zero ]) &#123;</span><br><span class=\"line\">  Layer child = firstChild;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childOffset == Offset.zero) &#123;</span><br><span class=\"line\">      child._addToSceneWithRetainedRendering(builder);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      child.addToScene(builder, childOffset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    child = child.nextSibling;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>renderView 的 layer 是一个 OffsetLayer ，继承自 ContainerLayer 。<br>Layer.buildScene(…) 这个方法在framework调用的地方很少，可以认为只有 renderView 的 layer 会调用 buildScene 方法创建创建一个 scene ， 即 scene 包含了页面的完整 layer 树。</p>\n<p>首先会调用 updateSubtreeNeedsAddToScene ， 需要update的原因是， 如果子layer标脏， 那显然父layer 也需要标脏</p>\n<p><strong>_addToSceneWithRetainedRendering</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> markNeedsAddToScene() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Already marked. Short-circuit.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_needsAddToScene) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _needsAddToScene = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _addToSceneWithRetainedRendering(ui.SceneBuilder builder) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_needsAddToScene &amp;&amp; _engineLayer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    builder.addRetained(_engineLayer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addToScene(builder);</span><br><span class=\"line\">  _needsAddToScene = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>markNeedAddToScene() 对 layer 节点进行标脏。在layer属性发生改变时会进行标脏；当子layer添加到父layer时也会进行标脏。</p>\n<p>这个方法是唯一用到使用到 _needsAddToScene 标脏flag值的地方。 如果 _needsAddToScene 为false ，调用 builder.addRetained(_engineLayer); 这个 _engineLayer</p>\n<p>_eingineLayer 是 layer.addToScene(…) 返回的engine生成的图层（ContainerLayer例外，没有engineLayer）</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是 OpacityLayer 的addToScene方法，生成了一个 engineLayer ，</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后调用addChildrenToScene(builder);</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> enabled = firstChild != <span class=\"keyword\">null</span>;  <span class=\"comment\">// don't add this layer if there's no child</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enabled)</span><br><span class=\"line\">    engineLayer = builder.pushOpacity(alpha, offset: offset + layerOffset, oldLayer: _engineLayer);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    engineLayer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  addChildrenToScene(builder);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enabled)</span><br><span class=\"line\">    builder.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>SceneBuilder.addRetained()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> addRetained(EngineLayer retainedLayer) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> _EngineLayerWrapper wrapper = retainedLayer;</span><br><span class=\"line\">  _addRetained(wrapper._nativeLayer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _addRetained(EngineLayer retainedLayer) native <span class=\"string\">'SceneBuilder_addRetained'</span>;</span><br></pre></td></tr></table></figure>\n<p>addRetained 直接调用了engine层的代码，对layer进行复用。。。</p>\n<h3 id=\"直接使用-layer-进行UI绘制\"><a href=\"#直接使用-layer-进行UI绘制\" class=\"headerlink\" title=\"直接使用 layer 进行UI绘制\"></a>直接使用 layer 进行UI绘制</h3><p>flutter最终是绘制在layer上的，那样的话，实际上，可以脱离 Widget、Element、RenderObject ，直接操作 layer 进行UI的绘制</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:ui'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/rendering.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> OffsetLayer rootLayer = <span class=\"keyword\">new</span> OffsetLayer();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> PictureLayer pictureLayer = <span class=\"keyword\">new</span> PictureLayer(Rect.zero);</span><br><span class=\"line\">    rootLayer.append(pictureLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">    PictureRecorder recorder = PictureRecorder();</span><br><span class=\"line\">    Canvas canvas = Canvas(recorder);</span><br><span class=\"line\"></span><br><span class=\"line\">    Paint paint = Paint();</span><br><span class=\"line\">    paint.color = Colors.primaries[Random().nextInt(Colors.primaries.length)];</span><br><span class=\"line\"></span><br><span class=\"line\">    canvas.drawRect(Rect.fromLTWH(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">300</span>, <span class=\"number\">300</span>), paint);</span><br><span class=\"line\">    pictureLayer.picture = recorder.endRecording();</span><br><span class=\"line\">    </span><br><span class=\"line\">    SceneBuilder sceneBuilder = SceneBuilder();</span><br><span class=\"line\">    rootLayer.addToScene(sceneBuilder);</span><br><span class=\"line\"></span><br><span class=\"line\">    Scene scene = sceneBuilder.build();</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.onDrawFrame = ()&#123;</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.render(scene);</span><br><span class=\"line\">      <span class=\"comment\">// window.scheduleFrame();</span></span><br><span class=\"line\">      <span class=\"comment\">// 在onDrawFrame回调最后加上scheduleFrame，可以使UI不断刷新，进行动画操作</span></span><br><span class=\"line\">      <span class=\"comment\">// 不是很懂那vsync的作用是什么。。。</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.scheduleFrame();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>在 main.dart 中添加 <code>debugRepaintRainbowEnabled = true;</code> ，或者通过 devtools 可以观察到App的layer树</p>\n<p><a href=\"https://xieguanglei.github.io/blog/post/flutter-code-chapter-02.html\" target=\"_blank\" rel=\"noopener\">Flutter Framework 源码解析（ 2 ）—— 图层详解</a></p>\n<p><a href=\"https://juejin.im/post/6844904133728665614#heading-10\" target=\"_blank\" rel=\"noopener\">从源码看flutter（四）：Layer篇</a></p>\n<p><a href=\"https://guoshuyu.cn/home/wx/Flutter-21.html\" target=\"_blank\" rel=\"noopener\">Flutter画面渲染全面解析</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"ParentData-和各种-Mixin\"><a href=\"#ParentData-和各种-Mixin\" class=\"headerlink\" title=\"ParentData 和各种 Mixin\"></a>ParentData 和各种 Mixin</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@startuml</span><br><span class=\"line\">BoxParentData --|&gt; ParentData</span><br><span class=\"line\">ContainerParentDataMixin --|&gt; ParentData</span><br><span class=\"line\">ContainerBoxParentData --|&gt; BoxParentData</span><br><span class=\"line\">ContainerBoxParentData --|&gt; ContainerParentDataMixin</span><br><span class=\"line\"></span><br><span class=\"line\">RenderObject *-- ParentData</span><br><span class=\"line\">RenderObjectWithChildMixin --|&gt; RenderObject</span><br><span class=\"line\">ContainerRenderObjectMixin --|&gt; RenderObject</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">class ContainerParentDataMixin&#123;</span><br><span class=\"line\">+ previousSlibling</span><br><span class=\"line\">+ nextSibling</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class ContainerRenderObjectMixin &#123;</span><br><span class=\"line\">+ firstChild *-- ContainerParentDataMixin</span><br><span class=\"line\">+ lastChild</span><br><span class=\"line\">+ childCount</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class BoxParentData&#123;</span><br><span class=\"line\">+ offset</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class RenderObject&#123;</span><br><span class=\"line\">+ parentData</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@enduml</span><br></pre></td></tr></table></figure>","more":"\n<ul>\n<li>ParentData<br>在 Flutter 的布局系统中，该类负责存储父节点所需要的子节点的布局信息<ul>\n<li>BoxParentData<br>– offset<br>包含有一个 offset 属性，该属性用于存储 child 的布局信息，也就是 child 应该被摆在哪个位置。与 Android 不同，Flutter并不是以父View为坐标基础进行绘制的，所以需要带上 offset 参数，得到一个累加的偏移值。至于偏移的参考点在哪里，可以看下面的绘制阶段的原理解析。</li>\n<li>ContainerParentDataMixin<br>– previousSibling<br>– nextSibling<br>该类使用频率很高，基本上所有父节点的 ParentData 都混入了该类，该类需要与ContainerRenderObjectMixin 共同使用，主要解决了对 child 的管理，previousSibling nextSibling 都是child RenderObject, 从而组成把父节点的所有 child 组成了一个双链表</li>\n<li>ContainerBoxParentData<br>空类，继承了 BoxParentData 并且混入了 ContainerParentDataMixin， 使其拥有二者的能力</li>\n</ul>\n</li>\n<li>RenderObject<br>Flutter 中真正实现布局和绘制的类<ul>\n<li>RenderObjectWithChildMixin<br>实现对只有一个child的管理</li>\n<li>ContainerRenderObjectMixin<br>– firstChild<br>– lastChild<br>– childCount<br>实现对多child的管理，firstChild、lastChild、childCount，用来获取首末 child，child的个数，配合使用 ContainerParentDataMixin 中的 previousSibling、nextSibling就可以对 child 进行遍历了。<br>child 的insert、remove、move等操作都在这个Mixin中实现</li>\n</ul>\n</li>\n</ul>\n<p>除了以上的类，Flutter 还提供了 RenderBoxContainerDefaultsMixin，该类提供了一些 RenderBox 默认的行为方法，如上面绘制 child 的流程调用该类中的 defaultPaint(PaintingContext context, Offset offset) 就可以了，可以简化一些模板代码。</p>\n<h2 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h2><p>在 RenderBox 中，控件大小的值为 _size 成员，它只包含宽高两个属性值，我们可以通过该成员的 set 和 get 方法访问或修改它的值。在测量时( layout 方法中)，parent 会传给当前 RenderBox 一个大小的限制，为 BoxConstraints 类型，最后测量得到的 size 必须满足这个限制，在 Flutter 的 debug 模式下对 size 是否满足 constraints 做了 assert 检查，如果检查未通过就会布局失败。所以测量上我们要做的是下面两点：</p>\n<ul>\n<li>如果没有 child，那么根据自身的属性计算出满足 constraints 的 size.</li>\n<li>如果有 child，那么综合自身的属性和 child 的测量结果计算出满足 constraints 的 size.</li>\n</ul>\n<p>测量和布局都在layout方法中完成</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> layout(Constraints constraints, &#123; <span class=\"built_in\">bool</span> parentUsesSize = <span class=\"keyword\">false</span> &#125;) &#123;</span><br><span class=\"line\">  RenderObject relayoutBoundary;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class=\"keyword\">is</span>! RenderObject) &#123;</span><br><span class=\"line\">    relayoutBoundary = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> RenderObject parent = <span class=\"keyword\">this</span>.parent;</span><br><span class=\"line\">    relayoutBoundary = parent._relayoutBoundary;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _constraints = constraints;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_relayoutBoundary != <span class=\"keyword\">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class=\"line\">    visitChildren((RenderObject child) &#123;</span><br><span class=\"line\">      child._cleanRelayoutBoundary();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _relayoutBoundary = relayoutBoundary;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sizedByParent) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      performResize();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">      _debugReportException(<span class=\"string\">'performResize'</span>, e, stack);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    performLayout();</span><br><span class=\"line\">    markNeedsSemanticsUpdate();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'performLayout'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  markNeedsPaint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>parentUsesSize<br>  layout 方法中由父节点传入，表示父节点的 size 依赖当前节点的 size </li>\n<li>constraints<br>  layout 方法中从父节点传入，当前节点会从更新到自己的变量中保存</li>\n<li>relayoutBoundary<br>  relayoutBoundary 是framework层自动设置的，如果满足<br>  <code>(!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject)</code> 则该节点是一个 relayoutBoundary, 否则会从父节点寻找。</li>\n<li>sizedByParent &amp; performResize()<br>  <strong>这两个必须成对配置，performResize() 方法如果被重写，sizedByParent 也必须重写为true，并且你不应该在 perfromLayout() 方法中对 size 重新赋值。</strong><br>  sizedByParent 意为该控件的大小是否能仅通过 parent 赋予它的 constraints 就可以被确定下来了，即该控件的大小与它自身的属性和与它的 child 都无关，比如如果一个控件永远充满 parent 的大小，那么 sizedByParent 就应该返回 true。<br>  <strong>这个操作不是必须的</strong><br>  官方文档中说这是一个优化项，如果完全不care这个，sizedByParent = false，那始终是正确的。 我的理解是，把 size 的计算单独抽出，避免每次 relayout 时对 size 重新计算。<br>  performResize() 这个方法名字可能会造成误会，认为测量必须放在这里，其实大多是情况下，测量和布局都在 performLayout() 中</li>\n<li>performLayout()<br>  上面已经说得差不多了</li>\n</ul>\n<p>如果是在标脏后，在一帧绘制的回调中刷新布局，不会调用layout方法，而是调用_layoutWithoutSize </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _layoutWithoutResize() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    performLayout();</span><br><span class=\"line\">    markNeedsSemanticsUpdate();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'performLayout'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  _needsLayout = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  markNeedsPaint();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"paint\"><a href=\"#paint\" class=\"headerlink\" title=\"paint\"></a>paint</h2><p>父节点绘制子节点的入口</p>\n<p><strong>paintContext.paintChild()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (child.isRepaintBoundary) &#123;</span><br><span class=\"line\">    stopRecordingIfNeeded();</span><br><span class=\"line\">    _compositeChild(child, offset);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    child._paintWithContext(<span class=\"keyword\">this</span>, offset);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create a layer for our child, and paint the child into it.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (child._needsPaint) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个方法会创建layer，然后再调用 child._paintWithContext 方法</span></span><br><span class=\"line\">    repaintCompositedChild(child, debugAlsoPaintedParent: <span class=\"keyword\">true</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> OffsetLayer childOffsetLayer = child._layer;</span><br><span class=\"line\">  childOffsetLayer.offset = offset;</span><br><span class=\"line\">  appendLayer(child._layer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _repaintCompositedChild(</span><br><span class=\"line\">  RenderObject child, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> debugAlsoPaintedParent = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  PaintingContext childContext,</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  OffsetLayer childLayer = child._layer;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childLayer == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    child._layer = childLayer = OffsetLayer();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    childLayer.removeAllChildren();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class=\"line\">  child._paintWithContext(childContext, Offset.zero);</span><br><span class=\"line\">  childContext.stopRecordingIfNeeded();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@protected</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> appendLayer(Layer layer) &#123;</span><br><span class=\"line\">  layer.remove();</span><br><span class=\"line\">  _containerLayer.append(layer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 paintChild 方法中，若 child 是一个 repaintBoundary ，会为 child 创建一个 layer ，然后再调用 child._paintWithContext(this, offset) ；如果 isRepaintBoundary 为false，则直接调用 child._paintWithContext(this, offset)。。<br>所以这个layer又是怎样？？？ </p>\n<p>在drawFrame()中，paint 标脏节点刷新时会直接执行 PaintContext.repaintCompositeChild() </p>\n<p><strong>_paintWithContext(..) &amp; paint()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_needsLayout)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  RenderObject debugLastActivePaint;</span><br><span class=\"line\">  _needsPaint = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    paint(context, offset);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e, stack) &#123;</span><br><span class=\"line\">    _debugReportException(<span class=\"string\">'paint'</span>, e, stack);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>RenderObject 中的 paint 是一个空方法，交给子类来实现。 以 RenderFlex 为例： </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_hasOverflow) &#123;</span><br><span class=\"line\">    defaultPaint(context, offset);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> defaultPaint(PaintingContext context, Offset offset) &#123;</span><br><span class=\"line\">  ChildType child = firstChild;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ParentDataType childParentData = child.parentData;</span><br><span class=\"line\">    context.paintChild(child, childParentData.offset + offset);</span><br><span class=\"line\">    child = childParentData.nextSibling;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为Flex没有要绘制的内容，所以调用 RenderBoxContainerDefaultsMixin 提供的默认实现。在 defaultPaint 中遍历child，绘制child时将 childParentData.offset累加到offset中。所以，这个 offset 的基准到底是个啥？？？？</p>\n<h2 id=\"PaintingContext-和-Layer\"><a href=\"#PaintingContext-和-Layer\" class=\"headerlink\" title=\"PaintingContext 和 Layer\"></a>PaintingContext 和 Layer</h2><h3 id=\"drawFrame\"><a href=\"#drawFrame\" class=\"headerlink\" title=\"drawFrame()\"></a>drawFrame()</h3><p>PaintContext 可以类比于 BuildContext，Layer 和 Element 最终会组成一个 Layer树，最终渲染是在C++的engine层完成的。在flutter的framework层构成了一颗Layer树，传送到engine进行绘制。</p>\n<p>回过头来看，在 drawFrame() 中对需要paint的节点是如何处理的。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> drawFrame() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// BD ADD:</span></span><br><span class=\"line\">  Boost.resetIdleCallbacks();</span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(renderView != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  pipelineOwner.flushLayout();</span><br><span class=\"line\">  pipelineOwner.flushCompositingBits();</span><br><span class=\"line\">  pipelineOwner.flushPaint();</span><br><span class=\"line\">  renderView.compositeFrame(); <span class=\"comment\">// this sends the bits to the GPU</span></span><br><span class=\"line\">  pipelineOwner.flushSemantics(); <span class=\"comment\">// this also sends the semantics to the OS.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先直接来看 pipelineOwner.flushPaint(); 和里面调用到的 PaintContext._repaintCompositedChild </p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> flushPaint() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class=\"line\">    _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class=\"line\">    <span class=\"comment\">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RenderObject node <span class=\"keyword\">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (node._needsPaint &amp;&amp; node.owner == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node._layer.attached) &#123;</span><br><span class=\"line\">          PaintingContext.repaintCompositedChild(node);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          node._skippedPaintingOnLayer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>PaintingContext._repaintCompositedChild(…)</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> _repaintCompositedChild(</span><br><span class=\"line\">  RenderObject child, &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> debugAlsoPaintedParent = <span class=\"keyword\">false</span>,</span><br><span class=\"line\">  PaintingContext childContext,</span><br><span class=\"line\">&#125;) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 关注这个 assert，证明了最终需要 paint 的都是 RepaintBoundary 节点</span></span><br><span class=\"line\">  <span class=\"keyword\">assert</span>(child.isRepaintBoundary);</span><br><span class=\"line\">  OffsetLayer childLayer = child._layer;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childLayer == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为 repaint boundaries 创建layer</span></span><br><span class=\"line\">    child._layer = childLayer = OffsetLayer();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    childLayer.removeAllChildren();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 为 RepaintBoundary 创建 PaintContext</span></span><br><span class=\"line\">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class=\"line\">  <span class=\"comment\">// 初始化了Offset，说明offset的值是以layer为参考依据的</span></span><br><span class=\"line\">  child._paintWithContext(childContext, Offset.zero);</span><br><span class=\"line\"></span><br><span class=\"line\">  childContext.stopRecordingIfNeeded();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次回顾 PaintingContext._repaintCompositedChild 方法，我们发现，它为 RepaintBoundary ，创建了PaintingContext 和 layer。 说明 RepaintBoundary 、PaintingContext 、layer 是一一对应的， <strong>即 layer 是绘制的基本单位，只有 RepaintBoundary 极其子 RenderObject 共享一个layer， 每次绘制会创建都会为 layer 创建一个 PaintingContext</strong>。而 paint 过程中的offset的参考点，就是layer的左上角的坐标原点。</p>\n<p><strong>renderView.compositeFrame();</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> compositeFrame() &#123;</span><br><span class=\"line\">  Timeline.startSync(<span class=\"string\">'Compositing'</span>, arguments: timelineWhitelistArguments);</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ui.SceneBuilder builder = ui.SceneBuilder();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ui.Scene scene = layer.buildScene(builder);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (automaticSystemUiAdjustment)</span><br><span class=\"line\">      _updateSystemChrome();</span><br><span class=\"line\">    _window.render(scene);</span><br><span class=\"line\">    scene.dispose();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    Timeline.finishSync();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>renderView 是页面的根RenderObject，renderView.layer 是页面的根layer。 调用 <code>layer.buildScene(builder);</code> 生成了一个scene， 调用_window.render(scene) 发送给engine层进行渲染</p>\n<h3 id=\"Layer的标脏和局部刷新\"><a href=\"#Layer的标脏和局部刷新\" class=\"headerlink\" title=\"Layer的标脏和局部刷新\"></a>Layer的标脏和局部刷新</h3><p><strong>layer.buildScene</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ui.Scene buildScene(ui.SceneBuilder builder) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;PictureLayer&gt; temporaryLayers;</span><br><span class=\"line\">  updateSubtreeNeedsAddToScene();</span><br><span class=\"line\">  addToScene(builder);</span><br><span class=\"line\">  _needsAddToScene = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> ui.Scene scene = builder.build();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> scene;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> updateSubtreeNeedsAddToScene() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.updateSubtreeNeedsAddToScene();</span><br><span class=\"line\">  Layer child = firstChild;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    child.updateSubtreeNeedsAddToScene();</span><br><span class=\"line\">    _needsAddToScene = _needsAddToScene || child._needsAddToScene;</span><br><span class=\"line\">    <span class=\"comment\">// child.nextSibling 是下一个子layer， 这里显然是一个树的 层序遍历</span></span><br><span class=\"line\">    child = child.nextSibling;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是 ContainerLayer 的实现， 没有子Layer的叶子 Layer 实现各不相同</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</span><br><span class=\"line\">  addChildrenToScene(builder, layerOffset);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> addChildrenToScene(ui.SceneBuilder builder, [ Offset childOffset = Offset.zero ]) &#123;</span><br><span class=\"line\">  Layer child = firstChild;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (child != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (childOffset == Offset.zero) &#123;</span><br><span class=\"line\">      child._addToSceneWithRetainedRendering(builder);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      child.addToScene(builder, childOffset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    child = child.nextSibling;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>renderView 的 layer 是一个 OffsetLayer ，继承自 ContainerLayer 。<br>Layer.buildScene(…) 这个方法在framework调用的地方很少，可以认为只有 renderView 的 layer 会调用 buildScene 方法创建创建一个 scene ， 即 scene 包含了页面的完整 layer 树。</p>\n<p>首先会调用 updateSubtreeNeedsAddToScene ， 需要update的原因是， 如果子layer标脏， 那显然父layer 也需要标脏</p>\n<p><strong>_addToSceneWithRetainedRendering</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> markNeedsAddToScene() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Already marked. Short-circuit.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_needsAddToScene) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _needsAddToScene = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _addToSceneWithRetainedRendering(ui.SceneBuilder builder) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_needsAddToScene &amp;&amp; _engineLayer != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    builder.addRetained(_engineLayer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  addToScene(builder);</span><br><span class=\"line\">  _needsAddToScene = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>markNeedAddToScene() 对 layer 节点进行标脏。在layer属性发生改变时会进行标脏；当子layer添加到父layer时也会进行标脏。</p>\n<p>这个方法是唯一用到使用到 _needsAddToScene 标脏flag值的地方。 如果 _needsAddToScene 为false ，调用 builder.addRetained(_engineLayer); 这个 _engineLayer</p>\n<p>_eingineLayer 是 layer.addToScene(…) 返回的engine生成的图层（ContainerLayer例外，没有engineLayer）</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 这是 OpacityLayer 的addToScene方法，生成了一个 engineLayer ，</span></span><br><span class=\"line\"><span class=\"comment\"> * 然后调用addChildrenToScene(builder);</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">bool</span> enabled = firstChild != <span class=\"keyword\">null</span>;  <span class=\"comment\">// don't add this layer if there's no child</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enabled)</span><br><span class=\"line\">    engineLayer = builder.pushOpacity(alpha, offset: offset + layerOffset, oldLayer: _engineLayer);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    engineLayer = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  addChildrenToScene(builder);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enabled)</span><br><span class=\"line\">    builder.pop();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>SceneBuilder.addRetained()</strong></p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> addRetained(EngineLayer retainedLayer) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> _EngineLayerWrapper wrapper = retainedLayer;</span><br><span class=\"line\">  _addRetained(wrapper._nativeLayer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> _addRetained(EngineLayer retainedLayer) native <span class=\"string\">'SceneBuilder_addRetained'</span>;</span><br></pre></td></tr></table></figure>\n<p>addRetained 直接调用了engine层的代码，对layer进行复用。。。</p>\n<h3 id=\"直接使用-layer-进行UI绘制\"><a href=\"#直接使用-layer-进行UI绘制\" class=\"headerlink\" title=\"直接使用 layer 进行UI绘制\"></a>直接使用 layer 进行UI绘制</h3><p>flutter最终是绘制在layer上的，那样的话，实际上，可以脱离 Widget、Element、RenderObject ，直接操作 layer 进行UI的绘制</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:ui'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:math'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/rendering.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> OffsetLayer rootLayer = <span class=\"keyword\">new</span> OffsetLayer();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> PictureLayer pictureLayer = <span class=\"keyword\">new</span> PictureLayer(Rect.zero);</span><br><span class=\"line\">    rootLayer.append(pictureLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">    PictureRecorder recorder = PictureRecorder();</span><br><span class=\"line\">    Canvas canvas = Canvas(recorder);</span><br><span class=\"line\"></span><br><span class=\"line\">    Paint paint = Paint();</span><br><span class=\"line\">    paint.color = Colors.primaries[Random().nextInt(Colors.primaries.length)];</span><br><span class=\"line\"></span><br><span class=\"line\">    canvas.drawRect(Rect.fromLTWH(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">300</span>, <span class=\"number\">300</span>), paint);</span><br><span class=\"line\">    pictureLayer.picture = recorder.endRecording();</span><br><span class=\"line\">    </span><br><span class=\"line\">    SceneBuilder sceneBuilder = SceneBuilder();</span><br><span class=\"line\">    rootLayer.addToScene(sceneBuilder);</span><br><span class=\"line\"></span><br><span class=\"line\">    Scene scene = sceneBuilder.build();</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.onDrawFrame = ()&#123;</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.render(scene);</span><br><span class=\"line\">      <span class=\"comment\">// window.scheduleFrame();</span></span><br><span class=\"line\">      <span class=\"comment\">// 在onDrawFrame回调最后加上scheduleFrame，可以使UI不断刷新，进行动画操作</span></span><br><span class=\"line\">      <span class=\"comment\">// 不是很懂那vsync的作用是什么。。。</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.scheduleFrame();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>在 main.dart 中添加 <code>debugRepaintRainbowEnabled = true;</code> ，或者通过 devtools 可以观察到App的layer树</p>\n<p><a href=\"https://xieguanglei.github.io/blog/post/flutter-code-chapter-02.html\" target=\"_blank\" rel=\"noopener\">Flutter Framework 源码解析（ 2 ）—— 图层详解</a></p>\n<p><a href=\"https://juejin.im/post/6844904133728665614#heading-10\" target=\"_blank\" rel=\"noopener\">从源码看flutter（四）：Layer篇</a></p>\n<p><a href=\"https://guoshuyu.cn/home/wx/Flutter-21.html\" target=\"_blank\" rel=\"noopener\">Flutter画面渲染全面解析</a></p>\n"},{"title":"协程上下文和异常传播","date":"2022-04-11T15:50:53.000Z","_content":"\n\nhttps://juejin.cn/post/7068901166456766472#heading-6","source":"_posts/Kotlin/协程上下文和异常传播.md","raw":"---\ntitle: 协程上下文和异常传播\ndate: 2022-04-11 23:50:53\ntags: Kotlin\n---\n\n\nhttps://juejin.cn/post/7068901166456766472#heading-6","slug":"Kotlin/协程上下文和异常传播","published":1,"updated":"2022-04-11T16:56:12.838Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno8u0045g0jegf8wuclf","content":"<p><a href=\"https://juejin.cn/post/7068901166456766472#heading-6\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/7068901166456766472#heading-6</a></p>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://juejin.cn/post/7068901166456766472#heading-6\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/7068901166456766472#heading-6</a></p>"},{"title":"handler机制源码解析","date":"2019-11-09T05:59:20.000Z","_content":"\n# Handler机制源码解析\n\n因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。\n\n## 1. Looper\n主要是loop()方法\n```java\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    for (;;) {\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            // 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中.\n            // 只有调用quit方法时,next()方法再能真正的返回null\n            return;\n        }\n        try {\n            // msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方\n            msg.target.dispatchMessage(msg);\n        } finally {\n            ... // 省略代码 \n        }\n        msg.recycleUnchecked();\n    }\n}\n```\n\n## 2. MessageQueue\n\n### 关键成员变量\n\n```java\n// mPtr是native的MessageQueue的指针\nprivate long mPtr; // used by native code\n// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个message\nMessage mMessages;\n\n\n// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作\nprivate final ArrayList<IdleHandler> mIdleHandlers = new ArrayList<IdleHandler>();\nprivate IdleHandler[] mPendingIdleHandlers;\n\nprivate SparseArray<FileDescriptorRecord> mFileDescriptorRecords;\nprivate boolean mQuitting;\n\n// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.\nprivate boolean mBlocked;\n\n// The next barrier token.\n// Barriers are indicated by messages with a null target whose arg1 field carries the token.\nprivate int mNextBarrierToken;\n```\n\n### 构造方法\n```java\nMessageQueue(boolean quitAllowed) {\n    mQuitAllowed = quitAllowed;\n    mPtr = nativeInit();\n}\n```\n\n### next()方法\n\n```java\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        // 调用native层的方法,使用epoll机制,挂起当前线程. \n        // nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            // 获取链表的头结点,即第一个message\n            Message msg = mMessages;\n            // 判断msg是否为同步栅栏\n            // 表示同步栅栏的msg, 其msg.target为null\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                // 寻找队列中第一个异步message\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n\n            // 处理 msg \n            if (msg != null) {\n                if (now < msg.when) {\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n\n            // msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到\n\n            // Process the quit message now that all pending messages have been handled.\n            // 判断是否需要结束循环\n            if (mQuitting) {\n                // dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0\n                // 只有在这里next()方法才会返回null\n                dispose();\n                return null;\n            }\n\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            // 当获取到的message为空, 或者message的执行时间没有到\n            // 当前没有msg可以处理的，开始处理 idleHandler\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                // 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis\n                mBlocked = true;\n                continue;\n            }\n\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        // 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(TAG, \"IdleHandler threw exception\", t);\n            }\n\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n\n#### 1. nativePollOnce(ptr, nextPollTimeoutMillis);\n这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间. \n**特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.** \nnextPollTimeoutMillis = -1 出现的时机两种情况:\n* 消息队列为空\n* 遇到了同步barrier, 并且之后没有遇到异步的msg\n\n#### 2. IdleHandler:\n```java\npublic static interface IdleHandler {\n    /**\n        * Called when the message queue has run out of messages and will now\n        * wait for more.  Return true to keep your idle handler active, false\n        * to have it removed.  This may be called if there are still messages\n        * pending in the queue, but they are all scheduled to be dispatched\n        * after the current time.\n        */\n        // queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次\n    boolean queueIdle();\n}\n```\nMessageQueue中有两个IdleHandler的集合, IdleHandler是一个接口, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到)\n\n#### 3. 同步栅栏 Barrier\n\n* 定义: target为null的msg为同步栅栏\n* 作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg\n* 意义: 相当于为msg添加了一个优先级\n\n### quit()\n\n```java\nvoid quit(boolean safe) {\n    synchronized (this) {\n        if (mQuitting) {\n            return;\n        }\n        mQuitting = true;\n\n        if (safe) {\n            // 这个方法会去除所有的msg.when > now 的msg\n            removeAllFutureMessagesLocked();\n        } else {\n            // 没有任何判断, 直接去除所有的msg\n            removeAllMessagesLocked();\n        }\n\n        // We can assume mPtr != 0 because mQuitting was previously false.\n        // 因为在next()方法中才会调用dispose()方法销毁消息队\n        // 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法\n        nativeWake(mPtr);\n    }\n}\n```\n\n### enqueueMessage\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    ... // 省略代码\n\n    synchronized (this) {\n        if (mQuitting) {\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            // New head, wake up the event queue if blocked.\n            // 添加到队列头部, 有可能是需要wake的\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // Inserted within the middle of the queue.  Usually we don't have to wake\n            // up the event queue unless there is a barrier at the head of the queue\n            // and the message is the earliest asynchronous message in the queue.\n            // 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n\n```\n\n#### **1. 插入顺序:**\n之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序\n\n#### **2. needWake**\n判断是否需要唤醒线程. \n在以下情况下, needWake会为true:\n* 消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1\n* 消息队列不为空, 并且当前线程是blocked的, 新插入msg.when < 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg\n* 消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1\n\n","source":"_posts/Android/Framework/handler机制源码解析.md","raw":"---\ntitle: handler机制源码解析\ndate: 2019-11-09 13:59:20\ntags:\n- Handler\n- 源码解析\ncategories: \n- Android\n---\n\n# Handler机制源码解析\n\n因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。\n\n## 1. Looper\n主要是loop()方法\n```java\npublic static void loop() {\n    final Looper me = myLooper();\n    if (me == null) {\n        throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n    }\n    final MessageQueue queue = me.mQueue;\n\n    for (;;) {\n        Message msg = queue.next(); // might block\n        if (msg == null) {\n            // No message indicates that the message queue is quitting.\n            // 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中.\n            // 只有调用quit方法时,next()方法再能真正的返回null\n            return;\n        }\n        try {\n            // msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方\n            msg.target.dispatchMessage(msg);\n        } finally {\n            ... // 省略代码 \n        }\n        msg.recycleUnchecked();\n    }\n}\n```\n\n## 2. MessageQueue\n\n### 关键成员变量\n\n```java\n// mPtr是native的MessageQueue的指针\nprivate long mPtr; // used by native code\n// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个message\nMessage mMessages;\n\n\n// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作\nprivate final ArrayList<IdleHandler> mIdleHandlers = new ArrayList<IdleHandler>();\nprivate IdleHandler[] mPendingIdleHandlers;\n\nprivate SparseArray<FileDescriptorRecord> mFileDescriptorRecords;\nprivate boolean mQuitting;\n\n// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.\nprivate boolean mBlocked;\n\n// The next barrier token.\n// Barriers are indicated by messages with a null target whose arg1 field carries the token.\nprivate int mNextBarrierToken;\n```\n\n### 构造方法\n```java\nMessageQueue(boolean quitAllowed) {\n    mQuitAllowed = quitAllowed;\n    mPtr = nativeInit();\n}\n```\n\n### next()方法\n\n```java\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        // 调用native层的方法,使用epoll机制,挂起当前线程. \n        // nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            // 获取链表的头结点,即第一个message\n            Message msg = mMessages;\n            // 判断msg是否为同步栅栏\n            // 表示同步栅栏的msg, 其msg.target为null\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                // 寻找队列中第一个异步message\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n\n            // 处理 msg \n            if (msg != null) {\n                if (now < msg.when) {\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // Got a message.\n                    mBlocked = false;\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n                    msg.next = null;\n                    return msg;\n                }\n            } else {\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n\n            // msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到\n\n            // Process the quit message now that all pending messages have been handled.\n            // 判断是否需要结束循环\n            if (mQuitting) {\n                // dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0\n                // 只有在这里next()方法才会返回null\n                dispose();\n                return null;\n            }\n\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            // 当获取到的message为空, 或者message的执行时间没有到\n            // 当前没有msg可以处理的，开始处理 idleHandler\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                // 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis\n                mBlocked = true;\n                continue;\n            }\n\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        // 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(TAG, \"IdleHandler threw exception\", t);\n            }\n\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n\n#### 1. nativePollOnce(ptr, nextPollTimeoutMillis);\n这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间. \n**特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.** \nnextPollTimeoutMillis = -1 出现的时机两种情况:\n* 消息队列为空\n* 遇到了同步barrier, 并且之后没有遇到异步的msg\n\n#### 2. IdleHandler:\n```java\npublic static interface IdleHandler {\n    /**\n        * Called when the message queue has run out of messages and will now\n        * wait for more.  Return true to keep your idle handler active, false\n        * to have it removed.  This may be called if there are still messages\n        * pending in the queue, but they are all scheduled to be dispatched\n        * after the current time.\n        */\n        // queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次\n    boolean queueIdle();\n}\n```\nMessageQueue中有两个IdleHandler的集合, IdleHandler是一个接口, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到)\n\n#### 3. 同步栅栏 Barrier\n\n* 定义: target为null的msg为同步栅栏\n* 作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg\n* 意义: 相当于为msg添加了一个优先级\n\n### quit()\n\n```java\nvoid quit(boolean safe) {\n    synchronized (this) {\n        if (mQuitting) {\n            return;\n        }\n        mQuitting = true;\n\n        if (safe) {\n            // 这个方法会去除所有的msg.when > now 的msg\n            removeAllFutureMessagesLocked();\n        } else {\n            // 没有任何判断, 直接去除所有的msg\n            removeAllMessagesLocked();\n        }\n\n        // We can assume mPtr != 0 because mQuitting was previously false.\n        // 因为在next()方法中才会调用dispose()方法销毁消息队\n        // 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法\n        nativeWake(mPtr);\n    }\n}\n```\n\n### enqueueMessage\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    ... // 省略代码\n\n    synchronized (this) {\n        if (mQuitting) {\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            // New head, wake up the event queue if blocked.\n            // 添加到队列头部, 有可能是需要wake的\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // Inserted within the middle of the queue.  Usually we don't have to wake\n            // up the event queue unless there is a barrier at the head of the queue\n            // and the message is the earliest asynchronous message in the queue.\n            // 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n\n```\n\n#### **1. 插入顺序:**\n之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序\n\n#### **2. needWake**\n判断是否需要唤醒线程. \n在以下情况下, needWake会为true:\n* 消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1\n* 消息队列不为空, 并且当前线程是blocked的, 新插入msg.when < 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg\n* 消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1\n\n","slug":"Android/Framework/handler机制源码解析","published":1,"updated":"2021-10-03T01:57:41.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno91004pg0jecdbzr6ii","content":"<h1 id=\"Handler机制源码解析\"><a href=\"#Handler机制源码解析\" class=\"headerlink\" title=\"Handler机制源码解析\"></a>Handler机制源码解析</h1><p>因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。</p><a id=\"more\"></a>\n<h2 id=\"1-Looper\"><a href=\"#1-Looper\" class=\"headerlink\" title=\"1. Looper\"></a>1. Looper</h2><p>主要是loop()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></span><br><span class=\"line\">            <span class=\"comment\">// 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中.</span></span><br><span class=\"line\">            <span class=\"comment\">// 只有调用quit方法时,next()方法再能真正的返回null</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            ... <span class=\"comment\">// 省略代码 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-MessageQueue\"><a href=\"#2-MessageQueue\" class=\"headerlink\" title=\"2. MessageQueue\"></a>2. MessageQueue</h2><h3 id=\"关键成员变量\"><a href=\"#关键成员变量\" class=\"headerlink\" title=\"关键成员变量\"></a>关键成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mPtr是native的MessageQueue的指针</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mPtr; <span class=\"comment\">// used by native code</span></span><br><span class=\"line\"><span class=\"comment\">// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个message</span></span><br><span class=\"line\">Message mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class=\"keyword\">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mQuitting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mBlocked;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The next barrier token.</span></span><br><span class=\"line\"><span class=\"comment\">// Barriers are indicated by messages with a null target whose arg1 field carries the token.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mNextBarrierToken;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123;</span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    mPtr = nativeInit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"next-方法\"><a href=\"#next-方法\" class=\"headerlink\" title=\"next()方法\"></a>next()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Return here if the message loop has already quit and been disposed.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can happen if the application tries to restart a looper after quit</span></span><br><span class=\"line\">    <span class=\"comment\">// which is not supported.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用native层的方法,使用epoll机制,挂起当前线程. </span></span><br><span class=\"line\">        <span class=\"comment\">// nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 获取链表的头结点,即第一个message</span></span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\">            <span class=\"comment\">// 判断msg是否为同步栅栏</span></span><br><span class=\"line\">            <span class=\"comment\">// 表示同步栅栏的msg, 其msg.target为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\">                <span class=\"comment\">// 寻找队列中第一个异步message</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 处理 msg </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">            <span class=\"comment\">// 判断是否需要结束循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0</span></span><br><span class=\"line\">                <span class=\"comment\">// 只有在这里next()方法才会返回null</span></span><br><span class=\"line\">                dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If first time idle, then get the number of idlers to run.</span></span><br><span class=\"line\">            <span class=\"comment\">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class=\"line\">            <span class=\"comment\">// 当获取到的message为空, 或者message的执行时间没有到</span></span><br><span class=\"line\">            <span class=\"comment\">// 当前没有msg可以处理的，开始处理 idleHandler</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">                <span class=\"comment\">// 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis</span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.</span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration.</span></span><br><span class=\"line\">        <span class=\"comment\">// 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>; <span class=\"comment\">// release the reference to the handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                keep = idler.queueIdle();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// While calling an idle handler, a new message could have been delivered</span></span><br><span class=\"line\">        <span class=\"comment\">// so go back and look again for a pending message without waiting.</span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-nativePollOnce-ptr-nextPollTimeoutMillis\"><a href=\"#1-nativePollOnce-ptr-nextPollTimeoutMillis\" class=\"headerlink\" title=\"1. nativePollOnce(ptr, nextPollTimeoutMillis);\"></a>1. nativePollOnce(ptr, nextPollTimeoutMillis);</h4><p>这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间.<br><strong>特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.</strong><br>nextPollTimeoutMillis = -1 出现的时机两种情况:</p>\n<ul>\n<li>消息队列为空</li>\n<li>遇到了同步barrier, 并且之后没有遇到异步的msg</li>\n</ul>\n<h4 id=\"2-IdleHandler\"><a href=\"#2-IdleHandler\" class=\"headerlink\" title=\"2. IdleHandler:\"></a>2. IdleHandler:</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IdleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Called when the message queue has run out of messages and will now</span></span><br><span class=\"line\"><span class=\"comment\">        * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class=\"line\"><span class=\"comment\">        * to have it removed.  This may be called if there are still messages</span></span><br><span class=\"line\"><span class=\"comment\">        * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class=\"line\"><span class=\"comment\">        * after the current time.</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"comment\">// queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue中有两个IdleHandler的集合, IdleHandler是一个接口, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到)</p>\n<h4 id=\"3-同步栅栏-Barrier\"><a href=\"#3-同步栅栏-Barrier\" class=\"headerlink\" title=\"3. 同步栅栏 Barrier\"></a>3. 同步栅栏 Barrier</h4><ul>\n<li>定义: target为null的msg为同步栅栏</li>\n<li>作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg</li>\n<li>意义: 相当于为msg添加了一个优先级</li>\n</ul>\n<h3 id=\"quit\"><a href=\"#quit\" class=\"headerlink\" title=\"quit()\"></a>quit()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">(<span class=\"keyword\">boolean</span> safe)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mQuitting = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (safe) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个方法会去除所有的msg.when &gt; now 的msg</span></span><br><span class=\"line\">            removeAllFutureMessagesLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有任何判断, 直接去除所有的msg</span></span><br><span class=\"line\">            removeAllMessagesLocked();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为在next()方法中才会调用dispose()方法销毁消息队</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法</span></span><br><span class=\"line\">        nativeWake(mPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"enqueueMessage\"><a href=\"#enqueueMessage\" class=\"headerlink\" title=\"enqueueMessage\"></a>enqueueMessage</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// New head, wake up the event queue if blocked.</span></span><br><span class=\"line\">            <span class=\"comment\">// 添加到队列头部, 有可能是需要wake的</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class=\"line\">            <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class=\"line\">            <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class=\"line\">            <span class=\"comment\">// 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-插入顺序\"><a href=\"#1-插入顺序\" class=\"headerlink\" title=\"1. 插入顺序:\"></a><strong>1. 插入顺序:</strong></h4><p>之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序</p>\n<h4 id=\"2-needWake\"><a href=\"#2-needWake\" class=\"headerlink\" title=\"2. needWake\"></a><strong>2. needWake</strong></h4><p>判断是否需要唤醒线程.<br>在以下情况下, needWake会为true:</p>\n<ul>\n<li>消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1</li>\n<li>消息队列不为空, 并且当前线程是blocked的, 新插入msg.when &lt; 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg</li>\n<li>消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"Handler机制源码解析\"><a href=\"#Handler机制源码解析\" class=\"headerlink\" title=\"Handler机制源码解析\"></a>Handler机制源码解析</h1><p>因为handler机制的大概源码网上都有，也很好理解，这里对关键源码做一些理解。</p>","more":"\n<h2 id=\"1-Looper\"><a href=\"#1-Looper\" class=\"headerlink\" title=\"1. Looper\"></a>1. Looper</h2><p>主要是loop()方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Looper me = myLooper();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (me == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"No Looper; Looper.prepare() wasn't called on this thread.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> MessageQueue queue = me.mQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Message msg = queue.next(); <span class=\"comment\">// might block</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (msg == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No message indicates that the message queue is quitting.</span></span><br><span class=\"line\">            <span class=\"comment\">// 当queue.next为空时,跳出循环. 但是,实际上当queue为空时,并不会返回null,而是一直阻塞在next()方法中.</span></span><br><span class=\"line\">            <span class=\"comment\">// 只有调用quit方法时,next()方法再能真正的返回null</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// msg的target为Handler, 这里是handler中handleMessage()或者callback具体调用的地方</span></span><br><span class=\"line\">            msg.target.dispatchMessage(msg);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            ... <span class=\"comment\">// 省略代码 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        msg.recycleUnchecked();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-MessageQueue\"><a href=\"#2-MessageQueue\" class=\"headerlink\" title=\"2. MessageQueue\"></a>2. MessageQueue</h2><h3 id=\"关键成员变量\"><a href=\"#关键成员变量\" class=\"headerlink\" title=\"关键成员变量\"></a>关键成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mPtr是native的MessageQueue的指针</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mPtr; <span class=\"comment\">// used by native code</span></span><br><span class=\"line\"><span class=\"comment\">// mMessages是消息队列的存储, 数据结构是一个单链表. next属性指向下一个message</span></span><br><span class=\"line\">Message mMessages;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面两个是IdleHandler的集合, IdleHandler用来在消息队列空闲时做一些操作</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class=\"keyword\">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class=\"line\"><span class=\"keyword\">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mQuitting;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mBlocked;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The next barrier token.</span></span><br><span class=\"line\"><span class=\"comment\">// Barriers are indicated by messages with a null target whose arg1 field carries the token.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mNextBarrierToken;</span><br></pre></td></tr></table></figure>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MessageQueue(<span class=\"keyword\">boolean</span> quitAllowed) &#123;</span><br><span class=\"line\">    mQuitAllowed = quitAllowed;</span><br><span class=\"line\">    mPtr = nativeInit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"next-方法\"><a href=\"#next-方法\" class=\"headerlink\" title=\"next()方法\"></a>next()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Message <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Return here if the message loop has already quit and been disposed.</span></span><br><span class=\"line\">    <span class=\"comment\">// This can happen if the application tries to restart a looper after quit</span></span><br><span class=\"line\">    <span class=\"comment\">// which is not supported.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> ptr = mPtr;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ptr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pendingIdleHandlerCount = -<span class=\"number\">1</span>; <span class=\"comment\">// -1 only during first iteration</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextPollTimeoutMillis != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Binder.flushPendingCommands();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用native层的方法,使用epoll机制,挂起当前线程. </span></span><br><span class=\"line\">        <span class=\"comment\">// nextPollTimeoutMillis为挂起时间, 为-1时表示永久挂起</span></span><br><span class=\"line\">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Try to retrieve the next message.  Return if found.</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">            Message prevMsg = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 获取链表的头结点,即第一个message</span></span><br><span class=\"line\">            Message msg = mMessages;</span><br><span class=\"line\">            <span class=\"comment\">// 判断msg是否为同步栅栏</span></span><br><span class=\"line\">            <span class=\"comment\">// 表示同步栅栏的msg, 其msg.target为null</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; msg.target == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class=\"line\">                <span class=\"comment\">// 寻找队列中第一个异步message</span></span><br><span class=\"line\">                <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                    prevMsg = msg;</span><br><span class=\"line\">                    msg = msg.next;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">while</span> (msg != <span class=\"keyword\">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 处理 msg </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (now &lt; msg.when) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class=\"line\">                    nextPollTimeoutMillis = (<span class=\"keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Got a message.</span></span><br><span class=\"line\">                    mBlocked = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevMsg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        prevMsg.next = msg.next;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        mMessages = msg.next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    msg.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No more messages.</span></span><br><span class=\"line\">                nextPollTimeoutMillis = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// msg为null, 有可能是消息队列为空, 有可能是msg的时间没有到</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Process the quit message now that all pending messages have been handled.</span></span><br><span class=\"line\">            <span class=\"comment\">// 判断是否需要结束循环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// dispose()方法做销毁工作, 会销毁native层的队列, 并把mPtr置0</span></span><br><span class=\"line\">                <span class=\"comment\">// 只有在这里next()方法才会返回null</span></span><br><span class=\"line\">                dispose();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If first time idle, then get the number of idlers to run.</span></span><br><span class=\"line\">            <span class=\"comment\">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class=\"line\">            <span class=\"comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class=\"line\">            <span class=\"comment\">// 当获取到的message为空, 或者message的执行时间没有到</span></span><br><span class=\"line\">            <span class=\"comment\">// 当前没有msg可以处理的，开始处理 idleHandler</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"number\">0</span></span><br><span class=\"line\">                    &amp;&amp; (mMessages == <span class=\"keyword\">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class=\"line\">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class=\"line\">                <span class=\"comment\">// 走到这里表示该线程需要阻塞一段时间, 阻塞时间为nextPollTimeoutMillis</span></span><br><span class=\"line\">                mBlocked = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mPendingIdleHandlers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mPendingIdleHandlers = <span class=\"keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"number\">4</span>)];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Run the idle handlers.</span></span><br><span class=\"line\">        <span class=\"comment\">// We only ever reach this code block during the first iteration.</span></span><br><span class=\"line\">        <span class=\"comment\">// 在消息队列空闲时, 遍历idleHandler集合, 执行idleHandler的相关方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class=\"line\">            mPendingIdleHandlers[i] = <span class=\"keyword\">null</span>; <span class=\"comment\">// release the reference to the handler</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> keep = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                keep = idler.queueIdle();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">                Log.wtf(TAG, <span class=\"string\">\"IdleHandler threw exception\"</span>, t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!keep) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    mIdleHandlers.remove(idler);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class=\"line\">        pendingIdleHandlerCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// While calling an idle handler, a new message could have been delivered</span></span><br><span class=\"line\">        <span class=\"comment\">// so go back and look again for a pending message without waiting.</span></span><br><span class=\"line\">        nextPollTimeoutMillis = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-nativePollOnce-ptr-nextPollTimeoutMillis\"><a href=\"#1-nativePollOnce-ptr-nextPollTimeoutMillis\" class=\"headerlink\" title=\"1. nativePollOnce(ptr, nextPollTimeoutMillis);\"></a>1. nativePollOnce(ptr, nextPollTimeoutMillis);</h4><p>这个方法在native层调用epoll机制, 讲当前线程挂起nextPollTimeoutMillis的时间.<br><strong>特别的nextPollTimeoutMillis = -1时, 永久挂起, 需要java层调用nativeWake()方法才能唤醒.</strong><br>nextPollTimeoutMillis = -1 出现的时机两种情况:</p>\n<ul>\n<li>消息队列为空</li>\n<li>遇到了同步barrier, 并且之后没有遇到异步的msg</li>\n</ul>\n<h4 id=\"2-IdleHandler\"><a href=\"#2-IdleHandler\" class=\"headerlink\" title=\"2. IdleHandler:\"></a>2. IdleHandler:</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IdleHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * Called when the message queue has run out of messages and will now</span></span><br><span class=\"line\"><span class=\"comment\">        * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class=\"line\"><span class=\"comment\">        * to have it removed.  This may be called if there are still messages</span></span><br><span class=\"line\"><span class=\"comment\">        * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class=\"line\"><span class=\"comment\">        * after the current time.</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"comment\">// queueIdle()返回值为false, 表示这个IdleHandler仅仅执行一次就自动销毁; 返回为true, 表示可以执行多次</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MessageQueue中有两个IdleHandler的集合, IdleHandler是一个接口, 实现了这个接口的handler可以用来在MessageQueue空闲时, 做一些操作, 即 获取message为null时(可能是队列为空, 也可能是时间没到)</p>\n<h4 id=\"3-同步栅栏-Barrier\"><a href=\"#3-同步栅栏-Barrier\" class=\"headerlink\" title=\"3. 同步栅栏 Barrier\"></a>3. 同步栅栏 Barrier</h4><ul>\n<li>定义: target为null的msg为同步栅栏</li>\n<li>作用: 当出现一个Barrier, 跳过所有的同步msg, 只执行异步msg</li>\n<li>意义: 相当于为msg添加了一个优先级</li>\n</ul>\n<h3 id=\"quit\"><a href=\"#quit\" class=\"headerlink\" title=\"quit()\"></a>quit()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">quit</span><span class=\"params\">(<span class=\"keyword\">boolean</span> safe)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mQuitting = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (safe) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这个方法会去除所有的msg.when &gt; now 的msg</span></span><br><span class=\"line\">            removeAllFutureMessagesLocked();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有任何判断, 直接去除所有的msg</span></span><br><span class=\"line\">            removeAllMessagesLocked();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为在next()方法中才会调用dispose()方法销毁消息队</span></span><br><span class=\"line\">        <span class=\"comment\">// 并且可能当前线程是阻塞的. 所以需要先要唤醒当前线程, 继续执行next()方法</span></span><br><span class=\"line\">        nativeWake(mPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"enqueueMessage\"><a href=\"#enqueueMessage\" class=\"headerlink\" title=\"enqueueMessage\"></a>enqueueMessage</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">enqueueMessage</span><span class=\"params\">(Message msg, <span class=\"keyword\">long</span> when)</span> </span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mQuitting) &#123;</span><br><span class=\"line\">            msg.recycle();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        msg.markInUse();</span><br><span class=\"line\">        msg.when = when;</span><br><span class=\"line\">        Message p = mMessages;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> needWake;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when == <span class=\"number\">0</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// New head, wake up the event queue if blocked.</span></span><br><span class=\"line\">            <span class=\"comment\">// 添加到队列头部, 有可能是需要wake的</span></span><br><span class=\"line\">            msg.next = p;</span><br><span class=\"line\">            mMessages = msg;</span><br><span class=\"line\">            needWake = mBlocked;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class=\"line\">            <span class=\"comment\">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class=\"line\">            <span class=\"comment\">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class=\"line\">            <span class=\"comment\">// 插入到队列的中间位置. 通常这种情况下, 我们不需要wake线程. 除非有一种请求, 就是队列的头msg是一个同步barrier, 并且新插入的msg是一个异步消息</span></span><br><span class=\"line\">            needWake = mBlocked &amp;&amp; p.target == <span class=\"keyword\">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class=\"line\">            Message prev;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                prev = p;</span><br><span class=\"line\">                p = p.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span> || when &lt; p.when) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class=\"line\">                    needWake = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            msg.next = p; <span class=\"comment\">// invariant: p == prev.next</span></span><br><span class=\"line\">            prev.next = msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (needWake) &#123;</span><br><span class=\"line\">            nativeWake(mPtr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-插入顺序\"><a href=\"#1-插入顺序\" class=\"headerlink\" title=\"1. 插入顺序:\"></a><strong>1. 插入顺序:</strong></h4><p>之前说了存储msg的数据机构是一个单链表, 并且链表是按照msg.when排序的(按执行的时间顺序排序). 所以插入时要寻找合适的位置, 保证排序</p>\n<h4 id=\"2-needWake\"><a href=\"#2-needWake\" class=\"headerlink\" title=\"2. needWake\"></a><strong>2. needWake</strong></h4><p>判断是否需要唤醒线程.<br>在以下情况下, needWake会为true:</p>\n<ul>\n<li>消息队列为空, 并且当前线程是blocked的. 这种情况下nativePollOnce方法执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1</li>\n<li>消息队列不为空, 并且当前线程是blocked的, 新插入msg.when &lt; 头结点p.when. 这种情况表示, 消息队列中头结点的时间还没到, 目标线程已经被挂起了, 但是新插入的msg执行时间小于头结点的时间, 此时当然应该唤醒线程先执行新msg</li>\n<li>消息队列不为空, 但是消息队列头结点是一个同步barrier, 并且新插入的msg为异步消息. 这种情况下nativePollOnce方法同样执行过, 目标线程被挂起, 并且nextPollTimeoutMillis = -1</li>\n</ul>\n"},{"title":"startService()和bindService()","date":"2019-07-04T12:37:58.000Z","_content":"\n# startService()和bindService()的区别\n\n![](/images/startService\\ and\\ bindService)\n\n### 生命周期上的差别\n#### startService()\n执行startService时，Service经历onCreate->onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。\n\n多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。**但是每次调用startService，onStartCommand方法都会被调用。**无论startService调用多少次，stopService只需要调用一次就能够终止Service\n\n#### BindService()\nbindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。\n1. **onBind返回值是null**\n调用bindService开启服务，生命周期执行的方法依次是：\nonCreate() ==> onBind();\n**调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。** 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。\n2. **onBind返回值不为null**\n这时候调用bindService开启服务，生命周期执行的方法依次是：\nonCreate() ==> onBind() ==> onServiceConnected();\n可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。**调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。**\n并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。\n也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。\n调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。\n<br>\n**总结**\n第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。\n\n### 既使用startService又使用bindService的情况\n如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。\n\n参考链接:\n[https://my.oschina.net/tingzi/blog/376545]()\n[https://www.jianshu.com/p/d870f99b675c]()\n\n# startService 启动过程源码分析\n\nContextImpl.startService(...) 最终会调用到 AMS 的对应方法，最终会调用到 ActivityService.startServiceLocked(...)\n\n```java\n// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java\n    ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,\n            int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)\n            throws TransactionTooLargeException {\n\n        ServiceLookupResult res =\n            retrieveServiceLocked(service, resolvedType, callingPackage,\n                    callingPid, callingUid, userId, true, callerFg, false, false);\n        ServiceRecord r = res.record;\n\n        ...\n\n        // ServiceRecord.StartItem 用于在 service 启动之后调用 startCommond\n        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),\n                service, neededGrants, callingUid));\n\n        ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);\n        return cmp;\n    }\n\n    ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,\n            boolean callerFg, boolean addToStarting) throws TransactionTooLargeException {\n\n        String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);\n        ...\n        return r.name;\n    }\n\n    private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,\n            boolean whileRestarting, boolean permissionsReviewRequired)\n            throws TransactionTooLargeException {\n\n        if (r.app != null && r.app.thread != null) {\n            // service 的进程已经启动，sendServiceArgsLocked 用于调用 startCommond() 方法\n            sendServiceArgsLocked(r, execInFg, false);\n            return null;\n        }\n\n        final boolean isolated = (r.serviceInfo.flags&ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;\n        final String procName = r.processName;\n        String hostingType = \"service\";\n        ProcessRecord app;\n\n        if (!isolated) {\n            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);\n            if (app != null && app.thread != null) {\n                // service 不是单独的进程且，service 所在进程已经启动，则直接启动进程\n                try {\n                    realStartServiceLocked(r, app, execInFg);\n                    return null;\n                } ...\n            }\n        } else {\n            app = r.isolatedProc;\n            ...\n        }\n\n        if (app == null && !permissionsReviewRequired) {\n            // servie 所在的进程还没有启动，启动相应的进程\n            if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,\n                    hostingType, r.name, false, isolated, false)) == null) {\n                String msg = ...\n                return msg;\n            }\n            if (isolated) {\n                r.isolatedProc = app;\n            }\n        }\n\n        // 暂存进程未启动的 service , 当 service 进程启动完，Application 进行 AMS.attach() 的时候，会 mPendingServices 取出 ServiceRecord 并执行 realStartServiceLocked \n        if (!mPendingServices.contains(r)) {\n            mPendingServices.add(r);\n        }\n\n        return null;\n    }\n\n    private final void realStartServiceLocked(ServiceRecord r,\n            ProcessRecord app, boolean execInFg) throws RemoteException {\n        if (app.thread == null) {\n            // service 进程未启动，抛出异常\n            throw new RemoteException();\n        }\n        r.app = app;\n        r.restartTime = r.lastActivity = SystemClock.uptimeMillis();\n\n        final boolean newService = app.services.add(r);\n\n        boolean created = false;\n        try {\n            ...\n            // 调用 Service 的 onCreate 方法\n            app.thread.scheduleCreateService(r, r.serviceInfo,\n                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),\n                    app.repProcState);\n            r.postNotification();\n            created = true;\n        } catch (DeadObjectException e) {\n            ...\n        } finally {\n            ...\n        }\n\n        // 向 service 请求 binder 对象\n        requestServiceBindingsLocked(r, execInFg);\n\n        if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {\n            // 如果 r.pendingStarts 为空，就添加一个，pendingStarts 在调用 service.startCommond() 有用\n            // 只有在 startService 的时候，r.startRequested才会为true\n            r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),\n                    null, null, 0));\n        }\n\n        // 执行 startCommond()\n        sendServiceArgsLocked(r, execInFg, true);\n        ...\n    }\n```\n\nstartService 暂时就到这，后面的就很简单了。\n\n# bindService 启动流程源码分析\n\n## bindService 启动流程概述\n\n1. 应用端调用 AMS.bindService\n2. AMS 查找是否存在这个 service 的 binder 对象，如果不存在，则启动 service 并请求 binder 对象\n3. service 将 binder 对象发布到 AMS\n4. AMS 返回 service 的 binder 对象给 应用\n\n## 应用端\n\n```java\n// frameworks/base/core/java/android/app/ContextImpl.java\n    private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler\n            handler, UserHandle user) {\n        IServiceConnection sd;\n        if (mPackageInfo != null) {\n            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);\n        } else {\n            throw new ...\n        }\n        try {\n            ...\n            int res = ActivityManager.getService().bindService(\n                mMainThread.getApplicationThread(), getActivityToken(), service,\n                service.resolveTypeIfNeeded(getContentResolver()),\n                sd, flags, getOpPackageName(), user.getIdentifier());\n            return res != 0;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n```\nIServiceConnection 是一个 IBinder 对象，但是 ServiceConnection 是一个只是一样普通对象。 ServiceDispatcher 可以理解为 IServiceConnection 和 ServiceConnection 的衔接者。 ServiceDispatcher 和 IServiceConnection 是一对一的，但是 IServiceConnection 和 ServiceConnection 不是。可以理解为 IServiceConnection 和 ServiceConnection + Context 是一对一的\n\n我们来看 ServiceDispatcher.connected(...)\n\n```java\n// frameworks/base/core/java/android/app/LoadedApk.java\n// ServiceDispatcher\n        public void connected(ComponentName name, IBinder service, boolean dead) {\n            if (mActivityThread != null) {\n                // 从 Binder 线程池切换到主线程\n                mActivityThread.post(new RunConnection(name, service, 0, dead));\n            } else {\n                doConnected(name, service, dead);\n            }\n        }\n        public void doConnected(ComponentName name, IBinder service, boolean dead) {\n            ServiceDispatcher.ConnectionInfo old;\n            ServiceDispatcher.ConnectionInfo info;\n\n            synchronized (this) {\n                old = mActiveConnections.get(name);\n                if (old != null && old.binder == service) {\n                    // Huh, already have this one.  Oh well!\n                    // 如果应用端已经存在 service 的 binder 对象，则不做处理。\n                    // 所以，onServiceConnected 只会执行一次 \n                    return;\n                }\n\n                if (service != null) {\n                    // A new service is being connected... set it all up.\n                    info = new ConnectionInfo();\n                    info.binder = service;\n                    info.deathMonitor = new DeathMonitor(name, service);\n                    try {\n                        // linkToDeath 监控 binder 死亡， 会调用 service.onServiceDisconnected\n                        service.linkToDeath(info.deathMonitor, 0);\n                        mActiveConnections.put(name, info);\n                    } catch (RemoteException e) {\n                        // This service was dead before we got it...  just\n                        // don't do anything with it.\n                        mActiveConnections.remove(name);\n                        return;\n                    }\n\n                } else {\n                    // The named service is being disconnected... clean up.\n                    mActiveConnections.remove(name);\n                }\n\n                if (old != null) {\n                    old.binder.unlinkToDeath(old.deathMonitor, 0);\n                }\n            }\n\n            // If there was an old service, it is now disconnected.\n            if (old != null) {\n                // old 不为空，还走到了这里，说明是断开连接\n                mConnection.onServiceDisconnected(name);\n            }\n            if (dead) {\n                mConnection.onBindingDied(name);\n            }\n            // If there is a new viable service, it is now connected.\n            if (service != null) {\n                mConnection.onServiceConnected(name, service);\n            } else {\n                // The binding machinery worked, but the remote returned null from onBind().\n                mConnection.onNullBinding(name);\n            }\n        }\n```\n\n## AMS\n\n```java\n    int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,\n            String resolvedType, final IServiceConnection connection, int flags,\n            String callingPackage, final int userId) throws TransactionTooLargeException {\n\n            ServiceLookupResult res = retrieveServiceLocked(service, ...);\n            ServiceRecord s = res.record;\n\n            if ((flags&Context.BIND_AUTO_CREATE) != 0) {\n                // 启动 service ，和 bindService 一样，可以翻翻上面\n                if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,\n                        permissionsReviewRequired) != null) {\n                    return 0;\n                }\n            }\n\n            if (s.app != null && b.intent.received) {\n                // service 的进程已经启动，并且，已经将 binder 对象发布给 AMS\n                // 直接调用应用端连接\n                try {\n                    c.conn.connected(s.name, b.intent.binder, false);\n                } catch (Exception e) {\n                    ...\n                }\n\n                // If this is the first app connected back to this binding,\n                // and the service had previously asked to be told when\n                // rebound, then do so.\n                if (b.intent.apps.size() == 1 && b.intent.doRebind) {\n                    requestServiceBindingLocked(s, b.intent, callerFg, true);\n                }\n            }  else if (!b.intent.requested) {\n                // !b.intent.requested 表明还未向 service 请求 binder 对象\n                requestServiceBindingLocked(s, b.intent, callerFg, false);\n            }\n    }\n\n    private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,\n            boolean execInFg, boolean rebind) throws TransactionTooLargeException {\n        if (r.app == null || r.app.thread == null) {\n            // If service is not currently running, can't yet bind.\n            return false;\n        }\n        if ((!i.requested || rebind) && i.apps.size() > 0) {\n            // 没有请求过 binder 对象， 或者 rebind\n            try {\n                // 调用 service 所在对象的 onBind 并将发挥的 binder 对象发布给 AMS\n                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,\n                        r.app.repProcState);\n                if (!rebind) {\n                    i.requested = true;\n                }\n                i.hasBound = true;\n                i.doRebind = false;\n            } catch (TransactionTooLargeException e) {\n                ...\n            } catch (RemoteException e) {\n                ...\n                return false;\n            }\n        }\n        return true;\n    }\n```\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Framework/startService-和bindService.md","raw":"---\ntitle: startService()和bindService()\ndate: 2019-07-04 20:37:58\ntags: \n- Service\ncategories:\n- Android\n- Service\n- Framework\n---\n\n# startService()和bindService()的区别\n\n![](/images/startService\\ and\\ bindService)\n\n### 生命周期上的差别\n#### startService()\n执行startService时，Service经历onCreate->onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。\n\n多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。**但是每次调用startService，onStartCommand方法都会被调用。**无论startService调用多少次，stopService只需要调用一次就能够终止Service\n\n#### BindService()\nbindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。\n1. **onBind返回值是null**\n调用bindService开启服务，生命周期执行的方法依次是：\nonCreate() ==> onBind();\n**调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。** 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。\n2. **onBind返回值不为null**\n这时候调用bindService开启服务，生命周期执行的方法依次是：\nonCreate() ==> onBind() ==> onServiceConnected();\n可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。**调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。**\n并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。\n也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。\n调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。\n<br>\n**总结**\n第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。\n\n### 既使用startService又使用bindService的情况\n如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。\n\n参考链接:\n[https://my.oschina.net/tingzi/blog/376545]()\n[https://www.jianshu.com/p/d870f99b675c]()\n\n# startService 启动过程源码分析\n\nContextImpl.startService(...) 最终会调用到 AMS 的对应方法，最终会调用到 ActivityService.startServiceLocked(...)\n\n```java\n// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java\n    ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType,\n            int callingPid, int callingUid, boolean fgRequired, String callingPackage, final int userId)\n            throws TransactionTooLargeException {\n\n        ServiceLookupResult res =\n            retrieveServiceLocked(service, resolvedType, callingPackage,\n                    callingPid, callingUid, userId, true, callerFg, false, false);\n        ServiceRecord r = res.record;\n\n        ...\n\n        // ServiceRecord.StartItem 用于在 service 启动之后调用 startCommond\n        r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),\n                service, neededGrants, callingUid));\n\n        ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);\n        return cmp;\n    }\n\n    ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r,\n            boolean callerFg, boolean addToStarting) throws TransactionTooLargeException {\n\n        String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false);\n        ...\n        return r.name;\n    }\n\n    private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg,\n            boolean whileRestarting, boolean permissionsReviewRequired)\n            throws TransactionTooLargeException {\n\n        if (r.app != null && r.app.thread != null) {\n            // service 的进程已经启动，sendServiceArgsLocked 用于调用 startCommond() 方法\n            sendServiceArgsLocked(r, execInFg, false);\n            return null;\n        }\n\n        final boolean isolated = (r.serviceInfo.flags&ServiceInfo.FLAG_ISOLATED_PROCESS) != 0;\n        final String procName = r.processName;\n        String hostingType = \"service\";\n        ProcessRecord app;\n\n        if (!isolated) {\n            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false);\n            if (app != null && app.thread != null) {\n                // service 不是单独的进程且，service 所在进程已经启动，则直接启动进程\n                try {\n                    realStartServiceLocked(r, app, execInFg);\n                    return null;\n                } ...\n            }\n        } else {\n            app = r.isolatedProc;\n            ...\n        }\n\n        if (app == null && !permissionsReviewRequired) {\n            // servie 所在的进程还没有启动，启动相应的进程\n            if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags,\n                    hostingType, r.name, false, isolated, false)) == null) {\n                String msg = ...\n                return msg;\n            }\n            if (isolated) {\n                r.isolatedProc = app;\n            }\n        }\n\n        // 暂存进程未启动的 service , 当 service 进程启动完，Application 进行 AMS.attach() 的时候，会 mPendingServices 取出 ServiceRecord 并执行 realStartServiceLocked \n        if (!mPendingServices.contains(r)) {\n            mPendingServices.add(r);\n        }\n\n        return null;\n    }\n\n    private final void realStartServiceLocked(ServiceRecord r,\n            ProcessRecord app, boolean execInFg) throws RemoteException {\n        if (app.thread == null) {\n            // service 进程未启动，抛出异常\n            throw new RemoteException();\n        }\n        r.app = app;\n        r.restartTime = r.lastActivity = SystemClock.uptimeMillis();\n\n        final boolean newService = app.services.add(r);\n\n        boolean created = false;\n        try {\n            ...\n            // 调用 Service 的 onCreate 方法\n            app.thread.scheduleCreateService(r, r.serviceInfo,\n                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),\n                    app.repProcState);\n            r.postNotification();\n            created = true;\n        } catch (DeadObjectException e) {\n            ...\n        } finally {\n            ...\n        }\n\n        // 向 service 请求 binder 对象\n        requestServiceBindingsLocked(r, execInFg);\n\n        if (r.startRequested && r.callStart && r.pendingStarts.size() == 0) {\n            // 如果 r.pendingStarts 为空，就添加一个，pendingStarts 在调用 service.startCommond() 有用\n            // 只有在 startService 的时候，r.startRequested才会为true\n            r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(),\n                    null, null, 0));\n        }\n\n        // 执行 startCommond()\n        sendServiceArgsLocked(r, execInFg, true);\n        ...\n    }\n```\n\nstartService 暂时就到这，后面的就很简单了。\n\n# bindService 启动流程源码分析\n\n## bindService 启动流程概述\n\n1. 应用端调用 AMS.bindService\n2. AMS 查找是否存在这个 service 的 binder 对象，如果不存在，则启动 service 并请求 binder 对象\n3. service 将 binder 对象发布到 AMS\n4. AMS 返回 service 的 binder 对象给 应用\n\n## 应用端\n\n```java\n// frameworks/base/core/java/android/app/ContextImpl.java\n    private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, Handler\n            handler, UserHandle user) {\n        IServiceConnection sd;\n        if (mPackageInfo != null) {\n            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);\n        } else {\n            throw new ...\n        }\n        try {\n            ...\n            int res = ActivityManager.getService().bindService(\n                mMainThread.getApplicationThread(), getActivityToken(), service,\n                service.resolveTypeIfNeeded(getContentResolver()),\n                sd, flags, getOpPackageName(), user.getIdentifier());\n            return res != 0;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n```\nIServiceConnection 是一个 IBinder 对象，但是 ServiceConnection 是一个只是一样普通对象。 ServiceDispatcher 可以理解为 IServiceConnection 和 ServiceConnection 的衔接者。 ServiceDispatcher 和 IServiceConnection 是一对一的，但是 IServiceConnection 和 ServiceConnection 不是。可以理解为 IServiceConnection 和 ServiceConnection + Context 是一对一的\n\n我们来看 ServiceDispatcher.connected(...)\n\n```java\n// frameworks/base/core/java/android/app/LoadedApk.java\n// ServiceDispatcher\n        public void connected(ComponentName name, IBinder service, boolean dead) {\n            if (mActivityThread != null) {\n                // 从 Binder 线程池切换到主线程\n                mActivityThread.post(new RunConnection(name, service, 0, dead));\n            } else {\n                doConnected(name, service, dead);\n            }\n        }\n        public void doConnected(ComponentName name, IBinder service, boolean dead) {\n            ServiceDispatcher.ConnectionInfo old;\n            ServiceDispatcher.ConnectionInfo info;\n\n            synchronized (this) {\n                old = mActiveConnections.get(name);\n                if (old != null && old.binder == service) {\n                    // Huh, already have this one.  Oh well!\n                    // 如果应用端已经存在 service 的 binder 对象，则不做处理。\n                    // 所以，onServiceConnected 只会执行一次 \n                    return;\n                }\n\n                if (service != null) {\n                    // A new service is being connected... set it all up.\n                    info = new ConnectionInfo();\n                    info.binder = service;\n                    info.deathMonitor = new DeathMonitor(name, service);\n                    try {\n                        // linkToDeath 监控 binder 死亡， 会调用 service.onServiceDisconnected\n                        service.linkToDeath(info.deathMonitor, 0);\n                        mActiveConnections.put(name, info);\n                    } catch (RemoteException e) {\n                        // This service was dead before we got it...  just\n                        // don't do anything with it.\n                        mActiveConnections.remove(name);\n                        return;\n                    }\n\n                } else {\n                    // The named service is being disconnected... clean up.\n                    mActiveConnections.remove(name);\n                }\n\n                if (old != null) {\n                    old.binder.unlinkToDeath(old.deathMonitor, 0);\n                }\n            }\n\n            // If there was an old service, it is now disconnected.\n            if (old != null) {\n                // old 不为空，还走到了这里，说明是断开连接\n                mConnection.onServiceDisconnected(name);\n            }\n            if (dead) {\n                mConnection.onBindingDied(name);\n            }\n            // If there is a new viable service, it is now connected.\n            if (service != null) {\n                mConnection.onServiceConnected(name, service);\n            } else {\n                // The binding machinery worked, but the remote returned null from onBind().\n                mConnection.onNullBinding(name);\n            }\n        }\n```\n\n## AMS\n\n```java\n    int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service,\n            String resolvedType, final IServiceConnection connection, int flags,\n            String callingPackage, final int userId) throws TransactionTooLargeException {\n\n            ServiceLookupResult res = retrieveServiceLocked(service, ...);\n            ServiceRecord s = res.record;\n\n            if ((flags&Context.BIND_AUTO_CREATE) != 0) {\n                // 启动 service ，和 bindService 一样，可以翻翻上面\n                if (bringUpServiceLocked(s, service.getFlags(), callerFg, false,\n                        permissionsReviewRequired) != null) {\n                    return 0;\n                }\n            }\n\n            if (s.app != null && b.intent.received) {\n                // service 的进程已经启动，并且，已经将 binder 对象发布给 AMS\n                // 直接调用应用端连接\n                try {\n                    c.conn.connected(s.name, b.intent.binder, false);\n                } catch (Exception e) {\n                    ...\n                }\n\n                // If this is the first app connected back to this binding,\n                // and the service had previously asked to be told when\n                // rebound, then do so.\n                if (b.intent.apps.size() == 1 && b.intent.doRebind) {\n                    requestServiceBindingLocked(s, b.intent, callerFg, true);\n                }\n            }  else if (!b.intent.requested) {\n                // !b.intent.requested 表明还未向 service 请求 binder 对象\n                requestServiceBindingLocked(s, b.intent, callerFg, false);\n            }\n    }\n\n    private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,\n            boolean execInFg, boolean rebind) throws TransactionTooLargeException {\n        if (r.app == null || r.app.thread == null) {\n            // If service is not currently running, can't yet bind.\n            return false;\n        }\n        if ((!i.requested || rebind) && i.apps.size() > 0) {\n            // 没有请求过 binder 对象， 或者 rebind\n            try {\n                // 调用 service 所在对象的 onBind 并将发挥的 binder 对象发布给 AMS\n                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,\n                        r.app.repProcState);\n                if (!rebind) {\n                    i.requested = true;\n                }\n                i.hasBound = true;\n                i.doRebind = false;\n            } catch (TransactionTooLargeException e) {\n                ...\n            } catch (RemoteException e) {\n                ...\n                return false;\n            }\n        }\n        return true;\n    }\n```\n\n\n\n\n\n\n\n\n\n","slug":"Android/Framework/startService-和bindService","published":1,"updated":"2021-10-03T01:57:41.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno92004qg0jetdf6kspx","content":"<h1 id=\"startService-和bindService-的区别\"><a href=\"#startService-和bindService-的区别\" class=\"headerlink\" title=\"startService()和bindService()的区别\"></a>startService()和bindService()的区别</h1><a id=\"more\"></a><p><img src=\"/images/startService\\ and\\ bindService\" alt></p>\n<h3 id=\"生命周期上的差别\"><a href=\"#生命周期上的差别\" class=\"headerlink\" title=\"生命周期上的差别\"></a>生命周期上的差别</h3><h4 id=\"startService\"><a href=\"#startService\" class=\"headerlink\" title=\"startService()\"></a>startService()</h4><p>执行startService时，Service经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。</p>\n<p>多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。<strong>但是每次调用startService，onStartCommand方法都会被调用。</strong>无论startService调用多少次，stopService只需要调用一次就能够终止Service</p>\n<h4 id=\"BindService\"><a href=\"#BindService\" class=\"headerlink\" title=\"BindService()\"></a>BindService()</h4><p>bindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。</p>\n<ol>\n<li><strong>onBind返回值是null</strong><br>调用bindService开启服务，生命周期执行的方法依次是：<br>onCreate() ==&gt; onBind();<br><strong>调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。</strong> 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。</li>\n<li><strong>onBind返回值不为null</strong><br>这时候调用bindService开启服务，生命周期执行的方法依次是：<br>onCreate() ==&gt; onBind() ==&gt; onServiceConnected();<br>可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。<strong>调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。</strong><br>并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。<br>也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。<br>调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。<br><br><br><strong>总结</strong><br>第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。</li>\n</ol>\n<h3 id=\"既使用startService又使用bindService的情况\"><a href=\"#既使用startService又使用bindService的情况\" class=\"headerlink\" title=\"既使用startService又使用bindService的情况\"></a>既使用startService又使用bindService的情况</h3><p>如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。</p>\n<p>参考链接:<br><a href>https://my.oschina.net/tingzi/blog/376545</a><br><a href>https://www.jianshu.com/p/d870f99b675c</a></p>\n<h1 id=\"startService-启动过程源码分析\"><a href=\"#startService-启动过程源码分析\" class=\"headerlink\" title=\"startService 启动过程源码分析\"></a>startService 启动过程源码分析</h1><p>ContextImpl.startService(…) 最终会调用到 AMS 的对应方法，最终会调用到 ActivityService.startServiceLocked(…)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class=\"line\">    <span class=\"function\">ComponentName <span class=\"title\">startServiceLocked</span><span class=\"params\">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> callingPid, <span class=\"keyword\">int</span> callingUid, <span class=\"keyword\">boolean</span> fgRequired, String callingPackage, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> userId)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ServiceLookupResult res =</span><br><span class=\"line\">            retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class=\"line\">                    callingPid, callingUid, userId, <span class=\"keyword\">true</span>, callerFg, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        ServiceRecord r = res.record;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ServiceRecord.StartItem 用于在 service 启动之后调用 startCommond</span></span><br><span class=\"line\">        r.pendingStarts.add(<span class=\"keyword\">new</span> ServiceRecord.StartItem(r, <span class=\"keyword\">false</span>, r.makeNextStartId(),</span><br><span class=\"line\">                service, neededGrants, callingUid));</span><br><span class=\"line\"></span><br><span class=\"line\">        ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ComponentName <span class=\"title\">startServiceInnerLocked</span><span class=\"params\">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> callerFg, <span class=\"keyword\">boolean</span> addToStarting)</span> <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">bringUpServiceLocked</span><span class=\"params\">(ServiceRecord r, <span class=\"keyword\">int</span> intentFlags, <span class=\"keyword\">boolean</span> execInFg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> whileRestarting, <span class=\"keyword\">boolean</span> permissionsReviewRequired)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.app != <span class=\"keyword\">null</span> &amp;&amp; r.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// service 的进程已经启动，sendServiceArgsLocked 用于调用 startCommond() 方法</span></span><br><span class=\"line\">            sendServiceArgsLocked(r, execInFg, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String procName = r.processName;</span><br><span class=\"line\">        String hostingType = <span class=\"string\">\"service\"</span>;</span><br><span class=\"line\">        ProcessRecord app;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isolated) &#123;</span><br><span class=\"line\">            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// service 不是单独的进程且，service 所在进程已经启动，则直接启动进程</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    realStartServiceLocked(r, app, execInFg);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            app = r.isolatedProc;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (app == <span class=\"keyword\">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// servie 所在的进程还没有启动，启动相应的进程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class=\"keyword\">true</span>, intentFlags,</span><br><span class=\"line\">                    hostingType, r.name, <span class=\"keyword\">false</span>, isolated, <span class=\"keyword\">false</span>)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                String msg = ...</span><br><span class=\"line\">                <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isolated) &#123;</span><br><span class=\"line\">                r.isolatedProc = app;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 暂存进程未启动的 service , 当 service 进程启动完，Application 进行 AMS.attach() 的时候，会 mPendingServices 取出 ServiceRecord 并执行 realStartServiceLocked </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class=\"line\">            mPendingServices.add(r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">realStartServiceLocked</span><span class=\"params\">(ServiceRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ProcessRecord app, <span class=\"keyword\">boolean</span> execInFg)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (app.thread == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// service 进程未启动，抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemoteException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r.app = app;</span><br><span class=\"line\">        r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> newService = app.services.add(r);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> created = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"comment\">// 调用 Service 的 onCreate 方法</span></span><br><span class=\"line\">            app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class=\"line\">                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class=\"line\">                    app.repProcState);</span><br><span class=\"line\">            r.postNotification();</span><br><span class=\"line\">            created = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (DeadObjectException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 向 service 请求 binder 对象</span></span><br><span class=\"line\">        requestServiceBindingsLocked(r, execInFg);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 r.pendingStarts 为空，就添加一个，pendingStarts 在调用 service.startCommond() 有用</span></span><br><span class=\"line\">            <span class=\"comment\">// 只有在 startService 的时候，r.startRequested才会为true</span></span><br><span class=\"line\">            r.pendingStarts.add(<span class=\"keyword\">new</span> ServiceRecord.StartItem(r, <span class=\"keyword\">false</span>, r.makeNextStartId(),</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 执行 startCommond()</span></span><br><span class=\"line\">        sendServiceArgsLocked(r, execInFg, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>startService 暂时就到这，后面的就很简单了。</p>\n<h1 id=\"bindService-启动流程源码分析\"><a href=\"#bindService-启动流程源码分析\" class=\"headerlink\" title=\"bindService 启动流程源码分析\"></a>bindService 启动流程源码分析</h1><h2 id=\"bindService-启动流程概述\"><a href=\"#bindService-启动流程概述\" class=\"headerlink\" title=\"bindService 启动流程概述\"></a>bindService 启动流程概述</h2><ol>\n<li>应用端调用 AMS.bindService</li>\n<li>AMS 查找是否存在这个 service 的 binder 对象，如果不存在，则启动 service 并请求 binder 对象</li>\n<li>service 将 binder 对象发布到 AMS</li>\n<li>AMS 返回 service 的 binder 对象给 应用</li>\n</ol>\n<h2 id=\"应用端\"><a href=\"#应用端\" class=\"headerlink\" title=\"应用端\"></a>应用端</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">bindServiceCommon</span><span class=\"params\">(Intent service, ServiceConnection conn, <span class=\"keyword\">int</span> flags, Handler</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            handler, UserHandle user)</span> </span>&#123;</span><br><span class=\"line\">        IServiceConnection sd;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPackageInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">int</span> res = ActivityManager.getService().bindService(</span><br><span class=\"line\">                mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class=\"line\">                service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class=\"line\">                sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res != <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e.rethrowFromSystemServer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>IServiceConnection 是一个 IBinder 对象，但是 ServiceConnection 是一个只是一样普通对象。 ServiceDispatcher 可以理解为 IServiceConnection 和 ServiceConnection 的衔接者。 ServiceDispatcher 和 IServiceConnection 是一对一的，但是 IServiceConnection 和 ServiceConnection 不是。可以理解为 IServiceConnection 和 ServiceConnection + Context 是一对一的</p>\n<p>我们来看 ServiceDispatcher.connected(…)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class=\"line\"><span class=\"comment\">// ServiceDispatcher</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">connected</span><span class=\"params\">(ComponentName name, IBinder service, <span class=\"keyword\">boolean</span> dead)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mActivityThread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从 Binder 线程池切换到主线程</span></span><br><span class=\"line\">                mActivityThread.post(<span class=\"keyword\">new</span> RunConnection(name, service, <span class=\"number\">0</span>, dead));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                doConnected(name, service, dead);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnected</span><span class=\"params\">(ComponentName name, IBinder service, <span class=\"keyword\">boolean</span> dead)</span> </span>&#123;</span><br><span class=\"line\">            ServiceDispatcher.ConnectionInfo old;</span><br><span class=\"line\">            ServiceDispatcher.ConnectionInfo info;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                old = mActiveConnections.get(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (old != <span class=\"keyword\">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Huh, already have this one.  Oh well!</span></span><br><span class=\"line\">                    <span class=\"comment\">// 如果应用端已经存在 service 的 binder 对象，则不做处理。</span></span><br><span class=\"line\">                    <span class=\"comment\">// 所以，onServiceConnected 只会执行一次 </span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (service != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// A new service is being connected... set it all up.</span></span><br><span class=\"line\">                    info = <span class=\"keyword\">new</span> ConnectionInfo();</span><br><span class=\"line\">                    info.binder = service;</span><br><span class=\"line\">                    info.deathMonitor = <span class=\"keyword\">new</span> DeathMonitor(name, service);</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// linkToDeath 监控 binder 死亡， 会调用 service.onServiceDisconnected</span></span><br><span class=\"line\">                        service.linkToDeath(info.deathMonitor, <span class=\"number\">0</span>);</span><br><span class=\"line\">                        mActiveConnections.put(name, info);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// This service was dead before we got it...  just</span></span><br><span class=\"line\">                        <span class=\"comment\">// don't do anything with it.</span></span><br><span class=\"line\">                        mActiveConnections.remove(name);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The named service is being disconnected... clean up.</span></span><br><span class=\"line\">                    mActiveConnections.remove(name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (old != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    old.binder.unlinkToDeath(old.deathMonitor, <span class=\"number\">0</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If there was an old service, it is now disconnected.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (old != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// old 不为空，还走到了这里，说明是断开连接</span></span><br><span class=\"line\">                mConnection.onServiceDisconnected(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dead) &#123;</span><br><span class=\"line\">                mConnection.onBindingDied(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// If there is a new viable service, it is now connected.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mConnection.onServiceConnected(name, service);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class=\"line\">                mConnection.onNullBinding(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"AMS\"><a href=\"#AMS\" class=\"headerlink\" title=\"AMS\"></a>AMS</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bindServiceLocked</span><span class=\"params\">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String resolvedType, <span class=\"keyword\">final</span> IServiceConnection connection, <span class=\"keyword\">int</span> flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String callingPackage, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> userId)</span> <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ServiceLookupResult res = retrieveServiceLocked(service, ...);</span><br><span class=\"line\">        ServiceRecord s = res.record;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 启动 service ，和 bindService 一样，可以翻翻上面</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class=\"keyword\">false</span>,</span><br><span class=\"line\">                    permissionsReviewRequired) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.app != <span class=\"keyword\">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// service 的进程已经启动，并且，已经将 binder 对象发布给 AMS</span></span><br><span class=\"line\">            <span class=\"comment\">// 直接调用应用端连接</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                c.conn.connected(s.name, b.intent.binder, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If this is the first app connected back to this binding,</span></span><br><span class=\"line\">            <span class=\"comment\">// and the service had previously asked to be told when</span></span><br><span class=\"line\">            <span class=\"comment\">// rebound, then do so.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b.intent.apps.size() == <span class=\"number\">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class=\"line\">                requestServiceBindingLocked(s, b.intent, callerFg, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!b.intent.requested) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// !b.intent.requested 表明还未向 service 请求 binder 对象</span></span><br><span class=\"line\">            requestServiceBindingLocked(s, b.intent, callerFg, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">requestServiceBindingLocked</span><span class=\"params\">(ServiceRecord r, IntentBindRecord i,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> execInFg, <span class=\"keyword\">boolean</span> rebind)</span> <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.app == <span class=\"keyword\">null</span> || r.app.thread == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If service is not currently running, can't yet bind.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 没有请求过 binder 对象， 或者 rebind</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用 service 所在对象的 onBind 并将发挥的 binder 对象发布给 AMS</span></span><br><span class=\"line\">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class=\"line\">                    r.app.repProcState);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!rebind) &#123;</span><br><span class=\"line\">                i.requested = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i.hasBound = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            i.doRebind = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"startService-和bindService-的区别\"><a href=\"#startService-和bindService-的区别\" class=\"headerlink\" title=\"startService()和bindService()的区别\"></a>startService()和bindService()的区别</h1>","more":"<p><img src=\"/images/startService\\ and\\ bindService\" alt></p>\n<h3 id=\"生命周期上的差别\"><a href=\"#生命周期上的差别\" class=\"headerlink\" title=\"生命周期上的差别\"></a>生命周期上的差别</h3><h4 id=\"startService\"><a href=\"#startService\" class=\"headerlink\" title=\"startService()\"></a>startService()</h4><p>执行startService时，Service经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。</p>\n<p>多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。<strong>但是每次调用startService，onStartCommand方法都会被调用。</strong>无论startService调用多少次，stopService只需要调用一次就能够终止Service</p>\n<h4 id=\"BindService\"><a href=\"#BindService\" class=\"headerlink\" title=\"BindService()\"></a>BindService()</h4><p>bindService开启服务时，根据生命周期里onBind方法的返回值是否为空，有两种情况。</p>\n<ol>\n<li><strong>onBind返回值是null</strong><br>调用bindService开启服务，生命周期执行的方法依次是：<br>onCreate() ==&gt; onBind();<br><strong>调用多次bindService，onCreate和onBind也只在第一次会被执行。调用unbindService结束服务，生命周期执行onDestroy方法，并且unbindService方法只能调用一次，多次调用应用会抛出异常。</strong> 使用时也要注意调用unbindService一定要确保服务已经开启，否则应用会抛出异常。</li>\n<li><strong>onBind返回值不为null</strong><br>这时候调用bindService开启服务，生命周期执行的方法依次是：<br>onCreate() ==&gt; onBind() ==&gt; onServiceConnected();<br>可以发现我们自己写的Connection类里的onServiceConnected方法被调用了。<strong>调用多次bindService，onCreate和onBind都只在第一次会被执行，onServiceConnected会执行多次。</strong><br>并且我们注意到onServiceConnected方法的第二个参数也是IBinder类型的，不难猜测onBind()方法返回的对象被传递到了这里。打印一下两个对象的地址可以证明猜测是正确的。<br>也就是说我们可以在onServiceConnected方法里拿到了Service服务的内部类Binder的对象，通过这个内部类对象，只要强转一下，我们可以调用这个内部类的非私有成员对象和方法。<br>调用unbindService结束服务和上面相同，unbindService只能调用一次，onDestroy也只执行一次，多次调用会抛出异常。<br><br><br><strong>总结</strong><br>第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。</li>\n</ol>\n<h3 id=\"既使用startService又使用bindService的情况\"><a href=\"#既使用startService又使用bindService的情况\" class=\"headerlink\" title=\"既使用startService又使用bindService的情况\"></a>既使用startService又使用bindService的情况</h3><p>如果一个Service又被启动又被绑定，则该Service会一直在后台运行。首先不管如何调用，onCreate始终只会调用一次。对应startService调用多少次，Service的onStart方法便会调用多少次。Service的终止，需要unbindService和stopService同时调用才行。不管startService与bindService的调用顺序，如果先调用unbindService，此时服务不会自动终止，再调用stopService之后，服务才会终止；如果先调用stopService，此时服务也不会终止，而再调用unbindService或者之前调用bindService的Context不存在了（如Activity被finish的时候）之后，服务才会自动停止。</p>\n<p>参考链接:<br><a href>https://my.oschina.net/tingzi/blog/376545</a><br><a href>https://www.jianshu.com/p/d870f99b675c</a></p>\n<h1 id=\"startService-启动过程源码分析\"><a href=\"#startService-启动过程源码分析\" class=\"headerlink\" title=\"startService 启动过程源码分析\"></a>startService 启动过程源码分析</h1><p>ContextImpl.startService(…) 最终会调用到 AMS 的对应方法，最终会调用到 ActivityService.startServiceLocked(…)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class=\"line\">    <span class=\"function\">ComponentName <span class=\"title\">startServiceLocked</span><span class=\"params\">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> callingPid, <span class=\"keyword\">int</span> callingUid, <span class=\"keyword\">boolean</span> fgRequired, String callingPackage, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> userId)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ServiceLookupResult res =</span><br><span class=\"line\">            retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class=\"line\">                    callingPid, callingUid, userId, <span class=\"keyword\">true</span>, callerFg, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        ServiceRecord r = res.record;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ServiceRecord.StartItem 用于在 service 启动之后调用 startCommond</span></span><br><span class=\"line\">        r.pendingStarts.add(<span class=\"keyword\">new</span> ServiceRecord.StartItem(r, <span class=\"keyword\">false</span>, r.makeNextStartId(),</span><br><span class=\"line\">                service, neededGrants, callingUid));</span><br><span class=\"line\"></span><br><span class=\"line\">        ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ComponentName <span class=\"title\">startServiceInnerLocked</span><span class=\"params\">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> callerFg, <span class=\"keyword\">boolean</span> addToStarting)</span> <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">bringUpServiceLocked</span><span class=\"params\">(ServiceRecord r, <span class=\"keyword\">int</span> intentFlags, <span class=\"keyword\">boolean</span> execInFg,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> whileRestarting, <span class=\"keyword\">boolean</span> permissionsReviewRequired)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.app != <span class=\"keyword\">null</span> &amp;&amp; r.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// service 的进程已经启动，sendServiceArgsLocked 用于调用 startCommond() 方法</span></span><br><span class=\"line\">            sendServiceArgsLocked(r, execInFg, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String procName = r.processName;</span><br><span class=\"line\">        String hostingType = <span class=\"string\">\"service\"</span>;</span><br><span class=\"line\">        ProcessRecord app;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isolated) &#123;</span><br><span class=\"line\">            app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// service 不是单独的进程且，service 所在进程已经启动，则直接启动进程</span></span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    realStartServiceLocked(r, app, execInFg);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            app = r.isolatedProc;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (app == <span class=\"keyword\">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// servie 所在的进程还没有启动，启动相应的进程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class=\"keyword\">true</span>, intentFlags,</span><br><span class=\"line\">                    hostingType, r.name, <span class=\"keyword\">false</span>, isolated, <span class=\"keyword\">false</span>)) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                String msg = ...</span><br><span class=\"line\">                <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isolated) &#123;</span><br><span class=\"line\">                r.isolatedProc = app;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 暂存进程未启动的 service , 当 service 进程启动完，Application 进行 AMS.attach() 的时候，会 mPendingServices 取出 ServiceRecord 并执行 realStartServiceLocked </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class=\"line\">            mPendingServices.add(r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">realStartServiceLocked</span><span class=\"params\">(ServiceRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ProcessRecord app, <span class=\"keyword\">boolean</span> execInFg)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (app.thread == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// service 进程未启动，抛出异常</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RemoteException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        r.app = app;</span><br><span class=\"line\">        r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> newService = app.services.add(r);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> created = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"comment\">// 调用 Service 的 onCreate 方法</span></span><br><span class=\"line\">            app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class=\"line\">                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class=\"line\">                    app.repProcState);</span><br><span class=\"line\">            r.postNotification();</span><br><span class=\"line\">            created = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (DeadObjectException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 向 service 请求 binder 对象</span></span><br><span class=\"line\">        requestServiceBindingsLocked(r, execInFg);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果 r.pendingStarts 为空，就添加一个，pendingStarts 在调用 service.startCommond() 有用</span></span><br><span class=\"line\">            <span class=\"comment\">// 只有在 startService 的时候，r.startRequested才会为true</span></span><br><span class=\"line\">            r.pendingStarts.add(<span class=\"keyword\">new</span> ServiceRecord.StartItem(r, <span class=\"keyword\">false</span>, r.makeNextStartId(),</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 执行 startCommond()</span></span><br><span class=\"line\">        sendServiceArgsLocked(r, execInFg, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>startService 暂时就到这，后面的就很简单了。</p>\n<h1 id=\"bindService-启动流程源码分析\"><a href=\"#bindService-启动流程源码分析\" class=\"headerlink\" title=\"bindService 启动流程源码分析\"></a>bindService 启动流程源码分析</h1><h2 id=\"bindService-启动流程概述\"><a href=\"#bindService-启动流程概述\" class=\"headerlink\" title=\"bindService 启动流程概述\"></a>bindService 启动流程概述</h2><ol>\n<li>应用端调用 AMS.bindService</li>\n<li>AMS 查找是否存在这个 service 的 binder 对象，如果不存在，则启动 service 并请求 binder 对象</li>\n<li>service 将 binder 对象发布到 AMS</li>\n<li>AMS 返回 service 的 binder 对象给 应用</li>\n</ol>\n<h2 id=\"应用端\"><a href=\"#应用端\" class=\"headerlink\" title=\"应用端\"></a>应用端</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">bindServiceCommon</span><span class=\"params\">(Intent service, ServiceConnection conn, <span class=\"keyword\">int</span> flags, Handler</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            handler, UserHandle user)</span> </span>&#123;</span><br><span class=\"line\">        IServiceConnection sd;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mPackageInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">int</span> res = ActivityManager.getService().bindService(</span><br><span class=\"line\">                mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class=\"line\">                service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class=\"line\">                sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res != <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e.rethrowFromSystemServer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>IServiceConnection 是一个 IBinder 对象，但是 ServiceConnection 是一个只是一样普通对象。 ServiceDispatcher 可以理解为 IServiceConnection 和 ServiceConnection 的衔接者。 ServiceDispatcher 和 IServiceConnection 是一对一的，但是 IServiceConnection 和 ServiceConnection 不是。可以理解为 IServiceConnection 和 ServiceConnection + Context 是一对一的</p>\n<p>我们来看 ServiceDispatcher.connected(…)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class=\"line\"><span class=\"comment\">// ServiceDispatcher</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">connected</span><span class=\"params\">(ComponentName name, IBinder service, <span class=\"keyword\">boolean</span> dead)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mActivityThread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从 Binder 线程池切换到主线程</span></span><br><span class=\"line\">                mActivityThread.post(<span class=\"keyword\">new</span> RunConnection(name, service, <span class=\"number\">0</span>, dead));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                doConnected(name, service, dead);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doConnected</span><span class=\"params\">(ComponentName name, IBinder service, <span class=\"keyword\">boolean</span> dead)</span> </span>&#123;</span><br><span class=\"line\">            ServiceDispatcher.ConnectionInfo old;</span><br><span class=\"line\">            ServiceDispatcher.ConnectionInfo info;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                old = mActiveConnections.get(name);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (old != <span class=\"keyword\">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// Huh, already have this one.  Oh well!</span></span><br><span class=\"line\">                    <span class=\"comment\">// 如果应用端已经存在 service 的 binder 对象，则不做处理。</span></span><br><span class=\"line\">                    <span class=\"comment\">// 所以，onServiceConnected 只会执行一次 </span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (service != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// A new service is being connected... set it all up.</span></span><br><span class=\"line\">                    info = <span class=\"keyword\">new</span> ConnectionInfo();</span><br><span class=\"line\">                    info.binder = service;</span><br><span class=\"line\">                    info.deathMonitor = <span class=\"keyword\">new</span> DeathMonitor(name, service);</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// linkToDeath 监控 binder 死亡， 会调用 service.onServiceDisconnected</span></span><br><span class=\"line\">                        service.linkToDeath(info.deathMonitor, <span class=\"number\">0</span>);</span><br><span class=\"line\">                        mActiveConnections.put(name, info);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// This service was dead before we got it...  just</span></span><br><span class=\"line\">                        <span class=\"comment\">// don't do anything with it.</span></span><br><span class=\"line\">                        mActiveConnections.remove(name);</span><br><span class=\"line\">                        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// The named service is being disconnected... clean up.</span></span><br><span class=\"line\">                    mActiveConnections.remove(name);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (old != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    old.binder.unlinkToDeath(old.deathMonitor, <span class=\"number\">0</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If there was an old service, it is now disconnected.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (old != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// old 不为空，还走到了这里，说明是断开连接</span></span><br><span class=\"line\">                mConnection.onServiceDisconnected(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dead) &#123;</span><br><span class=\"line\">                mConnection.onBindingDied(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// If there is a new viable service, it is now connected.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (service != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                mConnection.onServiceConnected(name, service);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class=\"line\">                mConnection.onNullBinding(name);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"AMS\"><a href=\"#AMS\" class=\"headerlink\" title=\"AMS\"></a>AMS</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bindServiceLocked</span><span class=\"params\">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String resolvedType, <span class=\"keyword\">final</span> IServiceConnection connection, <span class=\"keyword\">int</span> flags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String callingPackage, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> userId)</span> <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ServiceLookupResult res = retrieveServiceLocked(service, ...);</span><br><span class=\"line\">        ServiceRecord s = res.record;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 启动 service ，和 bindService 一样，可以翻翻上面</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class=\"keyword\">false</span>,</span><br><span class=\"line\">                    permissionsReviewRequired) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.app != <span class=\"keyword\">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// service 的进程已经启动，并且，已经将 binder 对象发布给 AMS</span></span><br><span class=\"line\">            <span class=\"comment\">// 直接调用应用端连接</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                c.conn.connected(s.name, b.intent.binder, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// If this is the first app connected back to this binding,</span></span><br><span class=\"line\">            <span class=\"comment\">// and the service had previously asked to be told when</span></span><br><span class=\"line\">            <span class=\"comment\">// rebound, then do so.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (b.intent.apps.size() == <span class=\"number\">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class=\"line\">                requestServiceBindingLocked(s, b.intent, callerFg, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!b.intent.requested) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// !b.intent.requested 表明还未向 service 请求 binder 对象</span></span><br><span class=\"line\">            requestServiceBindingLocked(s, b.intent, callerFg, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">requestServiceBindingLocked</span><span class=\"params\">(ServiceRecord r, IntentBindRecord i,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> execInFg, <span class=\"keyword\">boolean</span> rebind)</span> <span class=\"keyword\">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.app == <span class=\"keyword\">null</span> || r.app.thread == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If service is not currently running, can't yet bind.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 没有请求过 binder 对象， 或者 rebind</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用 service 所在对象的 onBind 并将发挥的 binder 对象发布给 AMS</span></span><br><span class=\"line\">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class=\"line\">                    r.app.repProcState);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!rebind) &#123;</span><br><span class=\"line\">                i.requested = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i.hasBound = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            i.doRebind = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"屏幕刷新机制","date":"2021-03-17T16:05:08.000Z","_content":"\n# requestLayout\n\nview.requestLayout 最终会调用 ViewRootImpl.requestLayout\n\n```java\n    @Override\n    public void requestLayout() {\n        if (!mHandlingLayoutInLayoutRequest) {\n            checkThread();  // 检查线程是否是 ViewRootImpl 实例化的线程\n            mLayoutRequested = true;\n            scheduleTraversals();\n        }\n    }\n\n    void scheduleTraversals() {\n        // mTraversalScheduled 标记位，避免短时间多次调用requestLayout重复刷新\n        if (!mTraversalScheduled) {\n            mTraversalScheduled = true;\n            // 添加一个同步屏障\n            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n            // 通过 Choreographer 添加一个 Vsync 回调\n            mChoreographer.postCallback(\n                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n            ...\n        }\n    }\n\n    final class TraversalRunnable implements Runnable {\n        @Override\n        public void run() {\n            doTraversal();\n        }\n    }\n\n    void doTraversal() {\n        if (mTraversalScheduled) {\n            mTraversalScheduled = false;\n            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n\n            // 开始 measure layout draw 三步走\n            performTraversals();\n        }\n    }\n```\n\n这个 `mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();` 这个操作会在 LooperQueue 中添加一个同步屏障，阻断同步 message（普通 message ）的执行。\n（异步 message 能正常执行）\n这里主要是为了保证在 Vync 到来时，这个 message 能够快速响应，保证在 Vync 到来的最初时刻就开始绘制，从而保证 UI 的绘制和 Vync 的周期是协调的。\n\n`mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);` 添加一个 Vsync 回调。在 Vsync 信号到来时执行 mTraversalRunnable 。\n\n# Choreographer\n\nChoreographer 是用来监听 Vsync 信号的一个类。 在刷新UI时主要有两步。\n\n## 添加一个 vsync 信号的回调\n\n```java\n    private void postCallbackDelayedInternal(int callbackType,\n            Object action, Object token, long delayMillis) {\n        synchronized (mLock) {\n            final long now = SystemClock.uptimeMillis();\n            final long dueTime = now + delayMillis;\n            // 这里 mCallbackQueues 是多个事件的队列\n            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);\n\n            if (dueTime <= now) {\n                scheduleFrameLocked(now);\n            } else {\n                // 延时做刷新，最终也会走 scheduleFrameLocked\n                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);\n                msg.arg1 = callbackType;\n                msg.setAsynchronous(true);\n                mHandler.sendMessageAtTime(msg, dueTime);\n            }\n        }\n    }\n\n    private void scheduleFrameLocked(long now) {\n        if (!mFrameScheduled) {\n            mFrameScheduled = true;\n            if (USE_VSYNC) {\n                // 判断是不是在 ViewRootImpl 实例化时的线程\n                if (isRunningOnLooperThreadLocked()) {\n                    scheduleVsyncLocked();\n                } else {\n                    // 如果不是，用一个 Handler 切换线程\n                    // 发送一个异步消息，并且放置在队列最前方\n                    Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);\n                    msg.setAsynchronous(true);\n                    mHandler.sendMessageAtFrontOfQueue(msg);\n                }\n            } else {\n                ...\n            }\n        }\n    }\n\n    private void scheduleVsyncLocked() {\n        mDisplayEventReceiver.scheduleVsync();\n    }\n\n    public void scheduleVsync() {\n        if (mReceiverPtr == 0) {\n            ...\n        } else {\n            // 调用 native 方法请求一个 vsync 回调\n            nativeScheduleVsync(mReceiverPtr);\n        }\n    }\n```\n\n## 处理 vsync 回调\n\n```java\n// 在 Choreographer 的构造方法里实例化 DisplayEventReceiver\n    private Choreographer(Looper looper, int vsyncSource) {\n        mLooper = looper;\n        mHandler = new FrameHandler(looper);\n        mDisplayEventReceiver = USE_VSYNC\n                ? new FrameDisplayEventReceiver(looper, vsyncSource)\n                : null;\n        mLastFrameTimeNanos = Long.MIN_VALUE;\n\n        mFrameIntervalNanos = (long)(1000000000 / getRefreshRate());\n\n        mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];\n        for (int i = 0; i <= CALLBACK_LAST; i++) {\n            mCallbackQueues[i] = new CallbackQueue();\n        }\n    }\n```\n\n```java\n    private final class FrameDisplayEventReceiver extends DisplayEventReceiver\n            implements Runnable {\n        private boolean mHavePendingVsync;\n        private long mTimestampNanos;\n        private int mFrame;\n\n        public FrameDisplayEventReceiver(Looper looper, int vsyncSource) {\n            super(looper, vsyncSource);\n        }\n\n        @Override\n        public void onVsync(long timestampNanos, int builtInDisplayId, int frame) {\n            long now = System.nanoTime();\n            if (timestampNanos > now) {\n                timestampNanos = now;\n            }\n\n            mTimestampNanos = timestampNanos;\n            mFrame = frame;\n            // 发送一个异步消息，注意，这里没有放置到消息队列最前端\n            Message msg = Message.obtain(mHandler, this);\n            msg.setAsynchronous(true);\n            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);\n        }\n\n        @Override\n        public void run() {\n            doFrame(mTimestampNanos, mFrame);\n        }\n    }\n\n    void doFrame(long frameTimeNanos, int frame) {\n        final long startNanos;\n        synchronized (mLock) {\n            if (!mFrameScheduled) {\n                return; // no work to do\n            }\n\n            long intendedFrameTimeNanos = frameTimeNanos;\n            startNanos = System.nanoTime();\n            // 当前时间 - vsync回调到来时间 = 主线程message耗时\n            final long jitterNanos = startNanos - frameTimeNanos;\n            // 当超过了屏幕一帧刷新时间 16ms\n            if (jitterNanos >= mFrameIntervalNanos) {\n                final long skippedFrames = jitterNanos / mFrameIntervalNanos;\n                if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {\n                    // 当跳过的帧超过一定程度\n                }\n                final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;\n                frameTimeNanos = startNanos - lastFrameOffset;\n            }\n\n            mFrameScheduled = false;\n            mLastFrameTimeNanos = frameTimeNanos;\n        }\n        try {\n            AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);\n\n            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);\n\n            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);\n\n            // 处理屏幕刷新的回调，这里会调用 ViewRootImpl.TraversalRunnable\n            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);\n\n            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);\n        } ...\n    }\n```\n\n\n\n","source":"_posts/Android/Framework/屏幕刷新机制.md","raw":"---\ntitle: 屏幕刷新机制\ndate: 2021-03-18 00:05:08\ntags:\n- Framework\n- Android\n---\n\n# requestLayout\n\nview.requestLayout 最终会调用 ViewRootImpl.requestLayout\n\n```java\n    @Override\n    public void requestLayout() {\n        if (!mHandlingLayoutInLayoutRequest) {\n            checkThread();  // 检查线程是否是 ViewRootImpl 实例化的线程\n            mLayoutRequested = true;\n            scheduleTraversals();\n        }\n    }\n\n    void scheduleTraversals() {\n        // mTraversalScheduled 标记位，避免短时间多次调用requestLayout重复刷新\n        if (!mTraversalScheduled) {\n            mTraversalScheduled = true;\n            // 添加一个同步屏障\n            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();\n            // 通过 Choreographer 添加一个 Vsync 回调\n            mChoreographer.postCallback(\n                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);\n            ...\n        }\n    }\n\n    final class TraversalRunnable implements Runnable {\n        @Override\n        public void run() {\n            doTraversal();\n        }\n    }\n\n    void doTraversal() {\n        if (mTraversalScheduled) {\n            mTraversalScheduled = false;\n            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);\n\n            // 开始 measure layout draw 三步走\n            performTraversals();\n        }\n    }\n```\n\n这个 `mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();` 这个操作会在 LooperQueue 中添加一个同步屏障，阻断同步 message（普通 message ）的执行。\n（异步 message 能正常执行）\n这里主要是为了保证在 Vync 到来时，这个 message 能够快速响应，保证在 Vync 到来的最初时刻就开始绘制，从而保证 UI 的绘制和 Vync 的周期是协调的。\n\n`mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);` 添加一个 Vsync 回调。在 Vsync 信号到来时执行 mTraversalRunnable 。\n\n# Choreographer\n\nChoreographer 是用来监听 Vsync 信号的一个类。 在刷新UI时主要有两步。\n\n## 添加一个 vsync 信号的回调\n\n```java\n    private void postCallbackDelayedInternal(int callbackType,\n            Object action, Object token, long delayMillis) {\n        synchronized (mLock) {\n            final long now = SystemClock.uptimeMillis();\n            final long dueTime = now + delayMillis;\n            // 这里 mCallbackQueues 是多个事件的队列\n            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);\n\n            if (dueTime <= now) {\n                scheduleFrameLocked(now);\n            } else {\n                // 延时做刷新，最终也会走 scheduleFrameLocked\n                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);\n                msg.arg1 = callbackType;\n                msg.setAsynchronous(true);\n                mHandler.sendMessageAtTime(msg, dueTime);\n            }\n        }\n    }\n\n    private void scheduleFrameLocked(long now) {\n        if (!mFrameScheduled) {\n            mFrameScheduled = true;\n            if (USE_VSYNC) {\n                // 判断是不是在 ViewRootImpl 实例化时的线程\n                if (isRunningOnLooperThreadLocked()) {\n                    scheduleVsyncLocked();\n                } else {\n                    // 如果不是，用一个 Handler 切换线程\n                    // 发送一个异步消息，并且放置在队列最前方\n                    Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);\n                    msg.setAsynchronous(true);\n                    mHandler.sendMessageAtFrontOfQueue(msg);\n                }\n            } else {\n                ...\n            }\n        }\n    }\n\n    private void scheduleVsyncLocked() {\n        mDisplayEventReceiver.scheduleVsync();\n    }\n\n    public void scheduleVsync() {\n        if (mReceiverPtr == 0) {\n            ...\n        } else {\n            // 调用 native 方法请求一个 vsync 回调\n            nativeScheduleVsync(mReceiverPtr);\n        }\n    }\n```\n\n## 处理 vsync 回调\n\n```java\n// 在 Choreographer 的构造方法里实例化 DisplayEventReceiver\n    private Choreographer(Looper looper, int vsyncSource) {\n        mLooper = looper;\n        mHandler = new FrameHandler(looper);\n        mDisplayEventReceiver = USE_VSYNC\n                ? new FrameDisplayEventReceiver(looper, vsyncSource)\n                : null;\n        mLastFrameTimeNanos = Long.MIN_VALUE;\n\n        mFrameIntervalNanos = (long)(1000000000 / getRefreshRate());\n\n        mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];\n        for (int i = 0; i <= CALLBACK_LAST; i++) {\n            mCallbackQueues[i] = new CallbackQueue();\n        }\n    }\n```\n\n```java\n    private final class FrameDisplayEventReceiver extends DisplayEventReceiver\n            implements Runnable {\n        private boolean mHavePendingVsync;\n        private long mTimestampNanos;\n        private int mFrame;\n\n        public FrameDisplayEventReceiver(Looper looper, int vsyncSource) {\n            super(looper, vsyncSource);\n        }\n\n        @Override\n        public void onVsync(long timestampNanos, int builtInDisplayId, int frame) {\n            long now = System.nanoTime();\n            if (timestampNanos > now) {\n                timestampNanos = now;\n            }\n\n            mTimestampNanos = timestampNanos;\n            mFrame = frame;\n            // 发送一个异步消息，注意，这里没有放置到消息队列最前端\n            Message msg = Message.obtain(mHandler, this);\n            msg.setAsynchronous(true);\n            mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);\n        }\n\n        @Override\n        public void run() {\n            doFrame(mTimestampNanos, mFrame);\n        }\n    }\n\n    void doFrame(long frameTimeNanos, int frame) {\n        final long startNanos;\n        synchronized (mLock) {\n            if (!mFrameScheduled) {\n                return; // no work to do\n            }\n\n            long intendedFrameTimeNanos = frameTimeNanos;\n            startNanos = System.nanoTime();\n            // 当前时间 - vsync回调到来时间 = 主线程message耗时\n            final long jitterNanos = startNanos - frameTimeNanos;\n            // 当超过了屏幕一帧刷新时间 16ms\n            if (jitterNanos >= mFrameIntervalNanos) {\n                final long skippedFrames = jitterNanos / mFrameIntervalNanos;\n                if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {\n                    // 当跳过的帧超过一定程度\n                }\n                final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;\n                frameTimeNanos = startNanos - lastFrameOffset;\n            }\n\n            mFrameScheduled = false;\n            mLastFrameTimeNanos = frameTimeNanos;\n        }\n        try {\n            AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);\n\n            doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);\n\n            doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);\n\n            // 处理屏幕刷新的回调，这里会调用 ViewRootImpl.TraversalRunnable\n            doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);\n\n            doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);\n        } ...\n    }\n```\n\n\n\n","slug":"Android/Framework/屏幕刷新机制","published":1,"updated":"2021-10-03T01:57:41.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno93004sg0jeu7dyypbi","content":"<h1 id=\"requestLayout\"><a href=\"#requestLayout\" class=\"headerlink\" title=\"requestLayout\"></a>requestLayout</h1><p>view.requestLayout 最终会调用 ViewRootImpl.requestLayout</p><a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class=\"line\">        checkThread();  <span class=\"comment\">// 检查线程是否是 ViewRootImpl 实例化的线程</span></span><br><span class=\"line\">        mLayoutRequested = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        scheduleTraversals();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// mTraversalScheduled 标记位，避免短时间多次调用requestLayout重复刷新</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 添加一个同步屏障</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\">        <span class=\"comment\">// 通过 Choreographer 添加一个 Vsync 回调</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTraversal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 开始 measure layout draw 三步走</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个 <code>mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</code> 这个操作会在 LooperQueue 中添加一个同步屏障，阻断同步 message（普通 message ）的执行。<br>（异步 message 能正常执行）<br>这里主要是为了保证在 Vync 到来时，这个 message 能够快速响应，保证在 Vync 到来的最初时刻就开始绘制，从而保证 UI 的绘制和 Vync 的周期是协调的。</p>\n<p><code>mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</code> 添加一个 Vsync 回调。在 Vsync 信号到来时执行 mTraversalRunnable 。</p>\n<h1 id=\"Choreographer\"><a href=\"#Choreographer\" class=\"headerlink\" title=\"Choreographer\"></a>Choreographer</h1><p>Choreographer 是用来监听 Vsync 信号的一个类。 在刷新UI时主要有两步。</p>\n<h2 id=\"添加一个-vsync-信号的回调\"><a href=\"#添加一个-vsync-信号的回调\" class=\"headerlink\" title=\"添加一个 vsync 信号的回调\"></a>添加一个 vsync 信号的回调</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Object action, Object token, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> dueTime = now + delayMillis;</span><br><span class=\"line\">        <span class=\"comment\">// 这里 mCallbackQueues 是多个事件的队列</span></span><br><span class=\"line\">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dueTime &lt;= now) &#123;</span><br><span class=\"line\">            scheduleFrameLocked(now);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 延时做刷新，最终也会走 scheduleFrameLocked</span></span><br><span class=\"line\">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class=\"line\">            msg.arg1 = callbackType;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleFrameLocked</span><span class=\"params\">(<span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">        mFrameScheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_VSYNC) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是不是在 ViewRootImpl 实例化时的线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class=\"line\">                scheduleVsyncLocked();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果不是，用一个 Handler 切换线程</span></span><br><span class=\"line\">                <span class=\"comment\">// 发送一个异步消息，并且放置在队列最前方</span></span><br><span class=\"line\">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleVsyncLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mDisplayEventReceiver.scheduleVsync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleVsync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mReceiverPtr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 native 方法请求一个 vsync 回调</span></span><br><span class=\"line\">        nativeScheduleVsync(mReceiverPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"处理-vsync-回调\"><a href=\"#处理-vsync-回调\" class=\"headerlink\" title=\"处理 vsync 回调\"></a>处理 vsync 回调</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 Choreographer 的构造方法里实例化 DisplayEventReceiver</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Choreographer</span><span class=\"params\">(Looper looper, <span class=\"keyword\">int</span> vsyncSource)</span> </span>&#123;</span><br><span class=\"line\">        mLooper = looper;</span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> FrameHandler(looper);</span><br><span class=\"line\">        mDisplayEventReceiver = USE_VSYNC</span><br><span class=\"line\">                ? <span class=\"keyword\">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class=\"line\">                : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameIntervalNanos = (<span class=\"keyword\">long</span>)(<span class=\"number\">1000000000</span> / getRefreshRate());</span><br><span class=\"line\"></span><br><span class=\"line\">        mCallbackQueues = <span class=\"keyword\">new</span> CallbackQueue[CALLBACK_LAST + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class=\"line\">            mCallbackQueues[i] = <span class=\"keyword\">new</span> CallbackQueue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrameDisplayEventReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">DisplayEventReceiver</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mHavePendingVsync;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mTimestampNanos;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mFrame;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FrameDisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"keyword\">int</span> vsyncSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(looper, vsyncSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onVsync</span><span class=\"params\">(<span class=\"keyword\">long</span> timestampNanos, <span class=\"keyword\">int</span> builtInDisplayId, <span class=\"keyword\">int</span> frame)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestampNanos &gt; now) &#123;</span><br><span class=\"line\">            timestampNanos = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mTimestampNanos = timestampNanos;</span><br><span class=\"line\">        mFrame = frame;</span><br><span class=\"line\">        <span class=\"comment\">// 发送一个异步消息，注意，这里没有放置到消息队列最前端</span></span><br><span class=\"line\">        Message msg = Message.obtain(mHandler, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        doFrame(mTimestampNanos, mFrame);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doFrame</span><span class=\"params\">(<span class=\"keyword\">long</span> frameTimeNanos, <span class=\"keyword\">int</span> frame)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> startNanos;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// no work to do</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">        startNanos = System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间 - vsync回调到来时间 = 主线程message耗时</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class=\"line\">        <span class=\"comment\">// 当超过了屏幕一帧刷新时间 16ms</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当跳过的帧超过一定程度</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class=\"line\">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameScheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 处理屏幕刷新的回调，这里会调用 ViewRootImpl.TraversalRunnable</span></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class=\"line\">    &#125; ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"requestLayout\"><a href=\"#requestLayout\" class=\"headerlink\" title=\"requestLayout\"></a>requestLayout</h1><p>view.requestLayout 最终会调用 ViewRootImpl.requestLayout</p>","more":"\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class=\"line\">        checkThread();  <span class=\"comment\">// 检查线程是否是 ViewRootImpl 实例化的线程</span></span><br><span class=\"line\">        mLayoutRequested = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        scheduleTraversals();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTraversals</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// mTraversalScheduled 标记位，避免短时间多次调用requestLayout重复刷新</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 添加一个同步屏障</span></span><br><span class=\"line\">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class=\"line\">        <span class=\"comment\">// 通过 Choreographer 添加一个 Vsync 回调</span></span><br><span class=\"line\">        mChoreographer.postCallback(</span><br><span class=\"line\">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TraversalRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        doTraversal();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doTraversal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mTraversalScheduled) &#123;</span><br><span class=\"line\">        mTraversalScheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 开始 measure layout draw 三步走</span></span><br><span class=\"line\">        performTraversals();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个 <code>mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</code> 这个操作会在 LooperQueue 中添加一个同步屏障，阻断同步 message（普通 message ）的执行。<br>（异步 message 能正常执行）<br>这里主要是为了保证在 Vync 到来时，这个 message 能够快速响应，保证在 Vync 到来的最初时刻就开始绘制，从而保证 UI 的绘制和 Vync 的周期是协调的。</p>\n<p><code>mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</code> 添加一个 Vsync 回调。在 Vsync 信号到来时执行 mTraversalRunnable 。</p>\n<h1 id=\"Choreographer\"><a href=\"#Choreographer\" class=\"headerlink\" title=\"Choreographer\"></a>Choreographer</h1><p>Choreographer 是用来监听 Vsync 信号的一个类。 在刷新UI时主要有两步。</p>\n<h2 id=\"添加一个-vsync-信号的回调\"><a href=\"#添加一个-vsync-信号的回调\" class=\"headerlink\" title=\"添加一个 vsync 信号的回调\"></a>添加一个 vsync 信号的回调</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">postCallbackDelayedInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> callbackType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Object action, Object token, <span class=\"keyword\">long</span> delayMillis)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> now = SystemClock.uptimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> dueTime = now + delayMillis;</span><br><span class=\"line\">        <span class=\"comment\">// 这里 mCallbackQueues 是多个事件的队列</span></span><br><span class=\"line\">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dueTime &lt;= now) &#123;</span><br><span class=\"line\">            scheduleFrameLocked(now);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 延时做刷新，最终也会走 scheduleFrameLocked</span></span><br><span class=\"line\">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class=\"line\">            msg.arg1 = callbackType;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleFrameLocked</span><span class=\"params\">(<span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">        mFrameScheduled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (USE_VSYNC) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断是不是在 ViewRootImpl 实例化时的线程</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class=\"line\">                scheduleVsyncLocked();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果不是，用一个 Handler 切换线程</span></span><br><span class=\"line\">                <span class=\"comment\">// 发送一个异步消息，并且放置在队列最前方</span></span><br><span class=\"line\">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class=\"line\">                msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleVsyncLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    mDisplayEventReceiver.scheduleVsync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleVsync</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mReceiverPtr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用 native 方法请求一个 vsync 回调</span></span><br><span class=\"line\">        nativeScheduleVsync(mReceiverPtr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"处理-vsync-回调\"><a href=\"#处理-vsync-回调\" class=\"headerlink\" title=\"处理 vsync 回调\"></a>处理 vsync 回调</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 Choreographer 的构造方法里实例化 DisplayEventReceiver</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Choreographer</span><span class=\"params\">(Looper looper, <span class=\"keyword\">int</span> vsyncSource)</span> </span>&#123;</span><br><span class=\"line\">        mLooper = looper;</span><br><span class=\"line\">        mHandler = <span class=\"keyword\">new</span> FrameHandler(looper);</span><br><span class=\"line\">        mDisplayEventReceiver = USE_VSYNC</span><br><span class=\"line\">                ? <span class=\"keyword\">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class=\"line\">                : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameIntervalNanos = (<span class=\"keyword\">long</span>)(<span class=\"number\">1000000000</span> / getRefreshRate());</span><br><span class=\"line\"></span><br><span class=\"line\">        mCallbackQueues = <span class=\"keyword\">new</span> CallbackQueue[CALLBACK_LAST + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class=\"line\">            mCallbackQueues[i] = <span class=\"keyword\">new</span> CallbackQueue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrameDisplayEventReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">DisplayEventReceiver</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> mHavePendingVsync;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> mTimestampNanos;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mFrame;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FrameDisplayEventReceiver</span><span class=\"params\">(Looper looper, <span class=\"keyword\">int</span> vsyncSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(looper, vsyncSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onVsync</span><span class=\"params\">(<span class=\"keyword\">long</span> timestampNanos, <span class=\"keyword\">int</span> builtInDisplayId, <span class=\"keyword\">int</span> frame)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestampNanos &gt; now) &#123;</span><br><span class=\"line\">            timestampNanos = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mTimestampNanos = timestampNanos;</span><br><span class=\"line\">        mFrame = frame;</span><br><span class=\"line\">        <span class=\"comment\">// 发送一个异步消息，注意，这里没有放置到消息队列最前端</span></span><br><span class=\"line\">        Message msg = Message.obtain(mHandler, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        doFrame(mTimestampNanos, mFrame);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doFrame</span><span class=\"params\">(<span class=\"keyword\">long</span> frameTimeNanos, <span class=\"keyword\">int</span> frame)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> startNanos;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (mLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!mFrameScheduled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>; <span class=\"comment\">// no work to do</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">        startNanos = System.nanoTime();</span><br><span class=\"line\">        <span class=\"comment\">// 当前时间 - vsync回调到来时间 = 主线程message耗时</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class=\"line\">        <span class=\"comment\">// 当超过了屏幕一帧刷新时间 16ms</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当跳过的帧超过一定程度</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class=\"line\">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mFrameScheduled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 处理屏幕刷新的回调，这里会调用 ViewRootImpl.TraversalRunnable</span></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class=\"line\"></span><br><span class=\"line\">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class=\"line\">    &#125; ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"源码探究Activity的生命周期","date":"2021-01-02T07:00:33.000Z","_content":"\n## startActivity\n\nstartActivity有很多重载方法，最终都会调用`startActivityForResult`\n\n```java\n    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) {\n        if (mParent == null) {\n            options = transferSpringboardActivityOptions(options);\n            Instrumentation.ActivityResult ar =\n                mInstrumentation.execStartActivity(\n                    this, mMainThread.getApplicationThread(), mToken, this,\n                    intent, requestCode, options);\n            if (ar != null) {\n                mMainThread.sendActivityResult(\n                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n                    ar.getResultData());\n            }\n            if (requestCode >= 0) {\n                // If this start is requesting a result, we can avoid making\n                // the activity visible until the result is received.  Setting\n                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the\n                // activity hidden during this time, to avoid flickering.\n                // This can only be done when a result is requested because\n                // that guarantees we will get information back when the\n                // activity is finished, no matter what happens to it.\n                mStartedActivity = true;\n            }\n\n            cancelInputsAndStartExitTransition(options);\n            // TODO Consider clearing/flushing other event sources and events for child windows.\n        } else {\n            ...\n        }\n    }\n```\n\nmParent 代表的是 ActivityGroup，是 Activity 很早的版本里才有的东西，在 api13 中已经被废弃。`mParent == null` 一定为 true\n\n然后的调用过程\n```\n-> Activit.startActivity(...)\n -> Instrumentation.execStartActivity(...)\n  -> ActivityManagerService.startActivity(...)\n   -> ...startActivityAsUser(...)\n```\n\n## startActivityAsUser\n\n```java\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,\n            boolean validateIncomingUser) {\n        enforceNotIsolatedCaller(\"startActivity\");\n\n        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\");\n\n        // TODO: Switch to user app stacks here.\n        return mActivityStartController.obtainStarter(intent, \"startActivityAsUser\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setProfilerInfo(profilerInfo)\n                .setActivityOptions(bOptions)\n                .setMayWait(userId)\n                .execute();\n    }\n```\n\n`mActivityStartController.obtainStarter` 会创建一个 ActivityStarter \n\n```java\n    ActivityStarter setMayWait(int userId) {\n        mRequest.mayWait = true;\n        mRequest.userId = userId;\n\n        return this;\n    }\n```\n\n```java\n    int execute() {\n        try {\n            if (mRequest.mayWait) {\n                return startActivityMayWait(mRequest.caller, mRequest.callingUid,\n                        mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,\n                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,\n                        mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,\n                        mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,\n                        mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,\n                        mRequest.inTask, mRequest.reason,\n                        mRequest.allowPendingRemoteAnimationRegistryLookup);\n            } else {\n                return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,\n                        mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,\n                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,\n                        mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,\n                        mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,\n                        mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,\n                        mRequest.ignoreTargetSecurity, mRequest.componentSpecified,\n                        mRequest.outActivity, mRequest.inTask, mRequest.reason,\n                        mRequest.allowPendingRemoteAnimationRegistryLookup);\n            }\n        } finally {\n            onExecutionComplete();\n        }\n    }\n```\n\n`execute()` 中 `mRequest.mayWait` 为 true\n\n```java\n    private int startActivityMayWait(IApplicationThread caller, int callingUid,\n            String callingPackage, Intent intent, String resolvedType,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n            ProfilerInfo profilerInfo, WaitResult outResult,\n            Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity,\n            int userId, TaskRecord inTask, String reason,\n            boolean allowPendingRemoteAnimationRegistryLookup) {\n            ...\n            int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,\n                    voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,\n                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,\n                    ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,\n                    allowPendingRemoteAnimationRegistryLookup);\n            ...\n            return res;\n        }\n    }\n\n    private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,\n                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n                int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,\n                ActivityRecord[] outActivity) {\n        ...\n            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,\n                    startFlags, doResume, options, inTask, outActivity);\n        ...\n        return result;\n    }\n```\n\n`startActivityUnchecked` 是一个很重要的方法，这个方法里会根据启动标志位和Activity启动模式来决定如何启动一个Activity以及是否要调用deliverNewIntent方法通知Activity有一个Intent试图重新启动它。\n因为这里只讨论住 activity 启动的主流程，所以先不看这个。\n\n`startActivityUnchecked` 之后的调用过程如下\n\n```\n-> ActivityStarter.startActivityUnchecked(...)\n -> ActivityStackSupervisor.resumeFocusedStackTopActivityLocked(...)\n  -> ActivityStack.resumeTopActivityUncheckedLocked(...)\n   -> ...resumeTopActivityInnerLocked(...)\n```\n\n在 `resumeTopActivityInnerLocked` 中会先对 resume 状态的 activity 执行 pause。 \n\n```java\n    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {\n        ...\n        boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);\n        if (mResumedActivity != null) {\n            pausing |= startPausingLocked(userLeaving, false, next, false);\n        }\n        ...\n        // 开始进行真正最终真正的activity启动\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n        \n        try {\n            next.completeResumeLocked();\n        } catch (Exception e) {\n            ...\n        }\n        ...\n        return true;\n    }\n```\n\n## activity 的 pause 过程\n\n`startPausingLocked` 之后会执行 startPausingLocked\n\n```java\n    final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping,\n            ActivityRecord resuming, boolean pauseImmediately) {\n        ...\n        if (prev.app != null && prev.app.thread != null) {\n            try {\n                EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev),\n                        prev.shortComponentName, \"userLeaving=\" + userLeaving);\n                mService.updateUsageStats(prev, false);\n                // Android 9.0在这里引入了ClientLifecycleManager和\n                // ClientTransactionHandler来辅助管理Activity生命周期，\n                // 他会发送EXECUTE_TRANSACTION消息到ActivityThread.H里面继续处理。\n                mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,\n                        PauseActivityItem.obtain(prev.finishing, userLeaving,\n                                prev.configChangeFlags, pauseImmediately));\n            } catch (Exception e) {\n                ...\n            }\n        } else {\n            mPausingActivity = null;\n            mLastPausedActivity = null;\n            mLastNoHistoryActivity = null;\n        }\n        ...\n    }\n```\n\n```java\n\n    void scheduleTransaction(@NonNull IApplicationThread client, @NonNull IBinder activityToken,\n            @NonNull ActivityLifecycleItem stateRequest) throws RemoteException {\n        final ClientTransaction clientTransaction = transactionWithState(client, activityToken,\n                stateRequest);\n        scheduleTransaction(clientTransaction);\n    }\n\n    private static ClientTransaction transactionWithState(@NonNull IApplicationThread client,\n            @NonNull IBinder activityToken, @NonNull ActivityLifecycleItem stateRequest) {\n        final ClientTransaction clientTransaction = ClientTransaction.obtain(client, activityToken);\n        clientTransaction.setLifecycleStateRequest(stateRequest);\n        return clientTransaction;\n    }\n    \n    void scheduleTransaction(ClientTransaction transaction) throws RemoteException {\n        final IApplicationThread client = transaction.getClient();\n        transaction.schedule();\n        if (!(client instanceof Binder)) {\n            transaction.recycle();\n        }\n    }\n```\n\nAndroid 9.0在这里引入了`ClientLifecycleManager`和 `ClientTransactionHandler`来辅助管理Activity生命周期，\n\n`startPausingLocked`生成了一个 `PauseActivityItem` 然后，`ClientLifecycleManager` 会将参数打包为一个 `ClientTransaction` 并设置一个改变生命周期的request。\n\n```java\n// ClientTransaction\n    public void schedule() throws RemoteException {\n        mClient.scheduleTransaction(this);\n    }\n```\n\n`schedule()` 将工作转给了 mClient ，mClient 是 transactionWithState 中传入的，是一个 IApplicationThread， IApplicationThread 是 ActivityThread 的内部类。\n\n```java\n\n// IAppliction\n@Override\npublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException {\n    ActivityThread.this.scheduleTransaction(transaction);\n}\n\n// ActivityThread\nvoid scheduleTransaction(ClientTransaction transaction) {\n    transaction.preExecute(this);\n    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);\n}\n\n// ActivityThread\n    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {\n        Message msg = Message.obtain();\n        ...\n        if (async) {\n            msg.setAsynchronous(true);\n        }\n        mH.sendMessage(msg);\n    }\n```\n\n### H extends Handler\n\n在上面可以看出，最终，向 mH 发送了一个 message\n\n```java\n    public void handleMessage(Message msg) {\n        switch (msg.what) {\n            ...\n            case EXECUTE_TRANSACTION:\n                final ClientTransaction transaction = (ClientTransaction) msg.obj;\n                mTransactionExecutor.execute(transaction);\n                ...\n                break;\n            ...\n        }\n    }\n```\n\nmsg.what 是 `ActivityThread.H.EXECUTE_TRANSACTION` 。将activity生命周期的变换任务交给了 TransactionExecutor\n\n```java\n    public void execute(ClientTransaction transaction) {\n        final IBinder token = transaction.getActivityToken();\n        log(\"Start resolving transaction for client: \" + mTransactionHandler + \", token: \" + token);\n\n        executeCallbacks(transaction);\n\n        executeLifecycleState(transaction);\n        mPendingActions.clear();\n        log(\"End resolving transaction\");\n    }\n\n    private void executeLifecycleState(ClientTransaction transaction) {\n        final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();\n        ...\n        // Cycle to the state right before the final requested state.\n        cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);\n\n        // Execute the final transition with proper parameters.\n        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);\n        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);\n    }\n```\n\n在 TransactionExecutor 中从 ClientTransaction 获取 ActivityLifecycleItem ， 并执行 execute 和 postExecute 。 由于我们传入的是 PauseActivityItem ， 所以真正执行的代码还是在 PauseActivityItem 里。\n\n```java\n    @Override\n    public void execute(ClientTransactionHandler client, IBinder token,PendingTransactionActions pendingActions) {\n        client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,\n                \"PAUSE_ACTIVITY_ITEM\");\n    }\n\n    @Override\n    public void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) {\n        if (mDontReport) {\n            return;\n        }\n        try {\n            // TODO(lifecycler): Use interface callback instead of AMS.\n            ActivityManager.getService().activityPaused(token);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }\n```\n\n```java\n// PauseActivityItem.execute 中调用的是 ClientTransactionHandler.\n// handlePauseActivity ，但是， ActivityThread 继承了 ClientTransactionHandler。 其实调用的还是 ActivityThread 。。\n\n    @Override\n    public void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving,\n            int configChanges, PendingTransactionActions pendingActions, String reason) {\n        ActivityClientRecord r = mActivities.get(token);\n        if (r != null) {\n            if (userLeaving) {\n                performUserLeavingActivity(r);\n            }\n\n            r.activity.mConfigChangeFlags |= configChanges;\n            performPauseActivity(r, finished, reason, pendingActions);\n\n            // Make sure any pending writes are now committed.\n            if (r.isPreHoneycomb()) {\n                QueuedWork.waitToFinish();\n            }\n            mSomeActivitiesChanged = true;\n        }\n    }\n\n    private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) {\n        try {\n            r.activity.mCalled = false;\n            mInstrumentation.callActivityOnPause(r.activity);\n        } ...\n        r.setState(ON_PAUSE);\n    }\n```\n\n```java\n// Instrumentation\n    public void callActivityOnPause(Activity activity) {\n        activity.performPause();\n    }\n```\n\n## 创建 App 进程\n\n```java\n// ActivityStackSupervisor\n    void startSpecificActivityLocked(ActivityRecord r,\n            boolean andResume, boolean checkConfig) {\n        // Is this activity's application already running?\n        ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n\n        getLaunchTimeTracker().setLaunchTime(r);\n\n        if (app != null && app.thread != null) {\n            try {\n                ...\n                realStartActivityLocked(r, app, andResume, checkConfig);\n                return;\n            } catch (RemoteException e) {\n                ...\n            }\n        }\n\n        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n    }\n```\n\nstartSpecificActivityLocked 中会判断要跳转的 activity 所在的进程是否已经存在，如果存在，则调用 realStartActivityLocked ，如果没有存在，则调用 mService.startProcessLocked 创建进程。 \n\n先看看应用进程不存在的情况。之后的调用栈如下： \n```\n-> ActivityManagerService.startProcessLocked\n -> ...startProcessLocked\n  -> ...startProcess\n   -> Process.start\n```\n\n```\n-> Process.start\n -> zygoteProcess.start\n  -> ...startViaZygote\n   -> ...zygoteSendArgsAndGetResult\n    -> ...openZygoteSocketIfNeeded\n```\n\n```java\n    private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n        Preconditions.checkState(Thread.holdsLock(mLock), \"ZygoteProcess lock not held\");\n\n        if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n            try {\n                primaryZygoteState = ZygoteState.connect(mSocket);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n            }\n            maybeSetApiBlacklistExemptions(primaryZygoteState, false);\n            maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);\n        }\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        // The primary zygote didn't match. Try the secondary.\n        if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n            try {\n                secondaryZygoteState = ZygoteState.connect(mSecondarySocket);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n            }\n            maybeSetApiBlacklistExemptions(secondaryZygoteState, false);\n            maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);\n        }\n\n        if (secondaryZygoteState.matches(abi)) {\n            return secondaryZygoteState;\n        }\n\n        throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n    }\n```\n\n。。。这里没太看懂，但是网上的文章说 “其最终调用了Zygote并通过socket通信的方式让Zygote进程fork出一个新的进程，并根据传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法对其进行初始化。“\n\n。。。不知道他是怎么看出来的。。记个 TODO 吧\n\n## 启动 activity\n\n```java\n// ActivityStackSupervisor\n    final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,\n            boolean andResume, boolean checkConfig) throws RemoteException {\n                ...\n                // Create activity launch transaction.\n                final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,\n                        r.appToken);\n                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),\n                        System.identityHashCode(r), r.info,\n                        // TODO: Have this take the merged configuration instead of separate global\n                        // and override configs.\n                        mergedConfiguration.getGlobalConfiguration(),\n                        mergedConfiguration.getOverrideConfiguration(), r.compat,\n                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,\n                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),\n                        profilerInfo));\n\n                // Set desired final state.\n                final ActivityLifecycleItem lifecycleItem;\n                if (andResume) {\n                    lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());\n                } else {\n                    lifecycleItem = PauseActivityItem.obtain();\n                }\n                clientTransaction.setLifecycleStateRequest(lifecycleItem);\n\n                // Schedule transaction.\n                mService.getLifecycleManager().scheduleTransaction(clientTransaction);\n                ...\n\n        return true;\n    }\n```\n\n这里核心是创建了一个 ClientTransaction ，先添加了一个 LaunchActivityItem 作为 callback ， ClientTransaction 在调度是会先执行 callback 。然后设置 LifecycleStateRequest ，这里传入的 andResume == true ，所以设置的是 ResumeActivityItem 。\n\n因为在之前 ClientTransaction 的调度流程已经分析过了，我们直接先来看 LaunchActivityItem.execute\n\n### activity 的 onCreate\n\n```java\n// LaunchActivityItem\n    @Override\n    public void execute(ClientTransactionHandler client, IBinder token,\n            PendingTransactionActions pendingActions) {\n        ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,\n                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,\n                mPendingResults, mPendingNewIntents, mIsForward,\n                mProfilerInfo, client);\n        client.handleLaunchActivity(r, pendingActions, null /* customIntent */);\n    }\n\n// ActivityThread\n    public Activity handleLaunchActivity(ActivityClientRecord r,\n            PendingTransactionActions pendingActions, Intent customIntent) {\n        ...\n        final Activity a = performLaunchActivity(r, customIntent);\n        ...\n        return a;\n    }\n```\n\n```java\n    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n        // 初始化ComponentName\n        ComponentName component = r.intent.getComponent();\n        if (component == null) {\n            component = r.intent.resolveActivity(\n                mInitialApplication.getPackageManager());\n            r.intent.setComponent(component);\n        }\n\n        if (r.activityInfo.targetActivity != null) {\n            component = new ComponentName(r.activityInfo.packageName,\n                    r.activityInfo.targetActivity);\n        }\n\n        // 初始化ContextImpl和Activity\n        ContextImpl appContext = createBaseContextForActivity(r);\n        Activity activity = null;\n        try {\n            // 创建 activity\n            java.lang.ClassLoader cl = appContext.getClassLoader();\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n            StrictMode.incrementExpectedActivityCount(activity.getClass());\n            r.intent.setExtrasClassLoader(cl);\n            r.intent.prepareToEnterProcess();\n            if (r.state != null) {\n                r.state.setClassLoader(cl);\n            }\n        } catch (Exception e) {\n            ...\n        }\n\n        try {\n            // 初始化Application\n            Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n\n            if (activity != null) {\n                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());\n                Configuration config = new Configuration(mCompatConfiguration);\n                if (r.overrideConfig != null) {\n                    config.updateFrom(r.overrideConfig);\n                }\n\n                // 添加window\n                Window window = null;\n                if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {\n                    window = r.mPendingRemoveWindow;\n                    r.mPendingRemoveWindow = null;\n                    r.mPendingRemoveWindowManager = null;\n                }\n                // Application、Activity和ContextImpl互相关联\n                appContext.setOuterContext(activity);\n                activity.attach(appContext, this, getInstrumentation(), r.token,\n                        r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                        r.embeddedID, r.lastNonConfigurationInstances, config,\n                        r.referrer, r.voiceInteractor, window, r.configCallback);\n\n                if (customIntent != null) {\n                    activity.mIntent = customIntent;\n                }\n                r.lastNonConfigurationInstances = null;\n                checkAndBlockForNetworkAccess();\n                activity.mStartedActivity = false;\n                // 设置Activity的Theme\n                int theme = r.activityInfo.getThemeResource();\n                if (theme != 0) {\n                    activity.setTheme(theme);\n                }\n\n                activity.mCalled = false;\n                if (r.isPersistable()) {\n                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n                } else {\n                    mInstrumentation.callActivityOnCreate(activity, r.state);\n                }\n                if (!activity.mCalled) {\n                    throw new SuperNotCalledException(\n                        \"Activity \" + r.intent.getComponent().toShortString() +\n                        \" did not call through to super.onCreate()\");\n                }\n                r.activity = activity;\n            }\n            r.setState(ON_CREATE);\n\n            mActivities.put(r.token, r);\n\n        } catch (SuperNotCalledException e) {\n            throw e;\n        } catch (Exception e) {\n            ...\n        }\n\n        return activity;\n    }\n\n// Instrumentation\n    public Activity newActivity(ClassLoader cl, String className,\n            Intent intent)\n            throws InstantiationException, IllegalAccessException,\n            ClassNotFoundException {\n        String pkg = intent != null && intent.getComponent() != null\n                ? intent.getComponent().getPackageName() : null;\n        // instantiateActivity 利用传入的 ClassLoader ，利用\n        return getFactory(pkg).instantiateActivity(cl, className, intent);\n    }\n```\n\n在 performLaunchActivity 中创建了 activity ，并将 context 和 application 与之绑定，执行 `activity.attach` 。 并添加 window ，设置主题\n\n接下来，performLaunchActivity 里通过调用 mInstrumentation.callActivityOnCreate ，开始进行 onCreate 的流程。\n\n```java\n// Instrumentation\n    public void callActivityOnCreate(Activity activity, Bundle icicle) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle);\n        postPerformCreate(activity);\n    }\n```\n\n### activity 的 onResume \n\n前面我们走完了 activity 的 onCreate 过程，执行代码是在 LaunchActivityItem 中，然后 onResume 显然是在 ResumeActivityItem 里， 那 onOnStart 呢？？\n\n再回到 ClientTransaction 的调度流程中来， 在 TransactionExecutor 里。\n\n```java\n// TransactionExecutor\n    public void execute(ClientTransaction transaction) {\n        final IBinder token = transaction.getActivityToken();\n\n        executeCallbacks(transaction);\n\n        executeLifecycleState(transaction);\n        mPendingActions.clear();\n    }\n\n    private void executeLifecycleState(ClientTransaction transaction) {\n        final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();\n        if (lifecycleItem == null) {\n            // No lifecycle request, return early.\n            return;\n        }\n\n        final IBinder token = transaction.getActivityToken();\n        final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);\n\n        if (r == null) {\n            // Ignore requests for non-existent client records for now.\n            return;\n        }\n\n        // Cycle to the state right before the final requested state.\n        cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);\n\n        // Execute the final transition with proper parameters.\n        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);\n        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);\n    }\n\n    private void cycleToPath(ActivityClientRecord r, int finish,\n            boolean excludeLastState) {\n        final int start = r.getLifecycleState();\n        final IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);\n        performLifecycleSequence(r, path);\n    }\n\n    /** Transition the client through previously initialized state sequence. */\n    private void performLifecycleSequence(ActivityClientRecord r, IntArray path) {\n        final int size = path.size();\n        for (int i = 0, state; i < size; i++) {\n            state = path.get(i);\n            switch (state) {\n                ...\n                case ON_START:\n                    mTransactionHandler.handleStartActivity(r, mPendingActions);\n                    break;\n                ...\n            }\n        }\n    }\n```\n\n在 TransactionExecutor 中先执行 callback ，然后 lifecycleItem.execute 。中间有一个 cycleToPath 方法。 cycleToPath 内部逻辑很明显，执行 start 和 finish 中间状态的逻辑。 对于 ResumeActivityItem 来说就会执行 onStart 的逻辑。。。 我佛了。\n\nactivity 之后的 start 过程和 create 过程基本一致。现在再来看看 onResume\n\n```java\n// ResumeActivityItem\n    @Override\n    public void execute(ClientTransactionHandler client, IBinder token,\n            PendingTransactionActions pendingActions) {\n        client.handleResumeActivity(token, true /* finalStateRequest */, mIsForward, \"RESUME_ACTIVITY\");\n    }\n\n// ActivityThread\n    @Override\n    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,\n            String reason) {\n        ...\n\n        final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);\n        ...\n\n        final Activity a = r.activity;\n\n        ...\n\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow();\n            View decor = r.window.getDecorView();\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager();\n            WindowManager.LayoutParams l = r.window.getAttributes();\n            a.mDecor = decor;\n            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n            l.softInputMode |= forwardBit;\n            if (r.mPreserveWindow) {\n                a.mWindowAdded = true;\n                r.mPreserveWindow = false;\n                ViewRootImpl impl = decor.getViewRootImpl();\n                if (impl != null) {\n                    impl.notifyChildRebuilt();\n                }\n            }\n            if (a.mVisibleFromClient) {\n                if (!a.mWindowAdded) {\n                    a.mWindowAdded = true;\n                    wm.addView(decor, l);\n                } else {\n                    a.onWindowAttributesChanged(l);\n                }\n            }\n        } else if (!willBeVisible) {\n            r.hideForNow = true;\n        }\n\n        ...\n\n        Looper.myQueue().addIdleHandler(new Idler());\n    }\n\n   public ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest,\n            String reason) {\n        ...\n        try {\n            r.activity.onStateNotSaved();\n            r.activity.mFragments.noteStateNotSaved();\n            checkAndBlockForNetworkAccess();\n            if (r.pendingIntents != null) {\n                deliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            if (r.pendingResults != null) {\n                deliverResults(r, r.pendingResults, reason);\n                r.pendingResults = null;\n            }\n            r.activity.performResume(r.startsNotResumed, reason);\n\n            r.state = null;\n            r.persistentState = null;\n            r.setState(ON_RESUME);\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(r.activity, e)) {\n                throw new RuntimeException(\"Unable to resume activity \"\n                        + r.intent.getComponent().toShortString() + \": \" + e.toString(), e);\n            }\n        }\n        ...\n        return r;\n    }\n\n```\n\nhandleResumeActivity 中操作了很多 window 相关的东西。 到这里 activity 的启动就完成了\n\n## activity 的 stop\n\n之前分析了 onPause 的流程， 但是没有看到 onStop ， 所以 onStop 是如何执行的呢。 在 activity 的生命周期中， activity a 启动 activity b ， b.onStop 应该在 a.onResume 之后执行。\n\n玄机竟然在 handleResumeActivity 里。。\n\n```java\n// ActivityThread\n    @Override\n    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,\n            String reason) {\n        ...\n\n        final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);\n        ...\n\n        Looper.myQueue().addIdleHandler(new Idler());\n    }\n\n    private class Idler implements MessageQueue.IdleHandler {\n        @Override\n        public final boolean queueIdle() {\n            ...\n            if (a.activity != null && !a.activity.mFinished) {\n                try {\n                    am.activityIdle(a.token, a.createdConfig, stopProfiling);\n                        a.createdConfig = null;\n                } catch (RemoteException ex) {\n                    throw ex.rethrowFromSystemServer();\n                }\n            }\n            ...\n            return false;\n        }\n    }\n```\n\n```java\n// ActivityManagerService\n    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (this) {\n            ActivityStack stack = ActivityRecord.getStackLocked(token);\n            if (stack != null) {\n                ActivityRecord r =\n                        mStackSupervisor.activityIdleInternalLocked(token, false /* fromTimeout */,\n                                false /* processPausingActivities */, config);\n                if (stopProfiling) {\n                    if ((mProfileProc == r.app) && mProfilerInfo != null) {\n                        clearProfilerLocked();\n                    }\n                }\n            }\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n```\n\n```java\n// ActivityStackSupervisor.java\n    final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,\n            boolean processPausingActivities, Configuration config) {\n        ...\n        final ArrayList<ActivityRecord> stops = processStoppingActivitiesLocked(r, true /* remove */, processPausingActivities);\n        ...\n\n        for (int i = 0; i < NS; i++) {\n            r = stops.get(i);\n            final ActivityStack stack = r.getStack();\n            if (stack != null) {\n                if (r.finishing) {\n                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false,\n                            \"activityIdleInternalLocked\");\n                } else {\n                    stack.stopActivityLocked(r);\n                }\n            }\n        }\n        ...\n\n        return r;\n    }\n\n// ActivityStack\n    final void stopActivityLocked(ActivityRecord r) {\n        ...\n        mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,\n                StopActivityItem.obtain(r.visible, r.configChangeFlags));\n        ...\n    }\n```\n\n经过一番调用，最终还是一样，向 ClientLifecycleManager 发送了一个 StopActivityItem 。\n\n到此，activity 的启动流程就结束了。\n\n## 参考\n\n[（Android 9.0）Activity启动流程源码分析](https://www.jianshu.com/p/89fd44083c1c)\n[Activity启动过程全解析](https://www.kancloud.cn/digest/androidframeworks/127782)\n[炼狱难度！腾讯Android高级岗：为什么 Activity.finish() 之后 10s 才 onDestroy ？](https://www.jianshu.com/p/15a0df736e52)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Android/Framework/源码探究Activity的生命周期.md","raw":"---\ntitle: 源码探究Activity的生命周期\ndate: 2021-01-02 15:00:33\ntags: Activity\n---\n\n## startActivity\n\nstartActivity有很多重载方法，最终都会调用`startActivityForResult`\n\n```java\n    public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) {\n        if (mParent == null) {\n            options = transferSpringboardActivityOptions(options);\n            Instrumentation.ActivityResult ar =\n                mInstrumentation.execStartActivity(\n                    this, mMainThread.getApplicationThread(), mToken, this,\n                    intent, requestCode, options);\n            if (ar != null) {\n                mMainThread.sendActivityResult(\n                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),\n                    ar.getResultData());\n            }\n            if (requestCode >= 0) {\n                // If this start is requesting a result, we can avoid making\n                // the activity visible until the result is received.  Setting\n                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the\n                // activity hidden during this time, to avoid flickering.\n                // This can only be done when a result is requested because\n                // that guarantees we will get information back when the\n                // activity is finished, no matter what happens to it.\n                mStartedActivity = true;\n            }\n\n            cancelInputsAndStartExitTransition(options);\n            // TODO Consider clearing/flushing other event sources and events for child windows.\n        } else {\n            ...\n        }\n    }\n```\n\nmParent 代表的是 ActivityGroup，是 Activity 很早的版本里才有的东西，在 api13 中已经被废弃。`mParent == null` 一定为 true\n\n然后的调用过程\n```\n-> Activit.startActivity(...)\n -> Instrumentation.execStartActivity(...)\n  -> ActivityManagerService.startActivity(...)\n   -> ...startActivityAsUser(...)\n```\n\n## startActivityAsUser\n\n```java\n    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId,\n            boolean validateIncomingUser) {\n        enforceNotIsolatedCaller(\"startActivity\");\n\n        userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,\n                Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\");\n\n        // TODO: Switch to user app stacks here.\n        return mActivityStartController.obtainStarter(intent, \"startActivityAsUser\")\n                .setCaller(caller)\n                .setCallingPackage(callingPackage)\n                .setResolvedType(resolvedType)\n                .setResultTo(resultTo)\n                .setResultWho(resultWho)\n                .setRequestCode(requestCode)\n                .setStartFlags(startFlags)\n                .setProfilerInfo(profilerInfo)\n                .setActivityOptions(bOptions)\n                .setMayWait(userId)\n                .execute();\n    }\n```\n\n`mActivityStartController.obtainStarter` 会创建一个 ActivityStarter \n\n```java\n    ActivityStarter setMayWait(int userId) {\n        mRequest.mayWait = true;\n        mRequest.userId = userId;\n\n        return this;\n    }\n```\n\n```java\n    int execute() {\n        try {\n            if (mRequest.mayWait) {\n                return startActivityMayWait(mRequest.caller, mRequest.callingUid,\n                        mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,\n                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,\n                        mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,\n                        mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,\n                        mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,\n                        mRequest.inTask, mRequest.reason,\n                        mRequest.allowPendingRemoteAnimationRegistryLookup);\n            } else {\n                return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,\n                        mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,\n                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,\n                        mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,\n                        mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,\n                        mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,\n                        mRequest.ignoreTargetSecurity, mRequest.componentSpecified,\n                        mRequest.outActivity, mRequest.inTask, mRequest.reason,\n                        mRequest.allowPendingRemoteAnimationRegistryLookup);\n            }\n        } finally {\n            onExecutionComplete();\n        }\n    }\n```\n\n`execute()` 中 `mRequest.mayWait` 为 true\n\n```java\n    private int startActivityMayWait(IApplicationThread caller, int callingUid,\n            String callingPackage, Intent intent, String resolvedType,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n            ProfilerInfo profilerInfo, WaitResult outResult,\n            Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity,\n            int userId, TaskRecord inTask, String reason,\n            boolean allowPendingRemoteAnimationRegistryLookup) {\n            ...\n            int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,\n                    voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,\n                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,\n                    ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,\n                    allowPendingRemoteAnimationRegistryLookup);\n            ...\n            return res;\n        }\n    }\n\n    private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord,\n                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n                int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask,\n                ActivityRecord[] outActivity) {\n        ...\n            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,\n                    startFlags, doResume, options, inTask, outActivity);\n        ...\n        return result;\n    }\n```\n\n`startActivityUnchecked` 是一个很重要的方法，这个方法里会根据启动标志位和Activity启动模式来决定如何启动一个Activity以及是否要调用deliverNewIntent方法通知Activity有一个Intent试图重新启动它。\n因为这里只讨论住 activity 启动的主流程，所以先不看这个。\n\n`startActivityUnchecked` 之后的调用过程如下\n\n```\n-> ActivityStarter.startActivityUnchecked(...)\n -> ActivityStackSupervisor.resumeFocusedStackTopActivityLocked(...)\n  -> ActivityStack.resumeTopActivityUncheckedLocked(...)\n   -> ...resumeTopActivityInnerLocked(...)\n```\n\n在 `resumeTopActivityInnerLocked` 中会先对 resume 状态的 activity 执行 pause。 \n\n```java\n    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {\n        ...\n        boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, false);\n        if (mResumedActivity != null) {\n            pausing |= startPausingLocked(userLeaving, false, next, false);\n        }\n        ...\n        // 开始进行真正最终真正的activity启动\n        mStackSupervisor.startSpecificActivityLocked(next, true, true);\n        \n        try {\n            next.completeResumeLocked();\n        } catch (Exception e) {\n            ...\n        }\n        ...\n        return true;\n    }\n```\n\n## activity 的 pause 过程\n\n`startPausingLocked` 之后会执行 startPausingLocked\n\n```java\n    final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping,\n            ActivityRecord resuming, boolean pauseImmediately) {\n        ...\n        if (prev.app != null && prev.app.thread != null) {\n            try {\n                EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev),\n                        prev.shortComponentName, \"userLeaving=\" + userLeaving);\n                mService.updateUsageStats(prev, false);\n                // Android 9.0在这里引入了ClientLifecycleManager和\n                // ClientTransactionHandler来辅助管理Activity生命周期，\n                // 他会发送EXECUTE_TRANSACTION消息到ActivityThread.H里面继续处理。\n                mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,\n                        PauseActivityItem.obtain(prev.finishing, userLeaving,\n                                prev.configChangeFlags, pauseImmediately));\n            } catch (Exception e) {\n                ...\n            }\n        } else {\n            mPausingActivity = null;\n            mLastPausedActivity = null;\n            mLastNoHistoryActivity = null;\n        }\n        ...\n    }\n```\n\n```java\n\n    void scheduleTransaction(@NonNull IApplicationThread client, @NonNull IBinder activityToken,\n            @NonNull ActivityLifecycleItem stateRequest) throws RemoteException {\n        final ClientTransaction clientTransaction = transactionWithState(client, activityToken,\n                stateRequest);\n        scheduleTransaction(clientTransaction);\n    }\n\n    private static ClientTransaction transactionWithState(@NonNull IApplicationThread client,\n            @NonNull IBinder activityToken, @NonNull ActivityLifecycleItem stateRequest) {\n        final ClientTransaction clientTransaction = ClientTransaction.obtain(client, activityToken);\n        clientTransaction.setLifecycleStateRequest(stateRequest);\n        return clientTransaction;\n    }\n    \n    void scheduleTransaction(ClientTransaction transaction) throws RemoteException {\n        final IApplicationThread client = transaction.getClient();\n        transaction.schedule();\n        if (!(client instanceof Binder)) {\n            transaction.recycle();\n        }\n    }\n```\n\nAndroid 9.0在这里引入了`ClientLifecycleManager`和 `ClientTransactionHandler`来辅助管理Activity生命周期，\n\n`startPausingLocked`生成了一个 `PauseActivityItem` 然后，`ClientLifecycleManager` 会将参数打包为一个 `ClientTransaction` 并设置一个改变生命周期的request。\n\n```java\n// ClientTransaction\n    public void schedule() throws RemoteException {\n        mClient.scheduleTransaction(this);\n    }\n```\n\n`schedule()` 将工作转给了 mClient ，mClient 是 transactionWithState 中传入的，是一个 IApplicationThread， IApplicationThread 是 ActivityThread 的内部类。\n\n```java\n\n// IAppliction\n@Override\npublic void scheduleTransaction(ClientTransaction transaction) throws RemoteException {\n    ActivityThread.this.scheduleTransaction(transaction);\n}\n\n// ActivityThread\nvoid scheduleTransaction(ClientTransaction transaction) {\n    transaction.preExecute(this);\n    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);\n}\n\n// ActivityThread\n    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {\n        Message msg = Message.obtain();\n        ...\n        if (async) {\n            msg.setAsynchronous(true);\n        }\n        mH.sendMessage(msg);\n    }\n```\n\n### H extends Handler\n\n在上面可以看出，最终，向 mH 发送了一个 message\n\n```java\n    public void handleMessage(Message msg) {\n        switch (msg.what) {\n            ...\n            case EXECUTE_TRANSACTION:\n                final ClientTransaction transaction = (ClientTransaction) msg.obj;\n                mTransactionExecutor.execute(transaction);\n                ...\n                break;\n            ...\n        }\n    }\n```\n\nmsg.what 是 `ActivityThread.H.EXECUTE_TRANSACTION` 。将activity生命周期的变换任务交给了 TransactionExecutor\n\n```java\n    public void execute(ClientTransaction transaction) {\n        final IBinder token = transaction.getActivityToken();\n        log(\"Start resolving transaction for client: \" + mTransactionHandler + \", token: \" + token);\n\n        executeCallbacks(transaction);\n\n        executeLifecycleState(transaction);\n        mPendingActions.clear();\n        log(\"End resolving transaction\");\n    }\n\n    private void executeLifecycleState(ClientTransaction transaction) {\n        final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();\n        ...\n        // Cycle to the state right before the final requested state.\n        cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);\n\n        // Execute the final transition with proper parameters.\n        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);\n        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);\n    }\n```\n\n在 TransactionExecutor 中从 ClientTransaction 获取 ActivityLifecycleItem ， 并执行 execute 和 postExecute 。 由于我们传入的是 PauseActivityItem ， 所以真正执行的代码还是在 PauseActivityItem 里。\n\n```java\n    @Override\n    public void execute(ClientTransactionHandler client, IBinder token,PendingTransactionActions pendingActions) {\n        client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,\n                \"PAUSE_ACTIVITY_ITEM\");\n    }\n\n    @Override\n    public void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) {\n        if (mDontReport) {\n            return;\n        }\n        try {\n            // TODO(lifecycler): Use interface callback instead of AMS.\n            ActivityManager.getService().activityPaused(token);\n        } catch (RemoteException ex) {\n            throw ex.rethrowFromSystemServer();\n        }\n    }\n```\n\n```java\n// PauseActivityItem.execute 中调用的是 ClientTransactionHandler.\n// handlePauseActivity ，但是， ActivityThread 继承了 ClientTransactionHandler。 其实调用的还是 ActivityThread 。。\n\n    @Override\n    public void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving,\n            int configChanges, PendingTransactionActions pendingActions, String reason) {\n        ActivityClientRecord r = mActivities.get(token);\n        if (r != null) {\n            if (userLeaving) {\n                performUserLeavingActivity(r);\n            }\n\n            r.activity.mConfigChangeFlags |= configChanges;\n            performPauseActivity(r, finished, reason, pendingActions);\n\n            // Make sure any pending writes are now committed.\n            if (r.isPreHoneycomb()) {\n                QueuedWork.waitToFinish();\n            }\n            mSomeActivitiesChanged = true;\n        }\n    }\n\n    private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) {\n        try {\n            r.activity.mCalled = false;\n            mInstrumentation.callActivityOnPause(r.activity);\n        } ...\n        r.setState(ON_PAUSE);\n    }\n```\n\n```java\n// Instrumentation\n    public void callActivityOnPause(Activity activity) {\n        activity.performPause();\n    }\n```\n\n## 创建 App 进程\n\n```java\n// ActivityStackSupervisor\n    void startSpecificActivityLocked(ActivityRecord r,\n            boolean andResume, boolean checkConfig) {\n        // Is this activity's application already running?\n        ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n\n        getLaunchTimeTracker().setLaunchTime(r);\n\n        if (app != null && app.thread != null) {\n            try {\n                ...\n                realStartActivityLocked(r, app, andResume, checkConfig);\n                return;\n            } catch (RemoteException e) {\n                ...\n            }\n        }\n\n        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n    }\n```\n\nstartSpecificActivityLocked 中会判断要跳转的 activity 所在的进程是否已经存在，如果存在，则调用 realStartActivityLocked ，如果没有存在，则调用 mService.startProcessLocked 创建进程。 \n\n先看看应用进程不存在的情况。之后的调用栈如下： \n```\n-> ActivityManagerService.startProcessLocked\n -> ...startProcessLocked\n  -> ...startProcess\n   -> Process.start\n```\n\n```\n-> Process.start\n -> zygoteProcess.start\n  -> ...startViaZygote\n   -> ...zygoteSendArgsAndGetResult\n    -> ...openZygoteSocketIfNeeded\n```\n\n```java\n    private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {\n        Preconditions.checkState(Thread.holdsLock(mLock), \"ZygoteProcess lock not held\");\n\n        if (primaryZygoteState == null || primaryZygoteState.isClosed()) {\n            try {\n                primaryZygoteState = ZygoteState.connect(mSocket);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe);\n            }\n            maybeSetApiBlacklistExemptions(primaryZygoteState, false);\n            maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);\n        }\n        if (primaryZygoteState.matches(abi)) {\n            return primaryZygoteState;\n        }\n\n        // The primary zygote didn't match. Try the secondary.\n        if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {\n            try {\n                secondaryZygoteState = ZygoteState.connect(mSecondarySocket);\n            } catch (IOException ioe) {\n                throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe);\n            }\n            maybeSetApiBlacklistExemptions(secondaryZygoteState, false);\n            maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);\n        }\n\n        if (secondaryZygoteState.matches(abi)) {\n            return secondaryZygoteState;\n        }\n\n        throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);\n    }\n```\n\n。。。这里没太看懂，但是网上的文章说 “其最终调用了Zygote并通过socket通信的方式让Zygote进程fork出一个新的进程，并根据传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法对其进行初始化。“\n\n。。。不知道他是怎么看出来的。。记个 TODO 吧\n\n## 启动 activity\n\n```java\n// ActivityStackSupervisor\n    final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,\n            boolean andResume, boolean checkConfig) throws RemoteException {\n                ...\n                // Create activity launch transaction.\n                final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,\n                        r.appToken);\n                clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),\n                        System.identityHashCode(r), r.info,\n                        // TODO: Have this take the merged configuration instead of separate global\n                        // and override configs.\n                        mergedConfiguration.getGlobalConfiguration(),\n                        mergedConfiguration.getOverrideConfiguration(), r.compat,\n                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,\n                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),\n                        profilerInfo));\n\n                // Set desired final state.\n                final ActivityLifecycleItem lifecycleItem;\n                if (andResume) {\n                    lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());\n                } else {\n                    lifecycleItem = PauseActivityItem.obtain();\n                }\n                clientTransaction.setLifecycleStateRequest(lifecycleItem);\n\n                // Schedule transaction.\n                mService.getLifecycleManager().scheduleTransaction(clientTransaction);\n                ...\n\n        return true;\n    }\n```\n\n这里核心是创建了一个 ClientTransaction ，先添加了一个 LaunchActivityItem 作为 callback ， ClientTransaction 在调度是会先执行 callback 。然后设置 LifecycleStateRequest ，这里传入的 andResume == true ，所以设置的是 ResumeActivityItem 。\n\n因为在之前 ClientTransaction 的调度流程已经分析过了，我们直接先来看 LaunchActivityItem.execute\n\n### activity 的 onCreate\n\n```java\n// LaunchActivityItem\n    @Override\n    public void execute(ClientTransactionHandler client, IBinder token,\n            PendingTransactionActions pendingActions) {\n        ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,\n                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,\n                mPendingResults, mPendingNewIntents, mIsForward,\n                mProfilerInfo, client);\n        client.handleLaunchActivity(r, pendingActions, null /* customIntent */);\n    }\n\n// ActivityThread\n    public Activity handleLaunchActivity(ActivityClientRecord r,\n            PendingTransactionActions pendingActions, Intent customIntent) {\n        ...\n        final Activity a = performLaunchActivity(r, customIntent);\n        ...\n        return a;\n    }\n```\n\n```java\n    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {\n        // 初始化ComponentName\n        ComponentName component = r.intent.getComponent();\n        if (component == null) {\n            component = r.intent.resolveActivity(\n                mInitialApplication.getPackageManager());\n            r.intent.setComponent(component);\n        }\n\n        if (r.activityInfo.targetActivity != null) {\n            component = new ComponentName(r.activityInfo.packageName,\n                    r.activityInfo.targetActivity);\n        }\n\n        // 初始化ContextImpl和Activity\n        ContextImpl appContext = createBaseContextForActivity(r);\n        Activity activity = null;\n        try {\n            // 创建 activity\n            java.lang.ClassLoader cl = appContext.getClassLoader();\n            activity = mInstrumentation.newActivity(\n                    cl, component.getClassName(), r.intent);\n            StrictMode.incrementExpectedActivityCount(activity.getClass());\n            r.intent.setExtrasClassLoader(cl);\n            r.intent.prepareToEnterProcess();\n            if (r.state != null) {\n                r.state.setClassLoader(cl);\n            }\n        } catch (Exception e) {\n            ...\n        }\n\n        try {\n            // 初始化Application\n            Application app = r.packageInfo.makeApplication(false, mInstrumentation);\n\n            if (activity != null) {\n                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());\n                Configuration config = new Configuration(mCompatConfiguration);\n                if (r.overrideConfig != null) {\n                    config.updateFrom(r.overrideConfig);\n                }\n\n                // 添加window\n                Window window = null;\n                if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {\n                    window = r.mPendingRemoveWindow;\n                    r.mPendingRemoveWindow = null;\n                    r.mPendingRemoveWindowManager = null;\n                }\n                // Application、Activity和ContextImpl互相关联\n                appContext.setOuterContext(activity);\n                activity.attach(appContext, this, getInstrumentation(), r.token,\n                        r.ident, app, r.intent, r.activityInfo, title, r.parent,\n                        r.embeddedID, r.lastNonConfigurationInstances, config,\n                        r.referrer, r.voiceInteractor, window, r.configCallback);\n\n                if (customIntent != null) {\n                    activity.mIntent = customIntent;\n                }\n                r.lastNonConfigurationInstances = null;\n                checkAndBlockForNetworkAccess();\n                activity.mStartedActivity = false;\n                // 设置Activity的Theme\n                int theme = r.activityInfo.getThemeResource();\n                if (theme != 0) {\n                    activity.setTheme(theme);\n                }\n\n                activity.mCalled = false;\n                if (r.isPersistable()) {\n                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);\n                } else {\n                    mInstrumentation.callActivityOnCreate(activity, r.state);\n                }\n                if (!activity.mCalled) {\n                    throw new SuperNotCalledException(\n                        \"Activity \" + r.intent.getComponent().toShortString() +\n                        \" did not call through to super.onCreate()\");\n                }\n                r.activity = activity;\n            }\n            r.setState(ON_CREATE);\n\n            mActivities.put(r.token, r);\n\n        } catch (SuperNotCalledException e) {\n            throw e;\n        } catch (Exception e) {\n            ...\n        }\n\n        return activity;\n    }\n\n// Instrumentation\n    public Activity newActivity(ClassLoader cl, String className,\n            Intent intent)\n            throws InstantiationException, IllegalAccessException,\n            ClassNotFoundException {\n        String pkg = intent != null && intent.getComponent() != null\n                ? intent.getComponent().getPackageName() : null;\n        // instantiateActivity 利用传入的 ClassLoader ，利用\n        return getFactory(pkg).instantiateActivity(cl, className, intent);\n    }\n```\n\n在 performLaunchActivity 中创建了 activity ，并将 context 和 application 与之绑定，执行 `activity.attach` 。 并添加 window ，设置主题\n\n接下来，performLaunchActivity 里通过调用 mInstrumentation.callActivityOnCreate ，开始进行 onCreate 的流程。\n\n```java\n// Instrumentation\n    public void callActivityOnCreate(Activity activity, Bundle icicle) {\n        prePerformCreate(activity);\n        activity.performCreate(icicle);\n        postPerformCreate(activity);\n    }\n```\n\n### activity 的 onResume \n\n前面我们走完了 activity 的 onCreate 过程，执行代码是在 LaunchActivityItem 中，然后 onResume 显然是在 ResumeActivityItem 里， 那 onOnStart 呢？？\n\n再回到 ClientTransaction 的调度流程中来， 在 TransactionExecutor 里。\n\n```java\n// TransactionExecutor\n    public void execute(ClientTransaction transaction) {\n        final IBinder token = transaction.getActivityToken();\n\n        executeCallbacks(transaction);\n\n        executeLifecycleState(transaction);\n        mPendingActions.clear();\n    }\n\n    private void executeLifecycleState(ClientTransaction transaction) {\n        final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();\n        if (lifecycleItem == null) {\n            // No lifecycle request, return early.\n            return;\n        }\n\n        final IBinder token = transaction.getActivityToken();\n        final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);\n\n        if (r == null) {\n            // Ignore requests for non-existent client records for now.\n            return;\n        }\n\n        // Cycle to the state right before the final requested state.\n        cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);\n\n        // Execute the final transition with proper parameters.\n        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);\n        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);\n    }\n\n    private void cycleToPath(ActivityClientRecord r, int finish,\n            boolean excludeLastState) {\n        final int start = r.getLifecycleState();\n        final IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);\n        performLifecycleSequence(r, path);\n    }\n\n    /** Transition the client through previously initialized state sequence. */\n    private void performLifecycleSequence(ActivityClientRecord r, IntArray path) {\n        final int size = path.size();\n        for (int i = 0, state; i < size; i++) {\n            state = path.get(i);\n            switch (state) {\n                ...\n                case ON_START:\n                    mTransactionHandler.handleStartActivity(r, mPendingActions);\n                    break;\n                ...\n            }\n        }\n    }\n```\n\n在 TransactionExecutor 中先执行 callback ，然后 lifecycleItem.execute 。中间有一个 cycleToPath 方法。 cycleToPath 内部逻辑很明显，执行 start 和 finish 中间状态的逻辑。 对于 ResumeActivityItem 来说就会执行 onStart 的逻辑。。。 我佛了。\n\nactivity 之后的 start 过程和 create 过程基本一致。现在再来看看 onResume\n\n```java\n// ResumeActivityItem\n    @Override\n    public void execute(ClientTransactionHandler client, IBinder token,\n            PendingTransactionActions pendingActions) {\n        client.handleResumeActivity(token, true /* finalStateRequest */, mIsForward, \"RESUME_ACTIVITY\");\n    }\n\n// ActivityThread\n    @Override\n    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,\n            String reason) {\n        ...\n\n        final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);\n        ...\n\n        final Activity a = r.activity;\n\n        ...\n\n        if (r.window == null && !a.mFinished && willBeVisible) {\n            r.window = r.activity.getWindow();\n            View decor = r.window.getDecorView();\n            decor.setVisibility(View.INVISIBLE);\n            ViewManager wm = a.getWindowManager();\n            WindowManager.LayoutParams l = r.window.getAttributes();\n            a.mDecor = decor;\n            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;\n            l.softInputMode |= forwardBit;\n            if (r.mPreserveWindow) {\n                a.mWindowAdded = true;\n                r.mPreserveWindow = false;\n                ViewRootImpl impl = decor.getViewRootImpl();\n                if (impl != null) {\n                    impl.notifyChildRebuilt();\n                }\n            }\n            if (a.mVisibleFromClient) {\n                if (!a.mWindowAdded) {\n                    a.mWindowAdded = true;\n                    wm.addView(decor, l);\n                } else {\n                    a.onWindowAttributesChanged(l);\n                }\n            }\n        } else if (!willBeVisible) {\n            r.hideForNow = true;\n        }\n\n        ...\n\n        Looper.myQueue().addIdleHandler(new Idler());\n    }\n\n   public ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest,\n            String reason) {\n        ...\n        try {\n            r.activity.onStateNotSaved();\n            r.activity.mFragments.noteStateNotSaved();\n            checkAndBlockForNetworkAccess();\n            if (r.pendingIntents != null) {\n                deliverNewIntents(r, r.pendingIntents);\n                r.pendingIntents = null;\n            }\n            if (r.pendingResults != null) {\n                deliverResults(r, r.pendingResults, reason);\n                r.pendingResults = null;\n            }\n            r.activity.performResume(r.startsNotResumed, reason);\n\n            r.state = null;\n            r.persistentState = null;\n            r.setState(ON_RESUME);\n        } catch (Exception e) {\n            if (!mInstrumentation.onException(r.activity, e)) {\n                throw new RuntimeException(\"Unable to resume activity \"\n                        + r.intent.getComponent().toShortString() + \": \" + e.toString(), e);\n            }\n        }\n        ...\n        return r;\n    }\n\n```\n\nhandleResumeActivity 中操作了很多 window 相关的东西。 到这里 activity 的启动就完成了\n\n## activity 的 stop\n\n之前分析了 onPause 的流程， 但是没有看到 onStop ， 所以 onStop 是如何执行的呢。 在 activity 的生命周期中， activity a 启动 activity b ， b.onStop 应该在 a.onResume 之后执行。\n\n玄机竟然在 handleResumeActivity 里。。\n\n```java\n// ActivityThread\n    @Override\n    public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,\n            String reason) {\n        ...\n\n        final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);\n        ...\n\n        Looper.myQueue().addIdleHandler(new Idler());\n    }\n\n    private class Idler implements MessageQueue.IdleHandler {\n        @Override\n        public final boolean queueIdle() {\n            ...\n            if (a.activity != null && !a.activity.mFinished) {\n                try {\n                    am.activityIdle(a.token, a.createdConfig, stopProfiling);\n                        a.createdConfig = null;\n                } catch (RemoteException ex) {\n                    throw ex.rethrowFromSystemServer();\n                }\n            }\n            ...\n            return false;\n        }\n    }\n```\n\n```java\n// ActivityManagerService\n    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {\n        final long origId = Binder.clearCallingIdentity();\n        synchronized (this) {\n            ActivityStack stack = ActivityRecord.getStackLocked(token);\n            if (stack != null) {\n                ActivityRecord r =\n                        mStackSupervisor.activityIdleInternalLocked(token, false /* fromTimeout */,\n                                false /* processPausingActivities */, config);\n                if (stopProfiling) {\n                    if ((mProfileProc == r.app) && mProfilerInfo != null) {\n                        clearProfilerLocked();\n                    }\n                }\n            }\n        }\n        Binder.restoreCallingIdentity(origId);\n    }\n```\n\n```java\n// ActivityStackSupervisor.java\n    final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout,\n            boolean processPausingActivities, Configuration config) {\n        ...\n        final ArrayList<ActivityRecord> stops = processStoppingActivitiesLocked(r, true /* remove */, processPausingActivities);\n        ...\n\n        for (int i = 0; i < NS; i++) {\n            r = stops.get(i);\n            final ActivityStack stack = r.getStack();\n            if (stack != null) {\n                if (r.finishing) {\n                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false,\n                            \"activityIdleInternalLocked\");\n                } else {\n                    stack.stopActivityLocked(r);\n                }\n            }\n        }\n        ...\n\n        return r;\n    }\n\n// ActivityStack\n    final void stopActivityLocked(ActivityRecord r) {\n        ...\n        mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,\n                StopActivityItem.obtain(r.visible, r.configChangeFlags));\n        ...\n    }\n```\n\n经过一番调用，最终还是一样，向 ClientLifecycleManager 发送了一个 StopActivityItem 。\n\n到此，activity 的启动流程就结束了。\n\n## 参考\n\n[（Android 9.0）Activity启动流程源码分析](https://www.jianshu.com/p/89fd44083c1c)\n[Activity启动过程全解析](https://www.kancloud.cn/digest/androidframeworks/127782)\n[炼狱难度！腾讯Android高级岗：为什么 Activity.finish() 之后 10s 才 onDestroy ？](https://www.jianshu.com/p/15a0df736e52)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Android/Framework/源码探究Activity的生命周期","published":1,"updated":"2021-10-03T01:57:41.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno94004tg0jehokryusz","content":"<h2 id=\"startActivity\"><a href=\"#startActivity\" class=\"headerlink\" title=\"startActivity\"></a>startActivity</h2><p>startActivity有很多重载方法，最终都会调用<code>startActivityForResult</code></p><a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">(@RequiresPermission Intent intent, <span class=\"keyword\">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        options = transferSpringboardActivityOptions(options);</span><br><span class=\"line\">        Instrumentation.ActivityResult ar =</span><br><span class=\"line\">            mInstrumentation.execStartActivity(</span><br><span class=\"line\">                <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                intent, requestCode, options);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mMainThread.sendActivityResult(</span><br><span class=\"line\">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class=\"line\">                ar.getResultData());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If this start is requesting a result, we can avoid making</span></span><br><span class=\"line\">            <span class=\"comment\">// the activity visible until the result is received.  Setting</span></span><br><span class=\"line\">            <span class=\"comment\">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class=\"line\">            <span class=\"comment\">// activity hidden during this time, to avoid flickering.</span></span><br><span class=\"line\">            <span class=\"comment\">// This can only be done when a result is requested because</span></span><br><span class=\"line\">            <span class=\"comment\">// that guarantees we will get information back when the</span></span><br><span class=\"line\">            <span class=\"comment\">// activity is finished, no matter what happens to it.</span></span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cancelInputsAndStartExitTransition(options);</span><br><span class=\"line\">        <span class=\"comment\">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>mParent 代表的是 ActivityGroup，是 Activity 很早的版本里才有的东西，在 api13 中已经被废弃。<code>mParent == null</code> 一定为 true</p>\n<p>然后的调用过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; Activit.startActivity(...)</span><br><span class=\"line\"> -&gt; Instrumentation.execStartActivity(...)</span><br><span class=\"line\">  -&gt; ActivityManagerService.startActivity(...)</span><br><span class=\"line\">   -&gt; ...startActivityAsUser(...)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"startActivityAsUser\"><a href=\"#startActivityAsUser\" class=\"headerlink\" title=\"startActivityAsUser\"></a>startActivityAsUser</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class=\"keyword\">int</span> userId,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class=\"line\">            Binder.getCallingPid(), Binder.getCallingUid(), <span class=\"string\">\"startActivityAsUser\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStartController.obtainStarter(intent, <span class=\"string\">\"startActivityAsUser\"</span>)</span><br><span class=\"line\">            .setCaller(caller)</span><br><span class=\"line\">            .setCallingPackage(callingPackage)</span><br><span class=\"line\">            .setResolvedType(resolvedType)</span><br><span class=\"line\">            .setResultTo(resultTo)</span><br><span class=\"line\">            .setResultWho(resultWho)</span><br><span class=\"line\">            .setRequestCode(requestCode)</span><br><span class=\"line\">            .setStartFlags(startFlags)</span><br><span class=\"line\">            .setProfilerInfo(profilerInfo)</span><br><span class=\"line\">            .setActivityOptions(bOptions)</span><br><span class=\"line\">            .setMayWait(userId)</span><br><span class=\"line\">            .execute();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mActivityStartController.obtainStarter</code> 会创建一个 ActivityStarter </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ActivityStarter <span class=\"title\">setMayWait</span><span class=\"params\">(<span class=\"keyword\">int</span> userId)</span> </span>&#123;</span><br><span class=\"line\">    mRequest.mayWait = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mRequest.userId = userId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRequest.mayWait) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class=\"line\">                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class=\"line\">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class=\"line\">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class=\"line\">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class=\"line\">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class=\"line\">                    mRequest.inTask, mRequest.reason,</span><br><span class=\"line\">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class=\"line\">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class=\"line\">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class=\"line\">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class=\"line\">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class=\"line\">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class=\"line\">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class=\"line\">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class=\"line\">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        onExecutionComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>execute()</code> 中 <code>mRequest.mayWait</code> 为 true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">(IApplicationThread caller, <span class=\"keyword\">int</span> callingUid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> startFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProfilerInfo profilerInfo, WaitResult outResult,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Configuration globalConfig, SafeActivityOptions options, <span class=\"keyword\">boolean</span> ignoreTargetSecurity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> userId, TaskRecord inTask, String reason,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class=\"line\">                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class=\"line\">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class=\"line\">                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class=\"line\">                allowPendingRemoteAnimationRegistryLookup);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">(<span class=\"keyword\">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> startFlags, <span class=\"keyword\">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class=\"line\">                startFlags, doResume, options, inTask, outActivity);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>startActivityUnchecked</code> 是一个很重要的方法，这个方法里会根据启动标志位和Activity启动模式来决定如何启动一个Activity以及是否要调用deliverNewIntent方法通知Activity有一个Intent试图重新启动它。<br>因为这里只讨论住 activity 启动的主流程，所以先不看这个。</p>\n<p><code>startActivityUnchecked</code> 之后的调用过程如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; ActivityStarter.startActivityUnchecked(...)</span><br><span class=\"line\"> -&gt; ActivityStackSupervisor.resumeFocusedStackTopActivityLocked(...)</span><br><span class=\"line\">  -&gt; ActivityStack.resumeTopActivityUncheckedLocked(...)</span><br><span class=\"line\">   -&gt; ...resumeTopActivityInnerLocked(...)</span><br></pre></td></tr></table></figure>\n<p>在 <code>resumeTopActivityInnerLocked</code> 中会先对 resume 状态的 activity 执行 pause。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        pausing |= startPausingLocked(userLeaving, <span class=\"keyword\">false</span>, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 开始进行真正最终真正的activity启动</span></span><br><span class=\"line\">    mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        next.completeResumeLocked();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"activity-的-pause-过程\"><a href=\"#activity-的-pause-过程\" class=\"headerlink\" title=\"activity 的 pause 过程\"></a>activity 的 pause 过程</h2><p><code>startPausingLocked</code> 之后会执行 startPausingLocked</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startPausingLocked</span><span class=\"params\">(<span class=\"keyword\">boolean</span> userLeaving, <span class=\"keyword\">boolean</span> uiSleeping,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ActivityRecord resuming, <span class=\"keyword\">boolean</span> pauseImmediately)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev.app != <span class=\"keyword\">null</span> &amp;&amp; prev.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev),</span><br><span class=\"line\">                    prev.shortComponentName, <span class=\"string\">\"userLeaving=\"</span> + userLeaving);</span><br><span class=\"line\">            mService.updateUsageStats(prev, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"comment\">// Android 9.0在这里引入了ClientLifecycleManager和</span></span><br><span class=\"line\">            <span class=\"comment\">// ClientTransactionHandler来辅助管理Activity生命周期，</span></span><br><span class=\"line\">            <span class=\"comment\">// 他会发送EXECUTE_TRANSACTION消息到ActivityThread.H里面继续处理。</span></span><br><span class=\"line\">            mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,</span><br><span class=\"line\">                    PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class=\"line\">                            prev.configChangeFlags, pauseImmediately));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mPausingActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        mLastPausedActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        mLastNoHistoryActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(@NonNull IApplicationThread client, @NonNull IBinder activityToken,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull ActivityLifecycleItem stateRequest)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ClientTransaction clientTransaction = transactionWithState(client, activityToken,</span><br><span class=\"line\">            stateRequest);</span><br><span class=\"line\">    scheduleTransaction(clientTransaction);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ClientTransaction <span class=\"title\">transactionWithState</span><span class=\"params\">(@NonNull IApplicationThread client,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull IBinder activityToken, @NonNull ActivityLifecycleItem stateRequest)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(client, activityToken);</span><br><span class=\"line\">    clientTransaction.setLifecycleStateRequest(stateRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clientTransaction;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> IApplicationThread client = transaction.getClient();</span><br><span class=\"line\">    transaction.schedule();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(client <span class=\"keyword\">instanceof</span> Binder)) &#123;</span><br><span class=\"line\">        transaction.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Android 9.0在这里引入了<code>ClientLifecycleManager</code>和 <code>ClientTransactionHandler</code>来辅助管理Activity生命周期，</p>\n<p><code>startPausingLocked</code>生成了一个 <code>PauseActivityItem</code> 然后，<code>ClientLifecycleManager</code> 会将参数打包为一个 <code>ClientTransaction</code> 并设置一个改变生命周期的request。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ClientTransaction</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        mClient.scheduleTransaction(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>schedule()</code> 将工作转给了 mClient ，mClient 是 transactionWithState 中传入的，是一个 IApplicationThread， IApplicationThread 是 ActivityThread 的内部类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IAppliction</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    ActivityThread.<span class=\"keyword\">this</span>.scheduleTransaction(transaction);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">    transaction.preExecute(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> what, Object obj, <span class=\"keyword\">int</span> arg1, <span class=\"keyword\">int</span> arg2, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">        Message msg = Message.obtain();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (async) &#123;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mH.sendMessage(msg);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"H-extends-Handler\"><a href=\"#H-extends-Handler\" class=\"headerlink\" title=\"H extends Handler\"></a>H extends Handler</h3><p>在上面可以看出，最终，向 mH 发送了一个 message</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EXECUTE_TRANSACTION:</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class=\"line\">            mTransactionExecutor.execute(transaction);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>msg.what 是 <code>ActivityThread.H.EXECUTE_TRANSACTION</code> 。将activity生命周期的变换任务交给了 TransactionExecutor</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> IBinder token = transaction.getActivityToken();</span><br><span class=\"line\">    log(<span class=\"string\">\"Start resolving transaction for client: \"</span> + mTransactionHandler + <span class=\"string\">\", token: \"</span> + token);</span><br><span class=\"line\"></span><br><span class=\"line\">    executeCallbacks(transaction);</span><br><span class=\"line\"></span><br><span class=\"line\">    executeLifecycleState(transaction);</span><br><span class=\"line\">    mPendingActions.clear();</span><br><span class=\"line\">    log(<span class=\"string\">\"End resolving transaction\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Cycle to the state right before the final requested state.</span></span><br><span class=\"line\">    cycleToPath(r, lifecycleItem.getTargetState(), <span class=\"keyword\">true</span> <span class=\"comment\">/* excludeLastState */</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Execute the final transition with proper parameters.</span></span><br><span class=\"line\">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 TransactionExecutor 中从 ClientTransaction 获取 ActivityLifecycleItem ， 并执行 execute 和 postExecute 。 由于我们传入的是 PauseActivityItem ， 所以真正执行的代码还是在 PauseActivityItem 里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">    client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,</span><br><span class=\"line\">            <span class=\"string\">\"PAUSE_ACTIVITY_ITEM\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postExecute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDontReport) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO(lifecycler): Use interface callback instead of AMS.</span></span><br><span class=\"line\">        ActivityManager.getService().activityPaused(token);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PauseActivityItem.execute 中调用的是 ClientTransactionHandler.</span></span><br><span class=\"line\"><span class=\"comment\">// handlePauseActivity ，但是， ActivityThread 继承了 ClientTransactionHandler。 其实调用的还是 ActivityThread 。。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handlePauseActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finished, <span class=\"keyword\">boolean</span> userLeaving,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;</span><br><span class=\"line\">        ActivityClientRecord r = mActivities.get(token);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (userLeaving) &#123;</span><br><span class=\"line\">                performUserLeavingActivity(r);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            r.activity.mConfigChangeFlags |= configChanges;</span><br><span class=\"line\">            performPauseActivity(r, finished, reason, pendingActions);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Make sure any pending writes are now committed.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class=\"line\">                QueuedWork.waitToFinish();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mSomeActivitiesChanged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performPauseActivityIfNeeded</span><span class=\"params\">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            r.activity.mCalled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            mInstrumentation.callActivityOnPause(r.activity);</span><br><span class=\"line\">        &#125; ...</span><br><span class=\"line\">        r.setState(ON_PAUSE);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Instrumentation</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnPause</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        activity.performPause();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建-App-进程\"><a href=\"#创建-App-进程\" class=\"headerlink\" title=\"创建 App 进程\"></a>创建 App 进程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityStackSupervisor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">(ActivityRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Is this activity's application already running?</span></span><br><span class=\"line\">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>startSpecificActivityLocked 中会判断要跳转的 activity 所在的进程是否已经存在，如果存在，则调用 realStartActivityLocked ，如果没有存在，则调用 mService.startProcessLocked 创建进程。 </p>\n<p>先看看应用进程不存在的情况。之后的调用栈如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; ActivityManagerService.startProcessLocked</span><br><span class=\"line\"> -&gt; ...startProcessLocked</span><br><span class=\"line\">  -&gt; ...startProcess</span><br><span class=\"line\">   -&gt; Process.start</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; Process.start</span><br><span class=\"line\"> -&gt; zygoteProcess.start</span><br><span class=\"line\">  -&gt; ...startViaZygote</span><br><span class=\"line\">   -&gt; ...zygoteSendArgsAndGetResult</span><br><span class=\"line\">    -&gt; ...openZygoteSocketIfNeeded</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ZygoteState <span class=\"title\">openZygoteSocketIfNeeded</span><span class=\"params\">(String abi)</span> <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    Preconditions.checkState(Thread.holdsLock(mLock), <span class=\"string\">\"ZygoteProcess lock not held\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (primaryZygoteState == <span class=\"keyword\">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Error connecting to primary zygote\"</span>, ioe);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maybeSetApiBlacklistExemptions(primaryZygoteState, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> primaryZygoteState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// The primary zygote didn't match. Try the secondary.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secondaryZygoteState == <span class=\"keyword\">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            secondaryZygoteState = ZygoteState.connect(mSecondarySocket);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Error connecting to secondary zygote\"</span>, ioe);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maybeSetApiBlacklistExemptions(secondaryZygoteState, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> secondaryZygoteState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Unsupported zygote ABI: \"</span> + abi);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>。。。这里没太看懂，但是网上的文章说 “其最终调用了Zygote并通过socket通信的方式让Zygote进程fork出一个新的进程，并根据传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法对其进行初始化。“</p>\n<p>。。。不知道他是怎么看出来的。。记个 TODO 吧</p>\n<h2 id=\"启动-activity\"><a href=\"#启动-activity\" class=\"headerlink\" title=\"启动 activity\"></a>启动 activity</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityStackSupervisor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"comment\">// Create activity launch transaction.</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class=\"line\">                        r.appToken);</span><br><span class=\"line\">                clientTransaction.addCallback(LaunchActivityItem.obtain(<span class=\"keyword\">new</span> Intent(r.intent),</span><br><span class=\"line\">                        System.identityHashCode(r), r.info,</span><br><span class=\"line\">                        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class=\"line\">                        <span class=\"comment\">// and override configs.</span></span><br><span class=\"line\">                        mergedConfiguration.getGlobalConfiguration(),</span><br><span class=\"line\">                        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class=\"line\">                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class=\"line\">                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class=\"line\">                        profilerInfo));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Set desired final state.</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (andResume) &#123;</span><br><span class=\"line\">                    lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    lifecycleItem = PauseActivityItem.obtain();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Schedule transaction.</span></span><br><span class=\"line\">                mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class=\"line\">                ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里核心是创建了一个 ClientTransaction ，先添加了一个 LaunchActivityItem 作为 callback ， ClientTransaction 在调度是会先执行 callback 。然后设置 LifecycleStateRequest ，这里传入的 andResume == true ，所以设置的是 ResumeActivityItem 。</p>\n<p>因为在之前 ClientTransaction 的调度流程已经分析过了，我们直接先来看 LaunchActivityItem.execute</p>\n<h3 id=\"activity-的-onCreate\"><a href=\"#activity-的-onCreate\" class=\"headerlink\" title=\"activity 的 onCreate\"></a>activity 的 onCreate</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LaunchActivityItem</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        ActivityClientRecord r = <span class=\"keyword\">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class=\"line\">                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class=\"line\">                mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class=\"line\">                mProfilerInfo, client);</span><br><span class=\"line\">        client.handleLaunchActivity(r, pendingActions, <span class=\"keyword\">null</span> <span class=\"comment\">/* customIntent */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">handleLaunchActivity</span><span class=\"params\">(ActivityClientRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化ComponentName</span></span><br><span class=\"line\">        ComponentName component = r.intent.getComponent();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (component == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            component = r.intent.resolveActivity(</span><br><span class=\"line\">                mInitialApplication.getPackageManager());</span><br><span class=\"line\">            r.intent.setComponent(component);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.activityInfo.targetActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            component = <span class=\"keyword\">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class=\"line\">                    r.activityInfo.targetActivity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化ContextImpl和Activity</span></span><br><span class=\"line\">        ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">        Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建 activity</span></span><br><span class=\"line\">            java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">            activity = mInstrumentation.newActivity(</span><br><span class=\"line\">                    cl, component.getClassName(), r.intent);</span><br><span class=\"line\">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class=\"line\">            r.intent.setExtrasClassLoader(cl);</span><br><span class=\"line\">            r.intent.prepareToEnterProcess();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                r.state.setClassLoader(cl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始化Application</span></span><br><span class=\"line\">            Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class=\"line\">                Configuration config = <span class=\"keyword\">new</span> Configuration(mCompatConfiguration);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.overrideConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    config.updateFrom(r.overrideConfig);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 添加window</span></span><br><span class=\"line\">                Window window = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.mPendingRemoveWindow != <span class=\"keyword\">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class=\"line\">                    window = r.mPendingRemoveWindow;</span><br><span class=\"line\">                    r.mPendingRemoveWindow = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    r.mPendingRemoveWindowManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// Application、Activity和ContextImpl互相关联</span></span><br><span class=\"line\">                appContext.setOuterContext(activity);</span><br><span class=\"line\">                activity.attach(appContext, <span class=\"keyword\">this</span>, getInstrumentation(), r.token,</span><br><span class=\"line\">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class=\"line\">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class=\"line\">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (customIntent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    activity.mIntent = customIntent;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                r.lastNonConfigurationInstances = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                checkAndBlockForNetworkAccess();</span><br><span class=\"line\">                activity.mStartedActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 设置Activity的Theme</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    activity.setTheme(theme);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                activity.mCalled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!activity.mCalled) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SuperNotCalledException(</span><br><span class=\"line\">                        <span class=\"string\">\"Activity \"</span> + r.intent.getComponent().toShortString() +</span><br><span class=\"line\">                        <span class=\"string\">\" did not call through to super.onCreate()\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                r.activity = activity;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r.setState(ON_CREATE);</span><br><span class=\"line\"></span><br><span class=\"line\">            mActivities.put(r.token, r);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SuperNotCalledException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Instrumentation</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">newActivity</span><span class=\"params\">(ClassLoader cl, String className,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Intent intent)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class=\"line\"><span class=\"function\">            ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        String pkg = intent != <span class=\"keyword\">null</span> &amp;&amp; intent.getComponent() != <span class=\"keyword\">null</span></span><br><span class=\"line\">                ? intent.getComponent().getPackageName() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// instantiateActivity 利用传入的 ClassLoader ，利用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 performLaunchActivity 中创建了 activity ，并将 context 和 application 与之绑定，执行 <code>activity.attach</code> 。 并添加 window ，设置主题</p>\n<p>接下来，performLaunchActivity 里通过调用 mInstrumentation.callActivityOnCreate ，开始进行 onCreate 的流程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Instrumentation</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class=\"line\">        prePerformCreate(activity);</span><br><span class=\"line\">        activity.performCreate(icicle);</span><br><span class=\"line\">        postPerformCreate(activity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"activity-的-onResume\"><a href=\"#activity-的-onResume\" class=\"headerlink\" title=\"activity 的 onResume\"></a>activity 的 onResume</h3><p>前面我们走完了 activity 的 onCreate 过程，执行代码是在 LaunchActivityItem 中，然后 onResume 显然是在 ResumeActivityItem 里， 那 onOnStart 呢？？</p>\n<p>再回到 ClientTransaction 的调度流程中来， 在 TransactionExecutor 里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TransactionExecutor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IBinder token = transaction.getActivityToken();</span><br><span class=\"line\"></span><br><span class=\"line\">        executeCallbacks(transaction);</span><br><span class=\"line\"></span><br><span class=\"line\">        executeLifecycleState(transaction);</span><br><span class=\"line\">        mPendingActions.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lifecycleItem == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No lifecycle request, return early.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> IBinder token = transaction.getActivityToken();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Ignore requests for non-existent client records for now.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Cycle to the state right before the final requested state.</span></span><br><span class=\"line\">        cycleToPath(r, lifecycleItem.getTargetState(), <span class=\"keyword\">true</span> <span class=\"comment\">/* excludeLastState */</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Execute the final transition with proper parameters.</span></span><br><span class=\"line\">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cycleToPath</span><span class=\"params\">(ActivityClientRecord r, <span class=\"keyword\">int</span> finish,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> start = r.getLifecycleState();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class=\"line\">        performLifecycleSequence(r, path);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Transition the client through previously initialized state sequence. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLifecycleSequence</span><span class=\"params\">(ActivityClientRecord r, IntArray path)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = path.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, state; i &lt; size; i++) &#123;</span><br><span class=\"line\">            state = path.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ON_START:</span><br><span class=\"line\">                    mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 TransactionExecutor 中先执行 callback ，然后 lifecycleItem.execute 。中间有一个 cycleToPath 方法。 cycleToPath 内部逻辑很明显，执行 start 和 finish 中间状态的逻辑。 对于 ResumeActivityItem 来说就会执行 onStart 的逻辑。。。 我佛了。</p>\n<p>activity 之后的 start 过程和 create 过程基本一致。现在再来看看 onResume</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ResumeActivityItem</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        client.handleResumeActivity(token, <span class=\"keyword\">true</span> <span class=\"comment\">/* finalStateRequest */</span>, mIsForward, <span class=\"string\">\"RESUME_ACTIVITY\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class=\"line\">            a.mDecor = decor;</span><br><span class=\"line\">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class=\"line\">            l.softInputMode |= forwardBit;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.mPreserveWindow) &#123;</span><br><span class=\"line\">                a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                r.mPreserveWindow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (impl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    impl.notifyChildRebuilt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                    a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    a.onWindowAttributesChanged(l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!willBeVisible) &#123;</span><br><span class=\"line\">            r.hideForNow = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> Idler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            r.activity.onStateNotSaved();</span><br><span class=\"line\">            r.activity.mFragments.noteStateNotSaved();</span><br><span class=\"line\">            checkAndBlockForNetworkAccess();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingIntents != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                deliverNewIntents(r, r.pendingIntents);</span><br><span class=\"line\">                r.pendingIntents = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingResults != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                deliverResults(r, r.pendingResults, reason);</span><br><span class=\"line\">                r.pendingResults = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r.activity.performResume(r.startsNotResumed, reason);</span><br><span class=\"line\"></span><br><span class=\"line\">            r.state = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.persistentState = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.setState(ON_RESUME);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Unable to resume activity \"</span></span><br><span class=\"line\">                        + r.intent.getComponent().toShortString() + <span class=\"string\">\": \"</span> + e.toString(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>handleResumeActivity 中操作了很多 window 相关的东西。 到这里 activity 的启动就完成了</p>\n<h2 id=\"activity-的-stop\"><a href=\"#activity-的-stop\" class=\"headerlink\" title=\"activity 的 stop\"></a>activity 的 stop</h2><p>之前分析了 onPause 的流程， 但是没有看到 onStop ， 所以 onStop 是如何执行的呢。 在 activity 的生命周期中， activity a 启动 activity b ， b.onStop 应该在 a.onResume 之后执行。</p>\n<p>玄机竟然在 handleResumeActivity 里。。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> Idler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Idler</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageQueue</span>.<span class=\"title\">IdleHandler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.activity != <span class=\"keyword\">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class=\"line\">                        a.createdConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityManagerService</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">activityIdle</span><span class=\"params\">(IBinder token, Configuration config, <span class=\"keyword\">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> origId = Binder.clearCallingIdentity();</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ActivityRecord r =</span><br><span class=\"line\">                        mStackSupervisor.activityIdleInternalLocked(token, <span class=\"keyword\">false</span> <span class=\"comment\">/* fromTimeout */</span>,</span><br><span class=\"line\">                                <span class=\"keyword\">false</span> <span class=\"comment\">/* processPausingActivities */</span>, config);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stopProfiling) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((mProfileProc == r.app) &amp;&amp; mProfilerInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        clearProfilerLocked();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Binder.restoreCallingIdentity(origId);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityStackSupervisor.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> ActivityRecord <span class=\"title\">activityIdleInternalLocked</span><span class=\"params\">(<span class=\"keyword\">final</span> IBinder token, <span class=\"keyword\">boolean</span> fromTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r, <span class=\"keyword\">true</span> <span class=\"comment\">/* remove */</span>, processPausingActivities);</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NS; i++) &#123;</span><br><span class=\"line\">            r = stops.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ActivityStack stack = r.getStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.finishing) &#123;</span><br><span class=\"line\">                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, <span class=\"keyword\">false</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"activityIdleInternalLocked\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    stack.stopActivityLocked(r);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityStack</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">stopActivityLocked</span><span class=\"params\">(ActivityRecord r)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,</span><br><span class=\"line\">                StopActivityItem.obtain(r.visible, r.configChangeFlags));</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>经过一番调用，最终还是一样，向 ClientLifecycleManager 发送了一个 StopActivityItem 。</p>\n<p>到此，activity 的启动流程就结束了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.jianshu.com/p/89fd44083c1c\" target=\"_blank\" rel=\"noopener\">（Android 9.0）Activity启动流程源码分析</a><br><a href=\"https://www.kancloud.cn/digest/androidframeworks/127782\" target=\"_blank\" rel=\"noopener\">Activity启动过程全解析</a><br><a href=\"https://www.jianshu.com/p/15a0df736e52\" target=\"_blank\" rel=\"noopener\">炼狱难度！腾讯Android高级岗：为什么 Activity.finish() 之后 10s 才 onDestroy ？</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"startActivity\"><a href=\"#startActivity\" class=\"headerlink\" title=\"startActivity\"></a>startActivity</h2><p>startActivity有很多重载方法，最终都会调用<code>startActivityForResult</code></p>","more":"\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startActivityForResult</span><span class=\"params\">(@RequiresPermission Intent intent, <span class=\"keyword\">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        options = transferSpringboardActivityOptions(options);</span><br><span class=\"line\">        Instrumentation.ActivityResult ar =</span><br><span class=\"line\">            mInstrumentation.execStartActivity(</span><br><span class=\"line\">                <span class=\"keyword\">this</span>, mMainThread.getApplicationThread(), mToken, <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                intent, requestCode, options);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ar != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            mMainThread.sendActivityResult(</span><br><span class=\"line\">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class=\"line\">                ar.getResultData());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (requestCode &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If this start is requesting a result, we can avoid making</span></span><br><span class=\"line\">            <span class=\"comment\">// the activity visible until the result is received.  Setting</span></span><br><span class=\"line\">            <span class=\"comment\">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class=\"line\">            <span class=\"comment\">// activity hidden during this time, to avoid flickering.</span></span><br><span class=\"line\">            <span class=\"comment\">// This can only be done when a result is requested because</span></span><br><span class=\"line\">            <span class=\"comment\">// that guarantees we will get information back when the</span></span><br><span class=\"line\">            <span class=\"comment\">// activity is finished, no matter what happens to it.</span></span><br><span class=\"line\">            mStartedActivity = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        cancelInputsAndStartExitTransition(options);</span><br><span class=\"line\">        <span class=\"comment\">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>mParent 代表的是 ActivityGroup，是 Activity 很早的版本里才有的东西，在 api13 中已经被废弃。<code>mParent == null</code> 一定为 true</p>\n<p>然后的调用过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; Activit.startActivity(...)</span><br><span class=\"line\"> -&gt; Instrumentation.execStartActivity(...)</span><br><span class=\"line\">  -&gt; ActivityManagerService.startActivity(...)</span><br><span class=\"line\">   -&gt; ...startActivityAsUser(...)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"startActivityAsUser\"><a href=\"#startActivityAsUser\" class=\"headerlink\" title=\"startActivityAsUser\"></a>startActivityAsUser</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityAsUser</span><span class=\"params\">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class=\"keyword\">int</span> userId,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class=\"line\">    enforceNotIsolatedCaller(<span class=\"string\">\"startActivity\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class=\"line\">            Binder.getCallingPid(), Binder.getCallingUid(), <span class=\"string\">\"startActivityAsUser\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Switch to user app stacks here.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mActivityStartController.obtainStarter(intent, <span class=\"string\">\"startActivityAsUser\"</span>)</span><br><span class=\"line\">            .setCaller(caller)</span><br><span class=\"line\">            .setCallingPackage(callingPackage)</span><br><span class=\"line\">            .setResolvedType(resolvedType)</span><br><span class=\"line\">            .setResultTo(resultTo)</span><br><span class=\"line\">            .setResultWho(resultWho)</span><br><span class=\"line\">            .setRequestCode(requestCode)</span><br><span class=\"line\">            .setStartFlags(startFlags)</span><br><span class=\"line\">            .setProfilerInfo(profilerInfo)</span><br><span class=\"line\">            .setActivityOptions(bOptions)</span><br><span class=\"line\">            .setMayWait(userId)</span><br><span class=\"line\">            .execute();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mActivityStartController.obtainStarter</code> 会创建一个 ActivityStarter </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ActivityStarter <span class=\"title\">setMayWait</span><span class=\"params\">(<span class=\"keyword\">int</span> userId)</span> </span>&#123;</span><br><span class=\"line\">    mRequest.mayWait = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    mRequest.userId = userId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mRequest.mayWait) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class=\"line\">                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class=\"line\">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class=\"line\">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class=\"line\">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class=\"line\">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class=\"line\">                    mRequest.inTask, mRequest.reason,</span><br><span class=\"line\">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class=\"line\">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class=\"line\">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class=\"line\">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class=\"line\">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class=\"line\">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class=\"line\">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class=\"line\">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class=\"line\">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        onExecutionComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>execute()</code> 中 <code>mRequest.mayWait</code> 为 true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivityMayWait</span><span class=\"params\">(IApplicationThread caller, <span class=\"keyword\">int</span> callingUid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IBinder resultTo, String resultWho, <span class=\"keyword\">int</span> requestCode, <span class=\"keyword\">int</span> startFlags,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProfilerInfo profilerInfo, WaitResult outResult,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Configuration globalConfig, SafeActivityOptions options, <span class=\"keyword\">boolean</span> ignoreTargetSecurity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> userId, TaskRecord inTask, String reason,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class=\"line\">                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class=\"line\">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class=\"line\">                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class=\"line\">                allowPendingRemoteAnimationRegistryLookup);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">startActivity</span><span class=\"params\">(<span class=\"keyword\">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> startFlags, <span class=\"keyword\">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class=\"line\">                startFlags, doResume, options, inTask, outActivity);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>startActivityUnchecked</code> 是一个很重要的方法，这个方法里会根据启动标志位和Activity启动模式来决定如何启动一个Activity以及是否要调用deliverNewIntent方法通知Activity有一个Intent试图重新启动它。<br>因为这里只讨论住 activity 启动的主流程，所以先不看这个。</p>\n<p><code>startActivityUnchecked</code> 之后的调用过程如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; ActivityStarter.startActivityUnchecked(...)</span><br><span class=\"line\"> -&gt; ActivityStackSupervisor.resumeFocusedStackTopActivityLocked(...)</span><br><span class=\"line\">  -&gt; ActivityStack.resumeTopActivityUncheckedLocked(...)</span><br><span class=\"line\">   -&gt; ...resumeTopActivityInnerLocked(...)</span><br></pre></td></tr></table></figure>\n<p>在 <code>resumeTopActivityInnerLocked</code> 中会先对 resume 状态的 activity 执行 pause。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resumeTopActivityInnerLocked</span><span class=\"params\">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mResumedActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        pausing |= startPausingLocked(userLeaving, <span class=\"keyword\">false</span>, next, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 开始进行真正最终真正的activity启动</span></span><br><span class=\"line\">    mStackSupervisor.startSpecificActivityLocked(next, <span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        next.completeResumeLocked();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"activity-的-pause-过程\"><a href=\"#activity-的-pause-过程\" class=\"headerlink\" title=\"activity 的 pause 过程\"></a>activity 的 pause 过程</h2><p><code>startPausingLocked</code> 之后会执行 startPausingLocked</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startPausingLocked</span><span class=\"params\">(<span class=\"keyword\">boolean</span> userLeaving, <span class=\"keyword\">boolean</span> uiSleeping,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ActivityRecord resuming, <span class=\"keyword\">boolean</span> pauseImmediately)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prev.app != <span class=\"keyword\">null</span> &amp;&amp; prev.app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev),</span><br><span class=\"line\">                    prev.shortComponentName, <span class=\"string\">\"userLeaving=\"</span> + userLeaving);</span><br><span class=\"line\">            mService.updateUsageStats(prev, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            <span class=\"comment\">// Android 9.0在这里引入了ClientLifecycleManager和</span></span><br><span class=\"line\">            <span class=\"comment\">// ClientTransactionHandler来辅助管理Activity生命周期，</span></span><br><span class=\"line\">            <span class=\"comment\">// 他会发送EXECUTE_TRANSACTION消息到ActivityThread.H里面继续处理。</span></span><br><span class=\"line\">            mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,</span><br><span class=\"line\">                    PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class=\"line\">                            prev.configChangeFlags, pauseImmediately));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        mPausingActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        mLastPausedActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        mLastNoHistoryActivity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(@NonNull IApplicationThread client, @NonNull IBinder activityToken,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull ActivityLifecycleItem stateRequest)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ClientTransaction clientTransaction = transactionWithState(client, activityToken,</span><br><span class=\"line\">            stateRequest);</span><br><span class=\"line\">    scheduleTransaction(clientTransaction);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ClientTransaction <span class=\"title\">transactionWithState</span><span class=\"params\">(@NonNull IApplicationThread client,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @NonNull IBinder activityToken, @NonNull ActivityLifecycleItem stateRequest)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(client, activityToken);</span><br><span class=\"line\">    clientTransaction.setLifecycleStateRequest(stateRequest);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clientTransaction;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> IApplicationThread client = transaction.getClient();</span><br><span class=\"line\">    transaction.schedule();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(client <span class=\"keyword\">instanceof</span> Binder)) &#123;</span><br><span class=\"line\">        transaction.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Android 9.0在这里引入了<code>ClientLifecycleManager</code>和 <code>ClientTransactionHandler</code>来辅助管理Activity生命周期，</p>\n<p><code>startPausingLocked</code>生成了一个 <code>PauseActivityItem</code> 然后，<code>ClientLifecycleManager</code> 会将参数打包为一个 <code>ClientTransaction</code> 并设置一个改变生命周期的request。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ClientTransaction</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        mClient.scheduleTransaction(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>schedule()</code> 将工作转给了 mClient ，mClient 是 transactionWithState 中传入的，是一个 IApplicationThread， IApplicationThread 是 ActivityThread 的内部类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IAppliction</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">    ActivityThread.<span class=\"keyword\">this</span>.scheduleTransaction(transaction);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">scheduleTransaction</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">    transaction.preExecute(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">sendMessage</span><span class=\"params\">(<span class=\"keyword\">int</span> what, Object obj, <span class=\"keyword\">int</span> arg1, <span class=\"keyword\">int</span> arg2, <span class=\"keyword\">boolean</span> async)</span> </span>&#123;</span><br><span class=\"line\">        Message msg = Message.obtain();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (async) &#123;</span><br><span class=\"line\">            msg.setAsynchronous(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mH.sendMessage(msg);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"H-extends-Handler\"><a href=\"#H-extends-Handler\" class=\"headerlink\" title=\"H extends Handler\"></a>H extends Handler</h3><p>在上面可以看出，最终，向 mH 发送了一个 message</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (msg.what) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">case</span> EXECUTE_TRANSACTION:</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class=\"line\">            mTransactionExecutor.execute(transaction);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>msg.what 是 <code>ActivityThread.H.EXECUTE_TRANSACTION</code> 。将activity生命周期的变换任务交给了 TransactionExecutor</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> IBinder token = transaction.getActivityToken();</span><br><span class=\"line\">    log(<span class=\"string\">\"Start resolving transaction for client: \"</span> + mTransactionHandler + <span class=\"string\">\", token: \"</span> + token);</span><br><span class=\"line\"></span><br><span class=\"line\">    executeCallbacks(transaction);</span><br><span class=\"line\"></span><br><span class=\"line\">    executeLifecycleState(transaction);</span><br><span class=\"line\">    mPendingActions.clear();</span><br><span class=\"line\">    log(<span class=\"string\">\"End resolving transaction\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// Cycle to the state right before the final requested state.</span></span><br><span class=\"line\">    cycleToPath(r, lifecycleItem.getTargetState(), <span class=\"keyword\">true</span> <span class=\"comment\">/* excludeLastState */</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Execute the final transition with proper parameters.</span></span><br><span class=\"line\">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 TransactionExecutor 中从 ClientTransaction 获取 ActivityLifecycleItem ， 并执行 execute 和 postExecute 。 由于我们传入的是 PauseActivityItem ， 所以真正执行的代码还是在 PauseActivityItem 里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">    client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,</span><br><span class=\"line\">            <span class=\"string\">\"PAUSE_ACTIVITY_ITEM\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postExecute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mDontReport) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO(lifecycler): Use interface callback instead of AMS.</span></span><br><span class=\"line\">        ActivityManager.getService().activityPaused(token);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PauseActivityItem.execute 中调用的是 ClientTransactionHandler.</span></span><br><span class=\"line\"><span class=\"comment\">// handlePauseActivity ，但是， ActivityThread 继承了 ClientTransactionHandler。 其实调用的还是 ActivityThread 。。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handlePauseActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finished, <span class=\"keyword\">boolean</span> userLeaving,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;</span><br><span class=\"line\">        ActivityClientRecord r = mActivities.get(token);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (userLeaving) &#123;</span><br><span class=\"line\">                performUserLeavingActivity(r);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            r.activity.mConfigChangeFlags |= configChanges;</span><br><span class=\"line\">            performPauseActivity(r, finished, reason, pendingActions);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Make sure any pending writes are now committed.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class=\"line\">                QueuedWork.waitToFinish();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mSomeActivitiesChanged = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performPauseActivityIfNeeded</span><span class=\"params\">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            r.activity.mCalled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            mInstrumentation.callActivityOnPause(r.activity);</span><br><span class=\"line\">        &#125; ...</span><br><span class=\"line\">        r.setState(ON_PAUSE);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Instrumentation</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnPause</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">        activity.performPause();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建-App-进程\"><a href=\"#创建-App-进程\" class=\"headerlink\" title=\"创建 App 进程\"></a>创建 App 进程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityStackSupervisor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">(ActivityRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Is this activity's application already running?</span></span><br><span class=\"line\">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>startSpecificActivityLocked 中会判断要跳转的 activity 所在的进程是否已经存在，如果存在，则调用 realStartActivityLocked ，如果没有存在，则调用 mService.startProcessLocked 创建进程。 </p>\n<p>先看看应用进程不存在的情况。之后的调用栈如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; ActivityManagerService.startProcessLocked</span><br><span class=\"line\"> -&gt; ...startProcessLocked</span><br><span class=\"line\">  -&gt; ...startProcess</span><br><span class=\"line\">   -&gt; Process.start</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; Process.start</span><br><span class=\"line\"> -&gt; zygoteProcess.start</span><br><span class=\"line\">  -&gt; ...startViaZygote</span><br><span class=\"line\">   -&gt; ...zygoteSendArgsAndGetResult</span><br><span class=\"line\">    -&gt; ...openZygoteSocketIfNeeded</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> ZygoteState <span class=\"title\">openZygoteSocketIfNeeded</span><span class=\"params\">(String abi)</span> <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">    Preconditions.checkState(Thread.holdsLock(mLock), <span class=\"string\">\"ZygoteProcess lock not held\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (primaryZygoteState == <span class=\"keyword\">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Error connecting to primary zygote\"</span>, ioe);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maybeSetApiBlacklistExemptions(primaryZygoteState, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> primaryZygoteState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// The primary zygote didn't match. Try the secondary.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secondaryZygoteState == <span class=\"keyword\">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            secondaryZygoteState = ZygoteState.connect(mSecondarySocket);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Error connecting to secondary zygote\"</span>, ioe);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        maybeSetApiBlacklistExemptions(secondaryZygoteState, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> secondaryZygoteState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ZygoteStartFailedEx(<span class=\"string\">\"Unsupported zygote ABI: \"</span> + abi);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>。。。这里没太看懂，但是网上的文章说 “其最终调用了Zygote并通过socket通信的方式让Zygote进程fork出一个新的进程，并根据传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法对其进行初始化。“</p>\n<p>。。。不知道他是怎么看出来的。。记个 TODO 吧</p>\n<h2 id=\"启动-activity\"><a href=\"#启动-activity\" class=\"headerlink\" title=\"启动 activity\"></a>启动 activity</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityStackSupervisor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">realStartActivityLocked</span><span class=\"params\">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"comment\">// Create activity launch transaction.</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class=\"line\">                        r.appToken);</span><br><span class=\"line\">                clientTransaction.addCallback(LaunchActivityItem.obtain(<span class=\"keyword\">new</span> Intent(r.intent),</span><br><span class=\"line\">                        System.identityHashCode(r), r.info,</span><br><span class=\"line\">                        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class=\"line\">                        <span class=\"comment\">// and override configs.</span></span><br><span class=\"line\">                        mergedConfiguration.getGlobalConfiguration(),</span><br><span class=\"line\">                        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class=\"line\">                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class=\"line\">                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class=\"line\">                        profilerInfo));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Set desired final state.</span></span><br><span class=\"line\">                <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (andResume) &#123;</span><br><span class=\"line\">                    lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    lifecycleItem = PauseActivityItem.obtain();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Schedule transaction.</span></span><br><span class=\"line\">                mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class=\"line\">                ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里核心是创建了一个 ClientTransaction ，先添加了一个 LaunchActivityItem 作为 callback ， ClientTransaction 在调度是会先执行 callback 。然后设置 LifecycleStateRequest ，这里传入的 andResume == true ，所以设置的是 ResumeActivityItem 。</p>\n<p>因为在之前 ClientTransaction 的调度流程已经分析过了，我们直接先来看 LaunchActivityItem.execute</p>\n<h3 id=\"activity-的-onCreate\"><a href=\"#activity-的-onCreate\" class=\"headerlink\" title=\"activity 的 onCreate\"></a>activity 的 onCreate</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LaunchActivityItem</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        ActivityClientRecord r = <span class=\"keyword\">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class=\"line\">                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class=\"line\">                mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class=\"line\">                mProfilerInfo, client);</span><br><span class=\"line\">        client.handleLaunchActivity(r, pendingActions, <span class=\"keyword\">null</span> <span class=\"comment\">/* customIntent */</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">handleLaunchActivity</span><span class=\"params\">(ActivityClientRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Activity <span class=\"title\">performLaunchActivity</span><span class=\"params\">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化ComponentName</span></span><br><span class=\"line\">        ComponentName component = r.intent.getComponent();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (component == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            component = r.intent.resolveActivity(</span><br><span class=\"line\">                mInitialApplication.getPackageManager());</span><br><span class=\"line\">            r.intent.setComponent(component);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.activityInfo.targetActivity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            component = <span class=\"keyword\">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class=\"line\">                    r.activityInfo.targetActivity);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化ContextImpl和Activity</span></span><br><span class=\"line\">        ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class=\"line\">        Activity activity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建 activity</span></span><br><span class=\"line\">            java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class=\"line\">            activity = mInstrumentation.newActivity(</span><br><span class=\"line\">                    cl, component.getClassName(), r.intent);</span><br><span class=\"line\">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class=\"line\">            r.intent.setExtrasClassLoader(cl);</span><br><span class=\"line\">            r.intent.prepareToEnterProcess();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.state != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                r.state.setClassLoader(cl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 初始化Application</span></span><br><span class=\"line\">            Application app = r.packageInfo.makeApplication(<span class=\"keyword\">false</span>, mInstrumentation);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (activity != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class=\"line\">                Configuration config = <span class=\"keyword\">new</span> Configuration(mCompatConfiguration);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.overrideConfig != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    config.updateFrom(r.overrideConfig);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 添加window</span></span><br><span class=\"line\">                Window window = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.mPendingRemoveWindow != <span class=\"keyword\">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class=\"line\">                    window = r.mPendingRemoveWindow;</span><br><span class=\"line\">                    r.mPendingRemoveWindow = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    r.mPendingRemoveWindowManager = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// Application、Activity和ContextImpl互相关联</span></span><br><span class=\"line\">                appContext.setOuterContext(activity);</span><br><span class=\"line\">                activity.attach(appContext, <span class=\"keyword\">this</span>, getInstrumentation(), r.token,</span><br><span class=\"line\">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class=\"line\">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class=\"line\">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (customIntent != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    activity.mIntent = customIntent;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                r.lastNonConfigurationInstances = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                checkAndBlockForNetworkAccess();</span><br><span class=\"line\">                activity.mStartedActivity = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 设置Activity的Theme</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (theme != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    activity.setTheme(theme);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                activity.mCalled = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.isPersistable()) &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!activity.mCalled) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SuperNotCalledException(</span><br><span class=\"line\">                        <span class=\"string\">\"Activity \"</span> + r.intent.getComponent().toShortString() +</span><br><span class=\"line\">                        <span class=\"string\">\" did not call through to super.onCreate()\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                r.activity = activity;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r.setState(ON_CREATE);</span><br><span class=\"line\"></span><br><span class=\"line\">            mActivities.put(r.token, r);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SuperNotCalledException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> activity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Instrumentation</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Activity <span class=\"title\">newActivity</span><span class=\"params\">(ClassLoader cl, String className,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Intent intent)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class=\"line\"><span class=\"function\">            ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        String pkg = intent != <span class=\"keyword\">null</span> &amp;&amp; intent.getComponent() != <span class=\"keyword\">null</span></span><br><span class=\"line\">                ? intent.getComponent().getPackageName() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// instantiateActivity 利用传入的 ClassLoader ，利用</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 performLaunchActivity 中创建了 activity ，并将 context 和 application 与之绑定，执行 <code>activity.attach</code> 。 并添加 window ，设置主题</p>\n<p>接下来，performLaunchActivity 里通过调用 mInstrumentation.callActivityOnCreate ，开始进行 onCreate 的流程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Instrumentation</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callActivityOnCreate</span><span class=\"params\">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class=\"line\">        prePerformCreate(activity);</span><br><span class=\"line\">        activity.performCreate(icicle);</span><br><span class=\"line\">        postPerformCreate(activity);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"activity-的-onResume\"><a href=\"#activity-的-onResume\" class=\"headerlink\" title=\"activity 的 onResume\"></a>activity 的 onResume</h3><p>前面我们走完了 activity 的 onCreate 过程，执行代码是在 LaunchActivityItem 中，然后 onResume 显然是在 ResumeActivityItem 里， 那 onOnStart 呢？？</p>\n<p>再回到 ClientTransaction 的调度流程中来， 在 TransactionExecutor 里。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TransactionExecutor</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IBinder token = transaction.getActivityToken();</span><br><span class=\"line\"></span><br><span class=\"line\">        executeCallbacks(transaction);</span><br><span class=\"line\"></span><br><span class=\"line\">        executeLifecycleState(transaction);</span><br><span class=\"line\">        mPendingActions.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">executeLifecycleState</span><span class=\"params\">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lifecycleItem == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// No lifecycle request, return early.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> IBinder token = transaction.getActivityToken();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Ignore requests for non-existent client records for now.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Cycle to the state right before the final requested state.</span></span><br><span class=\"line\">        cycleToPath(r, lifecycleItem.getTargetState(), <span class=\"keyword\">true</span> <span class=\"comment\">/* excludeLastState */</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Execute the final transition with proper parameters.</span></span><br><span class=\"line\">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">cycleToPath</span><span class=\"params\">(ActivityClientRecord r, <span class=\"keyword\">int</span> finish,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> start = r.getLifecycleState();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class=\"line\">        performLifecycleSequence(r, path);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Transition the client through previously initialized state sequence. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">performLifecycleSequence</span><span class=\"params\">(ActivityClientRecord r, IntArray path)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = path.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, state; i &lt; size; i++) &#123;</span><br><span class=\"line\">            state = path.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (state) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ON_START:</span><br><span class=\"line\">                    mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在 TransactionExecutor 中先执行 callback ，然后 lifecycleItem.execute 。中间有一个 cycleToPath 方法。 cycleToPath 内部逻辑很明显，执行 start 和 finish 中间状态的逻辑。 对于 ResumeActivityItem 来说就会执行 onStart 的逻辑。。。 我佛了。</p>\n<p>activity 之后的 start 过程和 create 过程基本一致。现在再来看看 onResume</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ResumeActivityItem</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class=\"line\">        client.handleResumeActivity(token, <span class=\"keyword\">true</span> <span class=\"comment\">/* finalStateRequest */</span>, mIsForward, <span class=\"string\">\"RESUME_ACTIVITY\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Activity a = r.activity;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (r.window == <span class=\"keyword\">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class=\"line\">            r.window = r.activity.getWindow();</span><br><span class=\"line\">            View decor = r.window.getDecorView();</span><br><span class=\"line\">            decor.setVisibility(View.INVISIBLE);</span><br><span class=\"line\">            ViewManager wm = a.getWindowManager();</span><br><span class=\"line\">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class=\"line\">            a.mDecor = decor;</span><br><span class=\"line\">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class=\"line\">            l.softInputMode |= forwardBit;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.mPreserveWindow) &#123;</span><br><span class=\"line\">                a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                r.mPreserveWindow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (impl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    impl.notifyChildRebuilt();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.mVisibleFromClient) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!a.mWindowAdded) &#123;</span><br><span class=\"line\">                    a.mWindowAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    wm.addView(decor, l);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    a.onWindowAttributesChanged(l);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!willBeVisible) &#123;</span><br><span class=\"line\">            r.hideForNow = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> Idler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> ActivityClientRecord <span class=\"title\">performResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            r.activity.onStateNotSaved();</span><br><span class=\"line\">            r.activity.mFragments.noteStateNotSaved();</span><br><span class=\"line\">            checkAndBlockForNetworkAccess();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingIntents != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                deliverNewIntents(r, r.pendingIntents);</span><br><span class=\"line\">                r.pendingIntents = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r.pendingResults != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                deliverResults(r, r.pendingResults, reason);</span><br><span class=\"line\">                r.pendingResults = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            r.activity.performResume(r.startsNotResumed, reason);</span><br><span class=\"line\"></span><br><span class=\"line\">            r.state = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.persistentState = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            r.setState(ON_RESUME);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Unable to resume activity \"</span></span><br><span class=\"line\">                        + r.intent.getComponent().toShortString() + <span class=\"string\">\": \"</span> + e.toString(), e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>handleResumeActivity 中操作了很多 window 相关的东西。 到这里 activity 的启动就完成了</p>\n<h2 id=\"activity-的-stop\"><a href=\"#activity-的-stop\" class=\"headerlink\" title=\"activity 的 stop\"></a>activity 的 stop</h2><p>之前分析了 onPause 的流程， 但是没有看到 onStop ， 所以 onStop 是如何执行的呢。 在 activity 的生命周期中， activity a 启动 activity b ， b.onStop 应该在 a.onResume 之后执行。</p>\n<p>玄机竟然在 handleResumeActivity 里。。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityThread</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResumeActivity</span><span class=\"params\">(IBinder token, <span class=\"keyword\">boolean</span> finalStateRequest, <span class=\"keyword\">boolean</span> isForward,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            String reason)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        Looper.myQueue().addIdleHandler(<span class=\"keyword\">new</span> Idler());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Idler</span> <span class=\"keyword\">implements</span> <span class=\"title\">MessageQueue</span>.<span class=\"title\">IdleHandler</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">queueIdle</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a.activity != <span class=\"keyword\">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class=\"line\">                        a.createdConfig = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityManagerService</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">activityIdle</span><span class=\"params\">(IBinder token, Configuration config, <span class=\"keyword\">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> origId = Binder.clearCallingIdentity();</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                ActivityRecord r =</span><br><span class=\"line\">                        mStackSupervisor.activityIdleInternalLocked(token, <span class=\"keyword\">false</span> <span class=\"comment\">/* fromTimeout */</span>,</span><br><span class=\"line\">                                <span class=\"keyword\">false</span> <span class=\"comment\">/* processPausingActivities */</span>, config);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stopProfiling) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ((mProfileProc == r.app) &amp;&amp; mProfilerInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        clearProfilerLocked();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Binder.restoreCallingIdentity(origId);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ActivityStackSupervisor.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> ActivityRecord <span class=\"title\">activityIdleInternalLocked</span><span class=\"params\">(<span class=\"keyword\">final</span> IBinder token, <span class=\"keyword\">boolean</span> fromTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r, <span class=\"keyword\">true</span> <span class=\"comment\">/* remove */</span>, processPausingActivities);</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NS; i++) &#123;</span><br><span class=\"line\">            r = stops.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ActivityStack stack = r.getStack();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (stack != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r.finishing) &#123;</span><br><span class=\"line\">                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, <span class=\"keyword\">false</span>,</span><br><span class=\"line\">                            <span class=\"string\">\"activityIdleInternalLocked\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    stack.stopActivityLocked(r);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ActivityStack</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">stopActivityLocked</span><span class=\"params\">(ActivityRecord r)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,</span><br><span class=\"line\">                StopActivityItem.obtain(r.visible, r.configChangeFlags));</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>经过一番调用，最终还是一样，向 ClientLifecycleManager 发送了一个 StopActivityItem 。</p>\n<p>到此，activity 的启动流程就结束了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.jianshu.com/p/89fd44083c1c\" target=\"_blank\" rel=\"noopener\">（Android 9.0）Activity启动流程源码分析</a><br><a href=\"https://www.kancloud.cn/digest/androidframeworks/127782\" target=\"_blank\" rel=\"noopener\">Activity启动过程全解析</a><br><a href=\"https://www.jianshu.com/p/15a0df736e52\" target=\"_blank\" rel=\"noopener\">炼狱难度！腾讯Android高级岗：为什么 Activity.finish() 之后 10s 才 onDestroy ？</a></p>\n"},{"title":"应用进程是如何启动的","date":"2021-03-06T16:23:23.000Z","_content":"\n\n# zygote的启动\n\n## zygote 的功能\nzygote 进程的主要功能有两个：\n1. 在系统启动时启动 SystemServer 进程\n2. 启动 应用进程\n\n## zygote 进程的启动过程\n\n### zygote进程的创建。\n在 Android 系统开机之后，会创建 init 进程，这是 Linux 系统启动后创建的第一个进程。 init 进程有一个配置文件 init.rc 。 将需要启动的服务写入到 init.rc 中， init 进程在启动后就会创建这些进程， 比如 zygote ， ServiceManager 等。\n\n### zygote 进程的 native 部分。\nzygote 的c层代码入口在 /rameworks/base/cmds/app_process/app_main.cpp 中，最终主要的工作内容在 /frameworks/base/core/jni/AndroidRuntime.cpp 。主要内容如下。不详细分析了\n\n* 启动虚拟机。\n* 注册 JNI 函数\n* 调用 Java 类 Zygote.main 方法，进入 Java 循环 。\n\n### zygote 进程的 Java 部分\nzygote 的 java 入口在 /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 中\n\n```java\n// /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java\n\n    public static void main(String argv[]) {\n        ZygoteServer zygoteServer = new ZygoteServer();\n        ...\n        final Runnable caller;\n        try {\n            \n            RuntimeInit.enableDdms();\n\n            boolean startSystemServer = false;\n            String socketName = \"zygote\";\n            String abiList = null;\n            boolean enableLazyPreload = false;\n            for (int i = 1; i < argv.length; i++) {\n                if (\"start-system-server\".equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (\"--enable-lazy-preload\".equals(argv[i])) {\n                    enableLazyPreload = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n                }\n            }\n\n            // 注册 socket\n            zygoteServer.registerServerSocketFromEnv(socketName);\n\n            // In some configurations, we avoid preloading resources and classes eagerly.\n            // In such cases, we will preload things prior to our first fork.\n            if (!enableLazyPreload) {\n                // 预加载类和资源\n                preload(bootTimingsTraceLog);\n            } else {\n                Zygote.resetNicePriority();\n            }\n            \n            ... \n            if (startSystemServer) {\n                // fork SystemServer 进程\n                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);\n\n                // {@code r == null} in the parent (zygote) process, and {@code r != null} in the\n                // child (system_server) process.\n                if (r != null) {\n                    // 如果 r != null ，说明是子进程 SystemServer ，r.run 应该是进入 SystemServer 的事件循环，然后直接return\n                    r.run();\n                    return;\n                }\n            }\n            \n            // zygote 事件循环，不让zygote退出\n            caller = zygoteServer.runSelectLoop(abiList);\n        } catch (Throwable ex) {\n            throw ex;\n        } finally {\n            zygoteServer.closeServerSocket();\n        }\n\n        // We're in the child process and have exited the select loop. Proceed to execute the\n        // command.\n        if (caller != null) {\n            caller.run();\n        }\n    }\n```\n* 注册 Socket 服务， zygote 进程通过 socket 和 AMS 通信\n* 预加载类和资源。这样在 fork SystemServer 和 应用进程时，能够直接拷贝给子进程使用\n* fork 出 SystemServer 进程， SystemServer 进程随后又会启动 Binder ，并启动这种系统 Service ，比如 AMS ，WMS 等。\n* 进入 loop 循环，等待接收 AMS 的 Socket 消息。 收到消息后会调用 runOnce 方法，fork 出应用进程，并执行应用进程的 ActivityThread.main() \n\n### 小结：\n**注意：zygote fork 进程时一定是单线程的**\n* **zygote 新 fork 出来的进程不需要再创建java虚拟机，因为 fork 出来的子进程是会继承拷贝父进程的资源的， fork 出来的进程会拥有 zygote 进程的虚拟机的拷贝**\n* **为什么要设计一个 zygote 来 fork 应用进程，而不是 SystemServer :**\n  *  因为systemServer中运行了很多系统服务，不能被继承。应用程序启动时，除了必要的资源外，最好是干净的，所以需要单独用一个zygote来fork。\n* **为什么Zygote要使用Socket不使用binder：**\n  * 因为binder机制支持并发有一个线程池，如果zygote支持并发，在fork之后，会把线程池中的线程一起复制一份。 如果zygote的binder线程池处于一个等待锁的状态，fork之后的新进程依然是在等待锁的，并且不能解锁。 从而有可能造成死锁\n\n### zygote 的事件循环\n\n```java\n// /frameworks/base/core/java/com/android/internal/os/ZygoteServer.java\n    Runnable runSelectLoop(String abiList) {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(mServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                //处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n\n                if (i == 0) {\n                    // 这里没看懂。。。\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    try {\n                        // 处理接收到的消息\n                        ZygoteConnection connection = peers.get(i);\n                        final Runnable command = connection.processOneCommand(this);\n                        ...\n                    } ...\n                }\n            }\n        }\n    }\n```\n\n```java\n// /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java\n    Runnable processOneCommand(ZygoteServer zygoteServer) {\n        ...\n        pid = Zygote.forkAndSpecialize(parsedArgs.uid, ...);\n\n        try {\n            if (pid == 0) {\n                // 子进程\n                zygoteServer.setForkChild();\n\n                zygoteServer.closeServerSocket();\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n\n                return handleChildProc(parsedArgs, descriptors, childPipeFd,\n                        parsedArgs.startChildZygote);\n            } else {\n                // 父进程\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                handleParentProc(pid, descriptors, serverPipeFd);\n                return null;\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n    }\n\n    private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors,\n            FileDescriptor pipeFd, boolean isZygote) {\n\n        closeSocket();\n        ...\n            if (!isZygote) {\n                // 应用进程启动流程进入这个分支\n                // 从 socket 传来参数中取出 class ，并执行 main 方法\n                return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,\n                        null /* classLoader */);\n            } else {\n                // 没看懂这个分支是做什么的。。\n                // 看注释的意思是提供了「跳过启动binder，直接创建进程」的方式\n                return ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,\n                        parsedArgs.remainingArgs, null /* classLoader */);\n            }\n    }\n```\n\n# 应用进程的启动\n\n我们以 Activity 的启动为入口，来探讨应用进程的启动过程\n\n## AMS 发起创建进程\n\n### 由 Activity 的启动寻找应用进程创建的入口\n首先来看 Activity 的启动。安卓四大组件都是由AMS来管理的。 应用进程会调用 AMS 的binder 对象，实现在 ActivityManagerService.startActivity 里。\n\n最终顺着调用栈，会走到 ActivityStackSupervisor.startSpecificActivityLocked(...)\n\n```java\n// /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java\n    void startSpecificActivityLocked(ActivityRecord r,\n            boolean andResume, boolean checkConfig) {\n        // Is this activity's application already running?\n        ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n\n        if (app != null && app.thread != null) {\n            try {\n                // 进程已启动，真正开始启动 activity 了，哎，调用链太长了\n                realStartActivityLocked(r, app, andResume, checkConfig);\n                return;\n            } catch (RemoteException e) {\n            }\n        }\n        // 进程没启动，开始启动进程了\n        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n    }\n```\n\n上面的逻辑里，会先判断要启动的 activity 所在应用的进程是否启动，如果已经成功启动，则开始启动 activity ；否则，启动引用进程。\n注意这里应用是否启动的判断条件： `if (app != null && app.thread != null)`\n ProcessRecord 是应用进程在 AMS 的信息记录，除了判断 app 不为空，还对 app.thread 。这个 app.thread 是一个 IApplicationThread binder 对象，这个对象很重要。\n\n### AMS 发送 Socket 给 zygote\n\n```java\n    @GuardedBy(\"this\")\n    private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,\n            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,\n            String seInfo, String requiredAbi, String instructionSet, String invokeWith,\n            long startTime) {\n        ...\n        if (mConstants.FLAG_PROCESS_START_ASYNC) {\n            // 异步启动进程，忽略吧\n            ...\n            return true;\n        } else {\n            try {\n                final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,\n                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,\n                        invokeWith, startTime);\n                handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,\n                        startSeq, false);\n            } catch (RuntimeException e) {\n                ...\n            }\n            return app.pid > 0;\n        }\n    }\n```\n\nAMS.startProcess 会调用 Process.start(...) 方法\n\n```java\n// /frameworks/base/core/java/android/os/Process.java\n    public static final ProcessStartResult start(final String processClass,\n                                  final String niceName,\n                                  int uid, int gid, int[] gids,\n                                  int runtimeFlags, int mountExternal,\n                                  int targetSdkVersion,\n                                  String seInfo,\n                                  String abi,\n                                  String instructionSet,\n                                  String appDataDir,\n                                  String invokeWith,\n                                  String[] zygoteArgs) {\n        return zygoteProcess.start(processClass, niceName, uid, gid, gids,\n                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,\n                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);\n    }\n\n// /frameworks/base/core/java/android/os/ZygoteProcess.java\n    public final Process.ProcessStartResult start(final String processClass,\n                                                  final String niceName,\n                                                  int uid, int gid, int[] gids,\n                                                  int runtimeFlags, int mountExternal,\n                                                  int targetSdkVersion,\n                                                  String seInfo,\n                                                  String abi,\n                                                  String instructionSet,\n                                                  String appDataDir,\n                                                  String invokeWith,\n                                                  String[] zygoteArgs) {\n        try {\n            return startViaZygote(processClass, niceName, uid, gid, gids,\n                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,\n                    abi, instructionSet, appDataDir, invokeWith, false /* startChildZygote */,\n                    zygoteArgs);\n        } catch (ZygoteStartFailedEx ex) {\n            ...\n        }\n    }\n\n    private Process.ProcessStartResult startViaZygote(final String processClass,\n                                                      final String niceName,\n                                                      final int uid, final int gid,\n                                                      final int[] gids,\n                                                      int runtimeFlags, int mountExternal,\n                                                      int targetSdkVersion,\n                                                      String seInfo,\n                                                      String abi,\n                                                      String instructionSet,\n                                                      String appDataDir,\n                                                      String invokeWith,\n                                                      boolean startChildZygote,\n                                                      String[] extraArgs)\n                                                      throws ZygoteStartFailedEx {\n        ArrayList<String> argsForZygote = new ArrayList<String>();\n        ... // 组装 socket 的参数\n        synchronized(mLock) {\n            // openZygoteSocketIfNeeded 会获取一个 ZygoteState ，有必要的话，会创建 socket 连接。 ZygoteState 包含了 socket 输入输出流。\n            // zygote fork 进程成功会返回应用进程的 pid\n            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n        }\n    }\n```\n\nAMS 会发送 socket 消息给 zygote ，zygote 会 fork 应用进程，并执行应用进程的 ActivityThread.main 方法\n\n# 应用进程在启动之后都干了啥？\n\n## thread.attach(...)\n\n```java\n// frameworks/base/core/java/android/app/ActivityThread.java\n    public static void main(String[] args) {\n        Looper.prepareMainLooper();\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false, startSeq);\n\n        Looper.loop();\n    }\n\n    private void attach(boolean system, long startSeq) {\n        sCurrentActivityThread = this;\n        mSystemThread = system;\n        if (!system) {\n            // 走这个分支\n            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n            final IActivityManager mgr = ActivityManager.getService();\n            try {\n                mgr.attachApplication(mAppThread, startSeq);\n            } catch (RemoteException ex) {\n                throw ex.rethrowFromSystemServer();\n            }\n            ...\n        } else {\n            ...\n        }\n        ...\n    }\n```\n\n应用整个进程的入口在 ActivityThread.main() 方法中，这个方法里没啥操作： 1. 准备 Looper 2. 实例化 ActivityThread ，并 attach 3. 开启 Looper 循环\n\n显然， main 方法里做的事情支撑不了一个 app 的启动。 重点看 thread.attach , 它 使用 binder 调用了 AMS.attachApplication ，然后又调用了 AMS.attachApplicationLocked(...)\n\n```java\n// 伪代码。。\n    private final boolean attachApplicationLocked(IApplicationThread thread,\n            int pid, int callingUid, long startSeq) {\n    \n        ProcessRecord app;\n        if (pid != MY_PID && pid >= 0) {\n            synchronized (mPidsSelfLocked) {\n                app = mPidsSelfLocked.get(pid);\n            }\n        } else {\n            app = null;\n        }\n\n        thread.bindApplication(...);\n\n        // 处理一些因为应用进程还没有启动而暂存的组件\n        mStackSupervisor.attachApplicationLocked(app);\n        ...\n        mServices.attachApplicationLocked(app, processName);\n        ...\n        sendPendingBroadcastsLocked(app);\n    }\n```\n\n## thread.bindApplication(...)\n\nAMS 在 attch 进程之后又通过 binder 调用了应用进程的 bindApplication \n\n```java\n        public final void bindApplication(String processName, ApplicationInfo appInfo,\n                List<ProviderInfo> providers, ComponentName instrumentationName,\n                ProfilerInfo profilerInfo, Bundle instrumentationArgs,\n                IInstrumentationWatcher instrumentationWatcher,\n                IUiAutomationConnection instrumentationUiConnection, int debugMode,\n                boolean enableBinderTracking, boolean trackAllocation,\n                boolean isRestrictedBackupMode, boolean persistent, Configuration config,\n                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,\n                String buildSerial, boolean autofillCompatibilityEnabled) {\n\n            ...\n\n            AppBindData data = new AppBindData();\n            ... // 补充 AppBindData 的参数\n\n            // 发送一个 消息到 H handler \n            sendMessage(H.BIND_APPLICATION, data);\n        }\n```\n\n在应用进程，发送了一个 H.BIND_APPLICATION 给 handler ，实现了线程的切换。 注意 **通过 binder对象调用，是运行在 binder 线程里的**，所以这个 bindApplication 也是运行在 binder 线程里的，需要切换回主线程。 \n\n## handleBindApplication\n\n```java\n// 伪代码\nprivate void handleBindApplication(AppBindData data) {\n    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);\n\n    Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n\n    mInstrumentation.callApplicationOnCreate(app);\n}\n```\n\ndata.info 是一个描述应用安装包信息的类。 `data.info.makeApplication` 一个applicaiton 类，并调用生命周期的 onCreate\n\n```java\n// frameworks/base/core/java/android/app/LoadedApk.java\npublic Application makeApplication(boolean forceDefaultAppClass,\n            Instrumentation instrumentation) {\n    // 创建 application 和 context 对象，并绑定\n    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n    app = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n}\n```\n\n这样，应用的启动就完成了\n","source":"_posts/Android/Framework/应用进程是如何启动的.md","raw":"---\ntitle: 应用进程是如何启动的\ndate: 2021-03-07 00:23:23\ntags:\n- Framework\n- Android\n---\n\n\n# zygote的启动\n\n## zygote 的功能\nzygote 进程的主要功能有两个：\n1. 在系统启动时启动 SystemServer 进程\n2. 启动 应用进程\n\n## zygote 进程的启动过程\n\n### zygote进程的创建。\n在 Android 系统开机之后，会创建 init 进程，这是 Linux 系统启动后创建的第一个进程。 init 进程有一个配置文件 init.rc 。 将需要启动的服务写入到 init.rc 中， init 进程在启动后就会创建这些进程， 比如 zygote ， ServiceManager 等。\n\n### zygote 进程的 native 部分。\nzygote 的c层代码入口在 /rameworks/base/cmds/app_process/app_main.cpp 中，最终主要的工作内容在 /frameworks/base/core/jni/AndroidRuntime.cpp 。主要内容如下。不详细分析了\n\n* 启动虚拟机。\n* 注册 JNI 函数\n* 调用 Java 类 Zygote.main 方法，进入 Java 循环 。\n\n### zygote 进程的 Java 部分\nzygote 的 java 入口在 /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 中\n\n```java\n// /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java\n\n    public static void main(String argv[]) {\n        ZygoteServer zygoteServer = new ZygoteServer();\n        ...\n        final Runnable caller;\n        try {\n            \n            RuntimeInit.enableDdms();\n\n            boolean startSystemServer = false;\n            String socketName = \"zygote\";\n            String abiList = null;\n            boolean enableLazyPreload = false;\n            for (int i = 1; i < argv.length; i++) {\n                if (\"start-system-server\".equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (\"--enable-lazy-preload\".equals(argv[i])) {\n                    enableLazyPreload = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n                }\n            }\n\n            // 注册 socket\n            zygoteServer.registerServerSocketFromEnv(socketName);\n\n            // In some configurations, we avoid preloading resources and classes eagerly.\n            // In such cases, we will preload things prior to our first fork.\n            if (!enableLazyPreload) {\n                // 预加载类和资源\n                preload(bootTimingsTraceLog);\n            } else {\n                Zygote.resetNicePriority();\n            }\n            \n            ... \n            if (startSystemServer) {\n                // fork SystemServer 进程\n                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);\n\n                // {@code r == null} in the parent (zygote) process, and {@code r != null} in the\n                // child (system_server) process.\n                if (r != null) {\n                    // 如果 r != null ，说明是子进程 SystemServer ，r.run 应该是进入 SystemServer 的事件循环，然后直接return\n                    r.run();\n                    return;\n                }\n            }\n            \n            // zygote 事件循环，不让zygote退出\n            caller = zygoteServer.runSelectLoop(abiList);\n        } catch (Throwable ex) {\n            throw ex;\n        } finally {\n            zygoteServer.closeServerSocket();\n        }\n\n        // We're in the child process and have exited the select loop. Proceed to execute the\n        // command.\n        if (caller != null) {\n            caller.run();\n        }\n    }\n```\n* 注册 Socket 服务， zygote 进程通过 socket 和 AMS 通信\n* 预加载类和资源。这样在 fork SystemServer 和 应用进程时，能够直接拷贝给子进程使用\n* fork 出 SystemServer 进程， SystemServer 进程随后又会启动 Binder ，并启动这种系统 Service ，比如 AMS ，WMS 等。\n* 进入 loop 循环，等待接收 AMS 的 Socket 消息。 收到消息后会调用 runOnce 方法，fork 出应用进程，并执行应用进程的 ActivityThread.main() \n\n### 小结：\n**注意：zygote fork 进程时一定是单线程的**\n* **zygote 新 fork 出来的进程不需要再创建java虚拟机，因为 fork 出来的子进程是会继承拷贝父进程的资源的， fork 出来的进程会拥有 zygote 进程的虚拟机的拷贝**\n* **为什么要设计一个 zygote 来 fork 应用进程，而不是 SystemServer :**\n  *  因为systemServer中运行了很多系统服务，不能被继承。应用程序启动时，除了必要的资源外，最好是干净的，所以需要单独用一个zygote来fork。\n* **为什么Zygote要使用Socket不使用binder：**\n  * 因为binder机制支持并发有一个线程池，如果zygote支持并发，在fork之后，会把线程池中的线程一起复制一份。 如果zygote的binder线程池处于一个等待锁的状态，fork之后的新进程依然是在等待锁的，并且不能解锁。 从而有可能造成死锁\n\n### zygote 的事件循环\n\n```java\n// /frameworks/base/core/java/com/android/internal/os/ZygoteServer.java\n    Runnable runSelectLoop(String abiList) {\n        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();\n        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();\n\n        fds.add(mServerSocket.getFileDescriptor());\n        peers.add(null);\n\n        while (true) {\n            StructPollfd[] pollFds = new StructPollfd[fds.size()];\n            for (int i = 0; i < pollFds.length; ++i) {\n                pollFds[i] = new StructPollfd();\n                pollFds[i].fd = fds.get(i);\n                pollFds[i].events = (short) POLLIN;\n            }\n            try {\n                //处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里\n                Os.poll(pollFds, -1);\n            } catch (ErrnoException ex) {\n                throw new RuntimeException(\"poll failed\", ex);\n            }\n            for (int i = pollFds.length - 1; i >= 0; --i) {\n                if ((pollFds[i].revents & POLLIN) == 0) {\n                    continue;\n                }\n\n                if (i == 0) {\n                    // 这里没看懂。。。\n                    ZygoteConnection newPeer = acceptCommandPeer(abiList);\n                    peers.add(newPeer);\n                    fds.add(newPeer.getFileDesciptor());\n                } else {\n                    try {\n                        // 处理接收到的消息\n                        ZygoteConnection connection = peers.get(i);\n                        final Runnable command = connection.processOneCommand(this);\n                        ...\n                    } ...\n                }\n            }\n        }\n    }\n```\n\n```java\n// /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java\n    Runnable processOneCommand(ZygoteServer zygoteServer) {\n        ...\n        pid = Zygote.forkAndSpecialize(parsedArgs.uid, ...);\n\n        try {\n            if (pid == 0) {\n                // 子进程\n                zygoteServer.setForkChild();\n\n                zygoteServer.closeServerSocket();\n                IoUtils.closeQuietly(serverPipeFd);\n                serverPipeFd = null;\n\n                return handleChildProc(parsedArgs, descriptors, childPipeFd,\n                        parsedArgs.startChildZygote);\n            } else {\n                // 父进程\n                IoUtils.closeQuietly(childPipeFd);\n                childPipeFd = null;\n                handleParentProc(pid, descriptors, serverPipeFd);\n                return null;\n            }\n        } finally {\n            IoUtils.closeQuietly(childPipeFd);\n            IoUtils.closeQuietly(serverPipeFd);\n        }\n    }\n\n    private Runnable handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors,\n            FileDescriptor pipeFd, boolean isZygote) {\n\n        closeSocket();\n        ...\n            if (!isZygote) {\n                // 应用进程启动流程进入这个分支\n                // 从 socket 传来参数中取出 class ，并执行 main 方法\n                return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,\n                        null /* classLoader */);\n            } else {\n                // 没看懂这个分支是做什么的。。\n                // 看注释的意思是提供了「跳过启动binder，直接创建进程」的方式\n                return ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,\n                        parsedArgs.remainingArgs, null /* classLoader */);\n            }\n    }\n```\n\n# 应用进程的启动\n\n我们以 Activity 的启动为入口，来探讨应用进程的启动过程\n\n## AMS 发起创建进程\n\n### 由 Activity 的启动寻找应用进程创建的入口\n首先来看 Activity 的启动。安卓四大组件都是由AMS来管理的。 应用进程会调用 AMS 的binder 对象，实现在 ActivityManagerService.startActivity 里。\n\n最终顺着调用栈，会走到 ActivityStackSupervisor.startSpecificActivityLocked(...)\n\n```java\n// /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java\n    void startSpecificActivityLocked(ActivityRecord r,\n            boolean andResume, boolean checkConfig) {\n        // Is this activity's application already running?\n        ProcessRecord app = mService.getProcessRecordLocked(r.processName,\n                r.info.applicationInfo.uid, true);\n\n        if (app != null && app.thread != null) {\n            try {\n                // 进程已启动，真正开始启动 activity 了，哎，调用链太长了\n                realStartActivityLocked(r, app, andResume, checkConfig);\n                return;\n            } catch (RemoteException e) {\n            }\n        }\n        // 进程没启动，开始启动进程了\n        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,\n                \"activity\", r.intent.getComponent(), false, false, true);\n    }\n```\n\n上面的逻辑里，会先判断要启动的 activity 所在应用的进程是否启动，如果已经成功启动，则开始启动 activity ；否则，启动引用进程。\n注意这里应用是否启动的判断条件： `if (app != null && app.thread != null)`\n ProcessRecord 是应用进程在 AMS 的信息记录，除了判断 app 不为空，还对 app.thread 。这个 app.thread 是一个 IApplicationThread binder 对象，这个对象很重要。\n\n### AMS 发送 Socket 给 zygote\n\n```java\n    @GuardedBy(\"this\")\n    private boolean startProcessLocked(String hostingType, String hostingNameStr, String entryPoint,\n            ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal,\n            String seInfo, String requiredAbi, String instructionSet, String invokeWith,\n            long startTime) {\n        ...\n        if (mConstants.FLAG_PROCESS_START_ASYNC) {\n            // 异步启动进程，忽略吧\n            ...\n            return true;\n        } else {\n            try {\n                final ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,\n                        uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,\n                        invokeWith, startTime);\n                handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,\n                        startSeq, false);\n            } catch (RuntimeException e) {\n                ...\n            }\n            return app.pid > 0;\n        }\n    }\n```\n\nAMS.startProcess 会调用 Process.start(...) 方法\n\n```java\n// /frameworks/base/core/java/android/os/Process.java\n    public static final ProcessStartResult start(final String processClass,\n                                  final String niceName,\n                                  int uid, int gid, int[] gids,\n                                  int runtimeFlags, int mountExternal,\n                                  int targetSdkVersion,\n                                  String seInfo,\n                                  String abi,\n                                  String instructionSet,\n                                  String appDataDir,\n                                  String invokeWith,\n                                  String[] zygoteArgs) {\n        return zygoteProcess.start(processClass, niceName, uid, gid, gids,\n                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,\n                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);\n    }\n\n// /frameworks/base/core/java/android/os/ZygoteProcess.java\n    public final Process.ProcessStartResult start(final String processClass,\n                                                  final String niceName,\n                                                  int uid, int gid, int[] gids,\n                                                  int runtimeFlags, int mountExternal,\n                                                  int targetSdkVersion,\n                                                  String seInfo,\n                                                  String abi,\n                                                  String instructionSet,\n                                                  String appDataDir,\n                                                  String invokeWith,\n                                                  String[] zygoteArgs) {\n        try {\n            return startViaZygote(processClass, niceName, uid, gid, gids,\n                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,\n                    abi, instructionSet, appDataDir, invokeWith, false /* startChildZygote */,\n                    zygoteArgs);\n        } catch (ZygoteStartFailedEx ex) {\n            ...\n        }\n    }\n\n    private Process.ProcessStartResult startViaZygote(final String processClass,\n                                                      final String niceName,\n                                                      final int uid, final int gid,\n                                                      final int[] gids,\n                                                      int runtimeFlags, int mountExternal,\n                                                      int targetSdkVersion,\n                                                      String seInfo,\n                                                      String abi,\n                                                      String instructionSet,\n                                                      String appDataDir,\n                                                      String invokeWith,\n                                                      boolean startChildZygote,\n                                                      String[] extraArgs)\n                                                      throws ZygoteStartFailedEx {\n        ArrayList<String> argsForZygote = new ArrayList<String>();\n        ... // 组装 socket 的参数\n        synchronized(mLock) {\n            // openZygoteSocketIfNeeded 会获取一个 ZygoteState ，有必要的话，会创建 socket 连接。 ZygoteState 包含了 socket 输入输出流。\n            // zygote fork 进程成功会返回应用进程的 pid\n            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);\n        }\n    }\n```\n\nAMS 会发送 socket 消息给 zygote ，zygote 会 fork 应用进程，并执行应用进程的 ActivityThread.main 方法\n\n# 应用进程在启动之后都干了啥？\n\n## thread.attach(...)\n\n```java\n// frameworks/base/core/java/android/app/ActivityThread.java\n    public static void main(String[] args) {\n        Looper.prepareMainLooper();\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false, startSeq);\n\n        Looper.loop();\n    }\n\n    private void attach(boolean system, long startSeq) {\n        sCurrentActivityThread = this;\n        mSystemThread = system;\n        if (!system) {\n            // 走这个分支\n            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n            final IActivityManager mgr = ActivityManager.getService();\n            try {\n                mgr.attachApplication(mAppThread, startSeq);\n            } catch (RemoteException ex) {\n                throw ex.rethrowFromSystemServer();\n            }\n            ...\n        } else {\n            ...\n        }\n        ...\n    }\n```\n\n应用整个进程的入口在 ActivityThread.main() 方法中，这个方法里没啥操作： 1. 准备 Looper 2. 实例化 ActivityThread ，并 attach 3. 开启 Looper 循环\n\n显然， main 方法里做的事情支撑不了一个 app 的启动。 重点看 thread.attach , 它 使用 binder 调用了 AMS.attachApplication ，然后又调用了 AMS.attachApplicationLocked(...)\n\n```java\n// 伪代码。。\n    private final boolean attachApplicationLocked(IApplicationThread thread,\n            int pid, int callingUid, long startSeq) {\n    \n        ProcessRecord app;\n        if (pid != MY_PID && pid >= 0) {\n            synchronized (mPidsSelfLocked) {\n                app = mPidsSelfLocked.get(pid);\n            }\n        } else {\n            app = null;\n        }\n\n        thread.bindApplication(...);\n\n        // 处理一些因为应用进程还没有启动而暂存的组件\n        mStackSupervisor.attachApplicationLocked(app);\n        ...\n        mServices.attachApplicationLocked(app, processName);\n        ...\n        sendPendingBroadcastsLocked(app);\n    }\n```\n\n## thread.bindApplication(...)\n\nAMS 在 attch 进程之后又通过 binder 调用了应用进程的 bindApplication \n\n```java\n        public final void bindApplication(String processName, ApplicationInfo appInfo,\n                List<ProviderInfo> providers, ComponentName instrumentationName,\n                ProfilerInfo profilerInfo, Bundle instrumentationArgs,\n                IInstrumentationWatcher instrumentationWatcher,\n                IUiAutomationConnection instrumentationUiConnection, int debugMode,\n                boolean enableBinderTracking, boolean trackAllocation,\n                boolean isRestrictedBackupMode, boolean persistent, Configuration config,\n                CompatibilityInfo compatInfo, Map services, Bundle coreSettings,\n                String buildSerial, boolean autofillCompatibilityEnabled) {\n\n            ...\n\n            AppBindData data = new AppBindData();\n            ... // 补充 AppBindData 的参数\n\n            // 发送一个 消息到 H handler \n            sendMessage(H.BIND_APPLICATION, data);\n        }\n```\n\n在应用进程，发送了一个 H.BIND_APPLICATION 给 handler ，实现了线程的切换。 注意 **通过 binder对象调用，是运行在 binder 线程里的**，所以这个 bindApplication 也是运行在 binder 线程里的，需要切换回主线程。 \n\n## handleBindApplication\n\n```java\n// 伪代码\nprivate void handleBindApplication(AppBindData data) {\n    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);\n\n    Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n\n    mInstrumentation.callApplicationOnCreate(app);\n}\n```\n\ndata.info 是一个描述应用安装包信息的类。 `data.info.makeApplication` 一个applicaiton 类，并调用生命周期的 onCreate\n\n```java\n// frameworks/base/core/java/android/app/LoadedApk.java\npublic Application makeApplication(boolean forceDefaultAppClass,\n            Instrumentation instrumentation) {\n    // 创建 application 和 context 对象，并绑定\n    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n    app = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n}\n```\n\n这样，应用的启动就完成了\n","slug":"Android/Framework/应用进程是如何启动的","published":1,"updated":"2022-05-02T07:54:51.567Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno95004wg0jehpfjr6yo","content":"<h1 id=\"zygote的启动\"><a href=\"#zygote的启动\" class=\"headerlink\" title=\"zygote的启动\"></a>zygote的启动</h1><h2 id=\"zygote-的功能\"><a href=\"#zygote-的功能\" class=\"headerlink\" title=\"zygote 的功能\"></a>zygote 的功能</h2><p>zygote 进程的主要功能有两个：</p><a id=\"more\"></a>\n<ol>\n<li>在系统启动时启动 SystemServer 进程</li>\n<li>启动 应用进程</li>\n</ol>\n<h2 id=\"zygote-进程的启动过程\"><a href=\"#zygote-进程的启动过程\" class=\"headerlink\" title=\"zygote 进程的启动过程\"></a>zygote 进程的启动过程</h2><h3 id=\"zygote进程的创建。\"><a href=\"#zygote进程的创建。\" class=\"headerlink\" title=\"zygote进程的创建。\"></a>zygote进程的创建。</h3><p>在 Android 系统开机之后，会创建 init 进程，这是 Linux 系统启动后创建的第一个进程。 init 进程有一个配置文件 init.rc 。 将需要启动的服务写入到 init.rc 中， init 进程在启动后就会创建这些进程， 比如 zygote ， ServiceManager 等。</p>\n<h3 id=\"zygote-进程的-native-部分。\"><a href=\"#zygote-进程的-native-部分。\" class=\"headerlink\" title=\"zygote 进程的 native 部分。\"></a>zygote 进程的 native 部分。</h3><p>zygote 的c层代码入口在 /rameworks/base/cmds/app_process/app_main.cpp 中，最终主要的工作内容在 /frameworks/base/core/jni/AndroidRuntime.cpp 。主要内容如下。不详细分析了</p>\n<ul>\n<li>启动虚拟机。</li>\n<li>注册 JNI 函数</li>\n<li>调用 Java 类 Zygote.main 方法，进入 Java 循环 。</li>\n</ul>\n<h3 id=\"zygote-进程的-Java-部分\"><a href=\"#zygote-进程的-Java-部分\" class=\"headerlink\" title=\"zygote 进程的 Java 部分\"></a>zygote 进程的 Java 部分</h3><p>zygote 的 java 入口在 /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String argv[])</span> </span>&#123;</span><br><span class=\"line\">        ZygoteServer zygoteServer = <span class=\"keyword\">new</span> ZygoteServer();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Runnable caller;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            RuntimeInit.enableDdms();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> startSystemServer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            String socketName = <span class=\"string\">\"zygote\"</span>;</span><br><span class=\"line\">            String abiList = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> enableLazyPreload = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">\"start-system-server\"</span>.equals(argv[i])) &#123;</span><br><span class=\"line\">                    startSystemServer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"--enable-lazy-preload\"</span>.equals(argv[i])) &#123;</span><br><span class=\"line\">                    enableLazyPreload = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class=\"line\">                    abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class=\"line\">                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Unknown command line argument: \"</span> + argv[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 注册 socket</span></span><br><span class=\"line\">            zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class=\"line\">            <span class=\"comment\">// In such cases, we will preload things prior to our first fork.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!enableLazyPreload) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 预加载类和资源</span></span><br><span class=\"line\">                preload(bootTimingsTraceLog);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Zygote.resetNicePriority();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            ... </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (startSystemServer) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// fork SystemServer 进程</span></span><br><span class=\"line\">                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class=\"line\">                <span class=\"comment\">// child (system_server) process.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果 r != null ，说明是子进程 SystemServer ，r.run 应该是进入 SystemServer 的事件循环，然后直接return</span></span><br><span class=\"line\">                    r.run();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// zygote 事件循环，不让zygote退出</span></span><br><span class=\"line\">            caller = zygoteServer.runSelectLoop(abiList);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            zygoteServer.closeServerSocket();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class=\"line\">        <span class=\"comment\">// command.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (caller != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            caller.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注册 Socket 服务， zygote 进程通过 socket 和 AMS 通信</li>\n<li>预加载类和资源。这样在 fork SystemServer 和 应用进程时，能够直接拷贝给子进程使用</li>\n<li>fork 出 SystemServer 进程， SystemServer 进程随后又会启动 Binder ，并启动这种系统 Service ，比如 AMS ，WMS 等。</li>\n<li>进入 loop 循环，等待接收 AMS 的 Socket 消息。 收到消息后会调用 runOnce 方法，fork 出应用进程，并执行应用进程的 ActivityThread.main() </li>\n</ul>\n<h3 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p><strong>注意：zygote fork 进程时一定是单线程的</strong></p>\n<ul>\n<li><strong>zygote 新 fork 出来的进程不需要再创建java虚拟机，因为 fork 出来的子进程是会继承拷贝父进程的资源的， fork 出来的进程会拥有 zygote 进程的虚拟机的拷贝</strong></li>\n<li><strong>为什么要设计一个 zygote 来 fork 应用进程，而不是 SystemServer :</strong><ul>\n<li>因为systemServer中运行了很多系统服务，不能被继承。应用程序启动时，除了必要的资源外，最好是干净的，所以需要单独用一个zygote来fork。</li>\n</ul>\n</li>\n<li><strong>为什么Zygote要使用Socket不使用binder：</strong><ul>\n<li>因为binder机制支持并发有一个线程池，如果zygote支持并发，在fork之后，会把线程池中的线程一起复制一份。 如果zygote的binder线程池处于一个等待锁的状态，fork之后的新进程依然是在等待锁的，并且不能解锁。 从而有可能造成死锁</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"zygote-的事件循环\"><a href=\"#zygote-的事件循环\" class=\"headerlink\" title=\"zygote 的事件循环\"></a>zygote 的事件循环</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /frameworks/base/core/java/com/android/internal/os/ZygoteServer.java</span></span><br><span class=\"line\">    <span class=\"function\">Runnable <span class=\"title\">runSelectLoop</span><span class=\"params\">(String abiList)</span> </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;FileDescriptor&gt; fds = <span class=\"keyword\">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class=\"line\">        ArrayList&lt;ZygoteConnection&gt; peers = <span class=\"keyword\">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        fds.add(mServerSocket.getFileDescriptor());</span><br><span class=\"line\">        peers.add(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            StructPollfd[] pollFds = <span class=\"keyword\">new</span> StructPollfd[fds.size()];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class=\"line\">                pollFds[i] = <span class=\"keyword\">new</span> StructPollfd();</span><br><span class=\"line\">                pollFds[i].fd = fds.get(i);</span><br><span class=\"line\">                pollFds[i].events = (<span class=\"keyword\">short</span>) POLLIN;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span></span><br><span class=\"line\">                Os.poll(pollFds, -<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ErrnoException ex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"poll failed\"</span>, ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = pollFds.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 这里没看懂。。。</span></span><br><span class=\"line\">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class=\"line\">                    peers.add(newPeer);</span><br><span class=\"line\">                    fds.add(newPeer.getFileDesciptor());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 处理接收到的消息</span></span><br><span class=\"line\">                        ZygoteConnection connection = peers.get(i);</span><br><span class=\"line\">                        <span class=\"keyword\">final</span> Runnable command = connection.processOneCommand(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                    &#125; ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</span></span><br><span class=\"line\">    <span class=\"function\">Runnable <span class=\"title\">processOneCommand</span><span class=\"params\">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, ...);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 子进程</span></span><br><span class=\"line\">                zygoteServer.setForkChild();</span><br><span class=\"line\"></span><br><span class=\"line\">                zygoteServer.closeServerSocket();</span><br><span class=\"line\">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class=\"line\">                serverPipeFd = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class=\"line\">                        parsedArgs.startChildZygote);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 父进程</span></span><br><span class=\"line\">                IoUtils.closeQuietly(childPipeFd);</span><br><span class=\"line\">                childPipeFd = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            IoUtils.closeQuietly(childPipeFd);</span><br><span class=\"line\">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">handleChildProc</span><span class=\"params\">(Arguments parsedArgs, FileDescriptor[] descriptors,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            FileDescriptor pipeFd, <span class=\"keyword\">boolean</span> isZygote)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        closeSocket();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isZygote) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 应用进程启动流程进入这个分支</span></span><br><span class=\"line\">                <span class=\"comment\">// 从 socket 传来参数中取出 class ，并执行 main 方法</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,</span><br><span class=\"line\">                        <span class=\"keyword\">null</span> <span class=\"comment\">/* classLoader */</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没看懂这个分支是做什么的。。</span></span><br><span class=\"line\">                <span class=\"comment\">// 看注释的意思是提供了「跳过启动binder，直接创建进程」的方式</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,</span><br><span class=\"line\">                        parsedArgs.remainingArgs, <span class=\"keyword\">null</span> <span class=\"comment\">/* classLoader */</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"应用进程的启动\"><a href=\"#应用进程的启动\" class=\"headerlink\" title=\"应用进程的启动\"></a>应用进程的启动</h1><p>我们以 Activity 的启动为入口，来探讨应用进程的启动过程</p>\n<h2 id=\"AMS-发起创建进程\"><a href=\"#AMS-发起创建进程\" class=\"headerlink\" title=\"AMS 发起创建进程\"></a>AMS 发起创建进程</h2><h3 id=\"由-Activity-的启动寻找应用进程创建的入口\"><a href=\"#由-Activity-的启动寻找应用进程创建的入口\" class=\"headerlink\" title=\"由 Activity 的启动寻找应用进程创建的入口\"></a>由 Activity 的启动寻找应用进程创建的入口</h3><p>首先来看 Activity 的启动。安卓四大组件都是由AMS来管理的。 应用进程会调用 AMS 的binder 对象，实现在 ActivityManagerService.startActivity 里。</p>\n<p>最终顺着调用栈，会走到 ActivityStackSupervisor.startSpecificActivityLocked(…)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">(ActivityRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Is this activity's application already running?</span></span><br><span class=\"line\">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 进程已启动，真正开始启动 activity 了，哎，调用链太长了</span></span><br><span class=\"line\">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 进程没启动，开始启动进程了</span></span><br><span class=\"line\">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面的逻辑里，会先判断要启动的 activity 所在应用的进程是否启动，如果已经成功启动，则开始启动 activity ；否则，启动引用进程。<br>注意这里应用是否启动的判断条件： <code>if (app != null &amp;&amp; app.thread != null)</code><br> ProcessRecord 是应用进程在 AMS 的信息记录，除了判断 app 不为空，还对 app.thread 。这个 app.thread 是一个 IApplicationThread binder 对象，这个对象很重要。</p>\n<h3 id=\"AMS-发送-Socket-给-zygote\"><a href=\"#AMS-发送-Socket-给-zygote\" class=\"headerlink\" title=\"AMS 发送 Socket 给 zygote\"></a>AMS 发送 Socket 给 zygote</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GuardedBy</span>(<span class=\"string\">\"this\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startProcessLocked</span><span class=\"params\">(String hostingType, String hostingNameStr, String entryPoint,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProcessRecord app, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span>[] gids, <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">long</span> startTime)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步启动进程，忽略吧</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,</span><br><span class=\"line\">                    uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                    invokeWith, startTime);</span><br><span class=\"line\">            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class=\"line\">                    startSeq, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> app.pid &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AMS.startProcess 会调用 Process.start(…) 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /frameworks/base/core/java/android/os/Process.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// /frameworks/base/core/java/android/os/ZygoteProcess.java</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                    abi, instructionSet, appDataDir, invokeWith, <span class=\"keyword\">false</span> <span class=\"comment\">/* startChildZygote */</span>,</span><br><span class=\"line\">                    zygoteArgs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">startViaZygote</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> uid, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> gid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">boolean</span> startChildZygote,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String[] extraArgs)</span></span></span><br><span class=\"line\"><span class=\"function\">                                                      <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; argsForZygote = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">        ... <span class=\"comment\">// 组装 socket 的参数</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(mLock) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// openZygoteSocketIfNeeded 会获取一个 ZygoteState ，有必要的话，会创建 socket 连接。 ZygoteState 包含了 socket 输入输出流。</span></span><br><span class=\"line\">            <span class=\"comment\">// zygote fork 进程成功会返回应用进程的 pid</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>AMS 会发送 socket 消息给 zygote ，zygote 会 fork 应用进程，并执行应用进程的 ActivityThread.main 方法</p>\n<h1 id=\"应用进程在启动之后都干了啥？\"><a href=\"#应用进程在启动之后都干了啥？\" class=\"headerlink\" title=\"应用进程在启动之后都干了啥？\"></a>应用进程在启动之后都干了啥？</h1><h2 id=\"thread-attach-…\"><a href=\"#thread-attach-…\" class=\"headerlink\" title=\"thread.attach(…)\"></a>thread.attach(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepareMainLooper();</span><br><span class=\"line\"></span><br><span class=\"line\">        ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</span><br><span class=\"line\">        thread.attach(<span class=\"keyword\">false</span>, startSeq);</span><br><span class=\"line\"></span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(<span class=\"keyword\">boolean</span> system, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">        sCurrentActivityThread = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        mSystemThread = system;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!system) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 走这个分支</span></span><br><span class=\"line\">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class=\"line\">            <span class=\"keyword\">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>应用整个进程的入口在 ActivityThread.main() 方法中，这个方法里没啥操作： 1. 准备 Looper 2. 实例化 ActivityThread ，并 attach 3. 开启 Looper 循环</p>\n<p>显然， main 方法里做的事情支撑不了一个 app 的启动。 重点看 thread.attach , 它 使用 binder 调用了 AMS.attachApplication ，然后又调用了 AMS.attachApplicationLocked(…)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码。。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">attachApplicationLocked</span><span class=\"params\">(IApplicationThread thread,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> pid, <span class=\"keyword\">int</span> callingUid, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        ProcessRecord app;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class=\"line\">                app = mPidsSelfLocked.get(pid);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            app = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        thread.bindApplication(...);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 处理一些因为应用进程还没有启动而暂存的组件</span></span><br><span class=\"line\">        mStackSupervisor.attachApplicationLocked(app);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mServices.attachApplicationLocked(app, processName);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        sendPendingBroadcastsLocked(app);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"thread-bindApplication-…\"><a href=\"#thread-bindApplication-…\" class=\"headerlink\" title=\"thread.bindApplication(…)\"></a>thread.bindApplication(…)</h2><p>AMS 在 attch 进程之后又通过 binder 调用了应用进程的 bindApplication </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">bindApplication</span><span class=\"params\">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IUiAutomationConnection instrumentationUiConnection, <span class=\"keyword\">int</span> debugMode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> enableBinderTracking, <span class=\"keyword\">boolean</span> trackAllocation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> isRestrictedBackupMode, <span class=\"keyword\">boolean</span> persistent, Configuration config,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String buildSerial, <span class=\"keyword\">boolean</span> autofillCompatibilityEnabled)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    AppBindData data = <span class=\"keyword\">new</span> AppBindData();</span><br><span class=\"line\">    ... <span class=\"comment\">// 补充 AppBindData 的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送一个 消息到 H handler </span></span><br><span class=\"line\">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在应用进程，发送了一个 H.BIND_APPLICATION 给 handler ，实现了线程的切换。 注意 <strong>通过 binder对象调用，是运行在 binder 线程里的</strong>，所以这个 bindApplication 也是运行在 binder 线程里的，需要切换回主线程。 </p>\n<h2 id=\"handleBindApplication\"><a href=\"#handleBindApplication\" class=\"headerlink\" title=\"handleBindApplication\"></a>handleBindApplication</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleBindApplication</span><span class=\"params\">(AppBindData data)</span> </span>&#123;</span><br><span class=\"line\">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>data.info 是一个描述应用安装包信息的类。 <code>data.info.makeApplication</code> 一个applicaiton 类，并调用生命周期的 onCreate</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Application <span class=\"title\">makeApplication</span><span class=\"params\">(<span class=\"keyword\">boolean</span> forceDefaultAppClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Instrumentation instrumentation)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 application 和 context 对象，并绑定</span></span><br><span class=\"line\">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    app = mActivityThread.mInstrumentation.newApplication(</span><br><span class=\"line\">                    cl, appClass, appContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，应用的启动就完成了</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"zygote的启动\"><a href=\"#zygote的启动\" class=\"headerlink\" title=\"zygote的启动\"></a>zygote的启动</h1><h2 id=\"zygote-的功能\"><a href=\"#zygote-的功能\" class=\"headerlink\" title=\"zygote 的功能\"></a>zygote 的功能</h2><p>zygote 进程的主要功能有两个：</p>","more":"\n<ol>\n<li>在系统启动时启动 SystemServer 进程</li>\n<li>启动 应用进程</li>\n</ol>\n<h2 id=\"zygote-进程的启动过程\"><a href=\"#zygote-进程的启动过程\" class=\"headerlink\" title=\"zygote 进程的启动过程\"></a>zygote 进程的启动过程</h2><h3 id=\"zygote进程的创建。\"><a href=\"#zygote进程的创建。\" class=\"headerlink\" title=\"zygote进程的创建。\"></a>zygote进程的创建。</h3><p>在 Android 系统开机之后，会创建 init 进程，这是 Linux 系统启动后创建的第一个进程。 init 进程有一个配置文件 init.rc 。 将需要启动的服务写入到 init.rc 中， init 进程在启动后就会创建这些进程， 比如 zygote ， ServiceManager 等。</p>\n<h3 id=\"zygote-进程的-native-部分。\"><a href=\"#zygote-进程的-native-部分。\" class=\"headerlink\" title=\"zygote 进程的 native 部分。\"></a>zygote 进程的 native 部分。</h3><p>zygote 的c层代码入口在 /rameworks/base/cmds/app_process/app_main.cpp 中，最终主要的工作内容在 /frameworks/base/core/jni/AndroidRuntime.cpp 。主要内容如下。不详细分析了</p>\n<ul>\n<li>启动虚拟机。</li>\n<li>注册 JNI 函数</li>\n<li>调用 Java 类 Zygote.main 方法，进入 Java 循环 。</li>\n</ul>\n<h3 id=\"zygote-进程的-Java-部分\"><a href=\"#zygote-进程的-Java-部分\" class=\"headerlink\" title=\"zygote 进程的 Java 部分\"></a>zygote 进程的 Java 部分</h3><p>zygote 的 java 入口在 /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String argv[])</span> </span>&#123;</span><br><span class=\"line\">        ZygoteServer zygoteServer = <span class=\"keyword\">new</span> ZygoteServer();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Runnable caller;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            RuntimeInit.enableDdms();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> startSystemServer = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            String socketName = <span class=\"string\">\"zygote\"</span>;</span><br><span class=\"line\">            String abiList = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> enableLazyPreload = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">\"start-system-server\"</span>.equals(argv[i])) &#123;</span><br><span class=\"line\">                    startSystemServer = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">\"--enable-lazy-preload\"</span>.equals(argv[i])) &#123;</span><br><span class=\"line\">                    enableLazyPreload = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class=\"line\">                    abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class=\"line\">                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Unknown command line argument: \"</span> + argv[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 注册 socket</span></span><br><span class=\"line\">            zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class=\"line\">            <span class=\"comment\">// In such cases, we will preload things prior to our first fork.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!enableLazyPreload) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 预加载类和资源</span></span><br><span class=\"line\">                preload(bootTimingsTraceLog);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                Zygote.resetNicePriority();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            ... </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (startSystemServer) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// fork SystemServer 进程</span></span><br><span class=\"line\">                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class=\"line\">                <span class=\"comment\">// child (system_server) process.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 如果 r != null ，说明是子进程 SystemServer ，r.run 应该是进入 SystemServer 的事件循环，然后直接return</span></span><br><span class=\"line\">                    r.run();</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// zygote 事件循环，不让zygote退出</span></span><br><span class=\"line\">            caller = zygoteServer.runSelectLoop(abiList);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            zygoteServer.closeServerSocket();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class=\"line\">        <span class=\"comment\">// command.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (caller != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            caller.run();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注册 Socket 服务， zygote 进程通过 socket 和 AMS 通信</li>\n<li>预加载类和资源。这样在 fork SystemServer 和 应用进程时，能够直接拷贝给子进程使用</li>\n<li>fork 出 SystemServer 进程， SystemServer 进程随后又会启动 Binder ，并启动这种系统 Service ，比如 AMS ，WMS 等。</li>\n<li>进入 loop 循环，等待接收 AMS 的 Socket 消息。 收到消息后会调用 runOnce 方法，fork 出应用进程，并执行应用进程的 ActivityThread.main() </li>\n</ul>\n<h3 id=\"小结：\"><a href=\"#小结：\" class=\"headerlink\" title=\"小结：\"></a>小结：</h3><p><strong>注意：zygote fork 进程时一定是单线程的</strong></p>\n<ul>\n<li><strong>zygote 新 fork 出来的进程不需要再创建java虚拟机，因为 fork 出来的子进程是会继承拷贝父进程的资源的， fork 出来的进程会拥有 zygote 进程的虚拟机的拷贝</strong></li>\n<li><strong>为什么要设计一个 zygote 来 fork 应用进程，而不是 SystemServer :</strong><ul>\n<li>因为systemServer中运行了很多系统服务，不能被继承。应用程序启动时，除了必要的资源外，最好是干净的，所以需要单独用一个zygote来fork。</li>\n</ul>\n</li>\n<li><strong>为什么Zygote要使用Socket不使用binder：</strong><ul>\n<li>因为binder机制支持并发有一个线程池，如果zygote支持并发，在fork之后，会把线程池中的线程一起复制一份。 如果zygote的binder线程池处于一个等待锁的状态，fork之后的新进程依然是在等待锁的，并且不能解锁。 从而有可能造成死锁</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"zygote-的事件循环\"><a href=\"#zygote-的事件循环\" class=\"headerlink\" title=\"zygote 的事件循环\"></a>zygote 的事件循环</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /frameworks/base/core/java/com/android/internal/os/ZygoteServer.java</span></span><br><span class=\"line\">    <span class=\"function\">Runnable <span class=\"title\">runSelectLoop</span><span class=\"params\">(String abiList)</span> </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;FileDescriptor&gt; fds = <span class=\"keyword\">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class=\"line\">        ArrayList&lt;ZygoteConnection&gt; peers = <span class=\"keyword\">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        fds.add(mServerSocket.getFileDescriptor());</span><br><span class=\"line\">        peers.add(<span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            StructPollfd[] pollFds = <span class=\"keyword\">new</span> StructPollfd[fds.size()];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class=\"line\">                pollFds[i] = <span class=\"keyword\">new</span> StructPollfd();</span><br><span class=\"line\">                pollFds[i].fd = fds.get(i);</span><br><span class=\"line\">                pollFds[i].events = (<span class=\"keyword\">short</span>) POLLIN;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span></span><br><span class=\"line\">                Os.poll(pollFds, -<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ErrnoException ex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"poll failed\"</span>, ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = pollFds.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 这里没看懂。。。</span></span><br><span class=\"line\">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class=\"line\">                    peers.add(newPeer);</span><br><span class=\"line\">                    fds.add(newPeer.getFileDesciptor());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 处理接收到的消息</span></span><br><span class=\"line\">                        ZygoteConnection connection = peers.get(i);</span><br><span class=\"line\">                        <span class=\"keyword\">final</span> Runnable command = connection.processOneCommand(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                    &#125; ...</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</span></span><br><span class=\"line\">    <span class=\"function\">Runnable <span class=\"title\">processOneCommand</span><span class=\"params\">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, ...);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 子进程</span></span><br><span class=\"line\">                zygoteServer.setForkChild();</span><br><span class=\"line\"></span><br><span class=\"line\">                zygoteServer.closeServerSocket();</span><br><span class=\"line\">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class=\"line\">                serverPipeFd = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class=\"line\">                        parsedArgs.startChildZygote);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 父进程</span></span><br><span class=\"line\">                IoUtils.closeQuietly(childPipeFd);</span><br><span class=\"line\">                childPipeFd = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            IoUtils.closeQuietly(childPipeFd);</span><br><span class=\"line\">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">handleChildProc</span><span class=\"params\">(Arguments parsedArgs, FileDescriptor[] descriptors,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            FileDescriptor pipeFd, <span class=\"keyword\">boolean</span> isZygote)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        closeSocket();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isZygote) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 应用进程启动流程进入这个分支</span></span><br><span class=\"line\">                <span class=\"comment\">// 从 socket 传来参数中取出 class ，并执行 main 方法</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,</span><br><span class=\"line\">                        <span class=\"keyword\">null</span> <span class=\"comment\">/* classLoader */</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 没看懂这个分支是做什么的。。</span></span><br><span class=\"line\">                <span class=\"comment\">// 看注释的意思是提供了「跳过启动binder，直接创建进程」的方式</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,</span><br><span class=\"line\">                        parsedArgs.remainingArgs, <span class=\"keyword\">null</span> <span class=\"comment\">/* classLoader */</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"应用进程的启动\"><a href=\"#应用进程的启动\" class=\"headerlink\" title=\"应用进程的启动\"></a>应用进程的启动</h1><p>我们以 Activity 的启动为入口，来探讨应用进程的启动过程</p>\n<h2 id=\"AMS-发起创建进程\"><a href=\"#AMS-发起创建进程\" class=\"headerlink\" title=\"AMS 发起创建进程\"></a>AMS 发起创建进程</h2><h3 id=\"由-Activity-的启动寻找应用进程创建的入口\"><a href=\"#由-Activity-的启动寻找应用进程创建的入口\" class=\"headerlink\" title=\"由 Activity 的启动寻找应用进程创建的入口\"></a>由 Activity 的启动寻找应用进程创建的入口</h3><p>首先来看 Activity 的启动。安卓四大组件都是由AMS来管理的。 应用进程会调用 AMS 的binder 对象，实现在 ActivityManagerService.startActivity 里。</p>\n<p>最终顺着调用栈，会走到 ActivityStackSupervisor.startSpecificActivityLocked(…)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startSpecificActivityLocked</span><span class=\"params\">(ActivityRecord r,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> andResume, <span class=\"keyword\">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Is this activity's application already running?</span></span><br><span class=\"line\">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class=\"line\">                r.info.applicationInfo.uid, <span class=\"keyword\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (app != <span class=\"keyword\">null</span> &amp;&amp; app.thread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 进程已启动，真正开始启动 activity 了，哎，调用链太长了</span></span><br><span class=\"line\">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemoteException e) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 进程没启动，开始启动进程了</span></span><br><span class=\"line\">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class=\"keyword\">true</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">                <span class=\"string\">\"activity\"</span>, r.intent.getComponent(), <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>上面的逻辑里，会先判断要启动的 activity 所在应用的进程是否启动，如果已经成功启动，则开始启动 activity ；否则，启动引用进程。<br>注意这里应用是否启动的判断条件： <code>if (app != null &amp;&amp; app.thread != null)</code><br> ProcessRecord 是应用进程在 AMS 的信息记录，除了判断 app 不为空，还对 app.thread 。这个 app.thread 是一个 IApplicationThread binder 对象，这个对象很重要。</p>\n<h3 id=\"AMS-发送-Socket-给-zygote\"><a href=\"#AMS-发送-Socket-给-zygote\" class=\"headerlink\" title=\"AMS 发送 Socket 给 zygote\"></a>AMS 发送 Socket 给 zygote</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GuardedBy</span>(<span class=\"string\">\"this\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startProcessLocked</span><span class=\"params\">(String hostingType, String hostingNameStr, String entryPoint,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProcessRecord app, <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span>[] gids, <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">long</span> startTime)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 异步启动进程，忽略吧</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,</span><br><span class=\"line\">                    uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class=\"line\">                    invokeWith, startTime);</span><br><span class=\"line\">            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class=\"line\">                    startSeq, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RuntimeException e) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> app.pid &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AMS.startProcess 会调用 Process.start(…) 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// /frameworks/base/core/java/android/os/Process.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// /frameworks/base/core/java/android/os/ZygoteProcess.java</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> uid, <span class=\"keyword\">int</span> gid, <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class=\"line\">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class=\"line\">                    abi, instructionSet, appDataDir, invokeWith, <span class=\"keyword\">false</span> <span class=\"comment\">/* startChildZygote */</span>,</span><br><span class=\"line\">                    zygoteArgs);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Process.<span class=\"function\">ProcessStartResult <span class=\"title\">startViaZygote</span><span class=\"params\">(<span class=\"keyword\">final</span> String processClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">final</span> String niceName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> uid, <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> gid,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] gids,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">int</span> runtimeFlags, <span class=\"keyword\">int</span> mountExternal,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">int</span> targetSdkVersion,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String seInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String abi,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String instructionSet,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String appDataDir,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String invokeWith,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      <span class=\"keyword\">boolean</span> startChildZygote,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                                      String[] extraArgs)</span></span></span><br><span class=\"line\"><span class=\"function\">                                                      <span class=\"keyword\">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;String&gt; argsForZygote = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">        ... <span class=\"comment\">// 组装 socket 的参数</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(mLock) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// openZygoteSocketIfNeeded 会获取一个 ZygoteState ，有必要的话，会创建 socket 连接。 ZygoteState 包含了 socket 输入输出流。</span></span><br><span class=\"line\">            <span class=\"comment\">// zygote fork 进程成功会返回应用进程的 pid</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>AMS 会发送 socket 消息给 zygote ，zygote 会 fork 应用进程，并执行应用进程的 ActivityThread.main 方法</p>\n<h1 id=\"应用进程在启动之后都干了啥？\"><a href=\"#应用进程在启动之后都干了啥？\" class=\"headerlink\" title=\"应用进程在启动之后都干了啥？\"></a>应用进程在启动之后都干了啥？</h1><h2 id=\"thread-attach-…\"><a href=\"#thread-attach-…\" class=\"headerlink\" title=\"thread.attach(…)\"></a>thread.attach(…)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Looper.prepareMainLooper();</span><br><span class=\"line\"></span><br><span class=\"line\">        ActivityThread thread = <span class=\"keyword\">new</span> ActivityThread();</span><br><span class=\"line\">        thread.attach(<span class=\"keyword\">false</span>, startSeq);</span><br><span class=\"line\"></span><br><span class=\"line\">        Looper.loop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">attach</span><span class=\"params\">(<span class=\"keyword\">boolean</span> system, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">        sCurrentActivityThread = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        mSystemThread = system;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!system) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 走这个分支</span></span><br><span class=\"line\">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class=\"line\">            <span class=\"keyword\">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (RemoteException ex) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> ex.rethrowFromSystemServer();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>应用整个进程的入口在 ActivityThread.main() 方法中，这个方法里没啥操作： 1. 准备 Looper 2. 实例化 ActivityThread ，并 attach 3. 开启 Looper 循环</p>\n<p>显然， main 方法里做的事情支撑不了一个 app 的启动。 重点看 thread.attach , 它 使用 binder 调用了 AMS.attachApplication ，然后又调用了 AMS.attachApplicationLocked(…)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码。。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">attachApplicationLocked</span><span class=\"params\">(IApplicationThread thread,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> pid, <span class=\"keyword\">int</span> callingUid, <span class=\"keyword\">long</span> startSeq)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">        ProcessRecord app;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class=\"line\">                app = mPidsSelfLocked.get(pid);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            app = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        thread.bindApplication(...);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 处理一些因为应用进程还没有启动而暂存的组件</span></span><br><span class=\"line\">        mStackSupervisor.attachApplicationLocked(app);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mServices.attachApplicationLocked(app, processName);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        sendPendingBroadcastsLocked(app);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"thread-bindApplication-…\"><a href=\"#thread-bindApplication-…\" class=\"headerlink\" title=\"thread.bindApplication(…)\"></a>thread.bindApplication(…)</h2><p>AMS 在 attch 进程之后又通过 binder 调用了应用进程的 bindApplication </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">bindApplication</span><span class=\"params\">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        IUiAutomationConnection instrumentationUiConnection, <span class=\"keyword\">int</span> debugMode,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> enableBinderTracking, <span class=\"keyword\">boolean</span> trackAllocation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> isRestrictedBackupMode, <span class=\"keyword\">boolean</span> persistent, Configuration config,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        String buildSerial, <span class=\"keyword\">boolean</span> autofillCompatibilityEnabled)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    AppBindData data = <span class=\"keyword\">new</span> AppBindData();</span><br><span class=\"line\">    ... <span class=\"comment\">// 补充 AppBindData 的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送一个 消息到 H handler </span></span><br><span class=\"line\">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在应用进程，发送了一个 H.BIND_APPLICATION 给 handler ，实现了线程的切换。 注意 <strong>通过 binder对象调用，是运行在 binder 线程里的</strong>，所以这个 bindApplication 也是运行在 binder 线程里的，需要切换回主线程。 </p>\n<h2 id=\"handleBindApplication\"><a href=\"#handleBindApplication\" class=\"headerlink\" title=\"handleBindApplication\"></a>handleBindApplication</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 伪代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleBindApplication</span><span class=\"params\">(AppBindData data)</span> </span>&#123;</span><br><span class=\"line\">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>data.info 是一个描述应用安装包信息的类。 <code>data.info.makeApplication</code> 一个applicaiton 类，并调用生命周期的 onCreate</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Application <span class=\"title\">makeApplication</span><span class=\"params\">(<span class=\"keyword\">boolean</span> forceDefaultAppClass,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Instrumentation instrumentation)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 application 和 context 对象，并绑定</span></span><br><span class=\"line\">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    app = mActivityThread.mInstrumentation.newApplication(</span><br><span class=\"line\">                    cl, appClass, appContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，应用的启动就完成了</p>\n"},{"title":"Binder源码笔记","date":"2021-11-03T13:42:37.000Z","_content":"\n# Service 的启动 (独立进程的 Service )\n## ProcessState\nProcessState 是一个系统 Service 进程的单例，一个进程只有一个 ProcessState 实例。 \n\n内部会打开设备 \"/dev/binder\" ，调用 mmap 函数，完成自己和内核空间的内存映射。\n\nioctl 和 Binder 设备传递参数，设置了 binder 线程池的最大线程数\n\n## Binder线程池\n调用 ProcessState::startThreadPool() 启动 Binder 线程池。 调用之后，实际上就已经 run 了一个 Binder 主线程, 并开始 while 死循环接收 Binder 消息。 \n之后会根据情况，选择在 Binder 线程池中创建新的线程，但是创建出来的就不是一个死循环的线程了\n\n# 通信\n## BpBinder 和 BBinder \nIBinder 对象是负责binder通信的实例。 BpBinder 是客户端和服务端交互的代理类，BBinder 代表服务端\n\n## BpBinder::transact\n发送数据的方法\n\n## IPCThreadState::self()->transact(...)\n真正数据通信的方法。 一个线程只会有一个实例， 使用 pthread_setspecific 实现，类似于 java 的 ThreadLocal\nIPCThreadState 有两个缓存 mIn 和 mOut 分别负责数据的接收和发射\n\n```shell\n-> transact(..)\n    -> writeTransactionData(..)\n        -> 将 cmd 和 data 写入到 mOut 中\n    -> waitForResponse(..)\n        -> talkWithDriver(doReceive)\n            -> 将 bwr(一个和Binder驱动的结构体) bwr.write_buffer 指向 mOut.data()\n            -> 将 bwr.read_buffer 指向 mIn.data()\n            -> do-while 循环，调用 ioctl 函数 和 Binder 驱动通信，直到结束\n```\n\n\n\n# 问题：\n## 1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的\n应用 Service 是发布到 AMS 上的，客户端从 AMS 上去查找 Service 的 Binder 对象","source":"_posts/Android/Framework/Binder源码笔记.md","raw":"---\ntitle: Binder源码笔记\ndate: 2021-11-03 21:42:37\ntags:\n---\n\n# Service 的启动 (独立进程的 Service )\n## ProcessState\nProcessState 是一个系统 Service 进程的单例，一个进程只有一个 ProcessState 实例。 \n\n内部会打开设备 \"/dev/binder\" ，调用 mmap 函数，完成自己和内核空间的内存映射。\n\nioctl 和 Binder 设备传递参数，设置了 binder 线程池的最大线程数\n\n## Binder线程池\n调用 ProcessState::startThreadPool() 启动 Binder 线程池。 调用之后，实际上就已经 run 了一个 Binder 主线程, 并开始 while 死循环接收 Binder 消息。 \n之后会根据情况，选择在 Binder 线程池中创建新的线程，但是创建出来的就不是一个死循环的线程了\n\n# 通信\n## BpBinder 和 BBinder \nIBinder 对象是负责binder通信的实例。 BpBinder 是客户端和服务端交互的代理类，BBinder 代表服务端\n\n## BpBinder::transact\n发送数据的方法\n\n## IPCThreadState::self()->transact(...)\n真正数据通信的方法。 一个线程只会有一个实例， 使用 pthread_setspecific 实现，类似于 java 的 ThreadLocal\nIPCThreadState 有两个缓存 mIn 和 mOut 分别负责数据的接收和发射\n\n```shell\n-> transact(..)\n    -> writeTransactionData(..)\n        -> 将 cmd 和 data 写入到 mOut 中\n    -> waitForResponse(..)\n        -> talkWithDriver(doReceive)\n            -> 将 bwr(一个和Binder驱动的结构体) bwr.write_buffer 指向 mOut.data()\n            -> 将 bwr.read_buffer 指向 mIn.data()\n            -> do-while 循环，调用 ioctl 函数 和 Binder 驱动通信，直到结束\n```\n\n\n\n# 问题：\n## 1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的\n应用 Service 是发布到 AMS 上的，客户端从 AMS 上去查找 Service 的 Binder 对象","slug":"Android/Framework/Binder源码笔记","published":1,"updated":"2021-11-09T14:29:00.433Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno97004zg0je1sziq2kb","content":"<h1 id=\"Service-的启动-独立进程的-Service\"><a href=\"#Service-的启动-独立进程的-Service\" class=\"headerlink\" title=\"Service 的启动 (独立进程的 Service )\"></a>Service 的启动 (独立进程的 Service )</h1><a id=\"more\"></a><h2 id=\"ProcessState\"><a href=\"#ProcessState\" class=\"headerlink\" title=\"ProcessState\"></a>ProcessState</h2><p>ProcessState 是一个系统 Service 进程的单例，一个进程只有一个 ProcessState 实例。 </p>\n<p>内部会打开设备 “/dev/binder” ，调用 mmap 函数，完成自己和内核空间的内存映射。</p>\n<p>ioctl 和 Binder 设备传递参数，设置了 binder 线程池的最大线程数</p>\n<h2 id=\"Binder线程池\"><a href=\"#Binder线程池\" class=\"headerlink\" title=\"Binder线程池\"></a>Binder线程池</h2><p>调用 ProcessState::startThreadPool() 启动 Binder 线程池。 调用之后，实际上就已经 run 了一个 Binder 主线程, 并开始 while 死循环接收 Binder 消息。<br>之后会根据情况，选择在 Binder 线程池中创建新的线程，但是创建出来的就不是一个死循环的线程了</p>\n<h1 id=\"通信\"><a href=\"#通信\" class=\"headerlink\" title=\"通信\"></a>通信</h1><h2 id=\"BpBinder-和-BBinder\"><a href=\"#BpBinder-和-BBinder\" class=\"headerlink\" title=\"BpBinder 和 BBinder\"></a>BpBinder 和 BBinder</h2><p>IBinder 对象是负责binder通信的实例。 BpBinder 是客户端和服务端交互的代理类，BBinder 代表服务端</p>\n<h2 id=\"BpBinder-transact\"><a href=\"#BpBinder-transact\" class=\"headerlink\" title=\"BpBinder::transact\"></a>BpBinder::transact</h2><p>发送数据的方法</p>\n<h2 id=\"IPCThreadState-self-gt-transact-…\"><a href=\"#IPCThreadState-self-gt-transact-…\" class=\"headerlink\" title=\"IPCThreadState::self()-&gt;transact(…)\"></a>IPCThreadState::self()-&gt;transact(…)</h2><p>真正数据通信的方法。 一个线程只会有一个实例， 使用 pthread_setspecific 实现，类似于 java 的 ThreadLocal<br>IPCThreadState 有两个缓存 mIn 和 mOut 分别负责数据的接收和发射</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">-&gt;</span> transact(..)</span><br><span class=\"line\">    -&gt; writeTransactionData(..)</span><br><span class=\"line\">        -&gt; 将 cmd 和 data 写入到 mOut 中</span><br><span class=\"line\">    -&gt; waitForResponse(..)</span><br><span class=\"line\">        -&gt; talkWithDriver(doReceive)</span><br><span class=\"line\">            -&gt; 将 bwr(一个和Binder驱动的结构体) bwr.write_buffer 指向 mOut.data()</span><br><span class=\"line\">            -&gt; 将 bwr.read_buffer 指向 mIn.data()</span><br><span class=\"line\">            -&gt; do-while 循环，调用 ioctl 函数 和 Binder 驱动通信，直到结束</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h1><h2 id=\"1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的\"><a href=\"#1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的\" class=\"headerlink\" title=\"1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的\"></a>1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的</h2><p>应用 Service 是发布到 AMS 上的，客户端从 AMS 上去查找 Service 的 Binder 对象</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Service-的启动-独立进程的-Service\"><a href=\"#Service-的启动-独立进程的-Service\" class=\"headerlink\" title=\"Service 的启动 (独立进程的 Service )\"></a>Service 的启动 (独立进程的 Service )</h1>","more":"<h2 id=\"ProcessState\"><a href=\"#ProcessState\" class=\"headerlink\" title=\"ProcessState\"></a>ProcessState</h2><p>ProcessState 是一个系统 Service 进程的单例，一个进程只有一个 ProcessState 实例。 </p>\n<p>内部会打开设备 “/dev/binder” ，调用 mmap 函数，完成自己和内核空间的内存映射。</p>\n<p>ioctl 和 Binder 设备传递参数，设置了 binder 线程池的最大线程数</p>\n<h2 id=\"Binder线程池\"><a href=\"#Binder线程池\" class=\"headerlink\" title=\"Binder线程池\"></a>Binder线程池</h2><p>调用 ProcessState::startThreadPool() 启动 Binder 线程池。 调用之后，实际上就已经 run 了一个 Binder 主线程, 并开始 while 死循环接收 Binder 消息。<br>之后会根据情况，选择在 Binder 线程池中创建新的线程，但是创建出来的就不是一个死循环的线程了</p>\n<h1 id=\"通信\"><a href=\"#通信\" class=\"headerlink\" title=\"通信\"></a>通信</h1><h2 id=\"BpBinder-和-BBinder\"><a href=\"#BpBinder-和-BBinder\" class=\"headerlink\" title=\"BpBinder 和 BBinder\"></a>BpBinder 和 BBinder</h2><p>IBinder 对象是负责binder通信的实例。 BpBinder 是客户端和服务端交互的代理类，BBinder 代表服务端</p>\n<h2 id=\"BpBinder-transact\"><a href=\"#BpBinder-transact\" class=\"headerlink\" title=\"BpBinder::transact\"></a>BpBinder::transact</h2><p>发送数据的方法</p>\n<h2 id=\"IPCThreadState-self-gt-transact-…\"><a href=\"#IPCThreadState-self-gt-transact-…\" class=\"headerlink\" title=\"IPCThreadState::self()-&gt;transact(…)\"></a>IPCThreadState::self()-&gt;transact(…)</h2><p>真正数据通信的方法。 一个线程只会有一个实例， 使用 pthread_setspecific 实现，类似于 java 的 ThreadLocal<br>IPCThreadState 有两个缓存 mIn 和 mOut 分别负责数据的接收和发射</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">-&gt;</span> transact(..)</span><br><span class=\"line\">    -&gt; writeTransactionData(..)</span><br><span class=\"line\">        -&gt; 将 cmd 和 data 写入到 mOut 中</span><br><span class=\"line\">    -&gt; waitForResponse(..)</span><br><span class=\"line\">        -&gt; talkWithDriver(doReceive)</span><br><span class=\"line\">            -&gt; 将 bwr(一个和Binder驱动的结构体) bwr.write_buffer 指向 mOut.data()</span><br><span class=\"line\">            -&gt; 将 bwr.read_buffer 指向 mIn.data()</span><br><span class=\"line\">            -&gt; do-while 循环，调用 ioctl 函数 和 Binder 驱动通信，直到结束</span><br></pre></td></tr></table></figure>\n<h1 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h1><h2 id=\"1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的\"><a href=\"#1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的\" class=\"headerlink\" title=\"1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的\"></a>1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的</h2><p>应用 Service 是发布到 AMS 上的，客户端从 AMS 上去查找 Service 的 Binder 对象</p>\n"},{"title":"事件分发机制","date":"2019-08-13T13:12:59.000Z","_content":"\n# 事件分发机制\n\n## dispatchTouchEvent\n\n### ViewGroup 的 dispatchTouchEvent 方法\n\n#### 伪代码\n\n```java\npublic boolean dispatchTouchEvent(){\n    boolean consume = false;\n    if (onInterceptTouchEvent(ev)){\n        consume = super.dispatchTouchEvent();\n    }else{\n        consume = child.dispatchTouchEvent(ev);\n        if (!consume)\n            consume = super.dispatchTouchEvent(ev)\n    }\n    return consume;\n}\n```\n\n解释：\n在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理\n\n#### 源代码\n\n##### dispatchTouchEvent\n\n```java\n// Handle an initial down.\nif (actionMasked == MotionEvent.ACTION_DOWN) {\n    // Throw away all previous state when starting a new touch gesture.\n    // The framework may have dropped the up or cancel event for the previous gesture\n    // due to an app switch, ANR, or some other state change.\n    // 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null\n    cancelAndClearTouchTargets(ev);\n    resetTouchState();\n}\n\n// Check for interception.\nfinal boolean intercepted;\n// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素\n// mFirstTouchTarget赋值在addTouchTarget方法中\nif (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {\n    final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n    if (!disallowIntercept) {\n        intercepted = onInterceptTouchEvent(ev);\n        ev.setAction(action); // restore action in case it was changed\n    } else {\n        intercepted = false;\n    }\n} else {\n    // mFirstTouchTarget == null, 并且这不是一个down事件, 说明\n    // down事件没有被ViewGroup拦击, down事件也没有被子view消费, \n    // 后续的事件也没有被子View消费, 所以后续的事件交给ViewGroup\n    intercepted = true;\n}\n\n.... //省略代码\n\n// Check for cancelation.\nfinal boolean canceled = resetCancelNextUpFlag(this)\n        || actionMasked == MotionEvent.ACTION_CANCEL;\n// Update list of touch targets for pointer down, if needed.\nfinal boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\nTouchTarget newTouchTarget = null;\nboolean alreadyDispatchedToNewTouchTarget = false;\n\nif (!canceled && !intercepted) {\n    ... //省略部分代码\n    for (int i = childrenCount - 1; i >= 0; i--) {\n\n        ... //省略部分代码\n\n        newTouchTarget = getTouchTarget(child);\n        if (newTouchTarget != null) {\n            // Child is already receiving touch within its bounds.\n            // Give it the new pointer in addition to the ones it is handling.\n            newTouchTarget.pointerIdBits |= idBitsToAssign;\n            break;\n        }\n\n        ... // 省略部分代码\n\n        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n            // Child wants to receive touch within its bounds.\n            // 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环\n\n            .... // 省略部分代码\n            newTouchTarget = addTouchTarget(child, idBitsToAssign);\n            alreadyDispatchedToNewTouchTarget = true;\n            break;\n        }\n\n        ... //省略代码\n    }\n    ... // 省略部分代码\n}\n\n... // 省略部分代码\n\n// Dispatch to touch targets.\nif (mFirstTouchTarget == null) {\n    // No touch targets so treat this as an ordinary view.\n    handled = dispatchTransformedTouchEvent(ev, canceled, null,\n            TouchTarget.ALL_POINTER_IDS);\n} else {\n\n    ... // 省略代码\n}\n```\n\n##### dispatchTransformedTouchEvent\n\n```java\nprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n    final boolean handled;\n\n    // 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理\n    final int oldAction = event.getAction();\n    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n        event.setAction(MotionEvent.ACTION_CANCEL);\n        if (child == null) {\n            handled = super.dispatchTouchEvent(event);\n        } else {\n            handled = child.dispatchTouchEvent(event);\n        }\n        event.setAction(oldAction);\n        return handled;\n    }\n\n    ... // 省略代码\n}\n```\n\n##### mFirstTarget\n\nmFirstTouchTarget 是一个 TouchTarget 对象，通过注释的说明：\"触摸目标的链接列表中的第一个触摸目标\"，可以得出：mFirstTouchTarget 是\"触摸目标\"链表的头部。\n\n```java\nif (!canceled && !intercepted) {\n    if (actionMasked == MotionEvent.ACTION_DOWN\n            || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n\n        final int childrenCount = mChildrenCount;\n        if (newTouchTarget == null && childrenCount != 0) {\n            final ArrayList<View> preorderedList = buildTouchDispatchChildList();\n            for (int i = childrenCount - 1; i >= 0; i--) {\n                final int childIndex = getAndVerifyPreorderedIndex(\n                        childrenCount, i, customOrder);\n                final View child = getAndVerifyPreorderedView(\n                        preorderedList, children, childIndex);\n\n                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                    ...\n                    newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                    alreadyDispatchedToNewTouchTarget = true;\n                    break;\n                }\n            }\n        }\n        ...\n    }\n}\n\nif (mFirstTouchTarget == null) {\n    handled = dispatchTransformedTouchEvent(ev, canceled, null,\n            TouchTarget.ALL_POINTER_IDS);\n} else {\n    ....\n    if (dispatchTransformedTouchEvent(ev, cancelChild,\n                    target.child, target.pointerIdBits)) {\n        handled = true;\n    }\n}\n```\n\naddTouchTarget(..) 方法是 mFirstTouchTarget 赋值的地方。 \n\n我们看 dispatchTouchEvent 中 mFirstTouchTarget 的使用。发现它只在 MotionEvent.ACTION_DOWN 事件的时候赋值。\n\n然后所有的事件都会判断 mFirstTouchTarget 是否为 null ，为 null 则有 ViewGroup 处理， 不为 null 则由 mFirstTouchTarget 对应的 子view 处理。\n由此也就可以得出结论： 如果 子view 消费了 TOUCH_DOWN 事件，后续的事件，如果 ViewGroup 不拦截，则都交给这个 子View 消费。**因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。** 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, dispatchTouchEvent 直接返回 false\n\n##### addTouchTarget\n\n**mFirstTarget 赋值的地方**\n\n```java\nprivate TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {\n    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);\n    target.next = mFirstTouchTarget;\n    mFirstTouchTarget = target;\n    return target;\n}\n```\n\n#### 需要注意的点\n\n##### ActionDown\n\n- ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理\n- ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位\n\n##### ActionMove、ActionUp 等其他事件\n\n- 若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截\n- 若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理。 ( 因为mFirstTouchTarget==null)\n\n(以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到)\n\n##### requestDisallowInterceptTouchEvent(true)\n\n- 子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。\n- 但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位\n\n##### mFirstTouchTarget\n\n**因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。** 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, ViewGroup 的 dispatchTouchEvent 直接返回 false\n\n## View 的 dispatchTouchEvent 方法\n\n如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent event) {\n    ... // 省略代码\n\n    ListenerInfo li = mListenerInfo;\n    if (li != null && li.mOnTouchListener != null\n            && (mViewFlags & ENABLED_MASK) == ENABLED\n            && li.mOnTouchListener.onTouch(this, event)) {\n        result = true;\n    }\n\n    if (!result && onTouchEvent(event)) {\n        result = true;\n    }\n\n    ... // 省略代码\n\n    return result;\n}\n```\n","source":"_posts/Android/Framework/事件分发机制.md","raw":"---\ntitle: 事件分发机制\ndate: 2019-08-13 21:12:59\ntags:\n- View\n- 源码解析\ncategories:\n- Android\n- View\n---\n\n# 事件分发机制\n\n## dispatchTouchEvent\n\n### ViewGroup 的 dispatchTouchEvent 方法\n\n#### 伪代码\n\n```java\npublic boolean dispatchTouchEvent(){\n    boolean consume = false;\n    if (onInterceptTouchEvent(ev)){\n        consume = super.dispatchTouchEvent();\n    }else{\n        consume = child.dispatchTouchEvent(ev);\n        if (!consume)\n            consume = super.dispatchTouchEvent(ev)\n    }\n    return consume;\n}\n```\n\n解释：\n在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理\n\n#### 源代码\n\n##### dispatchTouchEvent\n\n```java\n// Handle an initial down.\nif (actionMasked == MotionEvent.ACTION_DOWN) {\n    // Throw away all previous state when starting a new touch gesture.\n    // The framework may have dropped the up or cancel event for the previous gesture\n    // due to an app switch, ANR, or some other state change.\n    // 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null\n    cancelAndClearTouchTargets(ev);\n    resetTouchState();\n}\n\n// Check for interception.\nfinal boolean intercepted;\n// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素\n// mFirstTouchTarget赋值在addTouchTarget方法中\nif (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {\n    final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\n    if (!disallowIntercept) {\n        intercepted = onInterceptTouchEvent(ev);\n        ev.setAction(action); // restore action in case it was changed\n    } else {\n        intercepted = false;\n    }\n} else {\n    // mFirstTouchTarget == null, 并且这不是一个down事件, 说明\n    // down事件没有被ViewGroup拦击, down事件也没有被子view消费, \n    // 后续的事件也没有被子View消费, 所以后续的事件交给ViewGroup\n    intercepted = true;\n}\n\n.... //省略代码\n\n// Check for cancelation.\nfinal boolean canceled = resetCancelNextUpFlag(this)\n        || actionMasked == MotionEvent.ACTION_CANCEL;\n// Update list of touch targets for pointer down, if needed.\nfinal boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\nTouchTarget newTouchTarget = null;\nboolean alreadyDispatchedToNewTouchTarget = false;\n\nif (!canceled && !intercepted) {\n    ... //省略部分代码\n    for (int i = childrenCount - 1; i >= 0; i--) {\n\n        ... //省略部分代码\n\n        newTouchTarget = getTouchTarget(child);\n        if (newTouchTarget != null) {\n            // Child is already receiving touch within its bounds.\n            // Give it the new pointer in addition to the ones it is handling.\n            newTouchTarget.pointerIdBits |= idBitsToAssign;\n            break;\n        }\n\n        ... // 省略部分代码\n\n        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n            // Child wants to receive touch within its bounds.\n            // 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环\n\n            .... // 省略部分代码\n            newTouchTarget = addTouchTarget(child, idBitsToAssign);\n            alreadyDispatchedToNewTouchTarget = true;\n            break;\n        }\n\n        ... //省略代码\n    }\n    ... // 省略部分代码\n}\n\n... // 省略部分代码\n\n// Dispatch to touch targets.\nif (mFirstTouchTarget == null) {\n    // No touch targets so treat this as an ordinary view.\n    handled = dispatchTransformedTouchEvent(ev, canceled, null,\n            TouchTarget.ALL_POINTER_IDS);\n} else {\n\n    ... // 省略代码\n}\n```\n\n##### dispatchTransformedTouchEvent\n\n```java\nprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\n            View child, int desiredPointerIdBits) {\n    final boolean handled;\n\n    // 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理\n    final int oldAction = event.getAction();\n    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\n        event.setAction(MotionEvent.ACTION_CANCEL);\n        if (child == null) {\n            handled = super.dispatchTouchEvent(event);\n        } else {\n            handled = child.dispatchTouchEvent(event);\n        }\n        event.setAction(oldAction);\n        return handled;\n    }\n\n    ... // 省略代码\n}\n```\n\n##### mFirstTarget\n\nmFirstTouchTarget 是一个 TouchTarget 对象，通过注释的说明：\"触摸目标的链接列表中的第一个触摸目标\"，可以得出：mFirstTouchTarget 是\"触摸目标\"链表的头部。\n\n```java\nif (!canceled && !intercepted) {\n    if (actionMasked == MotionEvent.ACTION_DOWN\n            || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\n            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\n\n        final int childrenCount = mChildrenCount;\n        if (newTouchTarget == null && childrenCount != 0) {\n            final ArrayList<View> preorderedList = buildTouchDispatchChildList();\n            for (int i = childrenCount - 1; i >= 0; i--) {\n                final int childIndex = getAndVerifyPreorderedIndex(\n                        childrenCount, i, customOrder);\n                final View child = getAndVerifyPreorderedView(\n                        preorderedList, children, childIndex);\n\n                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\n                    ...\n                    newTouchTarget = addTouchTarget(child, idBitsToAssign);\n                    alreadyDispatchedToNewTouchTarget = true;\n                    break;\n                }\n            }\n        }\n        ...\n    }\n}\n\nif (mFirstTouchTarget == null) {\n    handled = dispatchTransformedTouchEvent(ev, canceled, null,\n            TouchTarget.ALL_POINTER_IDS);\n} else {\n    ....\n    if (dispatchTransformedTouchEvent(ev, cancelChild,\n                    target.child, target.pointerIdBits)) {\n        handled = true;\n    }\n}\n```\n\naddTouchTarget(..) 方法是 mFirstTouchTarget 赋值的地方。 \n\n我们看 dispatchTouchEvent 中 mFirstTouchTarget 的使用。发现它只在 MotionEvent.ACTION_DOWN 事件的时候赋值。\n\n然后所有的事件都会判断 mFirstTouchTarget 是否为 null ，为 null 则有 ViewGroup 处理， 不为 null 则由 mFirstTouchTarget 对应的 子view 处理。\n由此也就可以得出结论： 如果 子view 消费了 TOUCH_DOWN 事件，后续的事件，如果 ViewGroup 不拦截，则都交给这个 子View 消费。**因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。** 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, dispatchTouchEvent 直接返回 false\n\n##### addTouchTarget\n\n**mFirstTarget 赋值的地方**\n\n```java\nprivate TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {\n    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);\n    target.next = mFirstTouchTarget;\n    mFirstTouchTarget = target;\n    return target;\n}\n```\n\n#### 需要注意的点\n\n##### ActionDown\n\n- ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理\n- ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位\n\n##### ActionMove、ActionUp 等其他事件\n\n- 若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截\n- 若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理。 ( 因为mFirstTouchTarget==null)\n\n(以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到)\n\n##### requestDisallowInterceptTouchEvent(true)\n\n- 子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。\n- 但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位\n\n##### mFirstTouchTarget\n\n**因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。** 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, ViewGroup 的 dispatchTouchEvent 直接返回 false\n\n## View 的 dispatchTouchEvent 方法\n\n如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法\n\n```java\npublic boolean dispatchTouchEvent(MotionEvent event) {\n    ... // 省略代码\n\n    ListenerInfo li = mListenerInfo;\n    if (li != null && li.mOnTouchListener != null\n            && (mViewFlags & ENABLED_MASK) == ENABLED\n            && li.mOnTouchListener.onTouch(this, event)) {\n        result = true;\n    }\n\n    if (!result && onTouchEvent(event)) {\n        result = true;\n    }\n\n    ... // 省略代码\n\n    return result;\n}\n```\n","slug":"Android/Framework/事件分发机制","published":1,"updated":"2021-11-17T05:09:11.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno980051g0je9yaazbhf","content":"<h1 id=\"事件分发机制\"><a href=\"#事件分发机制\" class=\"headerlink\" title=\"事件分发机制\"></a>事件分发机制</h1><h2 id=\"dispatchTouchEvent\"><a href=\"#dispatchTouchEvent\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h2><a id=\"more\"></a><h3 id=\"ViewGroup-的-dispatchTouchEvent-方法\"><a href=\"#ViewGroup-的-dispatchTouchEvent-方法\" class=\"headerlink\" title=\"ViewGroup 的 dispatchTouchEvent 方法\"></a>ViewGroup 的 dispatchTouchEvent 方法</h3><h4 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> consume = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (onInterceptTouchEvent(ev))&#123;</span><br><span class=\"line\">        consume = <span class=\"keyword\">super</span>.dispatchTouchEvent();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        consume = child.dispatchTouchEvent(ev);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!consume)</span><br><span class=\"line\">            consume = <span class=\"keyword\">super</span>.dispatchTouchEvent(ev)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> consume;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：<br>在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><h5 id=\"dispatchTouchEvent-1\"><a href=\"#dispatchTouchEvent-1\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Handle an initial down.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class=\"line\">    <span class=\"comment\">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class=\"line\">    <span class=\"comment\">// due to an app switch, ANR, or some other state change.</span></span><br><span class=\"line\">    <span class=\"comment\">// 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null</span></span><br><span class=\"line\">    cancelAndClearTouchTargets(ev);</span><br><span class=\"line\">    resetTouchState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for interception.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> intercepted;</span><br><span class=\"line\"><span class=\"comment\">// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素</span></span><br><span class=\"line\"><span class=\"comment\">// mFirstTouchTarget赋值在addTouchTarget方法中</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!disallowIntercept) &#123;</span><br><span class=\"line\">        intercepted = onInterceptTouchEvent(ev);</span><br><span class=\"line\">        ev.setAction(action); <span class=\"comment\">// restore action in case it was changed</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        intercepted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// mFirstTouchTarget == null, 并且这不是一个down事件, 说明</span></span><br><span class=\"line\">    <span class=\"comment\">// down事件没有被ViewGroup拦击, down事件也没有被子view消费, </span></span><br><span class=\"line\">    <span class=\"comment\">// 后续的事件也没有被子View消费, 所以后续的事件交给ViewGroup</span></span><br><span class=\"line\">    intercepted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.... <span class=\"comment\">//省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for cancelation.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> canceled = resetCancelNextUpFlag(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class=\"line\"><span class=\"comment\">// Update list of touch targets for pointer down, if needed.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class=\"number\">0</span>;</span><br><span class=\"line\">TouchTarget newTouchTarget = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">    ... <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">        newTouchTarget = getTouchTarget(child);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Child is already receiving touch within its bounds.</span></span><br><span class=\"line\">            <span class=\"comment\">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class=\"line\">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, <span class=\"keyword\">false</span>, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Child wants to receive touch within its bounds.</span></span><br><span class=\"line\">            <span class=\"comment\">// 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">            .... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class=\"line\">            alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">//省略代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dispatch to touch targets.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// No touch targets so treat this as an ordinary view.</span></span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"dispatchTransformedTouchEvent\"><a href=\"#dispatchTransformedTouchEvent\" class=\"headerlink\" title=\"dispatchTransformedTouchEvent\"></a>dispatchTransformedTouchEvent</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTransformedTouchEvent</span><span class=\"params\">(MotionEvent event, <span class=\"keyword\">boolean</span> cancel,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            View child, <span class=\"keyword\">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> handled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldAction = event.getAction();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class=\"line\">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            handled = <span class=\"keyword\">super</span>.dispatchTouchEvent(event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        event.setAction(oldAction);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"mFirstTarget\"><a href=\"#mFirstTarget\" class=\"headerlink\" title=\"mFirstTarget\"></a>mFirstTarget</h5><p>mFirstTouchTarget 是一个 TouchTarget 对象，通过注释的说明：”触摸目标的链接列表中的第一个触摸目标”，可以得出：mFirstTouchTarget 是”触摸目标”链表的头部。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class=\"line\">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childrenCount = mChildrenCount;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTouchTarget == <span class=\"keyword\">null</span> &amp;&amp; childrenCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class=\"line\">                        childrenCount, i, customOrder);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> View child = getAndVerifyPreorderedView(</span><br><span class=\"line\">                        preorderedList, children, childIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, <span class=\"keyword\">false</span>, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class=\"line\">                    alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class=\"line\">                    target.child, target.pointerIdBits)) &#123;</span><br><span class=\"line\">        handled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>addTouchTarget(..) 方法是 mFirstTouchTarget 赋值的地方。 </p>\n<p>我们看 dispatchTouchEvent 中 mFirstTouchTarget 的使用。发现它只在 MotionEvent.ACTION_DOWN 事件的时候赋值。</p>\n<p>然后所有的事件都会判断 mFirstTouchTarget 是否为 null ，为 null 则有 ViewGroup 处理， 不为 null 则由 mFirstTouchTarget 对应的 子view 处理。<br>由此也就可以得出结论： 如果 子view 消费了 TOUCH_DOWN 事件，后续的事件，如果 ViewGroup 不拦截，则都交给这个 子View 消费。<strong>因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。</strong> 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, dispatchTouchEvent 直接返回 false</p>\n<h5 id=\"addTouchTarget\"><a href=\"#addTouchTarget\" class=\"headerlink\" title=\"addTouchTarget\"></a>addTouchTarget</h5><p><strong>mFirstTarget 赋值的地方</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> TouchTarget <span class=\"title\">addTouchTarget</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class=\"line\">    target.next = mFirstTouchTarget;</span><br><span class=\"line\">    mFirstTouchTarget = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h4><h5 id=\"ActionDown\"><a href=\"#ActionDown\" class=\"headerlink\" title=\"ActionDown\"></a>ActionDown</h5><ul>\n<li>ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理</li>\n<li>ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位</li>\n</ul>\n<h5 id=\"ActionMove、ActionUp-等其他事件\"><a href=\"#ActionMove、ActionUp-等其他事件\" class=\"headerlink\" title=\"ActionMove、ActionUp 等其他事件\"></a>ActionMove、ActionUp 等其他事件</h5><ul>\n<li>若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截</li>\n<li>若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理。 ( 因为mFirstTouchTarget==null)</li>\n</ul>\n<p>(以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到)</p>\n<h5 id=\"requestDisallowInterceptTouchEvent-true\"><a href=\"#requestDisallowInterceptTouchEvent-true\" class=\"headerlink\" title=\"requestDisallowInterceptTouchEvent(true)\"></a>requestDisallowInterceptTouchEvent(true)</h5><ul>\n<li>子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。</li>\n<li>但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位</li>\n</ul>\n<h5 id=\"mFirstTouchTarget\"><a href=\"#mFirstTouchTarget\" class=\"headerlink\" title=\"mFirstTouchTarget\"></a>mFirstTouchTarget</h5><p><strong>因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。</strong> 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, ViewGroup 的 dispatchTouchEvent 直接返回 false</p>\n<h2 id=\"View-的-dispatchTouchEvent-方法\"><a href=\"#View-的-dispatchTouchEvent-方法\" class=\"headerlink\" title=\"View 的 dispatchTouchEvent 方法\"></a>View 的 dispatchTouchEvent 方法</h2><p>如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnTouchListener != <span class=\"keyword\">null</span></span><br><span class=\"line\">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class=\"line\">            &amp;&amp; li.mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"事件分发机制\"><a href=\"#事件分发机制\" class=\"headerlink\" title=\"事件分发机制\"></a>事件分发机制</h1><h2 id=\"dispatchTouchEvent\"><a href=\"#dispatchTouchEvent\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h2>","more":"<h3 id=\"ViewGroup-的-dispatchTouchEvent-方法\"><a href=\"#ViewGroup-的-dispatchTouchEvent-方法\" class=\"headerlink\" title=\"ViewGroup 的 dispatchTouchEvent 方法\"></a>ViewGroup 的 dispatchTouchEvent 方法</h3><h4 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> consume = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (onInterceptTouchEvent(ev))&#123;</span><br><span class=\"line\">        consume = <span class=\"keyword\">super</span>.dispatchTouchEvent();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        consume = child.dispatchTouchEvent(ev);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!consume)</span><br><span class=\"line\">            consume = <span class=\"keyword\">super</span>.dispatchTouchEvent(ev)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> consume;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释：<br>在 dispatchTouchEvent 方法中，onInterceptTouchEvent 方法会判断当前 ViewGroup 是否会拦截，若拦截，则交给自己处理，若不拦截，则交给子 view。若子 view 不能处理，则还是由自己来处理</p>\n<h4 id=\"源代码\"><a href=\"#源代码\" class=\"headerlink\" title=\"源代码\"></a>源代码</h4><h5 id=\"dispatchTouchEvent-1\"><a href=\"#dispatchTouchEvent-1\" class=\"headerlink\" title=\"dispatchTouchEvent\"></a>dispatchTouchEvent</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Handle an initial down.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class=\"line\">    <span class=\"comment\">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class=\"line\">    <span class=\"comment\">// due to an app switch, ANR, or some other state change.</span></span><br><span class=\"line\">    <span class=\"comment\">// 在action_down事件时, 会重置所有的标志位, mFirstTouchTarget会置为null</span></span><br><span class=\"line\">    cancelAndClearTouchTargets(ev);</span><br><span class=\"line\">    resetTouchState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for interception.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> intercepted;</span><br><span class=\"line\"><span class=\"comment\">// mFirstTouchTarget：子元素成功处理时，mFirstTouchTarget会被赋值病指向子元素</span></span><br><span class=\"line\"><span class=\"comment\">// mFirstTouchTarget赋值在addTouchTarget方法中</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!disallowIntercept) &#123;</span><br><span class=\"line\">        intercepted = onInterceptTouchEvent(ev);</span><br><span class=\"line\">        ev.setAction(action); <span class=\"comment\">// restore action in case it was changed</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        intercepted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// mFirstTouchTarget == null, 并且这不是一个down事件, 说明</span></span><br><span class=\"line\">    <span class=\"comment\">// down事件没有被ViewGroup拦击, down事件也没有被子view消费, </span></span><br><span class=\"line\">    <span class=\"comment\">// 后续的事件也没有被子View消费, 所以后续的事件交给ViewGroup</span></span><br><span class=\"line\">    intercepted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.... <span class=\"comment\">//省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Check for cancelation.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> canceled = resetCancelNextUpFlag(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class=\"line\"><span class=\"comment\">// Update list of touch targets for pointer down, if needed.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class=\"number\">0</span>;</span><br><span class=\"line\">TouchTarget newTouchTarget = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">    ... <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">        newTouchTarget = getTouchTarget(child);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTouchTarget != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Child is already receiving touch within its bounds.</span></span><br><span class=\"line\">            <span class=\"comment\">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class=\"line\">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, <span class=\"keyword\">false</span>, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Child wants to receive touch within its bounds.</span></span><br><span class=\"line\">            <span class=\"comment\">// 子view消费了这个事件, 更新mFirstTouchTarget, 跳出循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">            .... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class=\"line\">            alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">//省略代码</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 省略部分代码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Dispatch to touch targets.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// No touch targets so treat this as an ordinary view.</span></span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"dispatchTransformedTouchEvent\"><a href=\"#dispatchTransformedTouchEvent\" class=\"headerlink\" title=\"dispatchTransformedTouchEvent\"></a>dispatchTransformedTouchEvent</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTransformedTouchEvent</span><span class=\"params\">(MotionEvent event, <span class=\"keyword\">boolean</span> cancel,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            View child, <span class=\"keyword\">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> handled;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在这里，如果child参数为null，则super.xxx交给ViewGroup自己处理;如果child不为空,则交给child处理</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> oldAction = event.getAction();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class=\"line\">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            handled = <span class=\"keyword\">super</span>.dispatchTouchEvent(event);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            handled = child.dispatchTouchEvent(event);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        event.setAction(oldAction);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> handled;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"mFirstTarget\"><a href=\"#mFirstTarget\" class=\"headerlink\" title=\"mFirstTarget\"></a>mFirstTarget</h5><p>mFirstTouchTarget 是一个 TouchTarget 对象，通过注释的说明：”触摸目标的链接列表中的第一个触摸目标”，可以得出：mFirstTouchTarget 是”触摸目标”链表的头部。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class=\"line\">            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class=\"line\">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childrenCount = mChildrenCount;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (newTouchTarget == <span class=\"keyword\">null</span> &amp;&amp; childrenCount != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = childrenCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class=\"line\">                        childrenCount, i, customOrder);</span><br><span class=\"line\">                <span class=\"keyword\">final</span> View child = getAndVerifyPreorderedView(</span><br><span class=\"line\">                        preorderedList, children, childIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, <span class=\"keyword\">false</span>, child, idBitsToAssign)) &#123;</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class=\"line\">                    alreadyDispatchedToNewTouchTarget = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (mFirstTouchTarget == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class=\"keyword\">null</span>,</span><br><span class=\"line\">            TouchTarget.ALL_POINTER_IDS);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class=\"line\">                    target.child, target.pointerIdBits)) &#123;</span><br><span class=\"line\">        handled = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>addTouchTarget(..) 方法是 mFirstTouchTarget 赋值的地方。 </p>\n<p>我们看 dispatchTouchEvent 中 mFirstTouchTarget 的使用。发现它只在 MotionEvent.ACTION_DOWN 事件的时候赋值。</p>\n<p>然后所有的事件都会判断 mFirstTouchTarget 是否为 null ，为 null 则有 ViewGroup 处理， 不为 null 则由 mFirstTouchTarget 对应的 子view 处理。<br>由此也就可以得出结论： 如果 子view 消费了 TOUCH_DOWN 事件，后续的事件，如果 ViewGroup 不拦截，则都交给这个 子View 消费。<strong>因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。</strong> 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, dispatchTouchEvent 直接返回 false</p>\n<h5 id=\"addTouchTarget\"><a href=\"#addTouchTarget\" class=\"headerlink\" title=\"addTouchTarget\"></a>addTouchTarget</h5><p><strong>mFirstTarget 赋值的地方</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> TouchTarget <span class=\"title\">addTouchTarget</span><span class=\"params\">(@NonNull View child, <span class=\"keyword\">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class=\"line\">    target.next = mFirstTouchTarget;</span><br><span class=\"line\">    mFirstTouchTarget = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"需要注意的点\"><a href=\"#需要注意的点\" class=\"headerlink\" title=\"需要注意的点\"></a>需要注意的点</h4><h5 id=\"ActionDown\"><a href=\"#ActionDown\" class=\"headerlink\" title=\"ActionDown\"></a>ActionDown</h5><ul>\n<li>ActionDown 事件是一个事件序列的开始。当 ActionDown 事件被 ViewGroup 拦截，则这个事件剩下的事件将不会通过 onInterceptTouchEvent 方法，而是直接交给 ViewGroup 处理</li>\n<li>ActionDown 事件一定会经过 onInterceptTouchEvent 方法, 并且在 dispatchTouchEvent 方法中每次都会触发重置标志位</li>\n</ul>\n<h5 id=\"ActionMove、ActionUp-等其他事件\"><a href=\"#ActionMove、ActionUp-等其他事件\" class=\"headerlink\" title=\"ActionMove、ActionUp 等其他事件\"></a>ActionMove、ActionUp 等其他事件</h5><ul>\n<li>若 ActionDown 没有被 ViewGroup 拦截, 而是被子 view 消费, 则这个事件序列的其他事件每次都会经过 ViewGroup 的 onInterceptTouchEvent 方法判断是否拦截</li>\n<li>若 ActionDown 没有被 ViewGroup 拦截, 也没有被子 View 消费, 则这个事件序列的其他事件不会经过 onInterceptTouchEvent 方法, 而是直接交给 ViewGroup 处理。 ( 因为mFirstTouchTarget==null)</li>\n</ul>\n<p>(以上结论是分析源代码, onInterceptTouchEvent 的执行判断条件, 推断得到)</p>\n<h5 id=\"requestDisallowInterceptTouchEvent-true\"><a href=\"#requestDisallowInterceptTouchEvent-true\" class=\"headerlink\" title=\"requestDisallowInterceptTouchEvent(true)\"></a>requestDisallowInterceptTouchEvent(true)</h5><ul>\n<li>子 View 可以调用父 ViewGroup 的 requestDisallowInterceptTouchEvent(true)屏蔽父 ViewGroup 的拦截(会添加 FLAG_DISALLOW_INTERCEPT 标志)。</li>\n<li>但是，这个这种操作对 ActionDown 事件无效。因为每次 ActionDown 事件来到 ViewGruop 的 dispatch 时，会 reset 所有的标志位</li>\n</ul>\n<h5 id=\"mFirstTouchTarget\"><a href=\"#mFirstTouchTarget\" class=\"headerlink\" title=\"mFirstTouchTarget\"></a>mFirstTouchTarget</h5><p><strong>因为mFirstTouchTarget只有在TOUCH_DOWN事件才会赋值。</strong> 如果这个 子view 对后续的某个事件不消费(onTouchEvent返回false) , 那 ViewGroup 也不会尝试消费这个事件, ViewGroup 的 dispatchTouchEvent 直接返回 false</p>\n<h2 id=\"View-的-dispatchTouchEvent-方法\"><a href=\"#View-的-dispatchTouchEvent-方法\" class=\"headerlink\" title=\"View 的 dispatchTouchEvent 方法\"></a>View 的 dispatchTouchEvent 方法</h2><p>如果有 onTouchListener，优先执行 onTouch 方法，如果 onTouch 方法返回 true，则不执行 onTouchEvent 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dispatchTouchEvent</span><span class=\"params\">(MotionEvent event)</span> </span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnTouchListener != <span class=\"keyword\">null</span></span><br><span class=\"line\">            &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class=\"line\">            &amp;&amp; li.mOnTouchListener.onTouch(<span class=\"keyword\">this</span>, event)) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"InputManagerService","date":"2021-10-18T13:31:03.000Z","_content":"\n## native层概述\n\n### InputReader \n\n输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。\n\nInputReader 持有 InputMapper 对应不同的输入设备的 事件加工器。 \n\n事件加工后，InputReader 会 调用 InputDispatcher.notifyXXX 函数 唤醒 InputDispatcher 进行事件分发\n\n### InputDispatcher\n\n输入事件的分发者。 分发输入事件到目标窗口。 运行在 InputDispatcherThread 中， 这个线程平时是休眠状态，等待 InputReader 的唤醒\n\n被唤醒后，调用 dispatchOnceInnerLocked 将输入事件分发到合适的窗口中\n\n","source":"_posts/Android/Framework/InputManagerService.md","raw":"---\ntitle: InputManagerService\ndate: 2021-10-18 21:31:03\ntags:\n---\n\n## native层概述\n\n### InputReader \n\n输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。\n\nInputReader 持有 InputMapper 对应不同的输入设备的 事件加工器。 \n\n事件加工后，InputReader 会 调用 InputDispatcher.notifyXXX 函数 唤醒 InputDispatcher 进行事件分发\n\n### InputDispatcher\n\n输入事件的分发者。 分发输入事件到目标窗口。 运行在 InputDispatcherThread 中， 这个线程平时是休眠状态，等待 InputReader 的唤醒\n\n被唤醒后，调用 dispatchOnceInnerLocked 将输入事件分发到合适的窗口中\n\n","slug":"Android/Framework/InputManagerService","published":1,"updated":"2021-10-18T14:01:44.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9l005ig0jeegfutttj","content":"<h2 id=\"native层概述\"><a href=\"#native层概述\" class=\"headerlink\" title=\"native层概述\"></a>native层概述</h2><h3 id=\"InputReader\"><a href=\"#InputReader\" class=\"headerlink\" title=\"InputReader\"></a>InputReader</h3><p>输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。</p><a id=\"more\"></a>\n<p>InputReader 持有 InputMapper 对应不同的输入设备的 事件加工器。 </p>\n<p>事件加工后，InputReader 会 调用 InputDispatcher.notifyXXX 函数 唤醒 InputDispatcher 进行事件分发</p>\n<h3 id=\"InputDispatcher\"><a href=\"#InputDispatcher\" class=\"headerlink\" title=\"InputDispatcher\"></a>InputDispatcher</h3><p>输入事件的分发者。 分发输入事件到目标窗口。 运行在 InputDispatcherThread 中， 这个线程平时是休眠状态，等待 InputReader 的唤醒</p>\n<p>被唤醒后，调用 dispatchOnceInnerLocked 将输入事件分发到合适的窗口中</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"native层概述\"><a href=\"#native层概述\" class=\"headerlink\" title=\"native层概述\"></a>native层概述</h2><h3 id=\"InputReader\"><a href=\"#InputReader\" class=\"headerlink\" title=\"InputReader\"></a>InputReader</h3><p>输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。</p>","more":"\n<p>InputReader 持有 InputMapper 对应不同的输入设备的 事件加工器。 </p>\n<p>事件加工后，InputReader 会 调用 InputDispatcher.notifyXXX 函数 唤醒 InputDispatcher 进行事件分发</p>\n<h3 id=\"InputDispatcher\"><a href=\"#InputDispatcher\" class=\"headerlink\" title=\"InputDispatcher\"></a>InputDispatcher</h3><p>输入事件的分发者。 分发输入事件到目标窗口。 运行在 InputDispatcherThread 中， 这个线程平时是休眠状态，等待 InputReader 的唤醒</p>\n<p>被唤醒后，调用 dispatchOnceInnerLocked 将输入事件分发到合适的窗口中</p>\n"},{"title":"MultiDex原理","date":"2021-12-25T10:20:52.000Z","_content":"\napk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535. \n为了规避安卓项目编译65536最大方法数的限制，需要做分dex\n\n## 1. Dalvik 和 ART 虚拟机的区别\n\nAndroid5.0以上系统使用 ART 虚拟机，5.0以下使用 Dalvik 虚拟机\n\nDalvik 编译策略是 JIT 技术。JIT意思是Just In Time Compiler，就是即时编译技术。 \nJIT是运行时编译，是动态编译，可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间可以加快Dalvik运行速度。每次运行都需要重新编译。\n\nAOT是指\"Ahead Of Time\"，与\"Just In Time\"不同，从字面来看是说提前编译。\nAOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex预编译，一次性将所有dex代码转换为机器码，每次运行程序的时候不用重新编译。 \n\n\nAndroid 7.0上，JIT 编译器被再次使用，采用AOT/JIT 混合编译的策略，特点是：\n\n应用在安装的时候dex不会再被编译\nApp运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息。\n手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译\n\n## 2. 不同虚拟机在 MultiDex 的区别。 \n\n* Andorid 5.0 之后，ART天然支持从apk文件中加载多个.dex文件，在应用安装期间，它会执行一个预编译操作。将所有的dex编译成一个单一的.oat文件，在应用运行是去加载这个.oat文件，而不是一个一个的加载.dex文件。\n  所以我们只需要 在 gradle 开启 multiDexEnabled true 即可\n* Dalvik 使用的 JIT ，JIT每次运行都需要重新编译。 所以我们需要在应用启动时手动去一个一个加载 dex 文件\n\n## 3. 在 Dalvik 加载多dex\n\n简单来说 hook PathClassLoader 。\n1. 获取到所有的dex文件\n2. 通过反射拿到DexPathList的Element数组，把dex添加到 Element数组中\n\n通过这样的方式也可以实现热热修复，将修改后的新class打包成一个dex， 然后通过反射将 新dex插入到 PathClassLoader 中的 element数组最前面。从而实现对旧类的覆盖\n","source":"_posts/Android/Framework/MultiDex原理.md","raw":"---\ntitle: MultiDex原理\ndate: 2021-12-25 18:20:52\ntags:\n---\n\napk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535. \n为了规避安卓项目编译65536最大方法数的限制，需要做分dex\n\n## 1. Dalvik 和 ART 虚拟机的区别\n\nAndroid5.0以上系统使用 ART 虚拟机，5.0以下使用 Dalvik 虚拟机\n\nDalvik 编译策略是 JIT 技术。JIT意思是Just In Time Compiler，就是即时编译技术。 \nJIT是运行时编译，是动态编译，可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间可以加快Dalvik运行速度。每次运行都需要重新编译。\n\nAOT是指\"Ahead Of Time\"，与\"Just In Time\"不同，从字面来看是说提前编译。\nAOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex预编译，一次性将所有dex代码转换为机器码，每次运行程序的时候不用重新编译。 \n\n\nAndroid 7.0上，JIT 编译器被再次使用，采用AOT/JIT 混合编译的策略，特点是：\n\n应用在安装的时候dex不会再被编译\nApp运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息。\n手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译\n\n## 2. 不同虚拟机在 MultiDex 的区别。 \n\n* Andorid 5.0 之后，ART天然支持从apk文件中加载多个.dex文件，在应用安装期间，它会执行一个预编译操作。将所有的dex编译成一个单一的.oat文件，在应用运行是去加载这个.oat文件，而不是一个一个的加载.dex文件。\n  所以我们只需要 在 gradle 开启 multiDexEnabled true 即可\n* Dalvik 使用的 JIT ，JIT每次运行都需要重新编译。 所以我们需要在应用启动时手动去一个一个加载 dex 文件\n\n## 3. 在 Dalvik 加载多dex\n\n简单来说 hook PathClassLoader 。\n1. 获取到所有的dex文件\n2. 通过反射拿到DexPathList的Element数组，把dex添加到 Element数组中\n\n通过这样的方式也可以实现热热修复，将修改后的新class打包成一个dex， 然后通过反射将 新dex插入到 PathClassLoader 中的 element数组最前面。从而实现对旧类的覆盖\n","slug":"Android/Framework/MultiDex原理","published":1,"updated":"2021-12-25T11:04:06.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9l005jg0je9bxfs5dj","content":"<p>apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.<br>为了规避安卓项目编译65536最大方法数的限制，需要做分dex</p><a id=\"more\"></a>\n<h2 id=\"1-Dalvik-和-ART-虚拟机的区别\"><a href=\"#1-Dalvik-和-ART-虚拟机的区别\" class=\"headerlink\" title=\"1. Dalvik 和 ART 虚拟机的区别\"></a>1. Dalvik 和 ART 虚拟机的区别</h2><p>Android5.0以上系统使用 ART 虚拟机，5.0以下使用 Dalvik 虚拟机</p>\n<p>Dalvik 编译策略是 JIT 技术。JIT意思是Just In Time Compiler，就是即时编译技术。<br>JIT是运行时编译，是动态编译，可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间可以加快Dalvik运行速度。每次运行都需要重新编译。</p>\n<p>AOT是指”Ahead Of Time”，与”Just In Time”不同，从字面来看是说提前编译。<br>AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex预编译，一次性将所有dex代码转换为机器码，每次运行程序的时候不用重新编译。 </p>\n<p>Android 7.0上，JIT 编译器被再次使用，采用AOT/JIT 混合编译的策略，特点是：</p>\n<p>应用在安装的时候dex不会再被编译<br>App运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息。<br>手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译</p>\n<h2 id=\"2-不同虚拟机在-MultiDex-的区别。\"><a href=\"#2-不同虚拟机在-MultiDex-的区别。\" class=\"headerlink\" title=\"2. 不同虚拟机在 MultiDex 的区别。\"></a>2. 不同虚拟机在 MultiDex 的区别。</h2><ul>\n<li>Andorid 5.0 之后，ART天然支持从apk文件中加载多个.dex文件，在应用安装期间，它会执行一个预编译操作。将所有的dex编译成一个单一的.oat文件，在应用运行是去加载这个.oat文件，而不是一个一个的加载.dex文件。<br>所以我们只需要 在 gradle 开启 multiDexEnabled true 即可</li>\n<li>Dalvik 使用的 JIT ，JIT每次运行都需要重新编译。 所以我们需要在应用启动时手动去一个一个加载 dex 文件</li>\n</ul>\n<h2 id=\"3-在-Dalvik-加载多dex\"><a href=\"#3-在-Dalvik-加载多dex\" class=\"headerlink\" title=\"3. 在 Dalvik 加载多dex\"></a>3. 在 Dalvik 加载多dex</h2><p>简单来说 hook PathClassLoader 。</p>\n<ol>\n<li>获取到所有的dex文件</li>\n<li>通过反射拿到DexPathList的Element数组，把dex添加到 Element数组中</li>\n</ol>\n<p>通过这样的方式也可以实现热热修复，将修改后的新class打包成一个dex， 然后通过反射将 新dex插入到 PathClassLoader 中的 element数组最前面。从而实现对旧类的覆盖</p>\n","site":{"data":{}},"excerpt":"<p>apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.<br>为了规避安卓项目编译65536最大方法数的限制，需要做分dex</p>","more":"\n<h2 id=\"1-Dalvik-和-ART-虚拟机的区别\"><a href=\"#1-Dalvik-和-ART-虚拟机的区别\" class=\"headerlink\" title=\"1. Dalvik 和 ART 虚拟机的区别\"></a>1. Dalvik 和 ART 虚拟机的区别</h2><p>Android5.0以上系统使用 ART 虚拟机，5.0以下使用 Dalvik 虚拟机</p>\n<p>Dalvik 编译策略是 JIT 技术。JIT意思是Just In Time Compiler，就是即时编译技术。<br>JIT是运行时编译，是动态编译，可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间可以加快Dalvik运行速度。每次运行都需要重新编译。</p>\n<p>AOT是指”Ahead Of Time”，与”Just In Time”不同，从字面来看是说提前编译。<br>AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex预编译，一次性将所有dex代码转换为机器码，每次运行程序的时候不用重新编译。 </p>\n<p>Android 7.0上，JIT 编译器被再次使用，采用AOT/JIT 混合编译的策略，特点是：</p>\n<p>应用在安装的时候dex不会再被编译<br>App运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息。<br>手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译</p>\n<h2 id=\"2-不同虚拟机在-MultiDex-的区别。\"><a href=\"#2-不同虚拟机在-MultiDex-的区别。\" class=\"headerlink\" title=\"2. 不同虚拟机在 MultiDex 的区别。\"></a>2. 不同虚拟机在 MultiDex 的区别。</h2><ul>\n<li>Andorid 5.0 之后，ART天然支持从apk文件中加载多个.dex文件，在应用安装期间，它会执行一个预编译操作。将所有的dex编译成一个单一的.oat文件，在应用运行是去加载这个.oat文件，而不是一个一个的加载.dex文件。<br>所以我们只需要 在 gradle 开启 multiDexEnabled true 即可</li>\n<li>Dalvik 使用的 JIT ，JIT每次运行都需要重新编译。 所以我们需要在应用启动时手动去一个一个加载 dex 文件</li>\n</ul>\n<h2 id=\"3-在-Dalvik-加载多dex\"><a href=\"#3-在-Dalvik-加载多dex\" class=\"headerlink\" title=\"3. 在 Dalvik 加载多dex\"></a>3. 在 Dalvik 加载多dex</h2><p>简单来说 hook PathClassLoader 。</p>\n<ol>\n<li>获取到所有的dex文件</li>\n<li>通过反射拿到DexPathList的Element数组，把dex添加到 Element数组中</li>\n</ol>\n<p>通过这样的方式也可以实现热热修复，将修改后的新class打包成一个dex， 然后通过反射将 新dex插入到 PathClassLoader 中的 element数组最前面。从而实现对旧类的覆盖</p>\n"},{"title":"gradle相关基础","date":"2020-06-18T11:54:57.000Z","_content":"\n## Gradle中的对象\nGradle主要有三种对象\n这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：\n\n* Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。\n* Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。\n* Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。\n\n构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。\n\n## setting.gradle\n\n```groovy\ninclude ':app', ':progect_1', ':progect_2'\n```\n用于指示 Gradle 在构建应用时应将哪些模块包括在内\n\n## gradle.properties\n\n里面可以定义一些常量供build.gradle使用，如版本号等.\n然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。\n\n```groovy\nCOMPILE_SDK_VERSION = 23\nBUILD_TOOLS_VERSION = 23.0.1\nVERSION_CODE = 1\n```\n\n## build.gradle\nbuild文件有两种，一个是针对当前的Module，一个是针对项目中所有的module\n在顶层的build文件中，我们可以来添加一些子module所共有的一些配置\n\n下面是一些常用的build.gradle的配置说明\n```groovy\n// 应用android官方插件，module中的build.gradle很多配置都是插件提供的支持\n// 'com.android.application' 代表app主工程，\n// 如果是子工程应该使用 'com.android.library'\napply plugin: 'com.android.application'\n\n// 仓库， \nbuildscript{\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath '' // 声明插件名称和版本号\n    }\n}\n// 外部依赖，添加的依赖会在这些配置的仓库中去寻找\ndependencies {\n    // \"group:name:version\"\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n}\n\n// 所有子工程的仓库地址\nallprojects {\n    repositories {\n        maven { url uri('/Users/bytedance/code/test/repo') }\n        google()\n        mavenCentral()\n    }\n}\n\n```\n\n**为什么`buildscript`和`allpojectes`都有`repositories`**\n* buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。\n* allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。比如用到的Glide/OkHttp等\n* 子项目可以配置自己的repositories以获取自己独需的依赖包。\n\n## Task\n\n包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。\n\n* depandsOn: 依赖于其它任务\n* doFirst, doLast(<<): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作\n\napply的插件自带和很多Task，在Gradle页面的 `<项目名>/Tasks/build` 目录里面可以看到。\n我们也可以自己编写任务，自己的Task在Gradle页面的 `<项目名>/Tasks/other/` 目录里可以查找到\n\n\n## Gradle的工作流程\n\n![gradle的工作流程](/images/gradle的构建过程.jpg)\n\n* Initialization: 初始化，在多模块的项目中，就是执行settings.gradle\n* Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。  Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。\n* Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段\n\n简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。\n在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！\n\n在每一步的步骤中间可以添加hook\n\n\n\n```java\n\ntask a {\n    println 'this is a'\n    doFirst {\n        println 'this is a do first'\n    }\n    doLast {\n        println \"this is a do last\"\n    }\n}\n\ntask testBoth {\n    // 配置阶段\n    // 依赖 a task 先执行\n    dependsOn(\"a\")\n    println 'this is b'\n    doFirst {\n        // 执行阶段\n        println 'this is b first'\n    }\n    doLast {\n        // 执行阶段\n        println 'this is b last'\n    }\n}\n/**\n输出：\n\n> Configure project :\nthis is a\nthis is b\n\n> Task :a\nthis is a do first\nthis is a do last\n\n> Task :testBoth\nthis is b first\nthis is b last\n*/\n```\n\n## 解决依赖版本冲突\n\n大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。\n\n以下是我们自己解决版本冲突的一般步骤\n\n### 查看依赖报告\n运行Gradle， `<项目名称>/app/Tasks/dependencies/` 查看依赖报告，输出如下\n\n`xxxx -> xxxx` 表示依赖包自动提升到了最高版本\n\n```\n+--- androidx.lifecycle:lifecycle-extensions:2.1.0\n|    +--- androidx.lifecycle:lifecycle-runtime:2.1.0\n|    |    +--- androidx.lifecycle:lifecycle-common:2.1.0 -> 2.3.0-alpha01\n|    |    |    \\--- androidx.annotation:annotation:1.1.0\n|    |    +--- androidx.arch.core:core-common:2.1.0\n|    |    |    \\--- androidx.annotation:annotation:1.1.0\n|    |    \\--- androidx.annotation:annotation:1.1.0\n|    +--- androidx.arch.core:core-common:2.1.0 (*)\n|    +--- androidx.arch.core:core-runtime:2.1.0\n\n```\n\n### 排除传递性冲突\n\n```groovy\ncompile ('cn.qqtheme.framework:WheelPicker:1.5.1'){\n    exclude group:'com.android.support', module:\"appcompat\"\n}\n```\n\n### 强制一个版本\n```groovy\nconfigurations.all{\n    resolutionStrategy{\n        force 'androidx.appcompat:appcompat:1.1.0'\n    }\n}\n```","source":"_posts/Android/gradle/gradle相关基础.md","raw":"---\ntitle: gradle相关基础\ndate: 2020-06-18 19:54:57\ntags: \n- Gradle\ncategories:\n- Android\n---\n\n## Gradle中的对象\nGradle主要有三种对象\n这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：\n\n* Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。\n* Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。\n* Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。\n\n构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。\n\n## setting.gradle\n\n```groovy\ninclude ':app', ':progect_1', ':progect_2'\n```\n用于指示 Gradle 在构建应用时应将哪些模块包括在内\n\n## gradle.properties\n\n里面可以定义一些常量供build.gradle使用，如版本号等.\n然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。\n\n```groovy\nCOMPILE_SDK_VERSION = 23\nBUILD_TOOLS_VERSION = 23.0.1\nVERSION_CODE = 1\n```\n\n## build.gradle\nbuild文件有两种，一个是针对当前的Module，一个是针对项目中所有的module\n在顶层的build文件中，我们可以来添加一些子module所共有的一些配置\n\n下面是一些常用的build.gradle的配置说明\n```groovy\n// 应用android官方插件，module中的build.gradle很多配置都是插件提供的支持\n// 'com.android.application' 代表app主工程，\n// 如果是子工程应该使用 'com.android.library'\napply plugin: 'com.android.application'\n\n// 仓库， \nbuildscript{\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath '' // 声明插件名称和版本号\n    }\n}\n// 外部依赖，添加的依赖会在这些配置的仓库中去寻找\ndependencies {\n    // \"group:name:version\"\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n}\n\n// 所有子工程的仓库地址\nallprojects {\n    repositories {\n        maven { url uri('/Users/bytedance/code/test/repo') }\n        google()\n        mavenCentral()\n    }\n}\n\n```\n\n**为什么`buildscript`和`allpojectes`都有`repositories`**\n* buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。\n* allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。比如用到的Glide/OkHttp等\n* 子项目可以配置自己的repositories以获取自己独需的依赖包。\n\n## Task\n\n包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。\n\n* depandsOn: 依赖于其它任务\n* doFirst, doLast(<<): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作\n\napply的插件自带和很多Task，在Gradle页面的 `<项目名>/Tasks/build` 目录里面可以看到。\n我们也可以自己编写任务，自己的Task在Gradle页面的 `<项目名>/Tasks/other/` 目录里可以查找到\n\n\n## Gradle的工作流程\n\n![gradle的工作流程](/images/gradle的构建过程.jpg)\n\n* Initialization: 初始化，在多模块的项目中，就是执行settings.gradle\n* Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。  Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。\n* Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段\n\n简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。\n在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！\n\n在每一步的步骤中间可以添加hook\n\n\n\n```java\n\ntask a {\n    println 'this is a'\n    doFirst {\n        println 'this is a do first'\n    }\n    doLast {\n        println \"this is a do last\"\n    }\n}\n\ntask testBoth {\n    // 配置阶段\n    // 依赖 a task 先执行\n    dependsOn(\"a\")\n    println 'this is b'\n    doFirst {\n        // 执行阶段\n        println 'this is b first'\n    }\n    doLast {\n        // 执行阶段\n        println 'this is b last'\n    }\n}\n/**\n输出：\n\n> Configure project :\nthis is a\nthis is b\n\n> Task :a\nthis is a do first\nthis is a do last\n\n> Task :testBoth\nthis is b first\nthis is b last\n*/\n```\n\n## 解决依赖版本冲突\n\n大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。\n\n以下是我们自己解决版本冲突的一般步骤\n\n### 查看依赖报告\n运行Gradle， `<项目名称>/app/Tasks/dependencies/` 查看依赖报告，输出如下\n\n`xxxx -> xxxx` 表示依赖包自动提升到了最高版本\n\n```\n+--- androidx.lifecycle:lifecycle-extensions:2.1.0\n|    +--- androidx.lifecycle:lifecycle-runtime:2.1.0\n|    |    +--- androidx.lifecycle:lifecycle-common:2.1.0 -> 2.3.0-alpha01\n|    |    |    \\--- androidx.annotation:annotation:1.1.0\n|    |    +--- androidx.arch.core:core-common:2.1.0\n|    |    |    \\--- androidx.annotation:annotation:1.1.0\n|    |    \\--- androidx.annotation:annotation:1.1.0\n|    +--- androidx.arch.core:core-common:2.1.0 (*)\n|    +--- androidx.arch.core:core-runtime:2.1.0\n\n```\n\n### 排除传递性冲突\n\n```groovy\ncompile ('cn.qqtheme.framework:WheelPicker:1.5.1'){\n    exclude group:'com.android.support', module:\"appcompat\"\n}\n```\n\n### 强制一个版本\n```groovy\nconfigurations.all{\n    resolutionStrategy{\n        force 'androidx.appcompat:appcompat:1.1.0'\n    }\n}\n```","slug":"Android/gradle/gradle相关基础","published":1,"updated":"2022-03-20T08:26:36.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9m005kg0jesvvyerm6","content":"<h2 id=\"Gradle中的对象\"><a href=\"#Gradle中的对象\" class=\"headerlink\" title=\"Gradle中的对象\"></a>Gradle中的对象</h2><p>Gradle主要有三种对象<br>这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：</p><a id=\"more\"></a>\n<ul>\n<li>Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。</li>\n<li>Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。</li>\n<li>Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。</li>\n</ul>\n<p>构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。</p>\n<h2 id=\"setting-gradle\"><a href=\"#setting-gradle\" class=\"headerlink\" title=\"setting.gradle\"></a>setting.gradle</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">':app'</span>, <span class=\"string\">':progect_1'</span>, <span class=\"string\">':progect_2'</span></span><br></pre></td></tr></table></figure>\n<p>用于指示 Gradle 在构建应用时应将哪些模块包括在内</p>\n<h2 id=\"gradle-properties\"><a href=\"#gradle-properties\" class=\"headerlink\" title=\"gradle.properties\"></a>gradle.properties</h2><p>里面可以定义一些常量供build.gradle使用，如版本号等.<br>然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COMPILE_SDK_VERSION = <span class=\"number\">23</span></span><br><span class=\"line\">BUILD_TOOLS_VERSION = <span class=\"number\">23.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">VERSION_CODE = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"build-gradle\"><a href=\"#build-gradle\" class=\"headerlink\" title=\"build.gradle\"></a>build.gradle</h2><p>build文件有两种，一个是针对当前的Module，一个是针对项目中所有的module<br>在顶层的build文件中，我们可以来添加一些子module所共有的一些配置</p>\n<p>下面是一些常用的build.gradle的配置说明<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 应用android官方插件，module中的build.gradle很多配置都是插件提供的支持</span></span><br><span class=\"line\"><span class=\"comment\">// 'com.android.application' 代表app主工程，</span></span><br><span class=\"line\"><span class=\"comment\">// 如果是子工程应该使用 'com.android.library'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仓库， </span></span><br><span class=\"line\">buildscript&#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">''</span> <span class=\"comment\">// 声明插件名称和版本号</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部依赖，添加的依赖会在这些配置的仓库中去寻找</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// \"group:name:version\"</span></span><br><span class=\"line\">    implementation <span class=\"string\">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有子工程的仓库地址</span></span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123; url uri(<span class=\"string\">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>为什么<code>buildscript</code>和<code>allpojectes</code>都有<code>repositories</code></strong></p>\n<ul>\n<li>buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。</li>\n<li>allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。比如用到的Glide/OkHttp等</li>\n<li>子项目可以配置自己的repositories以获取自己独需的依赖包。</li>\n</ul>\n<h2 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h2><p>包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。</p>\n<ul>\n<li>depandsOn: 依赖于其它任务</li>\n<li>doFirst, doLast(&lt;&lt;): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作</li>\n</ul>\n<p>apply的插件自带和很多Task，在Gradle页面的 <code>&lt;项目名&gt;/Tasks/build</code> 目录里面可以看到。<br>我们也可以自己编写任务，自己的Task在Gradle页面的 <code>&lt;项目名&gt;/Tasks/other/</code> 目录里可以查找到</p>\n<h2 id=\"Gradle的工作流程\"><a href=\"#Gradle的工作流程\" class=\"headerlink\" title=\"Gradle的工作流程\"></a>Gradle的工作流程</h2><p><img src=\"/images/gradle的构建过程.jpg\" alt=\"gradle的工作流程\"></p>\n<ul>\n<li>Initialization: 初始化，在多模块的项目中，就是执行settings.gradle</li>\n<li>Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。  Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。</li>\n<li>Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段</li>\n</ul>\n<p>简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。<br>在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！</p>\n<p>在每一步的步骤中间可以添加hook</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">task a &#123;</span><br><span class=\"line\">    println <span class=\"string\">'this is a'</span></span><br><span class=\"line\">    doFirst &#123;</span><br><span class=\"line\">        println <span class=\"string\">'this is a do first'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">\"this is a do last\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task testBoth &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 配置阶段</span></span><br><span class=\"line\">    <span class=\"comment\">// 依赖 a task 先执行</span></span><br><span class=\"line\">    dependsOn(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\">    println <span class=\"string\">'this is b'</span></span><br><span class=\"line\">    doFirst &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\">        println <span class=\"string\">'this is b first'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\">        println <span class=\"string\">'this is b last'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">输出：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Configure project :</span></span><br><span class=\"line\"><span class=\"comment\">this is a</span></span><br><span class=\"line\"><span class=\"comment\">this is b</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Task :a</span></span><br><span class=\"line\"><span class=\"comment\">this is a do first</span></span><br><span class=\"line\"><span class=\"comment\">this is a do last</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Task :testBoth</span></span><br><span class=\"line\"><span class=\"comment\">this is b first</span></span><br><span class=\"line\"><span class=\"comment\">this is b last</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"解决依赖版本冲突\"><a href=\"#解决依赖版本冲突\" class=\"headerlink\" title=\"解决依赖版本冲突\"></a>解决依赖版本冲突</h2><p>大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。</p>\n<p>以下是我们自己解决版本冲突的一般步骤</p>\n<h3 id=\"查看依赖报告\"><a href=\"#查看依赖报告\" class=\"headerlink\" title=\"查看依赖报告\"></a>查看依赖报告</h3><p>运行Gradle， <code>&lt;项目名称&gt;/app/Tasks/dependencies/</code> 查看依赖报告，输出如下</p>\n<p><code>xxxx -&gt; xxxx</code> 表示依赖包自动提升到了最高版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--- androidx.lifecycle:lifecycle-extensions:2.1.0</span><br><span class=\"line\">|    +--- androidx.lifecycle:lifecycle-runtime:2.1.0</span><br><span class=\"line\">|    |    +--- androidx.lifecycle:lifecycle-common:2.1.0 -&gt; 2.3.0-alpha01</span><br><span class=\"line\">|    |    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    |    +--- androidx.arch.core:core-common:2.1.0</span><br><span class=\"line\">|    |    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    +--- androidx.arch.core:core-common:2.1.0 (*)</span><br><span class=\"line\">|    +--- androidx.arch.core:core-runtime:2.1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"排除传递性冲突\"><a href=\"#排除传递性冲突\" class=\"headerlink\" title=\"排除传递性冲突\"></a>排除传递性冲突</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile (<span class=\"string\">'cn.qqtheme.framework:WheelPicker:1.5.1'</span>)&#123;</span><br><span class=\"line\">    exclude <span class=\"string\">group:</span><span class=\"string\">'com.android.support'</span>, <span class=\"string\">module:</span><span class=\"string\">\"appcompat\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"强制一个版本\"><a href=\"#强制一个版本\" class=\"headerlink\" title=\"强制一个版本\"></a>强制一个版本</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations.all&#123;</span><br><span class=\"line\">    resolutionStrategy&#123;</span><br><span class=\"line\">        force <span class=\"string\">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Gradle中的对象\"><a href=\"#Gradle中的对象\" class=\"headerlink\" title=\"Gradle中的对象\"></a>Gradle中的对象</h2><p>Gradle主要有三种对象<br>这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：</p>","more":"\n<ul>\n<li>Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。</li>\n<li>Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。</li>\n<li>Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。</li>\n</ul>\n<p>构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。</p>\n<h2 id=\"setting-gradle\"><a href=\"#setting-gradle\" class=\"headerlink\" title=\"setting.gradle\"></a>setting.gradle</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">':app'</span>, <span class=\"string\">':progect_1'</span>, <span class=\"string\">':progect_2'</span></span><br></pre></td></tr></table></figure>\n<p>用于指示 Gradle 在构建应用时应将哪些模块包括在内</p>\n<h2 id=\"gradle-properties\"><a href=\"#gradle-properties\" class=\"headerlink\" title=\"gradle.properties\"></a>gradle.properties</h2><p>里面可以定义一些常量供build.gradle使用，如版本号等.<br>然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COMPILE_SDK_VERSION = <span class=\"number\">23</span></span><br><span class=\"line\">BUILD_TOOLS_VERSION = <span class=\"number\">23.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">VERSION_CODE = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"build-gradle\"><a href=\"#build-gradle\" class=\"headerlink\" title=\"build.gradle\"></a>build.gradle</h2><p>build文件有两种，一个是针对当前的Module，一个是针对项目中所有的module<br>在顶层的build文件中，我们可以来添加一些子module所共有的一些配置</p>\n<p>下面是一些常用的build.gradle的配置说明<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 应用android官方插件，module中的build.gradle很多配置都是插件提供的支持</span></span><br><span class=\"line\"><span class=\"comment\">// 'com.android.application' 代表app主工程，</span></span><br><span class=\"line\"><span class=\"comment\">// 如果是子工程应该使用 'com.android.library'</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仓库， </span></span><br><span class=\"line\">buildscript&#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">''</span> <span class=\"comment\">// 声明插件名称和版本号</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 外部依赖，添加的依赖会在这些配置的仓库中去寻找</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    <span class=\"comment\">// \"group:name:version\"</span></span><br><span class=\"line\">    implementation <span class=\"string\">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有子工程的仓库地址</span></span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123; url uri(<span class=\"string\">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>为什么<code>buildscript</code>和<code>allpojectes</code>都有<code>repositories</code></strong></p>\n<ul>\n<li>buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。</li>\n<li>allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。比如用到的Glide/OkHttp等</li>\n<li>子项目可以配置自己的repositories以获取自己独需的依赖包。</li>\n</ul>\n<h2 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h2><p>包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。</p>\n<ul>\n<li>depandsOn: 依赖于其它任务</li>\n<li>doFirst, doLast(&lt;&lt;): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作</li>\n</ul>\n<p>apply的插件自带和很多Task，在Gradle页面的 <code>&lt;项目名&gt;/Tasks/build</code> 目录里面可以看到。<br>我们也可以自己编写任务，自己的Task在Gradle页面的 <code>&lt;项目名&gt;/Tasks/other/</code> 目录里可以查找到</p>\n<h2 id=\"Gradle的工作流程\"><a href=\"#Gradle的工作流程\" class=\"headerlink\" title=\"Gradle的工作流程\"></a>Gradle的工作流程</h2><p><img src=\"/images/gradle的构建过程.jpg\" alt=\"gradle的工作流程\"></p>\n<ul>\n<li>Initialization: 初始化，在多模块的项目中，就是执行settings.gradle</li>\n<li>Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。  Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。</li>\n<li>Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段</li>\n</ul>\n<p>简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。<br>在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！</p>\n<p>在每一步的步骤中间可以添加hook</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">task a &#123;</span><br><span class=\"line\">    println <span class=\"string\">'this is a'</span></span><br><span class=\"line\">    doFirst &#123;</span><br><span class=\"line\">        println <span class=\"string\">'this is a do first'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        println <span class=\"string\">\"this is a do last\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">task testBoth &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 配置阶段</span></span><br><span class=\"line\">    <span class=\"comment\">// 依赖 a task 先执行</span></span><br><span class=\"line\">    dependsOn(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\">    println <span class=\"string\">'this is b'</span></span><br><span class=\"line\">    doFirst &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\">        println <span class=\"string\">'this is b first'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    doLast &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 执行阶段</span></span><br><span class=\"line\">        println <span class=\"string\">'this is b last'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">输出：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Configure project :</span></span><br><span class=\"line\"><span class=\"comment\">this is a</span></span><br><span class=\"line\"><span class=\"comment\">this is b</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Task :a</span></span><br><span class=\"line\"><span class=\"comment\">this is a do first</span></span><br><span class=\"line\"><span class=\"comment\">this is a do last</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&gt; Task :testBoth</span></span><br><span class=\"line\"><span class=\"comment\">this is b first</span></span><br><span class=\"line\"><span class=\"comment\">this is b last</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"解决依赖版本冲突\"><a href=\"#解决依赖版本冲突\" class=\"headerlink\" title=\"解决依赖版本冲突\"></a>解决依赖版本冲突</h2><p>大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。</p>\n<p>以下是我们自己解决版本冲突的一般步骤</p>\n<h3 id=\"查看依赖报告\"><a href=\"#查看依赖报告\" class=\"headerlink\" title=\"查看依赖报告\"></a>查看依赖报告</h3><p>运行Gradle， <code>&lt;项目名称&gt;/app/Tasks/dependencies/</code> 查看依赖报告，输出如下</p>\n<p><code>xxxx -&gt; xxxx</code> 表示依赖包自动提升到了最高版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+--- androidx.lifecycle:lifecycle-extensions:2.1.0</span><br><span class=\"line\">|    +--- androidx.lifecycle:lifecycle-runtime:2.1.0</span><br><span class=\"line\">|    |    +--- androidx.lifecycle:lifecycle-common:2.1.0 -&gt; 2.3.0-alpha01</span><br><span class=\"line\">|    |    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    |    +--- androidx.arch.core:core-common:2.1.0</span><br><span class=\"line\">|    |    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    |    \\--- androidx.annotation:annotation:1.1.0</span><br><span class=\"line\">|    +--- androidx.arch.core:core-common:2.1.0 (*)</span><br><span class=\"line\">|    +--- androidx.arch.core:core-runtime:2.1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"排除传递性冲突\"><a href=\"#排除传递性冲突\" class=\"headerlink\" title=\"排除传递性冲突\"></a>排除传递性冲突</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile (<span class=\"string\">'cn.qqtheme.framework:WheelPicker:1.5.1'</span>)&#123;</span><br><span class=\"line\">    exclude <span class=\"string\">group:</span><span class=\"string\">'com.android.support'</span>, <span class=\"string\">module:</span><span class=\"string\">\"appcompat\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"强制一个版本\"><a href=\"#强制一个版本\" class=\"headerlink\" title=\"强制一个版本\"></a>强制一个版本</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">configurations.all&#123;</span><br><span class=\"line\">    resolutionStrategy&#123;</span><br><span class=\"line\">        force <span class=\"string\">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"RequestLayout和Invalidate","date":"2022-05-02T08:48:49.000Z","_content":"\n# RequestLayout\n\n## 标记自身\n\n给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。\n并将RequestLayout向上传递。\n\n```java\n//从源码注释可以看出，如果当前View在请求布局的时候，View树正在进行布局流程的话，\n//该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发现的时候再执行。\n@CallSuper\npublic void requestLayout() {\n    if (mMeasureCache != null) mMeasureCache.clear();\n\n    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) {\n        // Only trigger request-during-layout logic if this is the view requesting it,\n        // not the views in its parent hierarchy\n        ViewRootImpl viewRoot = getViewRootImpl();\n        if (viewRoot != null && viewRoot.isInLayout()) {\n            if (!viewRoot.requestLayoutDuringLayout(this)) {\n                return;\n            }\n        }\n        mAttachInfo.mViewRequestingLayout = this;\n    }\n\n    //为当前view设置标记位 PFLAG_FORCE_LAYOUT\n    mPrivateFlags |= PFLAG_FORCE_LAYOUT;\n    mPrivateFlags |= PFLAG_INVALIDATED;\n\n    if (mParent != null && !mParent.isLayoutRequested()) {\n        //向父容器请求布局\n        mParent.requestLayout();\n    }\n    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == this) {\n        mAttachInfo.mViewRequestingLayout = null;\n    }\n}\n```\n\n## ViewRootImpl\n\n会顺着view树，一路向上标记，最终到达 ViewRootImpl\n```java\n@Override\npublic void requestLayout() {\n    if (!mHandlingLayoutInLayoutRequest) {\n        checkThread();\n        mLayoutRequested = true;\n        scheduleTraversals(); // 开启measure、layout、draw三步走\n    }\n}\n```\n\n scheduleTraversals() 开启绘制三步走流程。 在measure、layout、draw过程中都会判断标志位，只有需要的时候才执行\n\n ```java\n public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n     ...\n\n    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||\n            widthMeasureSpec != mOldWidthMeasureSpec ||\n            heightMeasureSpec != mOldHeightMeasureSpec) {\n        ...\n        if (cacheIndex < 0 || sIgnoreMeasureCache) {\n            // measure ourselves, this should set the measured dimension flag back\n            onMeasure(widthMeasureSpec, heightMeasureSpec);\n            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n        } \n        ...\n        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;\n    }\n}\n ```\n\n measure时判断了PFLAG_FORCE_LAYOUT标记，需要时才做。\n  在 `mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;` 中给layout过程做了标记\n\n ```java\n public void layout(int l, int t, int r, int b) {\n    ...\n    //判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局\n    if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {\n        onLayout(changed, l, t, r, b);\n        //onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位\n        mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;\n        ListenerInfo li = mListenerInfo;\n        if (li != null && li.mOnLayoutChangeListeners != null) {\n            ArrayList<OnLayoutChangeListener> listenersCopy =\n                    (ArrayList<OnLayoutChangeListener>)li.mOnLayoutChangeListeners.clone();\n            int numListeners = listenersCopy.size();\n            for (int i = 0; i < numListeners; ++i) {\n                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);\n            }\n        }\n    }\n\n    //最后清除PFLAG_FORCE_LAYOUT标记位\n    mPrivateFlags &= ~PFLAG_FORCE_LAYOUT;\n    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;\n}\n ```\n\n layout时判断了PFLAG_LAYOUT_REQUIRED标记，需要时才做。\n\n # Invalidate\n\n ## 标记自身\n ```java\n void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,\n        boolean fullInvalidate) {\n    \n    ...\n\n    //根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘\n    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)\n            || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)\n            || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED\n            || (fullInvalidate && isOpaque() != mLastIsOpaque)) {\n        ...\n\n        //设置PFLAG_DIRTY标记位\n        mPrivateFlags |= PFLAG_DIRTY;\n\n        ...\n\n        // Propagate the damage rectangle to the parent view.\n        //把需要重绘的区域传递给父容器\n        final AttachInfo ai = mAttachInfo;\n        final ViewParent p = mParent;\n        if (p != null && ai != null && l < r && t < b) {\n            final Rect damage = ai.mTmpInvalRect;\n            damage.set(l, t, r, b);\n            //调用父容器的方法，向上传递事件\n            p.invalidateChild(this, damage);\n        }\n        ...\n    }\n}\n ```\n\n ## ViewGroup处理并向上传递\n\n ```java\n /**\n * Don't call or override this method. It is used for the implementation of\n * the view hierarchy.\n */\npublic final void invalidateChild(View child, final Rect dirty) {\n\n    //设置 parent 等于自身\n    ViewParent parent = this;\n\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        ...\n        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;\n\n        if (child.mLayerType != LAYER_TYPE_NONE) {\n            mPrivateFlags |= PFLAG_INVALIDATED;\n            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\n        }\n        \n        ...\n\n        do {\n            View view = null;\n            if (parent instanceof View) {\n                view = (View) parent;\n            }\n\n            ...\n            if (view != null) {\n                if ((view.mViewFlags & FADING_EDGE_MASK) != 0 &&\n                        view.getSolidColor() == 0) {\n                    opaqueFlag = PFLAG_DIRTY;\n                }\n                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {\n                    //对当前View的标记位进行设置\n                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;\n                }\n            }\n\n            //调用ViewGrup的invalidateChildInParent，如果已经达到最顶层view,则调用ViewRootImpl的invalidateChildInParent。\n            parent = parent.invalidateChildInParent(location, dirty);\n            ...\n        } while (parent != null);\n    }\n}\n\n```\n\n```java\npublic ViewParent invalidateChildInParent(final int[] location, final Rect dirty) {\n    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN ||\n            (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {\n        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) !=\n                    FLAG_OPTIMIZE_INVALIDATE) {\n\n            //将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响\n            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,\n                    location[CHILD_TOP_INDEX] - mScrollY);\n\n            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {\n                //求并集，结果是把子视图的dirty区域转化为父容器的dirty区域\n                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);\n            }\n\n            final int left = mLeft;\n            final int top = mTop;\n\n            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {\n                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {\n                    dirty.setEmpty();\n                }\n            }\n            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\n\n            //记录当前视图的mLeft和mTop值，在下一次循环中会把当前值再向父容器的坐标转化\n            location[CHILD_LEFT_INDEX] = left;\n            location[CHILD_TOP_INDEX] = top;\n\n            if (mLayerType != LAYER_TYPE_NONE) {\n                mPrivateFlags |= PFLAG_INVALIDATED;\n            }\n            //返回当前视图的父容器\n            return mParent;\n\n        }\n        ...\n    }\n    return null;\n}\n```\n\n## ViewRootImpl\n```java\n@Override\npublic ViewParent invalidateChildInParent(int[] location, Rect dirty) {\n    checkThread();\n    ...\n    invalidateRectOnScreen(dirty);\n    return null;\n}\n\nprivate void invalidateRectOnScreen(Rect dirty) {\n    ...\n    if (!mWillDrawSoon && (intersected || mIsAnimating)) {\n        scheduleTraversals();\n    }\n}\n```\n\n```java\nprivate boolean draw(boolean fullRedrawNeeded) {\n    // 1. 使用硬件加速渲染\n    // 2. 使用软件加速渲染\n}\n\n/**\n     * @return true if drawing was successful, false if an error occurred\n     */\n    private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,\n            boolean scalingRequired, Rect dirty) {\n\n        // Draw with software renderer.\n        final Canvas canvas;\n        try {\n            final int left = dirty.left;\n            final int top = dirty.top;\n            final int right = dirty.right;\n            final int bottom = dirty.bottom;\n\n            canvas = mSurface.lockCanvas(dirty);\n\n            // The dirty rectangle can be modified by Surface.lockCanvas()\n            //noinspection ConstantConditions\n            if (left != dirty.left || top != dirty.top || right != dirty.right\n                    || bottom != dirty.bottom) {\n                attachInfo.mIgnoreDirtyState = true;\n            }\n\n            // TODO: Do this in native\n            canvas.setDensity(mDensity);\n        } catch {\n            ...\n        }\n\n        // 伪代码\n        mView.mPrivateFlags |= View.PFLAG_DRAWN;\n        mView.draw(canvas);\n        \n        return true;\n    }\n```\n这里只有软件绘制的代码。 \n网上有人说invalidate只会重绘脏区域，但是这里只看到用dirty做了一个 `canvas = mSurface.lockCanvas(dirty);` 。还不是很懂局部重绘是怎么做到的。。。。\n\n\n\n\n\n","source":"_posts/Android/Framework/RequestLayout和Invalidate.md","raw":"---\ntitle: RequestLayout和Invalidate\ndate: 2022-05-02 16:48:49\ntags:\n---\n\n# RequestLayout\n\n## 标记自身\n\n给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。\n并将RequestLayout向上传递。\n\n```java\n//从源码注释可以看出，如果当前View在请求布局的时候，View树正在进行布局流程的话，\n//该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发现的时候再执行。\n@CallSuper\npublic void requestLayout() {\n    if (mMeasureCache != null) mMeasureCache.clear();\n\n    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == null) {\n        // Only trigger request-during-layout logic if this is the view requesting it,\n        // not the views in its parent hierarchy\n        ViewRootImpl viewRoot = getViewRootImpl();\n        if (viewRoot != null && viewRoot.isInLayout()) {\n            if (!viewRoot.requestLayoutDuringLayout(this)) {\n                return;\n            }\n        }\n        mAttachInfo.mViewRequestingLayout = this;\n    }\n\n    //为当前view设置标记位 PFLAG_FORCE_LAYOUT\n    mPrivateFlags |= PFLAG_FORCE_LAYOUT;\n    mPrivateFlags |= PFLAG_INVALIDATED;\n\n    if (mParent != null && !mParent.isLayoutRequested()) {\n        //向父容器请求布局\n        mParent.requestLayout();\n    }\n    if (mAttachInfo != null && mAttachInfo.mViewRequestingLayout == this) {\n        mAttachInfo.mViewRequestingLayout = null;\n    }\n}\n```\n\n## ViewRootImpl\n\n会顺着view树，一路向上标记，最终到达 ViewRootImpl\n```java\n@Override\npublic void requestLayout() {\n    if (!mHandlingLayoutInLayoutRequest) {\n        checkThread();\n        mLayoutRequested = true;\n        scheduleTraversals(); // 开启measure、layout、draw三步走\n    }\n}\n```\n\n scheduleTraversals() 开启绘制三步走流程。 在measure、layout、draw过程中都会判断标志位，只有需要的时候才执行\n\n ```java\n public final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n     ...\n\n    if ((mPrivateFlags & PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||\n            widthMeasureSpec != mOldWidthMeasureSpec ||\n            heightMeasureSpec != mOldHeightMeasureSpec) {\n        ...\n        if (cacheIndex < 0 || sIgnoreMeasureCache) {\n            // measure ourselves, this should set the measured dimension flag back\n            onMeasure(widthMeasureSpec, heightMeasureSpec);\n            mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;\n        } \n        ...\n        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;\n    }\n}\n ```\n\n measure时判断了PFLAG_FORCE_LAYOUT标记，需要时才做。\n  在 `mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;` 中给layout过程做了标记\n\n ```java\n public void layout(int l, int t, int r, int b) {\n    ...\n    //判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局\n    if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {\n        onLayout(changed, l, t, r, b);\n        //onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位\n        mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;\n        ListenerInfo li = mListenerInfo;\n        if (li != null && li.mOnLayoutChangeListeners != null) {\n            ArrayList<OnLayoutChangeListener> listenersCopy =\n                    (ArrayList<OnLayoutChangeListener>)li.mOnLayoutChangeListeners.clone();\n            int numListeners = listenersCopy.size();\n            for (int i = 0; i < numListeners; ++i) {\n                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);\n            }\n        }\n    }\n\n    //最后清除PFLAG_FORCE_LAYOUT标记位\n    mPrivateFlags &= ~PFLAG_FORCE_LAYOUT;\n    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;\n}\n ```\n\n layout时判断了PFLAG_LAYOUT_REQUIRED标记，需要时才做。\n\n # Invalidate\n\n ## 标记自身\n ```java\n void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,\n        boolean fullInvalidate) {\n    \n    ...\n\n    //根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘\n    if ((mPrivateFlags & (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)\n            || (invalidateCache && (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)\n            || (mPrivateFlags & PFLAG_INVALIDATED) != PFLAG_INVALIDATED\n            || (fullInvalidate && isOpaque() != mLastIsOpaque)) {\n        ...\n\n        //设置PFLAG_DIRTY标记位\n        mPrivateFlags |= PFLAG_DIRTY;\n\n        ...\n\n        // Propagate the damage rectangle to the parent view.\n        //把需要重绘的区域传递给父容器\n        final AttachInfo ai = mAttachInfo;\n        final ViewParent p = mParent;\n        if (p != null && ai != null && l < r && t < b) {\n            final Rect damage = ai.mTmpInvalRect;\n            damage.set(l, t, r, b);\n            //调用父容器的方法，向上传递事件\n            p.invalidateChild(this, damage);\n        }\n        ...\n    }\n}\n ```\n\n ## ViewGroup处理并向上传递\n\n ```java\n /**\n * Don't call or override this method. It is used for the implementation of\n * the view hierarchy.\n */\npublic final void invalidateChild(View child, final Rect dirty) {\n\n    //设置 parent 等于自身\n    ViewParent parent = this;\n\n    final AttachInfo attachInfo = mAttachInfo;\n    if (attachInfo != null) {\n        ...\n        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;\n\n        if (child.mLayerType != LAYER_TYPE_NONE) {\n            mPrivateFlags |= PFLAG_INVALIDATED;\n            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\n        }\n        \n        ...\n\n        do {\n            View view = null;\n            if (parent instanceof View) {\n                view = (View) parent;\n            }\n\n            ...\n            if (view != null) {\n                if ((view.mViewFlags & FADING_EDGE_MASK) != 0 &&\n                        view.getSolidColor() == 0) {\n                    opaqueFlag = PFLAG_DIRTY;\n                }\n                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {\n                    //对当前View的标记位进行设置\n                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;\n                }\n            }\n\n            //调用ViewGrup的invalidateChildInParent，如果已经达到最顶层view,则调用ViewRootImpl的invalidateChildInParent。\n            parent = parent.invalidateChildInParent(location, dirty);\n            ...\n        } while (parent != null);\n    }\n}\n\n```\n\n```java\npublic ViewParent invalidateChildInParent(final int[] location, final Rect dirty) {\n    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN ||\n            (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {\n        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) !=\n                    FLAG_OPTIMIZE_INVALIDATE) {\n\n            //将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响\n            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,\n                    location[CHILD_TOP_INDEX] - mScrollY);\n\n            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {\n                //求并集，结果是把子视图的dirty区域转化为父容器的dirty区域\n                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);\n            }\n\n            final int left = mLeft;\n            final int top = mTop;\n\n            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {\n                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {\n                    dirty.setEmpty();\n                }\n            }\n            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;\n\n            //记录当前视图的mLeft和mTop值，在下一次循环中会把当前值再向父容器的坐标转化\n            location[CHILD_LEFT_INDEX] = left;\n            location[CHILD_TOP_INDEX] = top;\n\n            if (mLayerType != LAYER_TYPE_NONE) {\n                mPrivateFlags |= PFLAG_INVALIDATED;\n            }\n            //返回当前视图的父容器\n            return mParent;\n\n        }\n        ...\n    }\n    return null;\n}\n```\n\n## ViewRootImpl\n```java\n@Override\npublic ViewParent invalidateChildInParent(int[] location, Rect dirty) {\n    checkThread();\n    ...\n    invalidateRectOnScreen(dirty);\n    return null;\n}\n\nprivate void invalidateRectOnScreen(Rect dirty) {\n    ...\n    if (!mWillDrawSoon && (intersected || mIsAnimating)) {\n        scheduleTraversals();\n    }\n}\n```\n\n```java\nprivate boolean draw(boolean fullRedrawNeeded) {\n    // 1. 使用硬件加速渲染\n    // 2. 使用软件加速渲染\n}\n\n/**\n     * @return true if drawing was successful, false if an error occurred\n     */\n    private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,\n            boolean scalingRequired, Rect dirty) {\n\n        // Draw with software renderer.\n        final Canvas canvas;\n        try {\n            final int left = dirty.left;\n            final int top = dirty.top;\n            final int right = dirty.right;\n            final int bottom = dirty.bottom;\n\n            canvas = mSurface.lockCanvas(dirty);\n\n            // The dirty rectangle can be modified by Surface.lockCanvas()\n            //noinspection ConstantConditions\n            if (left != dirty.left || top != dirty.top || right != dirty.right\n                    || bottom != dirty.bottom) {\n                attachInfo.mIgnoreDirtyState = true;\n            }\n\n            // TODO: Do this in native\n            canvas.setDensity(mDensity);\n        } catch {\n            ...\n        }\n\n        // 伪代码\n        mView.mPrivateFlags |= View.PFLAG_DRAWN;\n        mView.draw(canvas);\n        \n        return true;\n    }\n```\n这里只有软件绘制的代码。 \n网上有人说invalidate只会重绘脏区域，但是这里只看到用dirty做了一个 `canvas = mSurface.lockCanvas(dirty);` 。还不是很懂局部重绘是怎么做到的。。。。\n\n\n\n\n\n","slug":"Android/Framework/RequestLayout和Invalidate","published":1,"updated":"2022-05-02T10:53:02.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9n005lg0jeurx8f764","content":"<h1 id=\"RequestLayout\"><a href=\"#RequestLayout\" class=\"headerlink\" title=\"RequestLayout\"></a>RequestLayout</h1><h2 id=\"标记自身\"><a href=\"#标记自身\" class=\"headerlink\" title=\"标记自身\"></a>标记自身</h2><p>给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。<br>并将RequestLayout向上传递。</p><a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从源码注释可以看出，如果当前View在请求布局的时候，View树正在进行布局流程的话，</span></span><br><span class=\"line\"><span class=\"comment\">//该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发现的时候再执行。</span></span><br><span class=\"line\"><span class=\"meta\">@CallSuper</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mMeasureCache != <span class=\"keyword\">null</span>) mMeasureCache.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAttachInfo != <span class=\"keyword\">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Only trigger request-during-layout logic if this is the view requesting it,</span></span><br><span class=\"line\">        <span class=\"comment\">// not the views in its parent hierarchy</span></span><br><span class=\"line\">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (viewRoot != <span class=\"keyword\">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!viewRoot.requestLayoutDuringLayout(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAttachInfo.mViewRequestingLayout = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为当前view设置标记位 PFLAG_FORCE_LAYOUT</span></span><br><span class=\"line\">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class=\"line\">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//向父容器请求布局</span></span><br><span class=\"line\">        mParent.requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAttachInfo != <span class=\"keyword\">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        mAttachInfo.mViewRequestingLayout = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ViewRootImpl\"><a href=\"#ViewRootImpl\" class=\"headerlink\" title=\"ViewRootImpl\"></a>ViewRootImpl</h2><p>会顺着view树，一路向上标记，最终到达 ViewRootImpl<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class=\"line\">        checkThread();</span><br><span class=\"line\">        mLayoutRequested = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        scheduleTraversals(); <span class=\"comment\">// 开启measure、layout、draw三步走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> scheduleTraversals() 开启绘制三步走流程。 在measure、layout、draw过程中都会判断标志位，只有需要的时候才执行</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">measure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">     ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class=\"line\">            widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class=\"line\">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cacheIndex &lt; <span class=\"number\">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class=\"line\">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> measure时判断了PFLAG_FORCE_LAYOUT标记，需要时才做。<br>  在 <code>mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</code> 中给layout过程做了标记</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class=\"line\">        onLayout(changed, l, t, r, b);</span><br><span class=\"line\">        <span class=\"comment\">//onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位</span></span><br><span class=\"line\">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class=\"line\">        ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class=\"line\">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> numListeners = listenersCopy.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class=\"line\">                listenersCopy.get(i).onLayoutChange(<span class=\"keyword\">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//最后清除PFLAG_FORCE_LAYOUT标记位</span></span><br><span class=\"line\">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class=\"line\">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> layout时判断了PFLAG_LAYOUT_REQUIRED标记，需要时才做。</p>\n<h1 id=\"Invalidate\"><a href=\"#Invalidate\" class=\"headerlink\" title=\"Invalidate\"></a>Invalidate</h1><h2 id=\"标记自身-1\"><a href=\"#标记自身-1\" class=\"headerlink\" title=\"标记自身\"></a>标记自身</h2> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invalidateInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b, <span class=\"keyword\">boolean</span> invalidateCache,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class=\"line\">            || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class=\"line\">            || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class=\"line\">            || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//设置PFLAG_DIRTY标记位</span></span><br><span class=\"line\">        mPrivateFlags |= PFLAG_DIRTY;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Propagate the damage rectangle to the parent view.</span></span><br><span class=\"line\">        <span class=\"comment\">//把需要重绘的区域传递给父容器</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttachInfo ai = mAttachInfo;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ViewParent p = mParent;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; ai != <span class=\"keyword\">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class=\"line\">            damage.set(l, t, r, b);</span><br><span class=\"line\">            <span class=\"comment\">//调用父容器的方法，向上传递事件</span></span><br><span class=\"line\">            p.invalidateChild(<span class=\"keyword\">this</span>, damage);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ViewGroup处理并向上传递\"><a href=\"#ViewGroup处理并向上传递\" class=\"headerlink\" title=\"ViewGroup处理并向上传递\"></a>ViewGroup处理并向上传递</h2> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Don't call or override this method. It is used for the implementation of</span></span><br><span class=\"line\"><span class=\"comment\"> * the view hierarchy.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">invalidateChild</span><span class=\"params\">(View child, <span class=\"keyword\">final</span> Rect dirty)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置 parent 等于自身</span></span><br><span class=\"line\">    ViewParent parent = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (attachInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">int</span> opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child.mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class=\"line\">            mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class=\"line\">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            View view = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent <span class=\"keyword\">instanceof</span> View) &#123;</span><br><span class=\"line\">                view = (View) parent;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (view != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                        view.getSolidColor() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    opaqueFlag = PFLAG_DIRTY;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//对当前View的标记位进行设置</span></span><br><span class=\"line\">                    view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//调用ViewGrup的invalidateChildInParent，如果已经达到最顶层view,则调用ViewRootImpl的invalidateChildInParent。</span></span><br><span class=\"line\">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (parent != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewParent <span class=\"title\">invalidateChildInParent</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] location, <span class=\"keyword\">final</span> Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN ||</span><br><span class=\"line\">            (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) !=</span><br><span class=\"line\">                    FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响</span></span><br><span class=\"line\">            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,</span><br><span class=\"line\">                    location[CHILD_TOP_INDEX] - mScrollY);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//求并集，结果是把子视图的dirty区域转化为父容器的dirty区域</span></span><br><span class=\"line\">                dirty.union(<span class=\"number\">0</span>, <span class=\"number\">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> left = mLeft;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> top = mTop;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!dirty.intersect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, mRight - left, mBottom - top)) &#123;</span><br><span class=\"line\">                    dirty.setEmpty();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//记录当前视图的mLeft和mTop值，在下一次循环中会把当前值再向父容器的坐标转化</span></span><br><span class=\"line\">            location[CHILD_LEFT_INDEX] = left;</span><br><span class=\"line\">            location[CHILD_TOP_INDEX] = top;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class=\"line\">                mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//返回当前视图的父容器</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mParent;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ViewRootImpl-1\"><a href=\"#ViewRootImpl-1\" class=\"headerlink\" title=\"ViewRootImpl\"></a>ViewRootImpl</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewParent <span class=\"title\">invalidateChildInParent</span><span class=\"params\">(<span class=\"keyword\">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">    checkThread();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    invalidateRectOnScreen(dirty);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">invalidateRectOnScreen</span><span class=\"params\">(Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class=\"line\">        scheduleTraversals();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">draw</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 使用硬件加速渲染</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 使用软件加速渲染</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true if drawing was successful, false if an error occurred</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawSoftware</span><span class=\"params\">(Surface surface, AttachInfo attachInfo, <span class=\"keyword\">int</span> xoff, <span class=\"keyword\">int</span> yoff,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Draw with software renderer.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Canvas canvas;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> left = dirty.left;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> top = dirty.top;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> right = dirty.right;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> bottom = dirty.bottom;</span><br><span class=\"line\"></span><br><span class=\"line\">            canvas = mSurface.lockCanvas(dirty);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class=\"line\">            <span class=\"comment\">//noinspection ConstantConditions</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class=\"line\">                    || bottom != dirty.bottom) &#123;</span><br><span class=\"line\">                attachInfo.mIgnoreDirtyState = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Do this in native</span></span><br><span class=\"line\">            canvas.setDensity(mDensity);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 伪代码</span></span><br><span class=\"line\">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class=\"line\">        mView.draw(canvas);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里只有软件绘制的代码。<br>网上有人说invalidate只会重绘脏区域，但是这里只看到用dirty做了一个 <code>canvas = mSurface.lockCanvas(dirty);</code> 。还不是很懂局部重绘是怎么做到的。。。。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"RequestLayout\"><a href=\"#RequestLayout\" class=\"headerlink\" title=\"RequestLayout\"></a>RequestLayout</h1><h2 id=\"标记自身\"><a href=\"#标记自身\" class=\"headerlink\" title=\"标记自身\"></a>标记自身</h2><p>给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。<br>并将RequestLayout向上传递。</p>","more":"\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从源码注释可以看出，如果当前View在请求布局的时候，View树正在进行布局流程的话，</span></span><br><span class=\"line\"><span class=\"comment\">//该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发现的时候再执行。</span></span><br><span class=\"line\"><span class=\"meta\">@CallSuper</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mMeasureCache != <span class=\"keyword\">null</span>) mMeasureCache.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAttachInfo != <span class=\"keyword\">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Only trigger request-during-layout logic if this is the view requesting it,</span></span><br><span class=\"line\">        <span class=\"comment\">// not the views in its parent hierarchy</span></span><br><span class=\"line\">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (viewRoot != <span class=\"keyword\">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!viewRoot.requestLayoutDuringLayout(<span class=\"keyword\">this</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mAttachInfo.mViewRequestingLayout = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//为当前view设置标记位 PFLAG_FORCE_LAYOUT</span></span><br><span class=\"line\">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class=\"line\">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mParent != <span class=\"keyword\">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//向父容器请求布局</span></span><br><span class=\"line\">        mParent.requestLayout();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mAttachInfo != <span class=\"keyword\">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        mAttachInfo.mViewRequestingLayout = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ViewRootImpl\"><a href=\"#ViewRootImpl\" class=\"headerlink\" title=\"ViewRootImpl\"></a>ViewRootImpl</h2><p>会顺着view树，一路向上标记，最终到达 ViewRootImpl<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">requestLayout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class=\"line\">        checkThread();</span><br><span class=\"line\">        mLayoutRequested = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        scheduleTraversals(); <span class=\"comment\">// 开启measure、layout、draw三步走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p> scheduleTraversals() 开启绘制三步走流程。 在measure、layout、draw过程中都会判断标志位，只有需要的时候才执行</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">measure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">     ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class=\"line\">            widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class=\"line\">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cacheIndex &lt; <span class=\"number\">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class=\"line\">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ...</span><br><span class=\"line\">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> measure时判断了PFLAG_FORCE_LAYOUT标记，需要时才做。<br>  在 <code>mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</code> 中给layout过程做了标记</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layout</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class=\"line\">        onLayout(changed, l, t, r, b);</span><br><span class=\"line\">        <span class=\"comment\">//onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位</span></span><br><span class=\"line\">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class=\"line\">        ListenerInfo li = mListenerInfo;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (li != <span class=\"keyword\">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class=\"line\">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> numListeners = listenersCopy.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class=\"line\">                listenersCopy.get(i).onLayoutChange(<span class=\"keyword\">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//最后清除PFLAG_FORCE_LAYOUT标记位</span></span><br><span class=\"line\">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class=\"line\">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> layout时判断了PFLAG_LAYOUT_REQUIRED标记，需要时才做。</p>\n<h1 id=\"Invalidate\"><a href=\"#Invalidate\" class=\"headerlink\" title=\"Invalidate\"></a>Invalidate</h1><h2 id=\"标记自身-1\"><a href=\"#标记自身-1\" class=\"headerlink\" title=\"标记自身\"></a>标记自身</h2> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">invalidateInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b, <span class=\"keyword\">boolean</span> invalidateCache,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class=\"line\">            || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class=\"line\">            || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class=\"line\">            || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//设置PFLAG_DIRTY标记位</span></span><br><span class=\"line\">        mPrivateFlags |= PFLAG_DIRTY;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Propagate the damage rectangle to the parent view.</span></span><br><span class=\"line\">        <span class=\"comment\">//把需要重绘的区域传递给父容器</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> AttachInfo ai = mAttachInfo;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ViewParent p = mParent;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p != <span class=\"keyword\">null</span> &amp;&amp; ai != <span class=\"keyword\">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class=\"line\">            damage.set(l, t, r, b);</span><br><span class=\"line\">            <span class=\"comment\">//调用父容器的方法，向上传递事件</span></span><br><span class=\"line\">            p.invalidateChild(<span class=\"keyword\">this</span>, damage);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ViewGroup处理并向上传递\"><a href=\"#ViewGroup处理并向上传递\" class=\"headerlink\" title=\"ViewGroup处理并向上传递\"></a>ViewGroup处理并向上传递</h2> <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Don't call or override this method. It is used for the implementation of</span></span><br><span class=\"line\"><span class=\"comment\"> * the view hierarchy.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">invalidateChild</span><span class=\"params\">(View child, <span class=\"keyword\">final</span> Rect dirty)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置 parent 等于自身</span></span><br><span class=\"line\">    ViewParent parent = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (attachInfo != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">int</span> opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (child.mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class=\"line\">            mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class=\"line\">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            View view = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent <span class=\"keyword\">instanceof</span> View) &#123;</span><br><span class=\"line\">                view = (View) parent;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (view != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                        view.getSolidColor() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    opaqueFlag = PFLAG_DIRTY;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//对当前View的标记位进行设置</span></span><br><span class=\"line\">                    view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//调用ViewGrup的invalidateChildInParent，如果已经达到最顶层view,则调用ViewRootImpl的invalidateChildInParent。</span></span><br><span class=\"line\">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (parent != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewParent <span class=\"title\">invalidateChildInParent</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] location, <span class=\"keyword\">final</span> Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN ||</span><br><span class=\"line\">            (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) !=</span><br><span class=\"line\">                    FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响</span></span><br><span class=\"line\">            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,</span><br><span class=\"line\">                    location[CHILD_TOP_INDEX] - mScrollY);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//求并集，结果是把子视图的dirty区域转化为父容器的dirty区域</span></span><br><span class=\"line\">                dirty.union(<span class=\"number\">0</span>, <span class=\"number\">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> left = mLeft;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> top = mTop;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!dirty.intersect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, mRight - left, mBottom - top)) &#123;</span><br><span class=\"line\">                    dirty.setEmpty();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//记录当前视图的mLeft和mTop值，在下一次循环中会把当前值再向父容器的坐标转化</span></span><br><span class=\"line\">            location[CHILD_LEFT_INDEX] = left;</span><br><span class=\"line\">            location[CHILD_TOP_INDEX] = top;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class=\"line\">                mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//返回当前视图的父容器</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mParent;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ViewRootImpl-1\"><a href=\"#ViewRootImpl-1\" class=\"headerlink\" title=\"ViewRootImpl\"></a>ViewRootImpl</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ViewParent <span class=\"title\">invalidateChildInParent</span><span class=\"params\">(<span class=\"keyword\">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">    checkThread();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    invalidateRectOnScreen(dirty);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">invalidateRectOnScreen</span><span class=\"params\">(Rect dirty)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class=\"line\">        scheduleTraversals();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">draw</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 使用硬件加速渲染</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. 使用软件加速渲染</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true if drawing was successful, false if an error occurred</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">drawSoftware</span><span class=\"params\">(Surface surface, AttachInfo attachInfo, <span class=\"keyword\">int</span> xoff, <span class=\"keyword\">int</span> yoff,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Draw with software renderer.</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Canvas canvas;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> left = dirty.left;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> top = dirty.top;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> right = dirty.right;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> bottom = dirty.bottom;</span><br><span class=\"line\"></span><br><span class=\"line\">            canvas = mSurface.lockCanvas(dirty);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class=\"line\">            <span class=\"comment\">//noinspection ConstantConditions</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class=\"line\">                    || bottom != dirty.bottom) &#123;</span><br><span class=\"line\">                attachInfo.mIgnoreDirtyState = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Do this in native</span></span><br><span class=\"line\">            canvas.setDensity(mDensity);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 伪代码</span></span><br><span class=\"line\">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class=\"line\">        mView.draw(canvas);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>这里只有软件绘制的代码。<br>网上有人说invalidate只会重绘脏区域，但是这里只看到用dirty做了一个 <code>canvas = mSurface.lockCanvas(dirty);</code> 。还不是很懂局部重绘是怎么做到的。。。。</p>\n"},{"title":"自定义注解处理器并发布为gradle组件","date":"2022-03-13T07:27:24.000Z","_content":"\n自定义一个基于注解的路由框架\n\n## 定义注解类\n\n1. 新建一个模块 router_annotations \n2. 在 router_annotations 目录中创建 build.gradle \n\n```groovy\napply plugin: \"kotlin\" // 使用 kotlin\n\ntargetCompatibility = JavaVersion.VERSION_1_8\nsourceCompatibility = JavaVersion.VERSION_1_8\n\n// 应用 发布脚本，后面会写\napply from : rootProject.file(\"maven-publish.gradle\")\n```\n\n3. 定义注解类\n\n```kotlin\npackage com.example.test\n\n// 设置使用注解的对象是 类\n@Target(AnnotationTarget.CLASS)\n// 设置注解只在编译期存在\n@Retention(AnnotationRetention.BINARY)\nannotation class Destination(\n    val url: String\n)\n\n```\n\n## 定义注解处理器模块\n\n1. 新建一个模块 router_compile\n2. 在 router_compile 目录中创建 build.gradle\n\n```groovy\n\napply plugin: \"kotlin\" // 使用kotlin插件\napply plugin: \"kotlin-kapt\" // 使用kotlin注解\n\n\n// 设置源码兼容性\ntargetCompatibility = JavaVersion.VERSION_1_8\nsourceCompatibility = JavaVersion.VERSION_1_8\n\ndependencies {\n    implementation project(\":router_annotations\")\n    implementation \"com.google.auto.service:auto-service:1.0-rc6\"\n    kapt \"com.google.auto.service:auto-service:1.0-rc6\"\n}\n\n// 应用 发布脚本。后面会写\napply from : rootProject.file(\"maven-publish.gradle\")\n```\n\n在注解处理器模块，如果使用kotlin写注解处理器代码，需要引用 `kotlin-kapt` 这个插件\n`implementation \"com.google.auto.service:auto-service:1.0-rc6\"` 使用google的一个注解框架。 \n同时还要加上 `kapt \"com.google.auto.service:auto-service:1.0-rc6\"` 。 这是kotlin的写法，如果是java，需要换成\n`annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'`\n\n3. 编写注解处理器\n```kotlin\n@AutoService(Processor::class)\nclass DestinationProcessor : AbstractProcessor() {\n\n    private val TAG = \"DestinationProcessor\"\n\n    override fun process(\n        set: MutableSet<out TypeElement>,\n        roundEnvironment: RoundEnvironment\n    ): Boolean {\n        if (roundEnvironment.processingOver()) {\n            return false\n        }\n        println(\"$TAG >>>> process start\")\n\n        println(set)\n\n        val destinationClasses = roundEnvironment.getElementsAnnotatedWith(Destination::class.java)\n\n        println(TAG + \" \" + destinationClasses.size)\n        if (destinationClasses.size < 1) {\n            return false\n        }\n\n        for (element in destinationClasses) {\n            val typeElement = element as TypeElement\n            val destination = typeElement.getAnnotation(Destination::class.java)\n                ?: continue\n            val url = destination.url\n            val className = typeElement.qualifiedName\n            println(\"$TAG $url $className\")\n        }\n\n        println(\"$TAG >>>> process finish\")\n\n        return true\n    }\n\n    override fun getSupportedAnnotationTypes(): MutableSet<String> {\n        return mutableSetOf(\n            Destination::class.java.canonicalName\n        )\n    }\n}\n```\n\n`@AutoService(Processor::class)` 是固定写法\n\n`AbstractProcessor` 继承这个抽象类。 \n重写`getSupportedAnnotationTypes`方法，返回需要处理的注解。\n重写`process`方法，处理注解信息。 返回值为true表示已处理这个注解，相同的注解不会再被其他注解处理器处理。\n`roundEnvironment.processingOver()`表示之前已经有处理过一轮，此时`roundEnvironment.elements.size==0` 不是很明白gradle为什么会执行多轮。。。\n\n## 在本地使用注解\n```groovy\nimplementation project(\":router_annotations\")\nkapt project(\":router_compile\")\n```\n \n## 将注解处理器打包成组件并发布\n\n1. 在最外层的 build.properties 中写通用参数\n```groovy\nPOM_URL=../repo  // 发布的仓库地址，这里是本地\nGROUP_ID=com.example.test // group\nVERSION_NAME=1.0.0 // 版本\n```\n\n2. 在 router_annotation 和 router_compile 中写 group_id\n```groovy\n// 在 router_annotation build.properties\nPOM_ARTIFACT_ID=router-test-annotation\n\n// 在 router_compile build.properties\nPOM_ARTIFACT_ID=router-test-processor\n```\n\n3. 编写发布脚本 maven-publish.gradle\n\n```groovy\napply plugin: 'maven' // 引入maven插件\n\n// 从根目录的 gradle.properties 中获取通用参数 start\ndef rootProperties = new Properties()\nrootProperties.load(new FileInputStream(project.rootProject.file(\"gradle.properties\")))\n\ndef versionName = rootProperties.getProperty(\"VERSION_NAME\")\ndef pomUrl = rootProperties.getProperty(\"POM_URL\") // ../repo\ndef groupId = rootProperties.getProperty(\"GROUP_ID\")\n// 获取通用参数 end\n\n// 从当前项目的 gradle.properties 中获取参数\ndef projectProperties = new Properties()\nprojectProperties.load(new FileInputStream(project.file(\"gradle.properties\")))\ndef pomArtifactId = projectProperties.getProperty(\"POM_ARTIFACT_ID\")\n\nprintln(\"maven-publish $versionName $pomUrl $groupId $pomArtifactId\")\n\n// 编写maven的发布任务\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri(pomUrl)) {\n                pom.groupId = groupId\n                pom.artifactId = pomArtifactId\n                pom.version = versionName\n            }\n\n            pom.whenConfigured { pom ->\n                pom.dependencies.forEach { dep ->\n                    if (dep.getVersion() == \"unspecified\") {\n                        dep.setGroupId(groupId)\n                        dep.setVersion(versionName)\n                    }\n\n                }\n\n            }\n        }\n    }\n}\n```\n\n注意有一个 `pom.whenConfigured { pom -> ...` 的代码，这是因为 router_compile 应用到了 router_annotations 模块。如果不做处理，发布之后， router_comiple 模块是找不到 router_annotations 的正确位置和版本的。所以要强制制定\n\n## 执行发布任务\n```bash\n./gradlew :router_compile:uploadArchives\n./gradlew :router_annotations:uploadArchives\n```\n我们设置的 `POM_URL=../repo` 所以最终会在项目的repo目录里生成aar包。 \n\n## 使用发布后的组件\n\n1. 首先，moven本地仓库地址加入到工程里\n```groovy\nbuildscript {\n    repositories {\n        maven { url uri('/Users/bytedance/code/test/repo') }\n        google()\n        mavenCentral()\n    }\n}\n\nallprojects {\n    repositories {\n        maven { url uri('/Users/bytedance/code/test/repo') }\n        google()\n        mavenCentral()\n    }\n}\n```\nbuildscript.repositories 和 allprojects.repositories 都要加，这样才会应用到所有子工程\n\n2. 在app模块里引用组件\n```groovy\n    implementation \"com.example.test:router-test-annotation:1.0.0\"\n    kapt \"com.example.test:router-test-processor:1.0.0\"\n```\n\n3. gradle版本的区别\n\n在 gradle 7.+ 版本有很多东西不兼容，上述实现只有在 gradle 6.+ 的版本有效。 gradle 的版本升级和项目创建还是要谨慎一些。 \n","source":"_posts/Android/gradle/自定义注解处理器并发布为gradle组件.md","raw":"---\ntitle: 自定义注解处理器并发布为gradle组件\ndate: 2022-03-13 15:27:24\ntags:\n- Gradle\ncategories: \n- Android\n---\n\n自定义一个基于注解的路由框架\n\n## 定义注解类\n\n1. 新建一个模块 router_annotations \n2. 在 router_annotations 目录中创建 build.gradle \n\n```groovy\napply plugin: \"kotlin\" // 使用 kotlin\n\ntargetCompatibility = JavaVersion.VERSION_1_8\nsourceCompatibility = JavaVersion.VERSION_1_8\n\n// 应用 发布脚本，后面会写\napply from : rootProject.file(\"maven-publish.gradle\")\n```\n\n3. 定义注解类\n\n```kotlin\npackage com.example.test\n\n// 设置使用注解的对象是 类\n@Target(AnnotationTarget.CLASS)\n// 设置注解只在编译期存在\n@Retention(AnnotationRetention.BINARY)\nannotation class Destination(\n    val url: String\n)\n\n```\n\n## 定义注解处理器模块\n\n1. 新建一个模块 router_compile\n2. 在 router_compile 目录中创建 build.gradle\n\n```groovy\n\napply plugin: \"kotlin\" // 使用kotlin插件\napply plugin: \"kotlin-kapt\" // 使用kotlin注解\n\n\n// 设置源码兼容性\ntargetCompatibility = JavaVersion.VERSION_1_8\nsourceCompatibility = JavaVersion.VERSION_1_8\n\ndependencies {\n    implementation project(\":router_annotations\")\n    implementation \"com.google.auto.service:auto-service:1.0-rc6\"\n    kapt \"com.google.auto.service:auto-service:1.0-rc6\"\n}\n\n// 应用 发布脚本。后面会写\napply from : rootProject.file(\"maven-publish.gradle\")\n```\n\n在注解处理器模块，如果使用kotlin写注解处理器代码，需要引用 `kotlin-kapt` 这个插件\n`implementation \"com.google.auto.service:auto-service:1.0-rc6\"` 使用google的一个注解框架。 \n同时还要加上 `kapt \"com.google.auto.service:auto-service:1.0-rc6\"` 。 这是kotlin的写法，如果是java，需要换成\n`annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'`\n\n3. 编写注解处理器\n```kotlin\n@AutoService(Processor::class)\nclass DestinationProcessor : AbstractProcessor() {\n\n    private val TAG = \"DestinationProcessor\"\n\n    override fun process(\n        set: MutableSet<out TypeElement>,\n        roundEnvironment: RoundEnvironment\n    ): Boolean {\n        if (roundEnvironment.processingOver()) {\n            return false\n        }\n        println(\"$TAG >>>> process start\")\n\n        println(set)\n\n        val destinationClasses = roundEnvironment.getElementsAnnotatedWith(Destination::class.java)\n\n        println(TAG + \" \" + destinationClasses.size)\n        if (destinationClasses.size < 1) {\n            return false\n        }\n\n        for (element in destinationClasses) {\n            val typeElement = element as TypeElement\n            val destination = typeElement.getAnnotation(Destination::class.java)\n                ?: continue\n            val url = destination.url\n            val className = typeElement.qualifiedName\n            println(\"$TAG $url $className\")\n        }\n\n        println(\"$TAG >>>> process finish\")\n\n        return true\n    }\n\n    override fun getSupportedAnnotationTypes(): MutableSet<String> {\n        return mutableSetOf(\n            Destination::class.java.canonicalName\n        )\n    }\n}\n```\n\n`@AutoService(Processor::class)` 是固定写法\n\n`AbstractProcessor` 继承这个抽象类。 \n重写`getSupportedAnnotationTypes`方法，返回需要处理的注解。\n重写`process`方法，处理注解信息。 返回值为true表示已处理这个注解，相同的注解不会再被其他注解处理器处理。\n`roundEnvironment.processingOver()`表示之前已经有处理过一轮，此时`roundEnvironment.elements.size==0` 不是很明白gradle为什么会执行多轮。。。\n\n## 在本地使用注解\n```groovy\nimplementation project(\":router_annotations\")\nkapt project(\":router_compile\")\n```\n \n## 将注解处理器打包成组件并发布\n\n1. 在最外层的 build.properties 中写通用参数\n```groovy\nPOM_URL=../repo  // 发布的仓库地址，这里是本地\nGROUP_ID=com.example.test // group\nVERSION_NAME=1.0.0 // 版本\n```\n\n2. 在 router_annotation 和 router_compile 中写 group_id\n```groovy\n// 在 router_annotation build.properties\nPOM_ARTIFACT_ID=router-test-annotation\n\n// 在 router_compile build.properties\nPOM_ARTIFACT_ID=router-test-processor\n```\n\n3. 编写发布脚本 maven-publish.gradle\n\n```groovy\napply plugin: 'maven' // 引入maven插件\n\n// 从根目录的 gradle.properties 中获取通用参数 start\ndef rootProperties = new Properties()\nrootProperties.load(new FileInputStream(project.rootProject.file(\"gradle.properties\")))\n\ndef versionName = rootProperties.getProperty(\"VERSION_NAME\")\ndef pomUrl = rootProperties.getProperty(\"POM_URL\") // ../repo\ndef groupId = rootProperties.getProperty(\"GROUP_ID\")\n// 获取通用参数 end\n\n// 从当前项目的 gradle.properties 中获取参数\ndef projectProperties = new Properties()\nprojectProperties.load(new FileInputStream(project.file(\"gradle.properties\")))\ndef pomArtifactId = projectProperties.getProperty(\"POM_ARTIFACT_ID\")\n\nprintln(\"maven-publish $versionName $pomUrl $groupId $pomArtifactId\")\n\n// 编写maven的发布任务\nuploadArchives {\n    repositories {\n        mavenDeployer {\n            repository(url: uri(pomUrl)) {\n                pom.groupId = groupId\n                pom.artifactId = pomArtifactId\n                pom.version = versionName\n            }\n\n            pom.whenConfigured { pom ->\n                pom.dependencies.forEach { dep ->\n                    if (dep.getVersion() == \"unspecified\") {\n                        dep.setGroupId(groupId)\n                        dep.setVersion(versionName)\n                    }\n\n                }\n\n            }\n        }\n    }\n}\n```\n\n注意有一个 `pom.whenConfigured { pom -> ...` 的代码，这是因为 router_compile 应用到了 router_annotations 模块。如果不做处理，发布之后， router_comiple 模块是找不到 router_annotations 的正确位置和版本的。所以要强制制定\n\n## 执行发布任务\n```bash\n./gradlew :router_compile:uploadArchives\n./gradlew :router_annotations:uploadArchives\n```\n我们设置的 `POM_URL=../repo` 所以最终会在项目的repo目录里生成aar包。 \n\n## 使用发布后的组件\n\n1. 首先，moven本地仓库地址加入到工程里\n```groovy\nbuildscript {\n    repositories {\n        maven { url uri('/Users/bytedance/code/test/repo') }\n        google()\n        mavenCentral()\n    }\n}\n\nallprojects {\n    repositories {\n        maven { url uri('/Users/bytedance/code/test/repo') }\n        google()\n        mavenCentral()\n    }\n}\n```\nbuildscript.repositories 和 allprojects.repositories 都要加，这样才会应用到所有子工程\n\n2. 在app模块里引用组件\n```groovy\n    implementation \"com.example.test:router-test-annotation:1.0.0\"\n    kapt \"com.example.test:router-test-processor:1.0.0\"\n```\n\n3. gradle版本的区别\n\n在 gradle 7.+ 版本有很多东西不兼容，上述实现只有在 gradle 6.+ 的版本有效。 gradle 的版本升级和项目创建还是要谨慎一些。 \n","slug":"Android/gradle/自定义注解处理器并发布为gradle组件","published":1,"updated":"2022-03-13T09:10:55.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9n005ng0jee3gzfm10","content":"<p>自定义一个基于注解的路由框架</p><h2 id=\"定义注解类\"><a href=\"#定义注解类\" class=\"headerlink\" title=\"定义注解类\"></a>定义注解类</h2><ol>\n<li>新建一个模块 router_annotations </li>\n<li>在 router_annotations 目录中创建 build.gradle </li>\n</ol><a id=\"more\"></a>\n\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"kotlin\"</span> <span class=\"comment\">// 使用 kotlin</span></span><br><span class=\"line\"></span><br><span class=\"line\">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 应用 发布脚本，后面会写</span></span><br><span class=\"line\">apply <span class=\"string\">from :</span> rootProject.file(<span class=\"string\">\"maven-publish.gradle\"</span>)</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>定义注解类</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置使用注解的对象是 类</span></span><br><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"comment\">// 设置注解只在编译期存在</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Destination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> url: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"定义注解处理器模块\"><a href=\"#定义注解处理器模块\" class=\"headerlink\" title=\"定义注解处理器模块\"></a>定义注解处理器模块</h2><ol>\n<li>新建一个模块 router_compile</li>\n<li>在 router_compile 目录中创建 build.gradle</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"kotlin\"</span> <span class=\"comment\">// 使用kotlin插件</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"kotlin-kapt\"</span> <span class=\"comment\">// 使用kotlin注解</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置源码兼容性</span></span><br><span class=\"line\">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation project(<span class=\"string\">\":router_annotations\"</span>)</span><br><span class=\"line\">    implementation <span class=\"string\">\"com.google.auto.service:auto-service:1.0-rc6\"</span></span><br><span class=\"line\">    kapt <span class=\"string\">\"com.google.auto.service:auto-service:1.0-rc6\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 应用 发布脚本。后面会写</span></span><br><span class=\"line\">apply <span class=\"string\">from :</span> rootProject.file(<span class=\"string\">\"maven-publish.gradle\"</span>)</span><br></pre></td></tr></table></figure>\n<p>在注解处理器模块，如果使用kotlin写注解处理器代码，需要引用 <code>kotlin-kapt</code> 这个插件<br><code>implementation &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 使用google的一个注解框架。<br>同时还要加上 <code>kapt &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 。 这是kotlin的写法，如果是java，需要换成<br><code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code></p>\n<ol start=\"3\">\n<li>编写注解处理器<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoService(Processor::class)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DestinationProcessor</span> : <span class=\"type\">AbstractProcessor</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> TAG = <span class=\"string\">\"DestinationProcessor\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">set</span>: <span class=\"type\">MutableSet</span>&lt;<span class=\"type\">out</span> <span class=\"type\">TypeElement</span>&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        roundEnvironment: <span class=\"type\">RoundEnvironment</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (roundEnvironment.processingOver()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        println(<span class=\"string\">\"<span class=\"variable\">$TAG</span> &gt;&gt;&gt;&gt; process start\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        println(<span class=\"keyword\">set</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> destinationClasses = roundEnvironment.getElementsAnnotatedWith(Destination::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        println(TAG + <span class=\"string\">\" \"</span> + destinationClasses.size)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (destinationClasses.size &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> destinationClasses) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> typeElement = element <span class=\"keyword\">as</span> TypeElement</span><br><span class=\"line\">            <span class=\"keyword\">val</span> destination = typeElement.getAnnotation(Destination::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">                ?: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> url = destination.url</span><br><span class=\"line\">            <span class=\"keyword\">val</span> className = typeElement.qualifiedName</span><br><span class=\"line\">            println(<span class=\"string\">\"<span class=\"variable\">$TAG</span> <span class=\"variable\">$url</span> <span class=\"variable\">$className</span>\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        println(<span class=\"string\">\"<span class=\"variable\">$TAG</span> &gt;&gt;&gt;&gt; process finish\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mutableSetOf(</span><br><span class=\"line\">            Destination::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>.<span class=\"title\">canonicalName</span></span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>@AutoService(Processor::class)</code> 是固定写法</p>\n<p><code>AbstractProcessor</code> 继承这个抽象类。<br>重写<code>getSupportedAnnotationTypes</code>方法，返回需要处理的注解。<br>重写<code>process</code>方法，处理注解信息。 返回值为true表示已处理这个注解，相同的注解不会再被其他注解处理器处理。<br><code>roundEnvironment.processingOver()</code>表示之前已经有处理过一轮，此时<code>roundEnvironment.elements.size==0</code> 不是很明白gradle为什么会执行多轮。。。</p>\n<h2 id=\"在本地使用注解\"><a href=\"#在本地使用注解\" class=\"headerlink\" title=\"在本地使用注解\"></a>在本地使用注解</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation project(<span class=\"string\">\":router_annotations\"</span>)</span><br><span class=\"line\">kapt project(<span class=\"string\">\":router_compile\"</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"将注解处理器打包成组件并发布\"><a href=\"#将注解处理器打包成组件并发布\" class=\"headerlink\" title=\"将注解处理器打包成组件并发布\"></a>将注解处理器打包成组件并发布</h2><ol>\n<li><p>在最外层的 build.properties 中写通用参数</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POM_URL=..<span class=\"regexp\">/repo  /</span>/ 发布的仓库地址，这里是本地</span><br><span class=\"line\">GROUP_ID=com.example.test <span class=\"comment\">// group</span></span><br><span class=\"line\">VERSION_NAME=<span class=\"number\">1.0</span><span class=\"number\">.0</span> <span class=\"comment\">// 版本</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 router_annotation 和 router_compile 中写 group_id</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 router_annotation build.properties</span></span><br><span class=\"line\">POM_ARTIFACT_ID=router-test-annotation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 router_compile build.properties</span></span><br><span class=\"line\">POM_ARTIFACT_ID=router-test-processor</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写发布脚本 maven-publish.gradle</p>\n</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'maven'</span> <span class=\"comment\">// 引入maven插件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从根目录的 gradle.properties 中获取通用参数 start</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> rootProperties = <span class=\"keyword\">new</span> Properties()</span><br><span class=\"line\">rootProperties.load(<span class=\"keyword\">new</span> FileInputStream(project.rootProject.file(<span class=\"string\">\"gradle.properties\"</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> versionName = rootProperties.getProperty(<span class=\"string\">\"VERSION_NAME\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">def</span> pomUrl = rootProperties.getProperty(<span class=\"string\">\"POM_URL\"</span>) <span class=\"comment\">// ../repo</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> groupId = rootProperties.getProperty(<span class=\"string\">\"GROUP_ID\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 获取通用参数 end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从当前项目的 gradle.properties 中获取参数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> projectProperties = <span class=\"keyword\">new</span> Properties()</span><br><span class=\"line\">projectProperties.load(<span class=\"keyword\">new</span> FileInputStream(project.file(<span class=\"string\">\"gradle.properties\"</span>)))</span><br><span class=\"line\"><span class=\"keyword\">def</span> pomArtifactId = projectProperties.getProperty(<span class=\"string\">\"POM_ARTIFACT_ID\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">println(<span class=\"string\">\"maven-publish $versionName $pomUrl $groupId $pomArtifactId\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编写maven的发布任务</span></span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        mavenDeployer &#123;</span><br><span class=\"line\">            repository(<span class=\"string\">url:</span> uri(pomUrl)) &#123;</span><br><span class=\"line\">                pom.groupId = groupId</span><br><span class=\"line\">                pom.artifactId = pomArtifactId</span><br><span class=\"line\">                pom.version = versionName</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            pom.whenConfigured &#123; pom -&gt;</span><br><span class=\"line\">                pom.dependencies.forEach &#123; dep -&gt;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dep.getVersion() == <span class=\"string\">\"unspecified\"</span>) &#123;</span><br><span class=\"line\">                        dep.setGroupId(groupId)</span><br><span class=\"line\">                        dep.setVersion(versionName)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意有一个 <code>pom.whenConfigured { pom -&gt; ...</code> 的代码，这是因为 router_compile 应用到了 router_annotations 模块。如果不做处理，发布之后， router_comiple 模块是找不到 router_annotations 的正确位置和版本的。所以要强制制定</p>\n<h2 id=\"执行发布任务\"><a href=\"#执行发布任务\" class=\"headerlink\" title=\"执行发布任务\"></a>执行发布任务</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gradlew :router_compile:uploadArchives</span><br><span class=\"line\">./gradlew :router_annotations:uploadArchives</span><br></pre></td></tr></table></figure>\n<p>我们设置的 <code>POM_URL=../repo</code> 所以最终会在项目的repo目录里生成aar包。 </p>\n<h2 id=\"使用发布后的组件\"><a href=\"#使用发布后的组件\" class=\"headerlink\" title=\"使用发布后的组件\"></a>使用发布后的组件</h2><ol>\n<li>首先，moven本地仓库地址加入到工程里<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123; url uri(<span class=\"string\">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123; url uri(<span class=\"string\">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>buildscript.repositories 和 allprojects.repositories 都要加，这样才会应用到所有子工程</p>\n<ol start=\"2\">\n<li><p>在app模块里引用组件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">\"com.example.test:router-test-annotation:1.0.0\"</span></span><br><span class=\"line\">kapt <span class=\"string\">\"com.example.test:router-test-processor:1.0.0\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>gradle版本的区别</p>\n</li>\n</ol>\n<p>在 gradle 7.+ 版本有很多东西不兼容，上述实现只有在 gradle 6.+ 的版本有效。 gradle 的版本升级和项目创建还是要谨慎一些。 </p>\n","site":{"data":{}},"excerpt":"<p>自定义一个基于注解的路由框架</p><h2 id=\"定义注解类\"><a href=\"#定义注解类\" class=\"headerlink\" title=\"定义注解类\"></a>定义注解类</h2><ol>\n<li>新建一个模块 router_annotations </li>\n<li>在 router_annotations 目录中创建 build.gradle </li>\n</ol>","more":"\n\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"kotlin\"</span> <span class=\"comment\">// 使用 kotlin</span></span><br><span class=\"line\"></span><br><span class=\"line\">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 应用 发布脚本，后面会写</span></span><br><span class=\"line\">apply <span class=\"string\">from :</span> rootProject.file(<span class=\"string\">\"maven-publish.gradle\"</span>)</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>定义注解类</li>\n</ol>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置使用注解的对象是 类</span></span><br><span class=\"line\"><span class=\"meta\">@Target(AnnotationTarget.CLASS)</span></span><br><span class=\"line\"><span class=\"comment\">// 设置注解只在编译期存在</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(AnnotationRetention.BINARY)</span></span><br><span class=\"line\"><span class=\"keyword\">annotation</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Destination</span></span>(</span><br><span class=\"line\">    <span class=\"keyword\">val</span> url: String</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h2 id=\"定义注解处理器模块\"><a href=\"#定义注解处理器模块\" class=\"headerlink\" title=\"定义注解处理器模块\"></a>定义注解处理器模块</h2><ol>\n<li>新建一个模块 router_compile</li>\n<li>在 router_compile 目录中创建 build.gradle</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"kotlin\"</span> <span class=\"comment\">// 使用kotlin插件</span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"kotlin-kapt\"</span> <span class=\"comment\">// 使用kotlin注解</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置源码兼容性</span></span><br><span class=\"line\">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation project(<span class=\"string\">\":router_annotations\"</span>)</span><br><span class=\"line\">    implementation <span class=\"string\">\"com.google.auto.service:auto-service:1.0-rc6\"</span></span><br><span class=\"line\">    kapt <span class=\"string\">\"com.google.auto.service:auto-service:1.0-rc6\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 应用 发布脚本。后面会写</span></span><br><span class=\"line\">apply <span class=\"string\">from :</span> rootProject.file(<span class=\"string\">\"maven-publish.gradle\"</span>)</span><br></pre></td></tr></table></figure>\n<p>在注解处理器模块，如果使用kotlin写注解处理器代码，需要引用 <code>kotlin-kapt</code> 这个插件<br><code>implementation &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 使用google的一个注解框架。<br>同时还要加上 <code>kapt &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 。 这是kotlin的写法，如果是java，需要换成<br><code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code></p>\n<ol start=\"3\">\n<li>编写注解处理器<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AutoService(Processor::class)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DestinationProcessor</span> : <span class=\"type\">AbstractProcessor</span></span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> TAG = <span class=\"string\">\"DestinationProcessor\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">process</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">set</span>: <span class=\"type\">MutableSet</span>&lt;<span class=\"type\">out</span> <span class=\"type\">TypeElement</span>&gt;,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        roundEnvironment: <span class=\"type\">RoundEnvironment</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>: <span class=\"built_in\">Boolean</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (roundEnvironment.processingOver()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        println(<span class=\"string\">\"<span class=\"variable\">$TAG</span> &gt;&gt;&gt;&gt; process start\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        println(<span class=\"keyword\">set</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">val</span> destinationClasses = roundEnvironment.getElementsAnnotatedWith(Destination::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">        println(TAG + <span class=\"string\">\" \"</span> + destinationClasses.size)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (destinationClasses.size &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (element <span class=\"keyword\">in</span> destinationClasses) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">val</span> typeElement = element <span class=\"keyword\">as</span> TypeElement</span><br><span class=\"line\">            <span class=\"keyword\">val</span> destination = typeElement.getAnnotation(Destination::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>)</span></span><br><span class=\"line\">                ?: <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> url = destination.url</span><br><span class=\"line\">            <span class=\"keyword\">val</span> className = typeElement.qualifiedName</span><br><span class=\"line\">            println(<span class=\"string\">\"<span class=\"variable\">$TAG</span> <span class=\"variable\">$url</span> <span class=\"variable\">$className</span>\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        println(<span class=\"string\">\"<span class=\"variable\">$TAG</span> &gt;&gt;&gt;&gt; process finish\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">getSupportedAnnotationTypes</span><span class=\"params\">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mutableSetOf(</span><br><span class=\"line\">            Destination::<span class=\"class\"><span class=\"keyword\">class</span>.<span class=\"title\">java</span>.<span class=\"title\">canonicalName</span></span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><code>@AutoService(Processor::class)</code> 是固定写法</p>\n<p><code>AbstractProcessor</code> 继承这个抽象类。<br>重写<code>getSupportedAnnotationTypes</code>方法，返回需要处理的注解。<br>重写<code>process</code>方法，处理注解信息。 返回值为true表示已处理这个注解，相同的注解不会再被其他注解处理器处理。<br><code>roundEnvironment.processingOver()</code>表示之前已经有处理过一轮，此时<code>roundEnvironment.elements.size==0</code> 不是很明白gradle为什么会执行多轮。。。</p>\n<h2 id=\"在本地使用注解\"><a href=\"#在本地使用注解\" class=\"headerlink\" title=\"在本地使用注解\"></a>在本地使用注解</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation project(<span class=\"string\">\":router_annotations\"</span>)</span><br><span class=\"line\">kapt project(<span class=\"string\">\":router_compile\"</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"将注解处理器打包成组件并发布\"><a href=\"#将注解处理器打包成组件并发布\" class=\"headerlink\" title=\"将注解处理器打包成组件并发布\"></a>将注解处理器打包成组件并发布</h2><ol>\n<li><p>在最外层的 build.properties 中写通用参数</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POM_URL=..<span class=\"regexp\">/repo  /</span>/ 发布的仓库地址，这里是本地</span><br><span class=\"line\">GROUP_ID=com.example.test <span class=\"comment\">// group</span></span><br><span class=\"line\">VERSION_NAME=<span class=\"number\">1.0</span><span class=\"number\">.0</span> <span class=\"comment\">// 版本</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 router_annotation 和 router_compile 中写 group_id</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 router_annotation build.properties</span></span><br><span class=\"line\">POM_ARTIFACT_ID=router-test-annotation</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 router_compile build.properties</span></span><br><span class=\"line\">POM_ARTIFACT_ID=router-test-processor</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写发布脚本 maven-publish.gradle</p>\n</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'maven'</span> <span class=\"comment\">// 引入maven插件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从根目录的 gradle.properties 中获取通用参数 start</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> rootProperties = <span class=\"keyword\">new</span> Properties()</span><br><span class=\"line\">rootProperties.load(<span class=\"keyword\">new</span> FileInputStream(project.rootProject.file(<span class=\"string\">\"gradle.properties\"</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> versionName = rootProperties.getProperty(<span class=\"string\">\"VERSION_NAME\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">def</span> pomUrl = rootProperties.getProperty(<span class=\"string\">\"POM_URL\"</span>) <span class=\"comment\">// ../repo</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> groupId = rootProperties.getProperty(<span class=\"string\">\"GROUP_ID\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// 获取通用参数 end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从当前项目的 gradle.properties 中获取参数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> projectProperties = <span class=\"keyword\">new</span> Properties()</span><br><span class=\"line\">projectProperties.load(<span class=\"keyword\">new</span> FileInputStream(project.file(<span class=\"string\">\"gradle.properties\"</span>)))</span><br><span class=\"line\"><span class=\"keyword\">def</span> pomArtifactId = projectProperties.getProperty(<span class=\"string\">\"POM_ARTIFACT_ID\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">println(<span class=\"string\">\"maven-publish $versionName $pomUrl $groupId $pomArtifactId\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编写maven的发布任务</span></span><br><span class=\"line\">uploadArchives &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        mavenDeployer &#123;</span><br><span class=\"line\">            repository(<span class=\"string\">url:</span> uri(pomUrl)) &#123;</span><br><span class=\"line\">                pom.groupId = groupId</span><br><span class=\"line\">                pom.artifactId = pomArtifactId</span><br><span class=\"line\">                pom.version = versionName</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            pom.whenConfigured &#123; pom -&gt;</span><br><span class=\"line\">                pom.dependencies.forEach &#123; dep -&gt;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dep.getVersion() == <span class=\"string\">\"unspecified\"</span>) &#123;</span><br><span class=\"line\">                        dep.setGroupId(groupId)</span><br><span class=\"line\">                        dep.setVersion(versionName)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意有一个 <code>pom.whenConfigured { pom -&gt; ...</code> 的代码，这是因为 router_compile 应用到了 router_annotations 模块。如果不做处理，发布之后， router_comiple 模块是找不到 router_annotations 的正确位置和版本的。所以要强制制定</p>\n<h2 id=\"执行发布任务\"><a href=\"#执行发布任务\" class=\"headerlink\" title=\"执行发布任务\"></a>执行发布任务</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./gradlew :router_compile:uploadArchives</span><br><span class=\"line\">./gradlew :router_annotations:uploadArchives</span><br></pre></td></tr></table></figure>\n<p>我们设置的 <code>POM_URL=../repo</code> 所以最终会在项目的repo目录里生成aar包。 </p>\n<h2 id=\"使用发布后的组件\"><a href=\"#使用发布后的组件\" class=\"headerlink\" title=\"使用发布后的组件\"></a>使用发布后的组件</h2><ol>\n<li>首先，moven本地仓库地址加入到工程里<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123; url uri(<span class=\"string\">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        maven &#123; url uri(<span class=\"string\">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        mavenCentral()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>buildscript.repositories 和 allprojects.repositories 都要加，这样才会应用到所有子工程</p>\n<ol start=\"2\">\n<li><p>在app模块里引用组件</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">\"com.example.test:router-test-annotation:1.0.0\"</span></span><br><span class=\"line\">kapt <span class=\"string\">\"com.example.test:router-test-processor:1.0.0\"</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>gradle版本的区别</p>\n</li>\n</ol>\n<p>在 gradle 7.+ 版本有很多东西不兼容，上述实现只有在 gradle 6.+ 的版本有效。 gradle 的版本升级和项目创建还是要谨慎一些。 </p>\n"},{"title":"自定义gradle插件","date":"2022-03-19T09:52:18.000Z","_content":"\n这里只记录本地插件的写法\n\n## 创建 buildSrc 目录\n1. 在创建的 buildScr 目录中创建 build.gradle 文件\n\n```groovy\napply plugin: \"groovy\"\n\nrepositories {\n    jcenter()\n    google()\n    mavenCentral()\n\n}\n\ndependencies {\n    implementation gradleApi()\n    implementation localGroovy()\n}\n\n// 设置源码兼容性\ntargetCompatibility = JavaVersion.VERSION_1_8\nsourceCompatibility = JavaVersion.VERSION_1_8\n\n```\n\n上面是固定写法，这里只使用了 groovy 插件，所以我们的插件代码只支持用 groovy 编写\n\n2. 在 buildSrc 目录中，创建对应的 groovy 目录\n文件路径是\nsrc/main/groovy/...(包名)/\n\n3. 创建 自定义的插件 RouterPlugin2\n   \n创建文件名 RouterPlugin2.Plugin\n创建插件类，并实现 Plugin 接口\n\n```groovy\n\nclass RouterPlugin2 implements Plugin<Project> {\n\n    String TAG = \"RouterPlugin2\"\n\n    @Override\n    void apply(Project project) {\n        ...\n    }\n}\n```\n   \n4. 创建 res 文件暴露自己的 groovy\n创建文件路径：\nsrc/main/resources/META-INF.gradle-plugins/RouterPlugin.properties\n\n内容如下\n```groovy\nimplementation-class=com.example.test.RouterPlugin2\n```\n\n创建的文件名 META-INF.gradle-plugins 是固定目录名，xxxx.properties 中的xxxx就是对外暴露的插件的名字。 properties文件的内容表示插件的实现类\n\n## 外部使用插件\n\n1. 导入插件\n\n在业务的module的 build.gradle 文件中\n\n```groovy\napply plugin: \"RouterPlugin2\"\n```\n\n2. 向插件写入参数\n\n在 buildSrc module 中创建一个 groovy 类，代表参数的model类\n\n```groovy\nclass RouterExtension2 {\n    String wiki;\n}\n```\n\n3. 插件类读取参数\n```groovy\ndef extension = project.extensions.create(\"router\", RouterExtension2)\ndef path = extension.wiki\n```\n\n4. 在业务调用方传入参数\n```groovy\napply plugin: \"RouterPlugin2\"\n\nrouter {\n    wiki \"${getRootDir().absolutePath}/router_wiki.md\"\n}\n```\n\n## RouterPlugin2 的详细实现\n\n插件中要实现三个功能\n1. 在使用路由注解处理器的module，都向注解处理器插入一个参数，代表路由文件生成的路径。 \n2. 在项目clean时清除掉注解中间文件\n3. 将所有module生成的注解中间文件，汇总生成一个路由wiki文档\n\n```groovy\npackage com.example.test\n\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project\n\nclass RouterPlugin2 implements Plugin<Project> {\n\n    String TAG = \"RouterPlugin2\"\n\n    @Override\n    void apply(Project project) {\n\n        println(\"$TAG apply kotlin\")\n\n        def routerFileDir = new File(project.getRootDir(), \"router_mapping\")\n\n        /**\n         * kapt {\n         *      rguments {\n         *          arg(\"router_mapping\", rootProject.rootProjectDir.absolutePath）\n         *      }\n         *  }\n         **/\n        // 1. 自动帮助用户传递路径参数到注解处理器中 start\n        // 以下代码可以替代以上的 build.gradle 配置\n        if (project.extensions.findByName(\"kapt\") != null) {\n            project.extensions.findByName(\"kapt\").arguments {\n                arg(\"router_file_dir\", routerFileDir)\n                arg(\"project_name\", project.name)\n            }\n        }\n        // 1. 自动帮助用户传递路径参数到注解处理器中 end\n\n        // 2. 在clean时自动清理旧的构建产物\n        project.clean.doFirst {\n            def routerMappingFile = routerFileDir\n            if (routerMappingFile.exists()) {\n                routerMappingFile.deleteDir()\n            }\n        }\n\n        // 3. 集合各个子project路由信息，生成路由文档\n        def extension = project.extensions.create(\"router\", RouterExtension2)\n        project.afterEvaluate {\n            // 在工程完成配置阶段之后才能获取到 外部配置的参数\n            def wikiPath = extension.wiki\n            project.tasks.findAll { task ->\n                // 找到编译的task，compileDebugJavaWithJavac\n                task.name.startsWith(\"compile\") && task.name.endsWith(\"JavaWithJavac\")\n            }.each {task ->\n                task.doLast {\n                    def wikiFile = new File(wikiPath)\n                    if (!wikiFile.exists()) {\n                        wikiFile.createNewFile()\n                    }\n                    def jsonFiles = routerFileDir\n                    jsonFiles.eachFile {file ->\n                        def content = file.readBytes()\n                        wikiFile.append(new String(content))\n                    }\n                    // write jsonFile content into wikiPath\n                }\n            }\n        }\n    }\n}\n```\n\n\n","source":"_posts/Android/gradle/自定义gradle插件.md","raw":"---\ntitle: 自定义gradle插件\ndate: 2022-03-19 17:52:18\ntags:\n- Gradle\ncategories: \n- Android\n---\n\n这里只记录本地插件的写法\n\n## 创建 buildSrc 目录\n1. 在创建的 buildScr 目录中创建 build.gradle 文件\n\n```groovy\napply plugin: \"groovy\"\n\nrepositories {\n    jcenter()\n    google()\n    mavenCentral()\n\n}\n\ndependencies {\n    implementation gradleApi()\n    implementation localGroovy()\n}\n\n// 设置源码兼容性\ntargetCompatibility = JavaVersion.VERSION_1_8\nsourceCompatibility = JavaVersion.VERSION_1_8\n\n```\n\n上面是固定写法，这里只使用了 groovy 插件，所以我们的插件代码只支持用 groovy 编写\n\n2. 在 buildSrc 目录中，创建对应的 groovy 目录\n文件路径是\nsrc/main/groovy/...(包名)/\n\n3. 创建 自定义的插件 RouterPlugin2\n   \n创建文件名 RouterPlugin2.Plugin\n创建插件类，并实现 Plugin 接口\n\n```groovy\n\nclass RouterPlugin2 implements Plugin<Project> {\n\n    String TAG = \"RouterPlugin2\"\n\n    @Override\n    void apply(Project project) {\n        ...\n    }\n}\n```\n   \n4. 创建 res 文件暴露自己的 groovy\n创建文件路径：\nsrc/main/resources/META-INF.gradle-plugins/RouterPlugin.properties\n\n内容如下\n```groovy\nimplementation-class=com.example.test.RouterPlugin2\n```\n\n创建的文件名 META-INF.gradle-plugins 是固定目录名，xxxx.properties 中的xxxx就是对外暴露的插件的名字。 properties文件的内容表示插件的实现类\n\n## 外部使用插件\n\n1. 导入插件\n\n在业务的module的 build.gradle 文件中\n\n```groovy\napply plugin: \"RouterPlugin2\"\n```\n\n2. 向插件写入参数\n\n在 buildSrc module 中创建一个 groovy 类，代表参数的model类\n\n```groovy\nclass RouterExtension2 {\n    String wiki;\n}\n```\n\n3. 插件类读取参数\n```groovy\ndef extension = project.extensions.create(\"router\", RouterExtension2)\ndef path = extension.wiki\n```\n\n4. 在业务调用方传入参数\n```groovy\napply plugin: \"RouterPlugin2\"\n\nrouter {\n    wiki \"${getRootDir().absolutePath}/router_wiki.md\"\n}\n```\n\n## RouterPlugin2 的详细实现\n\n插件中要实现三个功能\n1. 在使用路由注解处理器的module，都向注解处理器插入一个参数，代表路由文件生成的路径。 \n2. 在项目clean时清除掉注解中间文件\n3. 将所有module生成的注解中间文件，汇总生成一个路由wiki文档\n\n```groovy\npackage com.example.test\n\nimport org.gradle.api.Plugin\nimport org.gradle.api.Project\n\nclass RouterPlugin2 implements Plugin<Project> {\n\n    String TAG = \"RouterPlugin2\"\n\n    @Override\n    void apply(Project project) {\n\n        println(\"$TAG apply kotlin\")\n\n        def routerFileDir = new File(project.getRootDir(), \"router_mapping\")\n\n        /**\n         * kapt {\n         *      rguments {\n         *          arg(\"router_mapping\", rootProject.rootProjectDir.absolutePath）\n         *      }\n         *  }\n         **/\n        // 1. 自动帮助用户传递路径参数到注解处理器中 start\n        // 以下代码可以替代以上的 build.gradle 配置\n        if (project.extensions.findByName(\"kapt\") != null) {\n            project.extensions.findByName(\"kapt\").arguments {\n                arg(\"router_file_dir\", routerFileDir)\n                arg(\"project_name\", project.name)\n            }\n        }\n        // 1. 自动帮助用户传递路径参数到注解处理器中 end\n\n        // 2. 在clean时自动清理旧的构建产物\n        project.clean.doFirst {\n            def routerMappingFile = routerFileDir\n            if (routerMappingFile.exists()) {\n                routerMappingFile.deleteDir()\n            }\n        }\n\n        // 3. 集合各个子project路由信息，生成路由文档\n        def extension = project.extensions.create(\"router\", RouterExtension2)\n        project.afterEvaluate {\n            // 在工程完成配置阶段之后才能获取到 外部配置的参数\n            def wikiPath = extension.wiki\n            project.tasks.findAll { task ->\n                // 找到编译的task，compileDebugJavaWithJavac\n                task.name.startsWith(\"compile\") && task.name.endsWith(\"JavaWithJavac\")\n            }.each {task ->\n                task.doLast {\n                    def wikiFile = new File(wikiPath)\n                    if (!wikiFile.exists()) {\n                        wikiFile.createNewFile()\n                    }\n                    def jsonFiles = routerFileDir\n                    jsonFiles.eachFile {file ->\n                        def content = file.readBytes()\n                        wikiFile.append(new String(content))\n                    }\n                    // write jsonFile content into wikiPath\n                }\n            }\n        }\n    }\n}\n```\n\n\n","slug":"Android/gradle/自定义gradle插件","published":1,"updated":"2022-05-04T08:53:22.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9o005og0jegbacs4aw","content":"<p>这里只记录本地插件的写法</p><h2 id=\"创建-buildSrc-目录\"><a href=\"#创建-buildSrc-目录\" class=\"headerlink\" title=\"创建 buildSrc 目录\"></a>创建 buildSrc 目录</h2><a id=\"more\"></a>\n<ol>\n<li>在创建的 buildScr 目录中创建 build.gradle 文件</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"groovy\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    jcenter()</span><br><span class=\"line\">    google()</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation gradleApi()</span><br><span class=\"line\">    implementation localGroovy()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置源码兼容性</span></span><br><span class=\"line\">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\">sourceCompatibility = JavaVersion.VERSION_1_8</span><br></pre></td></tr></table></figure>\n<p>上面是固定写法，这里只使用了 groovy 插件，所以我们的插件代码只支持用 groovy 编写</p>\n<ol start=\"2\">\n<li><p>在 buildSrc 目录中，创建对应的 groovy 目录<br>文件路径是<br>src/main/groovy/…(包名)/</p>\n</li>\n<li><p>创建 自定义的插件 RouterPlugin2</p>\n</li>\n</ol>\n<p>创建文件名 RouterPlugin2.Plugin<br>创建插件类，并实现 Plugin 接口</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterPlugin2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    String TAG = <span class=\"string\">\"RouterPlugin2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>创建 res 文件暴露自己的 groovy<br>创建文件路径：<br>src/main/resources/META-INF.gradle-plugins/RouterPlugin.properties</li>\n</ol>\n<p>内容如下<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-<span class=\"class\"><span class=\"keyword\">class</span>=<span class=\"title\">com</span>.<span class=\"title\">example</span>.<span class=\"title\">test</span>.<span class=\"title\">RouterPlugin2</span></span></span><br></pre></td></tr></table></figure></p>\n<p>创建的文件名 META-INF.gradle-plugins 是固定目录名，xxxx.properties 中的xxxx就是对外暴露的插件的名字。 properties文件的内容表示插件的实现类</p>\n<h2 id=\"外部使用插件\"><a href=\"#外部使用插件\" class=\"headerlink\" title=\"外部使用插件\"></a>外部使用插件</h2><ol>\n<li>导入插件</li>\n</ol>\n<p>在业务的module的 build.gradle 文件中</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"RouterPlugin2\"</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>向插件写入参数</li>\n</ol>\n<p>在 buildSrc module 中创建一个 groovy 类，代表参数的model类</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterExtension2</span> &#123;</span></span><br><span class=\"line\">    String wiki;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>插件类读取参数</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> extension = project.extensions.create(<span class=\"string\">\"router\"</span>, RouterExtension2)</span><br><span class=\"line\"><span class=\"keyword\">def</span> path = extension.wiki</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在业务调用方传入参数</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"RouterPlugin2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">router &#123;</span><br><span class=\"line\">    wiki <span class=\"string\">\"$&#123;getRootDir().absolutePath&#125;/router_wiki.md\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"RouterPlugin2-的详细实现\"><a href=\"#RouterPlugin2-的详细实现\" class=\"headerlink\" title=\"RouterPlugin2 的详细实现\"></a>RouterPlugin2 的详细实现</h2><p>插件中要实现三个功能</p>\n<ol>\n<li>在使用路由注解处理器的module，都向注解处理器插入一个参数，代表路由文件生成的路径。 </li>\n<li>在项目clean时清除掉注解中间文件</li>\n<li>将所有module生成的注解中间文件，汇总生成一个路由wiki文档</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.Plugin</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.Project</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterPlugin2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    String TAG = <span class=\"string\">\"RouterPlugin2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        println(<span class=\"string\">\"$TAG apply kotlin\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> routerFileDir = <span class=\"keyword\">new</span> File(project.getRootDir(), <span class=\"string\">\"router_mapping\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * kapt &#123;</span></span><br><span class=\"line\"><span class=\"comment\">         *      rguments &#123;</span></span><br><span class=\"line\"><span class=\"comment\">         *          arg(\"router_mapping\", rootProject.rootProjectDir.absolutePath）</span></span><br><span class=\"line\"><span class=\"comment\">         *      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">         *  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">         **/</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 自动帮助用户传递路径参数到注解处理器中 start</span></span><br><span class=\"line\">        <span class=\"comment\">// 以下代码可以替代以上的 build.gradle 配置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (project.extensions.findByName(<span class=\"string\">\"kapt\"</span>) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            project.extensions.findByName(<span class=\"string\">\"kapt\"</span>).arguments &#123;</span><br><span class=\"line\">                arg(<span class=\"string\">\"router_file_dir\"</span>, routerFileDir)</span><br><span class=\"line\">                arg(<span class=\"string\">\"project_name\"</span>, project.name)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 自动帮助用户传递路径参数到注解处理器中 end</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. 在clean时自动清理旧的构建产物</span></span><br><span class=\"line\">        project.clean.doFirst &#123;</span><br><span class=\"line\">            <span class=\"keyword\">def</span> routerMappingFile = routerFileDir</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (routerMappingFile.exists()) &#123;</span><br><span class=\"line\">                routerMappingFile.deleteDir()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 集合各个子project路由信息，生成路由文档</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> extension = project.extensions.create(<span class=\"string\">\"router\"</span>, RouterExtension2)</span><br><span class=\"line\">        project.afterEvaluate &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在工程完成配置阶段之后才能获取到 外部配置的参数</span></span><br><span class=\"line\">            <span class=\"keyword\">def</span> wikiPath = extension.wiki</span><br><span class=\"line\">            project.tasks.findAll &#123; task -&gt;</span><br><span class=\"line\">                <span class=\"comment\">// 找到编译的task，compileDebugJavaWithJavac</span></span><br><span class=\"line\">                task.name.startsWith(<span class=\"string\">\"compile\"</span>) &amp;&amp; task.name.endsWith(<span class=\"string\">\"JavaWithJavac\"</span>)</span><br><span class=\"line\">            &#125;.each &#123;task -&gt;</span><br><span class=\"line\">                task.doLast &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">def</span> wikiFile = <span class=\"keyword\">new</span> File(wikiPath)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!wikiFile.exists()) &#123;</span><br><span class=\"line\">                        wikiFile.createNewFile()</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">def</span> jsonFiles = routerFileDir</span><br><span class=\"line\">                    jsonFiles.eachFile &#123;file -&gt;</span><br><span class=\"line\">                        <span class=\"keyword\">def</span> content = file.readBytes()</span><br><span class=\"line\">                        wikiFile.append(<span class=\"keyword\">new</span> String(content))</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// write jsonFile content into wikiPath</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>这里只记录本地插件的写法</p><h2 id=\"创建-buildSrc-目录\"><a href=\"#创建-buildSrc-目录\" class=\"headerlink\" title=\"创建 buildSrc 目录\"></a>创建 buildSrc 目录</h2>","more":"\n<ol>\n<li>在创建的 buildScr 目录中创建 build.gradle 文件</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"groovy\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    jcenter()</span><br><span class=\"line\">    google()</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation gradleApi()</span><br><span class=\"line\">    implementation localGroovy()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置源码兼容性</span></span><br><span class=\"line\">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class=\"line\">sourceCompatibility = JavaVersion.VERSION_1_8</span><br></pre></td></tr></table></figure>\n<p>上面是固定写法，这里只使用了 groovy 插件，所以我们的插件代码只支持用 groovy 编写</p>\n<ol start=\"2\">\n<li><p>在 buildSrc 目录中，创建对应的 groovy 目录<br>文件路径是<br>src/main/groovy/…(包名)/</p>\n</li>\n<li><p>创建 自定义的插件 RouterPlugin2</p>\n</li>\n</ol>\n<p>创建文件名 RouterPlugin2.Plugin<br>创建插件类，并实现 Plugin 接口</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterPlugin2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    String TAG = <span class=\"string\">\"RouterPlugin2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>创建 res 文件暴露自己的 groovy<br>创建文件路径：<br>src/main/resources/META-INF.gradle-plugins/RouterPlugin.properties</li>\n</ol>\n<p>内容如下<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation-<span class=\"class\"><span class=\"keyword\">class</span>=<span class=\"title\">com</span>.<span class=\"title\">example</span>.<span class=\"title\">test</span>.<span class=\"title\">RouterPlugin2</span></span></span><br></pre></td></tr></table></figure></p>\n<p>创建的文件名 META-INF.gradle-plugins 是固定目录名，xxxx.properties 中的xxxx就是对外暴露的插件的名字。 properties文件的内容表示插件的实现类</p>\n<h2 id=\"外部使用插件\"><a href=\"#外部使用插件\" class=\"headerlink\" title=\"外部使用插件\"></a>外部使用插件</h2><ol>\n<li>导入插件</li>\n</ol>\n<p>在业务的module的 build.gradle 文件中</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"RouterPlugin2\"</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>向插件写入参数</li>\n</ol>\n<p>在 buildSrc module 中创建一个 groovy 类，代表参数的model类</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterExtension2</span> &#123;</span></span><br><span class=\"line\">    String wiki;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>插件类读取参数</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> extension = project.extensions.create(<span class=\"string\">\"router\"</span>, RouterExtension2)</span><br><span class=\"line\"><span class=\"keyword\">def</span> path = extension.wiki</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在业务调用方传入参数</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">\"RouterPlugin2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">router &#123;</span><br><span class=\"line\">    wiki <span class=\"string\">\"$&#123;getRootDir().absolutePath&#125;/router_wiki.md\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"RouterPlugin2-的详细实现\"><a href=\"#RouterPlugin2-的详细实现\" class=\"headerlink\" title=\"RouterPlugin2 的详细实现\"></a>RouterPlugin2 的详细实现</h2><p>插件中要实现三个功能</p>\n<ol>\n<li>在使用路由注解处理器的module，都向注解处理器插入一个参数，代表路由文件生成的路径。 </li>\n<li>在项目clean时清除掉注解中间文件</li>\n<li>将所有module生成的注解中间文件，汇总生成一个路由wiki文档</li>\n</ol>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.Plugin</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.gradle.api.Project</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterPlugin2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    String TAG = <span class=\"string\">\"RouterPlugin2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        println(<span class=\"string\">\"$TAG apply kotlin\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">def</span> routerFileDir = <span class=\"keyword\">new</span> File(project.getRootDir(), <span class=\"string\">\"router_mapping\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * kapt &#123;</span></span><br><span class=\"line\"><span class=\"comment\">         *      rguments &#123;</span></span><br><span class=\"line\"><span class=\"comment\">         *          arg(\"router_mapping\", rootProject.rootProjectDir.absolutePath）</span></span><br><span class=\"line\"><span class=\"comment\">         *      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">         *  &#125;</span></span><br><span class=\"line\"><span class=\"comment\">         **/</span></span><br><span class=\"line\">        <span class=\"comment\">// 1. 自动帮助用户传递路径参数到注解处理器中 start</span></span><br><span class=\"line\">        <span class=\"comment\">// 以下代码可以替代以上的 build.gradle 配置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (project.extensions.findByName(<span class=\"string\">\"kapt\"</span>) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            project.extensions.findByName(<span class=\"string\">\"kapt\"</span>).arguments &#123;</span><br><span class=\"line\">                arg(<span class=\"string\">\"router_file_dir\"</span>, routerFileDir)</span><br><span class=\"line\">                arg(<span class=\"string\">\"project_name\"</span>, project.name)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 自动帮助用户传递路径参数到注解处理器中 end</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. 在clean时自动清理旧的构建产物</span></span><br><span class=\"line\">        project.clean.doFirst &#123;</span><br><span class=\"line\">            <span class=\"keyword\">def</span> routerMappingFile = routerFileDir</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (routerMappingFile.exists()) &#123;</span><br><span class=\"line\">                routerMappingFile.deleteDir()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3. 集合各个子project路由信息，生成路由文档</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> extension = project.extensions.create(<span class=\"string\">\"router\"</span>, RouterExtension2)</span><br><span class=\"line\">        project.afterEvaluate &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在工程完成配置阶段之后才能获取到 外部配置的参数</span></span><br><span class=\"line\">            <span class=\"keyword\">def</span> wikiPath = extension.wiki</span><br><span class=\"line\">            project.tasks.findAll &#123; task -&gt;</span><br><span class=\"line\">                <span class=\"comment\">// 找到编译的task，compileDebugJavaWithJavac</span></span><br><span class=\"line\">                task.name.startsWith(<span class=\"string\">\"compile\"</span>) &amp;&amp; task.name.endsWith(<span class=\"string\">\"JavaWithJavac\"</span>)</span><br><span class=\"line\">            &#125;.each &#123;task -&gt;</span><br><span class=\"line\">                task.doLast &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">def</span> wikiFile = <span class=\"keyword\">new</span> File(wikiPath)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!wikiFile.exists()) &#123;</span><br><span class=\"line\">                        wikiFile.createNewFile()</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">def</span> jsonFiles = routerFileDir</span><br><span class=\"line\">                    jsonFiles.eachFile &#123;file -&gt;</span><br><span class=\"line\">                        <span class=\"keyword\">def</span> content = file.readBytes()</span><br><span class=\"line\">                        wikiFile.append(<span class=\"keyword\">new</span> String(content))</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">// write jsonFile content into wikiPath</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"transform和asm初探","date":"2022-03-21T13:54:26.000Z","_content":"\n## 自定义RouterTransform\nTransform 是AGP官方提供的接口，在 class->dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类\n\n### 添加依赖\n因为是安卓官方提供的能力，需要在 buildSrc 的 build.gradle 中 添加 google() 仓库和安卓构建工具的依赖\n\n```groovy\nrepositories {\n    jcenter()\n    google()\n    mavenCentral()\n\n}\n\ndependencies {\n    implementation gradleApi()\n    implementation localGroovy()\n    implementation \"com.android.tools.build:gradle:3.5.3\"\n\n}\n```\n\n### 编写 RouterTranform\n\n```groovy\nclass RouterTransform extends Transform {\n\n    @Override\n    String getName() {\n        return \"RouterMappingTransform\"\n    }\n\n    /**\n     * 需要插桩的输入类型， 这里是类文件\n     * @return\n     */\n    @Override\n    Set<QualifiedContent.ContentType> getInputTypes() {\n        return TransformManager.CONTENT_CLASS\n    }\n\n    /**\n     * 需要插桩的范围, 这里是整个工程\n     * @return\n     */\n    @Override\n    Set<? super QualifiedContent.Scope> getScopes() {\n        return TransformManager.SCOPE_FULL_PROJECT\n    }\n\n    /**\n     * 是否支持增量\n     * @return\n     */\n    @Override\n    boolean isIncremental() {\n        return false\n    }\n\n    /**\n     * 实现\n     * @param transformInvocation\n     * @throws TransformException\n     * @throws InterruptedException\n     * @throws IOException\n     */\n    @Override\n    void transform(TransformInvocation transformInvocation)\n        throws TransformException, InterruptedException, IOException {\n        super.transform(transformInvocation)\n\n        println(\"transform start\")\n\n        def collector = new RouterMappingCollector()\n\n        // 遍历所有的输入\n        transformInvocation.inputs.each {\n            // 把 文件夹 类型的输入，拷贝到目标目录\n            it.directoryInputs.each { directoryInput ->\n                def destDir = transformInvocation.outputProvider\n                    .getContentLocation(\n                        directoryInput.name,\n                        directoryInput.contentTypes,\n                        directoryInput.scopes,\n                        Format.DIRECTORY)\n\n                collector.collect(directoryInput.file)\n                FileUtils.copyDirectory(directoryInput.file, destDir)\n            }\n\n            // 把 JAR 类型的输入，拷贝到目标目录\n            it.jarInputs.each { jarInput ->\n                def dest = transformInvocation.outputProvider\n                    .getContentLocation(\n                        jarInput.name,\n                        jarInput.contentTypes,\n                        jarInput.scopes, Format.JAR)\n                collector.collectFromJarFile(jarInput.file)\n                println(\"transform jar input path ${jarInput.file.absolutePath}\")\n                println(\"transform jar output path ${dest.absolutePath}\")\n                FileUtils.copyFile(jarInput.file, dest)\n            }\n        }\n\n\n        File mappingJarFile = transformInvocation.outputProvider.\n            getContentLocation(\n                \"router_mapping\",\n                getOutputTypes(),\n                getScopes(),\n                Format.JAR)\n\n        println(\"${getName()}  mappingJarFile = $mappingJarFile\")\n\n        if (mappingJarFile.getParentFile().exists()) {\n            mappingJarFile.getParentFile().mkdirs()\n        }\n\n        if (mappingJarFile.exists()) {\n            mappingJarFile.delete()\n        }\n\n        // 将生成的字节码，写入本地文件\n        FileOutputStream fos = new FileOutputStream(mappingJarFile)\n        JarOutputStream jarOutputStream = new JarOutputStream(fos)\n        // CLASS_NAME = \"com/imooc/router/mapping/generated/RouterMapping\"\n        ZipEntry zipEntry =\n            new ZipEntry(RouterMappingByteCodeBuilder.CLASS_NAME + \".class\")\n        jarOutputStream.putNextEntry(zipEntry)\n        println(\"transform collect class ${collector.mappingClassName}\")\n        jarOutputStream.write(\n            // 写入字节码\n            RouterMappingByteCodeBuilder.get(collector.mappingClassName)\n        )\n        jarOutputStream.closeEntry()\n        jarOutputStream.close()\n        fos.close()\n\n        println(\"transform end\")\n    }\n}\n```\n\n* `transformInvocation.inputs.each {`\n表示遍历所有输入\n* `it.directoryInputs.each { directoryInput ->`\n表示遍历所有目录文件输入，directoryInput 是class文件的目录\n* `it.jarInputs.each { jarInput ->`\n遍历所有jar包输入， jarInput 是jar包\n* `transformInvocation.outputProvider.getContentLocation(`\n获取具体的输入\n* `collector.collect(directoryInput.file)`\n这里是一个自定义逻辑，表示从 class文件 或 jar包 中找到生成的 RouterMapping 路由映射类。 \n* `FileUtils.copyFile(jarInput.file, dest)`\n拷贝文件到目标目录， 最终transform执行之后会在 /...项目目录/app/build/intermediates/transforms 中生成一个RouterMappingTransform目录。 需要吧class文件和jar包都拷贝过去。有意思是，我原本以为我们工程自己的代码应该都是 class文件，都在 `it.directoryInputs.each { directoryInput ->` 这个输入里。 但是后来发现，只有 app工程是 class 文件，子工程打包成了 jar 包，和其他第三方库放在了一起\n\n* 后面的代码都是动态生成了一个集合了所有子工程路由注册的路由类，使用asm写入了字节码\n\n**即使我们没有对文件做任何处理，我们仍然需要把输入文件拷贝到目标目录下，否则下一个Task就没有TansformInput，如果我们没有将input目录复制到output指定目录，会导致最后的打包的apk缺少class**\n\n\n## 注册transform\n\n```groovy\nclass RouterPlugin2 implements Plugin<Project> {\n\n    String TAG = \"RouterPlugin2\"\n\n    @Override\n    void apply(Project project) {\n\n        if (project.plugins.hasPlugin(AppPlugin)) {\n            // hasPlugin(AppPlugin) 表示这是 app 主工程\n            // 注册进我们的 RouterTransform\n            def extension = project.extensions.getByType(AppExtension)\n            extension.registerTransform(new RouterTransform())\n        }\n    }\n}\n```\n\n插件也是需要注册的。。。在resource目录的方式注册。 不写了，网上搜一下吧。\n\n## 使用我们的 Router\n\n使用反射实例化我们的类即可\n```kotlin\n        try {\n            // GENERATED_MAPPING = \"com.imooc.router.mapping.generated.RouterMapping\"\n            // 注意上面原来文件\"/\"的分割要变成\".\"\n            val clazz = Class.forName(GENERATED_MAPPING)\n            val method = clazz.getMethod(\"get\")\n            val allMapping = method.invoke(null) as Map<String, String>\n\n            if (allMapping?.size > 0) {\n                Log.i(TAG, \"init: get all mapping:\")\n                allMapping.onEach {\n                    Log.i(TAG, \"    ${it.key} -> ${it.value}\")\n                }\n                mapping.putAll(allMapping)\n            }\n\n        } catch (e: Throwable) {\n            Log.e(TAG, \"init: error while init router : $e\")\n        }\n```\n\n\n","source":"_posts/Android/gradle/transform和asm初探.md","raw":"---\ntitle: transform和asm初探\ndate: 2022-03-21 21:54:26\ntags:\n- Gradle\ncategories:\n- Android\n---\n\n## 自定义RouterTransform\nTransform 是AGP官方提供的接口，在 class->dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类\n\n### 添加依赖\n因为是安卓官方提供的能力，需要在 buildSrc 的 build.gradle 中 添加 google() 仓库和安卓构建工具的依赖\n\n```groovy\nrepositories {\n    jcenter()\n    google()\n    mavenCentral()\n\n}\n\ndependencies {\n    implementation gradleApi()\n    implementation localGroovy()\n    implementation \"com.android.tools.build:gradle:3.5.3\"\n\n}\n```\n\n### 编写 RouterTranform\n\n```groovy\nclass RouterTransform extends Transform {\n\n    @Override\n    String getName() {\n        return \"RouterMappingTransform\"\n    }\n\n    /**\n     * 需要插桩的输入类型， 这里是类文件\n     * @return\n     */\n    @Override\n    Set<QualifiedContent.ContentType> getInputTypes() {\n        return TransformManager.CONTENT_CLASS\n    }\n\n    /**\n     * 需要插桩的范围, 这里是整个工程\n     * @return\n     */\n    @Override\n    Set<? super QualifiedContent.Scope> getScopes() {\n        return TransformManager.SCOPE_FULL_PROJECT\n    }\n\n    /**\n     * 是否支持增量\n     * @return\n     */\n    @Override\n    boolean isIncremental() {\n        return false\n    }\n\n    /**\n     * 实现\n     * @param transformInvocation\n     * @throws TransformException\n     * @throws InterruptedException\n     * @throws IOException\n     */\n    @Override\n    void transform(TransformInvocation transformInvocation)\n        throws TransformException, InterruptedException, IOException {\n        super.transform(transformInvocation)\n\n        println(\"transform start\")\n\n        def collector = new RouterMappingCollector()\n\n        // 遍历所有的输入\n        transformInvocation.inputs.each {\n            // 把 文件夹 类型的输入，拷贝到目标目录\n            it.directoryInputs.each { directoryInput ->\n                def destDir = transformInvocation.outputProvider\n                    .getContentLocation(\n                        directoryInput.name,\n                        directoryInput.contentTypes,\n                        directoryInput.scopes,\n                        Format.DIRECTORY)\n\n                collector.collect(directoryInput.file)\n                FileUtils.copyDirectory(directoryInput.file, destDir)\n            }\n\n            // 把 JAR 类型的输入，拷贝到目标目录\n            it.jarInputs.each { jarInput ->\n                def dest = transformInvocation.outputProvider\n                    .getContentLocation(\n                        jarInput.name,\n                        jarInput.contentTypes,\n                        jarInput.scopes, Format.JAR)\n                collector.collectFromJarFile(jarInput.file)\n                println(\"transform jar input path ${jarInput.file.absolutePath}\")\n                println(\"transform jar output path ${dest.absolutePath}\")\n                FileUtils.copyFile(jarInput.file, dest)\n            }\n        }\n\n\n        File mappingJarFile = transformInvocation.outputProvider.\n            getContentLocation(\n                \"router_mapping\",\n                getOutputTypes(),\n                getScopes(),\n                Format.JAR)\n\n        println(\"${getName()}  mappingJarFile = $mappingJarFile\")\n\n        if (mappingJarFile.getParentFile().exists()) {\n            mappingJarFile.getParentFile().mkdirs()\n        }\n\n        if (mappingJarFile.exists()) {\n            mappingJarFile.delete()\n        }\n\n        // 将生成的字节码，写入本地文件\n        FileOutputStream fos = new FileOutputStream(mappingJarFile)\n        JarOutputStream jarOutputStream = new JarOutputStream(fos)\n        // CLASS_NAME = \"com/imooc/router/mapping/generated/RouterMapping\"\n        ZipEntry zipEntry =\n            new ZipEntry(RouterMappingByteCodeBuilder.CLASS_NAME + \".class\")\n        jarOutputStream.putNextEntry(zipEntry)\n        println(\"transform collect class ${collector.mappingClassName}\")\n        jarOutputStream.write(\n            // 写入字节码\n            RouterMappingByteCodeBuilder.get(collector.mappingClassName)\n        )\n        jarOutputStream.closeEntry()\n        jarOutputStream.close()\n        fos.close()\n\n        println(\"transform end\")\n    }\n}\n```\n\n* `transformInvocation.inputs.each {`\n表示遍历所有输入\n* `it.directoryInputs.each { directoryInput ->`\n表示遍历所有目录文件输入，directoryInput 是class文件的目录\n* `it.jarInputs.each { jarInput ->`\n遍历所有jar包输入， jarInput 是jar包\n* `transformInvocation.outputProvider.getContentLocation(`\n获取具体的输入\n* `collector.collect(directoryInput.file)`\n这里是一个自定义逻辑，表示从 class文件 或 jar包 中找到生成的 RouterMapping 路由映射类。 \n* `FileUtils.copyFile(jarInput.file, dest)`\n拷贝文件到目标目录， 最终transform执行之后会在 /...项目目录/app/build/intermediates/transforms 中生成一个RouterMappingTransform目录。 需要吧class文件和jar包都拷贝过去。有意思是，我原本以为我们工程自己的代码应该都是 class文件，都在 `it.directoryInputs.each { directoryInput ->` 这个输入里。 但是后来发现，只有 app工程是 class 文件，子工程打包成了 jar 包，和其他第三方库放在了一起\n\n* 后面的代码都是动态生成了一个集合了所有子工程路由注册的路由类，使用asm写入了字节码\n\n**即使我们没有对文件做任何处理，我们仍然需要把输入文件拷贝到目标目录下，否则下一个Task就没有TansformInput，如果我们没有将input目录复制到output指定目录，会导致最后的打包的apk缺少class**\n\n\n## 注册transform\n\n```groovy\nclass RouterPlugin2 implements Plugin<Project> {\n\n    String TAG = \"RouterPlugin2\"\n\n    @Override\n    void apply(Project project) {\n\n        if (project.plugins.hasPlugin(AppPlugin)) {\n            // hasPlugin(AppPlugin) 表示这是 app 主工程\n            // 注册进我们的 RouterTransform\n            def extension = project.extensions.getByType(AppExtension)\n            extension.registerTransform(new RouterTransform())\n        }\n    }\n}\n```\n\n插件也是需要注册的。。。在resource目录的方式注册。 不写了，网上搜一下吧。\n\n## 使用我们的 Router\n\n使用反射实例化我们的类即可\n```kotlin\n        try {\n            // GENERATED_MAPPING = \"com.imooc.router.mapping.generated.RouterMapping\"\n            // 注意上面原来文件\"/\"的分割要变成\".\"\n            val clazz = Class.forName(GENERATED_MAPPING)\n            val method = clazz.getMethod(\"get\")\n            val allMapping = method.invoke(null) as Map<String, String>\n\n            if (allMapping?.size > 0) {\n                Log.i(TAG, \"init: get all mapping:\")\n                allMapping.onEach {\n                    Log.i(TAG, \"    ${it.key} -> ${it.value}\")\n                }\n                mapping.putAll(allMapping)\n            }\n\n        } catch (e: Throwable) {\n            Log.e(TAG, \"init: error while init router : $e\")\n        }\n```\n\n\n","slug":"Android/gradle/transform和asm初探","published":1,"updated":"2022-05-04T08:50:41.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9p005qg0jenz6w2wf1","content":"<h2 id=\"自定义RouterTransform\"><a href=\"#自定义RouterTransform\" class=\"headerlink\" title=\"自定义RouterTransform\"></a>自定义RouterTransform</h2><p>Transform 是AGP官方提供的接口，在 class-&gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类</p><a id=\"more\"></a>\n<h3 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h3><p>因为是安卓官方提供的能力，需要在 buildSrc 的 build.gradle 中 添加 google() 仓库和安卓构建工具的依赖</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    jcenter()</span><br><span class=\"line\">    google()</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation gradleApi()</span><br><span class=\"line\">    implementation localGroovy()</span><br><span class=\"line\">    implementation <span class=\"string\">\"com.android.tools.build:gradle:3.5.3\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写-RouterTranform\"><a href=\"#编写-RouterTranform\" class=\"headerlink\" title=\"编写 RouterTranform\"></a>编写 RouterTranform</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterTransform</span> <span class=\"keyword\">extends</span> <span class=\"title\">Transform</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    String getName() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"RouterMappingTransform\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 需要插桩的输入类型， 这里是类文件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TransformManager.CONTENT_CLASS</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 需要插桩的范围, 这里是整个工程</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class=\"line\">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 是否支持增量</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    boolean isIncremental() &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 实现</span><br><span class=\"line\">     * @param transformInvocation</span><br><span class=\"line\">     * @throws TransformException</span><br><span class=\"line\">     * @throws InterruptedException</span><br><span class=\"line\">     * @throws IOException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    void transform(TransformInvocation transformInvocation)</span><br><span class=\"line\">        throws TransformException, InterruptedException, IOException &#123;</span><br><span class=\"line\">        super.transform(transformInvocation)</span><br><span class=\"line\"></span><br><span class=\"line\">        println(\"transform start\")</span><br><span class=\"line\"></span><br><span class=\"line\">        def collector = new RouterMappingCollector()</span><br><span class=\"line\"></span><br><span class=\"line\">        // 遍历所有的输入</span><br><span class=\"line\">        transformInvocation.inputs.each &#123;</span><br><span class=\"line\">            // 把 文件夹 类型的输入，拷贝到目标目录</span><br><span class=\"line\">            it.directoryInputs.each &#123; directoryInput -&gt;</span><br><span class=\"line\">                def destDir = transformInvocation.outputProvider</span><br><span class=\"line\">                    .getContentLocation(</span><br><span class=\"line\">                        directoryInput.name,</span><br><span class=\"line\">                        directoryInput.contentTypes,</span><br><span class=\"line\">                        directoryInput.scopes,</span><br><span class=\"line\">                        Format.DIRECTORY)</span><br><span class=\"line\"></span><br><span class=\"line\">                collector.collect(directoryInput.file)</span><br><span class=\"line\">                FileUtils.copyDirectory(directoryInput.file, destDir)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 把 JAR 类型的输入，拷贝到目标目录</span><br><span class=\"line\">            it.jarInputs.each &#123; jarInput -&gt;</span><br><span class=\"line\">                def dest = transformInvocation.outputProvider</span><br><span class=\"line\">                    .getContentLocation(</span><br><span class=\"line\">                        jarInput.name,</span><br><span class=\"line\">                        jarInput.contentTypes,</span><br><span class=\"line\">                        jarInput.scopes, Format.JAR)</span><br><span class=\"line\">                collector.collectFromJarFile(jarInput.file)</span><br><span class=\"line\">                println(\"transform jar input path $&#123;jarInput.file.absolutePath&#125;\")</span><br><span class=\"line\">                println(\"transform jar output path $&#123;dest.absolutePath&#125;\")</span><br><span class=\"line\">                FileUtils.copyFile(jarInput.file, dest)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        File mappingJarFile = transformInvocation.outputProvider.</span><br><span class=\"line\">            getContentLocation(</span><br><span class=\"line\">                \"router_mapping\",</span><br><span class=\"line\">                getOutputTypes(),</span><br><span class=\"line\">                getScopes(),</span><br><span class=\"line\">                Format.JAR)</span><br><span class=\"line\"></span><br><span class=\"line\">        println(\"$&#123;getName()&#125;  mappingJarFile = $mappingJarFile\")</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mappingJarFile.getParentFile().exists()) &#123;</span><br><span class=\"line\">            mappingJarFile.getParentFile().mkdirs()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mappingJarFile.exists()) &#123;</span><br><span class=\"line\">            mappingJarFile.delete()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将生成的字节码，写入本地文件</span><br><span class=\"line\">        FileOutputStream fos = new FileOutputStream(mappingJarFile)</span><br><span class=\"line\">        JarOutputStream jarOutputStream = new JarOutputStream(fos)</span><br><span class=\"line\">        // CLASS_NAME = \"com/imooc/router/mapping/generated/RouterMapping\"</span><br><span class=\"line\">        ZipEntry zipEntry =</span><br><span class=\"line\">            new ZipEntry(RouterMappingByteCodeBuilder.CLASS_NAME + \".class\")</span><br><span class=\"line\">        jarOutputStream.putNextEntry(zipEntry)</span><br><span class=\"line\">        println(\"transform collect class $&#123;collector.mappingClassName&#125;\")</span><br><span class=\"line\">        jarOutputStream.write(</span><br><span class=\"line\">            // 写入字节码</span><br><span class=\"line\">            RouterMappingByteCodeBuilder.get(collector.mappingClassName)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        jarOutputStream.closeEntry()</span><br><span class=\"line\">        jarOutputStream.close()</span><br><span class=\"line\">        fos.close()</span><br><span class=\"line\"></span><br><span class=\"line\">        println(\"transform end\")</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>transformInvocation.inputs.each {</code><br>表示遍历所有输入</li>\n<li><code>it.directoryInputs.each { directoryInput -&gt;</code><br>表示遍历所有目录文件输入，directoryInput 是class文件的目录</li>\n<li><code>it.jarInputs.each { jarInput -&gt;</code><br>遍历所有jar包输入， jarInput 是jar包</li>\n<li><code>transformInvocation.outputProvider.getContentLocation(</code><br>获取具体的输入</li>\n<li><code>collector.collect(directoryInput.file)</code><br>这里是一个自定义逻辑，表示从 class文件 或 jar包 中找到生成的 RouterMapping 路由映射类。 </li>\n<li><p><code>FileUtils.copyFile(jarInput.file, dest)</code><br>拷贝文件到目标目录， 最终transform执行之后会在 /…项目目录/app/build/intermediates/transforms 中生成一个RouterMappingTransform目录。 需要吧class文件和jar包都拷贝过去。有意思是，我原本以为我们工程自己的代码应该都是 class文件，都在 <code>it.directoryInputs.each { directoryInput -&gt;</code> 这个输入里。 但是后来发现，只有 app工程是 class 文件，子工程打包成了 jar 包，和其他第三方库放在了一起</p>\n</li>\n<li><p>后面的代码都是动态生成了一个集合了所有子工程路由注册的路由类，使用asm写入了字节码</p>\n</li>\n</ul>\n<p><strong>即使我们没有对文件做任何处理，我们仍然需要把输入文件拷贝到目标目录下，否则下一个Task就没有TansformInput，如果我们没有将input目录复制到output指定目录，会导致最后的打包的apk缺少class</strong></p>\n<h2 id=\"注册transform\"><a href=\"#注册transform\" class=\"headerlink\" title=\"注册transform\"></a>注册transform</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterPlugin2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    String TAG = <span class=\"string\">\"RouterPlugin2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (project.plugins.hasPlugin(AppPlugin)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hasPlugin(AppPlugin) 表示这是 app 主工程</span></span><br><span class=\"line\">            <span class=\"comment\">// 注册进我们的 RouterTransform</span></span><br><span class=\"line\">            <span class=\"keyword\">def</span> extension = project.extensions.getByType(AppExtension)</span><br><span class=\"line\">            extension.registerTransform(<span class=\"keyword\">new</span> RouterTransform())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插件也是需要注册的。。。在resource目录的方式注册。 不写了，网上搜一下吧。</p>\n<h2 id=\"使用我们的-Router\"><a href=\"#使用我们的-Router\" class=\"headerlink\" title=\"使用我们的 Router\"></a>使用我们的 Router</h2><p>使用反射实例化我们的类即可<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// GENERATED_MAPPING = \"com.imooc.router.mapping.generated.RouterMapping\"</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意上面原来文件\"/\"的分割要变成\".\"</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> clazz = Class.forName(GENERATED_MAPPING)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> method = clazz.getMethod(<span class=\"string\">\"get\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> allMapping = method.invoke(<span class=\"literal\">null</span>) <span class=\"keyword\">as</span> Map&lt;String, String&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allMapping?.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"init: get all mapping:\"</span>)</span><br><span class=\"line\">        allMapping.onEach &#123;</span><br><span class=\"line\">            Log.i(TAG, <span class=\"string\">\"    <span class=\"subst\">$&#123;it.key&#125;</span> -&gt; <span class=\"subst\">$&#123;it.value&#125;</span>\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mapping.putAll(allMapping)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: Throwable) &#123;</span><br><span class=\"line\">    Log.e(TAG, <span class=\"string\">\"init: error while init router : <span class=\"variable\">$e</span>\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"自定义RouterTransform\"><a href=\"#自定义RouterTransform\" class=\"headerlink\" title=\"自定义RouterTransform\"></a>自定义RouterTransform</h2><p>Transform 是AGP官方提供的接口，在 class-&gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类</p>","more":"\n<h3 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h3><p>因为是安卓官方提供的能力，需要在 buildSrc 的 build.gradle 中 添加 google() 仓库和安卓构建工具的依赖</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">repositories &#123;</span><br><span class=\"line\">    jcenter()</span><br><span class=\"line\">    google()</span><br><span class=\"line\">    mavenCentral()</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation gradleApi()</span><br><span class=\"line\">    implementation localGroovy()</span><br><span class=\"line\">    implementation <span class=\"string\">\"com.android.tools.build:gradle:3.5.3\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写-RouterTranform\"><a href=\"#编写-RouterTranform\" class=\"headerlink\" title=\"编写 RouterTranform\"></a>编写 RouterTranform</h3><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterTransform</span> <span class=\"keyword\">extends</span> <span class=\"title\">Transform</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    String getName() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"RouterMappingTransform\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 需要插桩的输入类型， 这里是类文件</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> TransformManager.CONTENT_CLASS</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 需要插桩的范围, 这里是整个工程</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class=\"line\">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 是否支持增量</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    boolean isIncremental() &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 实现</span><br><span class=\"line\">     * @param transformInvocation</span><br><span class=\"line\">     * @throws TransformException</span><br><span class=\"line\">     * @throws InterruptedException</span><br><span class=\"line\">     * @throws IOException</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    void transform(TransformInvocation transformInvocation)</span><br><span class=\"line\">        throws TransformException, InterruptedException, IOException &#123;</span><br><span class=\"line\">        super.transform(transformInvocation)</span><br><span class=\"line\"></span><br><span class=\"line\">        println(\"transform start\")</span><br><span class=\"line\"></span><br><span class=\"line\">        def collector = new RouterMappingCollector()</span><br><span class=\"line\"></span><br><span class=\"line\">        // 遍历所有的输入</span><br><span class=\"line\">        transformInvocation.inputs.each &#123;</span><br><span class=\"line\">            // 把 文件夹 类型的输入，拷贝到目标目录</span><br><span class=\"line\">            it.directoryInputs.each &#123; directoryInput -&gt;</span><br><span class=\"line\">                def destDir = transformInvocation.outputProvider</span><br><span class=\"line\">                    .getContentLocation(</span><br><span class=\"line\">                        directoryInput.name,</span><br><span class=\"line\">                        directoryInput.contentTypes,</span><br><span class=\"line\">                        directoryInput.scopes,</span><br><span class=\"line\">                        Format.DIRECTORY)</span><br><span class=\"line\"></span><br><span class=\"line\">                collector.collect(directoryInput.file)</span><br><span class=\"line\">                FileUtils.copyDirectory(directoryInput.file, destDir)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            // 把 JAR 类型的输入，拷贝到目标目录</span><br><span class=\"line\">            it.jarInputs.each &#123; jarInput -&gt;</span><br><span class=\"line\">                def dest = transformInvocation.outputProvider</span><br><span class=\"line\">                    .getContentLocation(</span><br><span class=\"line\">                        jarInput.name,</span><br><span class=\"line\">                        jarInput.contentTypes,</span><br><span class=\"line\">                        jarInput.scopes, Format.JAR)</span><br><span class=\"line\">                collector.collectFromJarFile(jarInput.file)</span><br><span class=\"line\">                println(\"transform jar input path $&#123;jarInput.file.absolutePath&#125;\")</span><br><span class=\"line\">                println(\"transform jar output path $&#123;dest.absolutePath&#125;\")</span><br><span class=\"line\">                FileUtils.copyFile(jarInput.file, dest)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        File mappingJarFile = transformInvocation.outputProvider.</span><br><span class=\"line\">            getContentLocation(</span><br><span class=\"line\">                \"router_mapping\",</span><br><span class=\"line\">                getOutputTypes(),</span><br><span class=\"line\">                getScopes(),</span><br><span class=\"line\">                Format.JAR)</span><br><span class=\"line\"></span><br><span class=\"line\">        println(\"$&#123;getName()&#125;  mappingJarFile = $mappingJarFile\")</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mappingJarFile.getParentFile().exists()) &#123;</span><br><span class=\"line\">            mappingJarFile.getParentFile().mkdirs()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (mappingJarFile.exists()) &#123;</span><br><span class=\"line\">            mappingJarFile.delete()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将生成的字节码，写入本地文件</span><br><span class=\"line\">        FileOutputStream fos = new FileOutputStream(mappingJarFile)</span><br><span class=\"line\">        JarOutputStream jarOutputStream = new JarOutputStream(fos)</span><br><span class=\"line\">        // CLASS_NAME = \"com/imooc/router/mapping/generated/RouterMapping\"</span><br><span class=\"line\">        ZipEntry zipEntry =</span><br><span class=\"line\">            new ZipEntry(RouterMappingByteCodeBuilder.CLASS_NAME + \".class\")</span><br><span class=\"line\">        jarOutputStream.putNextEntry(zipEntry)</span><br><span class=\"line\">        println(\"transform collect class $&#123;collector.mappingClassName&#125;\")</span><br><span class=\"line\">        jarOutputStream.write(</span><br><span class=\"line\">            // 写入字节码</span><br><span class=\"line\">            RouterMappingByteCodeBuilder.get(collector.mappingClassName)</span><br><span class=\"line\">        )</span><br><span class=\"line\">        jarOutputStream.closeEntry()</span><br><span class=\"line\">        jarOutputStream.close()</span><br><span class=\"line\">        fos.close()</span><br><span class=\"line\"></span><br><span class=\"line\">        println(\"transform end\")</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>transformInvocation.inputs.each {</code><br>表示遍历所有输入</li>\n<li><code>it.directoryInputs.each { directoryInput -&gt;</code><br>表示遍历所有目录文件输入，directoryInput 是class文件的目录</li>\n<li><code>it.jarInputs.each { jarInput -&gt;</code><br>遍历所有jar包输入， jarInput 是jar包</li>\n<li><code>transformInvocation.outputProvider.getContentLocation(</code><br>获取具体的输入</li>\n<li><code>collector.collect(directoryInput.file)</code><br>这里是一个自定义逻辑，表示从 class文件 或 jar包 中找到生成的 RouterMapping 路由映射类。 </li>\n<li><p><code>FileUtils.copyFile(jarInput.file, dest)</code><br>拷贝文件到目标目录， 最终transform执行之后会在 /…项目目录/app/build/intermediates/transforms 中生成一个RouterMappingTransform目录。 需要吧class文件和jar包都拷贝过去。有意思是，我原本以为我们工程自己的代码应该都是 class文件，都在 <code>it.directoryInputs.each { directoryInput -&gt;</code> 这个输入里。 但是后来发现，只有 app工程是 class 文件，子工程打包成了 jar 包，和其他第三方库放在了一起</p>\n</li>\n<li><p>后面的代码都是动态生成了一个集合了所有子工程路由注册的路由类，使用asm写入了字节码</p>\n</li>\n</ul>\n<p><strong>即使我们没有对文件做任何处理，我们仍然需要把输入文件拷贝到目标目录下，否则下一个Task就没有TansformInput，如果我们没有将input目录复制到output指定目录，会导致最后的打包的apk缺少class</strong></p>\n<h2 id=\"注册transform\"><a href=\"#注册transform\" class=\"headerlink\" title=\"注册transform\"></a>注册transform</h2><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RouterPlugin2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Plugin</span>&lt;<span class=\"title\">Project</span>&gt; &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    String TAG = <span class=\"string\">\"RouterPlugin2\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> apply(Project project) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (project.plugins.hasPlugin(AppPlugin)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// hasPlugin(AppPlugin) 表示这是 app 主工程</span></span><br><span class=\"line\">            <span class=\"comment\">// 注册进我们的 RouterTransform</span></span><br><span class=\"line\">            <span class=\"keyword\">def</span> extension = project.extensions.getByType(AppExtension)</span><br><span class=\"line\">            extension.registerTransform(<span class=\"keyword\">new</span> RouterTransform())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>插件也是需要注册的。。。在resource目录的方式注册。 不写了，网上搜一下吧。</p>\n<h2 id=\"使用我们的-Router\"><a href=\"#使用我们的-Router\" class=\"headerlink\" title=\"使用我们的 Router\"></a>使用我们的 Router</h2><p>使用反射实例化我们的类即可<br><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// GENERATED_MAPPING = \"com.imooc.router.mapping.generated.RouterMapping\"</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意上面原来文件\"/\"的分割要变成\".\"</span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> clazz = Class.forName(GENERATED_MAPPING)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> method = clazz.getMethod(<span class=\"string\">\"get\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> allMapping = method.invoke(<span class=\"literal\">null</span>) <span class=\"keyword\">as</span> Map&lt;String, String&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allMapping?.size &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"init: get all mapping:\"</span>)</span><br><span class=\"line\">        allMapping.onEach &#123;</span><br><span class=\"line\">            Log.i(TAG, <span class=\"string\">\"    <span class=\"subst\">$&#123;it.key&#125;</span> -&gt; <span class=\"subst\">$&#123;it.value&#125;</span>\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mapping.putAll(allMapping)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e: Throwable) &#123;</span><br><span class=\"line\">    Log.e(TAG, <span class=\"string\">\"init: error while init router : <span class=\"variable\">$e</span>\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Glide源码-缓存机制","date":"2019-11-18T08:52:17.000Z","_content":"\n## Glide的配置\n\n在实例化Glide的时候, 对很多重要的部分做了初始化.\n\n```java\n\n// 起始入口\npublic DrawableTypeRequest<String> load(String string) {\n    return (DrawableTypeRequest<String>) fromString().load(string);\n}\n\n... // 省略中间步骤\n```\n\n一直向下追溯, 可以找到Glide类的这个方法\n\n```java\nGlide createGlide() {\n    if (sourceService == null) {\n        // 初始化加载网络图片的线程池\n        final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());\n        sourceService = new FifoPriorityThreadPoolExecutor(cores);\n    }\n    if (diskCacheService == null) {\n        // 初始化加载磁盘缓存的线程池\n        diskCacheService = new FifoPriorityThreadPoolExecutor(1);\n    }\n\n    // 初始化内存缓存池, 可以看到, 是一个lrucache\n    MemorySizeCalculator calculator = new MemorySizeCalculator(context);\n    if (bitmapPool == null) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n            int size = calculator.getBitmapPoolSize();\n            bitmapPool = new LruBitmapPool(size);\n        } else {\n            bitmapPool = new BitmapPoolAdapter();\n        }\n    }\n\n    if (memoryCache == null) {\n        memoryCache = new LruResourceCache(calculator.getMemoryCacheSize());\n    }\n\n    if (diskCacheFactory == null) {\n        diskCacheFactory = new InternalCacheDiskCacheFactory(context);\n    }\n\n    if (engine == null) {\n        // 实例化Glide Engine\n        engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);\n    }\n\n    if (decodeFormat == null) {\n        decodeFormat = DecodeFormat.DEFAULT;\n    }\n\n    return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);\n}\n```\n\n## 内存缓存\n\n### Engine-load\n\n```java\nprivate final Map<Key, WeakReference<EngineResource<?>>> activeResources;\n\n...\n\npublic <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n        DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n\n    // 组装key\n    final String id = fetcher.getId();\n    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n            transcoder, loadProvider.getSourceEncoder());\n\n    // 先从内存cache中获取\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n        cb.onResourceReady(cached);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n        }\n        return null;\n    }\n\n    // 从ActiveResources获取\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n        cb.onResourceReady(active);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n        }\n        return null;\n    }\n\n    // 后面的内容暂时和内存缓存无关\n\n    EngineJob current = jobs.get(key);\n    if (current != null) {\n        // 当已经存在相同的图片加载job, 直接添加新的callback即可\n        current.addCallback(cb);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Added to existing load\", startTime, key);\n        }\n        return new LoadStatus(cb, current);\n    }\n\n    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n    DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n            transcoder, diskCacheProvider, diskCacheStrategy, priority);\n    // 具体的图片请求工作在这个runnable中\n    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n    jobs.put(key, engineJob);\n    engineJob.addCallback(cb);\n    engineJob.start(runnable);\n    \n    return new LoadStatus(cb, engineJob);\n}\n```\n\n可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取. \nActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合:\n* 为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:\n使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。\n* 存储的正在使用的图片资源的**弱引用**: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用\n\n来看看对lrucache和ActiveResources的操作\n\n### 内存cache的获取\n\n```java\n// 从cache中获取\nprivate EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {\n    // 检查内存缓存是否被禁用\n    if (!isMemoryCacheable) {\n        return null;\n    }\n\n    EngineResource<?> cached = getEngineResourceFromCache(key);\n    if (cached != null) {\n        // cache命中, 从lrucache中取出后放入ActiveResources\n        cached.acquire();\n        activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));\n    }\n    return cached;\n}\n// 从cache中获取资源\nprivate EngineResource<?> getEngineResourceFromCache(Key key) {\n    // 注意这里是直接remove的\n    Resource<?> cached = cache.remove(key);\n\n    final EngineResource result;\n    if (cached == null) {\n        result = null;\n    } else if (cached instanceof EngineResource) {\n        // Save an object allocation if we've cached an EngineResource (the typical case).\n        result = (EngineResource) cached;\n    } else {\n        result = new EngineResource(cached, true /*isCacheable*/);\n    }\n    return result;\n}\n\nprivate EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {\n    // 检查内存cache是否被禁用\n    if (!isMemoryCacheable) {\n        return null;\n    }\n\n    EngineResource<?> active = null;\n    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);\n    if (activeRef != null) {\n        active = activeRef.get();\n        if (active != null) {\n            // ActiveResource命中\n            active.acquire();\n        } else {\n            // 弱引用的对象被释放了, 直接remove\n            activeResources.remove(key);\n        }\n    }\n\n    return active;\n}\n```\n\n### 内存cache的释放\n\n先来看看resource中如何表示图片需要被释放\n```java\nclass EngineResource<Z> implements Resource<Z> {\n    private int acquired;\n    ...\n\n    void acquire() {\n        ... // 省略异常处理\n        ++acquired;\n    }\n\n    void release() {\n        ... // 省略异常处理\n        if (--acquired == 0) {\n            // 当acquired为0的使用, 表示当前图片没有被引用\n            listener.onResourceReleased(key, this);\n        }\n    }\n}\n```\n\nresource中listener的回调是在EngineJob类中实现的\n\n```java\n// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache\n@Override\npublic void onResourceReleased(Key cacheKey, EngineResource resource) {\n    Util.assertMainThread();\n    activeResources.remove(cacheKey);\n    if (resource.isCacheable()) {\n        cache.put(cacheKey, resource);\n    } else {\n        resourceRecycler.recycle(resource);\n    }\n}\n```\n\n## 磁盘缓存\n\n首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理.\n\n### 入口\n\n内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中\n\n```java\nprivate Resource<?> decode() throws Exception {\n    if (isDecodingFromCache()) {\n        return decodeFromCache();\n    } else {\n        return decodeFromSource();\n    }\n}\n\n// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片\nprivate Resource<?> decodeFromCache() throws Exception {\n    Resource<?> result = null;\n    try {\n        result = decodeJob.decodeResultFromCache();\n    } catch (Exception e) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Exception decoding result from cache: \" + e);\n        }\n    }\n\n    if (result == null) {\n        result = decodeJob.decodeSourceFromCache();\n    }\n    return result;\n    }\n```\n\n### 磁盘cache读取\n\n```java\npublic Resource<Z> decodeResultFromCache() throws Exception {\n    if (!diskCacheStrategy.cacheResult()) {\n        return null;\n    }\n    long startTime = LogTime.getLogTime();\n    Resource<T> transformed = loadFromCache(resultKey);\n    startTime = LogTime.getLogTime();\n    Resource<Z> result = transcode(transformed);\n    return result;\n}\n\npublic Resource<Z> decodeSourceFromCache() throws Exception {\n    if (!diskCacheStrategy.cacheSource()) {\n        return null;\n    }\n    long startTime = LogTime.getLogTime();\n    Resource<T> decoded = loadFromCache(resultKey.getOriginalKey());\n    return transformEncodeAndTranscode(decoded);\n}\n\nprivate Resource<T> loadFromCache(Key key) throws IOException {\n    File cacheFile = diskCacheProvider.getDiskCache().get(key);\n    if (cacheFile == null) {\n        return null;\n    }\n    Resource<T> result = null;\n    try {\n        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);\n    } finally {\n        if (result == null) {\n            diskCacheProvider.getDiskCache().delete(key);\n        }\n    }\n    return result;\n}\n```\n\n磁盘缓存读取这里挺好懂的\n\n### 磁盘cache写入\n\n#### 缓存原始图片\n\n直接贴调用过程吧\n\nEngineRunnable.decodeFromSource()\n-> EngineRunnable.decodeFromSource()\n-> DecodeJob.decodeFromSource()\n-> DecodeJob.decodeSource()\n-> DecodeJob.decodeFromSourceData()\n-> DecodeJob.cacheAndDecodeSourceData\n\n```java\nprivate Resource<T> decodeSource() throws Exception {\n    Resource<T> decoded = null;\n    try {\n        long startTime = LogTime.getLogTime();\n        // 从网络获取图片\n        final A data = fetcher.loadData(priority);\n        if (isCancelled) {\n            return null;\n        }\n        decoded = decodeFromSourceData(data);\n    } finally {\n        fetcher.cleanup();\n    }\n    return decoded;\n}\n\nprivate Resource<T> cacheAndDecodeSourceData(A data) throws IOException {\n    long startTime = LogTime.getLogTime();\n    SourceWriter<A> writer = new SourceWriter<A>(loadProvider.getSourceEncoder(), data);\n    diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);\n\n    startTime = LogTime.getLogTime();\n    // ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个?\n    Resource<T> result = loadFromCache(resultKey.getOriginalKey());\n    return result;\n}\n```\n\n#### 缓存处理过后的图片\n\nEngineRunnable.decodeFromSource()\n-> EngineRunnable.decodeFromSource()\n-> DecodeJob.decodeFromSource()\n-> DecodeJob.transformEncodeAndTranscode\n-> DecodeJob.writeTransformedToCache\n\n```java\nprivate Resource<Z> transformEncodeAndTranscode(Resource<T> decoded) {\n    long startTime = LogTime.getLogTime();\n    // 先转换图片\n    Resource<T> transformed = transform(decoded);\n    // 写入磁盘\n    writeTransformedToCache(transformed);\n\n    startTime = LogTime.getLogTime();\n    // 转码\n    Resource<Z> result = transcode(transformed);\n\n    return result;\n}\n\nprivate void writeTransformedToCache(Resource<T> transformed) {\n    if (transformed == null || !diskCacheStrategy.cacheResult()) {\n        return;\n    }\n    long startTime = LogTime.getLogTime();\n    SourceWriter<Resource<T>> writer = new SourceWriter<Resource<T>>(loadProvider.getEncoder(), transformed);\n    diskCacheProvider.getDiskCache().put(resultKey, writer);\n}\n```\n","source":"_posts/Android/源码解析/Glide源码-缓存机制.md","raw":"---\ntitle: Glide源码-缓存机制\ndate: 2019-11-18 16:52:17\ntags:\n- glide\n- 源码解析\ncategories:\n- Android\n---\n\n## Glide的配置\n\n在实例化Glide的时候, 对很多重要的部分做了初始化.\n\n```java\n\n// 起始入口\npublic DrawableTypeRequest<String> load(String string) {\n    return (DrawableTypeRequest<String>) fromString().load(string);\n}\n\n... // 省略中间步骤\n```\n\n一直向下追溯, 可以找到Glide类的这个方法\n\n```java\nGlide createGlide() {\n    if (sourceService == null) {\n        // 初始化加载网络图片的线程池\n        final int cores = Math.max(1, Runtime.getRuntime().availableProcessors());\n        sourceService = new FifoPriorityThreadPoolExecutor(cores);\n    }\n    if (diskCacheService == null) {\n        // 初始化加载磁盘缓存的线程池\n        diskCacheService = new FifoPriorityThreadPoolExecutor(1);\n    }\n\n    // 初始化内存缓存池, 可以看到, 是一个lrucache\n    MemorySizeCalculator calculator = new MemorySizeCalculator(context);\n    if (bitmapPool == null) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n            int size = calculator.getBitmapPoolSize();\n            bitmapPool = new LruBitmapPool(size);\n        } else {\n            bitmapPool = new BitmapPoolAdapter();\n        }\n    }\n\n    if (memoryCache == null) {\n        memoryCache = new LruResourceCache(calculator.getMemoryCacheSize());\n    }\n\n    if (diskCacheFactory == null) {\n        diskCacheFactory = new InternalCacheDiskCacheFactory(context);\n    }\n\n    if (engine == null) {\n        // 实例化Glide Engine\n        engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);\n    }\n\n    if (decodeFormat == null) {\n        decodeFormat = DecodeFormat.DEFAULT;\n    }\n\n    return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);\n}\n```\n\n## 内存缓存\n\n### Engine-load\n\n```java\nprivate final Map<Key, WeakReference<EngineResource<?>>> activeResources;\n\n...\n\npublic <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n        DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n\n    // 组装key\n    final String id = fetcher.getId();\n    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n            transcoder, loadProvider.getSourceEncoder());\n\n    // 先从内存cache中获取\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n        cb.onResourceReady(cached);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n        }\n        return null;\n    }\n\n    // 从ActiveResources获取\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n        cb.onResourceReady(active);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n        }\n        return null;\n    }\n\n    // 后面的内容暂时和内存缓存无关\n\n    EngineJob current = jobs.get(key);\n    if (current != null) {\n        // 当已经存在相同的图片加载job, 直接添加新的callback即可\n        current.addCallback(cb);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Added to existing load\", startTime, key);\n        }\n        return new LoadStatus(cb, current);\n    }\n\n    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n    DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n            transcoder, diskCacheProvider, diskCacheStrategy, priority);\n    // 具体的图片请求工作在这个runnable中\n    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n    jobs.put(key, engineJob);\n    engineJob.addCallback(cb);\n    engineJob.start(runnable);\n    \n    return new LoadStatus(cb, engineJob);\n}\n```\n\n可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取. \nActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合:\n* 为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:\n使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。\n* 存储的正在使用的图片资源的**弱引用**: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用\n\n来看看对lrucache和ActiveResources的操作\n\n### 内存cache的获取\n\n```java\n// 从cache中获取\nprivate EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {\n    // 检查内存缓存是否被禁用\n    if (!isMemoryCacheable) {\n        return null;\n    }\n\n    EngineResource<?> cached = getEngineResourceFromCache(key);\n    if (cached != null) {\n        // cache命中, 从lrucache中取出后放入ActiveResources\n        cached.acquire();\n        activeResources.put(key, new ResourceWeakReference(key, cached, getReferenceQueue()));\n    }\n    return cached;\n}\n// 从cache中获取资源\nprivate EngineResource<?> getEngineResourceFromCache(Key key) {\n    // 注意这里是直接remove的\n    Resource<?> cached = cache.remove(key);\n\n    final EngineResource result;\n    if (cached == null) {\n        result = null;\n    } else if (cached instanceof EngineResource) {\n        // Save an object allocation if we've cached an EngineResource (the typical case).\n        result = (EngineResource) cached;\n    } else {\n        result = new EngineResource(cached, true /*isCacheable*/);\n    }\n    return result;\n}\n\nprivate EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {\n    // 检查内存cache是否被禁用\n    if (!isMemoryCacheable) {\n        return null;\n    }\n\n    EngineResource<?> active = null;\n    WeakReference<EngineResource<?>> activeRef = activeResources.get(key);\n    if (activeRef != null) {\n        active = activeRef.get();\n        if (active != null) {\n            // ActiveResource命中\n            active.acquire();\n        } else {\n            // 弱引用的对象被释放了, 直接remove\n            activeResources.remove(key);\n        }\n    }\n\n    return active;\n}\n```\n\n### 内存cache的释放\n\n先来看看resource中如何表示图片需要被释放\n```java\nclass EngineResource<Z> implements Resource<Z> {\n    private int acquired;\n    ...\n\n    void acquire() {\n        ... // 省略异常处理\n        ++acquired;\n    }\n\n    void release() {\n        ... // 省略异常处理\n        if (--acquired == 0) {\n            // 当acquired为0的使用, 表示当前图片没有被引用\n            listener.onResourceReleased(key, this);\n        }\n    }\n}\n```\n\nresource中listener的回调是在EngineJob类中实现的\n\n```java\n// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache\n@Override\npublic void onResourceReleased(Key cacheKey, EngineResource resource) {\n    Util.assertMainThread();\n    activeResources.remove(cacheKey);\n    if (resource.isCacheable()) {\n        cache.put(cacheKey, resource);\n    } else {\n        resourceRecycler.recycle(resource);\n    }\n}\n```\n\n## 磁盘缓存\n\n首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理.\n\n### 入口\n\n内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中\n\n```java\nprivate Resource<?> decode() throws Exception {\n    if (isDecodingFromCache()) {\n        return decodeFromCache();\n    } else {\n        return decodeFromSource();\n    }\n}\n\n// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片\nprivate Resource<?> decodeFromCache() throws Exception {\n    Resource<?> result = null;\n    try {\n        result = decodeJob.decodeResultFromCache();\n    } catch (Exception e) {\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"Exception decoding result from cache: \" + e);\n        }\n    }\n\n    if (result == null) {\n        result = decodeJob.decodeSourceFromCache();\n    }\n    return result;\n    }\n```\n\n### 磁盘cache读取\n\n```java\npublic Resource<Z> decodeResultFromCache() throws Exception {\n    if (!diskCacheStrategy.cacheResult()) {\n        return null;\n    }\n    long startTime = LogTime.getLogTime();\n    Resource<T> transformed = loadFromCache(resultKey);\n    startTime = LogTime.getLogTime();\n    Resource<Z> result = transcode(transformed);\n    return result;\n}\n\npublic Resource<Z> decodeSourceFromCache() throws Exception {\n    if (!diskCacheStrategy.cacheSource()) {\n        return null;\n    }\n    long startTime = LogTime.getLogTime();\n    Resource<T> decoded = loadFromCache(resultKey.getOriginalKey());\n    return transformEncodeAndTranscode(decoded);\n}\n\nprivate Resource<T> loadFromCache(Key key) throws IOException {\n    File cacheFile = diskCacheProvider.getDiskCache().get(key);\n    if (cacheFile == null) {\n        return null;\n    }\n    Resource<T> result = null;\n    try {\n        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);\n    } finally {\n        if (result == null) {\n            diskCacheProvider.getDiskCache().delete(key);\n        }\n    }\n    return result;\n}\n```\n\n磁盘缓存读取这里挺好懂的\n\n### 磁盘cache写入\n\n#### 缓存原始图片\n\n直接贴调用过程吧\n\nEngineRunnable.decodeFromSource()\n-> EngineRunnable.decodeFromSource()\n-> DecodeJob.decodeFromSource()\n-> DecodeJob.decodeSource()\n-> DecodeJob.decodeFromSourceData()\n-> DecodeJob.cacheAndDecodeSourceData\n\n```java\nprivate Resource<T> decodeSource() throws Exception {\n    Resource<T> decoded = null;\n    try {\n        long startTime = LogTime.getLogTime();\n        // 从网络获取图片\n        final A data = fetcher.loadData(priority);\n        if (isCancelled) {\n            return null;\n        }\n        decoded = decodeFromSourceData(data);\n    } finally {\n        fetcher.cleanup();\n    }\n    return decoded;\n}\n\nprivate Resource<T> cacheAndDecodeSourceData(A data) throws IOException {\n    long startTime = LogTime.getLogTime();\n    SourceWriter<A> writer = new SourceWriter<A>(loadProvider.getSourceEncoder(), data);\n    diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);\n\n    startTime = LogTime.getLogTime();\n    // ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个?\n    Resource<T> result = loadFromCache(resultKey.getOriginalKey());\n    return result;\n}\n```\n\n#### 缓存处理过后的图片\n\nEngineRunnable.decodeFromSource()\n-> EngineRunnable.decodeFromSource()\n-> DecodeJob.decodeFromSource()\n-> DecodeJob.transformEncodeAndTranscode\n-> DecodeJob.writeTransformedToCache\n\n```java\nprivate Resource<Z> transformEncodeAndTranscode(Resource<T> decoded) {\n    long startTime = LogTime.getLogTime();\n    // 先转换图片\n    Resource<T> transformed = transform(decoded);\n    // 写入磁盘\n    writeTransformedToCache(transformed);\n\n    startTime = LogTime.getLogTime();\n    // 转码\n    Resource<Z> result = transcode(transformed);\n\n    return result;\n}\n\nprivate void writeTransformedToCache(Resource<T> transformed) {\n    if (transformed == null || !diskCacheStrategy.cacheResult()) {\n        return;\n    }\n    long startTime = LogTime.getLogTime();\n    SourceWriter<Resource<T>> writer = new SourceWriter<Resource<T>>(loadProvider.getEncoder(), transformed);\n    diskCacheProvider.getDiskCache().put(resultKey, writer);\n}\n```\n","slug":"Android/源码解析/Glide源码-缓存机制","published":1,"updated":"2021-10-03T01:57:41.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9q005tg0je808udvdr","content":"<h2 id=\"Glide的配置\"><a href=\"#Glide的配置\" class=\"headerlink\" title=\"Glide的配置\"></a>Glide的配置</h2><p>在实例化Glide的时候, 对很多重要的部分做了初始化.</p><a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 起始入口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;String&gt; <span class=\"title\">load</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 省略中间步骤</span></span><br></pre></td></tr></table></figure>\n<p>一直向下追溯, 可以找到Glide类的这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Glide <span class=\"title\">createGlide</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化加载网络图片的线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cores = Math.max(<span class=\"number\">1</span>, Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">        sourceService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(cores);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diskCacheService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化加载磁盘缓存的线程池</span></span><br><span class=\"line\">        diskCacheService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化内存缓存池, 可以看到, 是一个lrucache</span></span><br><span class=\"line\">    MemorySizeCalculator calculator = <span class=\"keyword\">new</span> MemorySizeCalculator(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bitmapPool == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = calculator.getBitmapPoolSize();</span><br><span class=\"line\">            bitmapPool = <span class=\"keyword\">new</span> LruBitmapPool(size);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            bitmapPool = <span class=\"keyword\">new</span> BitmapPoolAdapter();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memoryCache == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        memoryCache = <span class=\"keyword\">new</span> LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diskCacheFactory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        diskCacheFactory = <span class=\"keyword\">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (engine == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化Glide Engine</span></span><br><span class=\"line\">        engine = <span class=\"keyword\">new</span> Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (decodeFormat == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        decodeFormat = DecodeFormat.DEFAULT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Glide(engine, memoryCache, bitmapPool, context, decodeFormat);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h2><h3 id=\"Engine-load\"><a href=\"#Engine-load\" class=\"headerlink\" title=\"Engine-load\"></a>Engine-load</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 组装key</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();</span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class=\"line\">            transcoder, loadProvider.getSourceEncoder());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 先从内存cache中获取</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(cached);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从ActiveResources获取</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(active);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后面的内容暂时和内存缓存无关</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob current = jobs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当已经存在相同的图片加载job, 直接添加新的callback即可</span></span><br><span class=\"line\">        current.addCallback(cb);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class=\"line\">    <span class=\"comment\">// 具体的图片请求工作在这个runnable中</span></span><br><span class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(runnable);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取.<br>ActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合:</p>\n<ul>\n<li>为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:<br>使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。</li>\n<li>存储的正在使用的图片资源的<strong>弱引用</strong>: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用</li>\n</ul>\n<p>来看看对lrucache和ActiveResources的操作</p>\n<h3 id=\"内存cache的获取\"><a href=\"#内存cache的获取\" class=\"headerlink\" title=\"内存cache的获取\"></a>内存cache的获取</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从cache中获取</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class=\"keyword\">boolean</span> isMemoryCacheable) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查内存缓存是否被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMemoryCacheable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cache命中, 从lrucache中取出后放入ActiveResources</span></span><br><span class=\"line\">        cached.acquire();</span><br><span class=\"line\">        activeResources.put(key, <span class=\"keyword\">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cached;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从cache中获取资源</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意这里是直接remove的</span></span><br><span class=\"line\">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> EngineResource result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cached <span class=\"keyword\">instanceof</span> EngineResource) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class=\"line\">        result = (EngineResource) cached;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> EngineResource(cached, <span class=\"keyword\">true</span> <span class=\"comment\">/*isCacheable*/</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class=\"keyword\">boolean</span> isMemoryCacheable) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查内存cache是否被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMemoryCacheable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activeRef != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        active = activeRef.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ActiveResource命中</span></span><br><span class=\"line\">            active.acquire();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 弱引用的对象被释放了, 直接remove</span></span><br><span class=\"line\">            activeResources.remove(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> active;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内存cache的释放\"><a href=\"#内存cache的释放\" class=\"headerlink\" title=\"内存cache的释放\"></a>内存cache的释放</h3><p>先来看看resource中如何表示图片需要被释放<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineResource</span>&lt;<span class=\"title\">Z</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Resource</span>&lt;<span class=\"title\">Z</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> acquired;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ... <span class=\"comment\">// 省略异常处理</span></span><br><span class=\"line\">        ++acquired;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ... <span class=\"comment\">// 省略异常处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (--acquired == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当acquired为0的使用, 表示当前图片没有被引用</span></span><br><span class=\"line\">            listener.onResourceReleased(key, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>resource中listener的回调是在EngineJob类中实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReleased</span><span class=\"params\">(Key cacheKey, EngineResource resource)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    activeResources.remove(cacheKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resource.isCacheable()) &#123;</span><br><span class=\"line\">        cache.put(cacheKey, resource);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resourceRecycler.recycle(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"磁盘缓存\"><a href=\"#磁盘缓存\" class=\"headerlink\" title=\"磁盘缓存\"></a>磁盘缓存</h2><p>首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理.</p>\n<h3 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h3><p>内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Resource&lt;?&gt; decode() <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDecodingFromCache()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decodeFromCache();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decodeFromSource();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Resource&lt;?&gt; decodeFromCache() <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    Resource&lt;?&gt; result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        result = decodeJob.decodeResultFromCache();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class=\"line\">            Log.d(TAG, <span class=\"string\">\"Exception decoding result from cache: \"</span> + e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = decodeJob.decodeSourceFromCache();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"磁盘cache读取\"><a href=\"#磁盘cache读取\" class=\"headerlink\" title=\"磁盘cache读取\"></a>磁盘cache读取</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Z&gt; <span class=\"title\">decodeResultFromCache</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!diskCacheStrategy.cacheResult()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;T&gt; transformed = loadFromCache(resultKey);</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Z&gt; <span class=\"title\">decodeSourceFromCache</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!diskCacheStrategy.cacheSource()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformEncodeAndTranscode(decoded);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">loadFromCache</span><span class=\"params\">(Key key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    File cacheFile = diskCacheProvider.getDiskCache().get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheFile == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Resource&lt;T&gt; result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            diskCacheProvider.getDiskCache().delete(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>磁盘缓存读取这里挺好懂的</p>\n<h3 id=\"磁盘cache写入\"><a href=\"#磁盘cache写入\" class=\"headerlink\" title=\"磁盘cache写入\"></a>磁盘cache写入</h3><h4 id=\"缓存原始图片\"><a href=\"#缓存原始图片\" class=\"headerlink\" title=\"缓存原始图片\"></a>缓存原始图片</h4><p>直接贴调用过程吧</p>\n<p>EngineRunnable.decodeFromSource()<br>-&gt; EngineRunnable.decodeFromSource()<br>-&gt; DecodeJob.decodeFromSource()<br>-&gt; DecodeJob.decodeSource()<br>-&gt; DecodeJob.decodeFromSourceData()<br>-&gt; DecodeJob.cacheAndDecodeSourceData</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">decodeSource</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Resource&lt;T&gt; decoded = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">        <span class=\"comment\">// 从网络获取图片</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> A data = fetcher.loadData(priority);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        decoded = decodeFromSourceData(data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        fetcher.cleanup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decoded;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">cacheAndDecodeSourceData</span><span class=\"params\">(A data)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    SourceWriter&lt;A&gt; writer = <span class=\"keyword\">new</span> SourceWriter&lt;A&gt;(loadProvider.getSourceEncoder(), data);</span><br><span class=\"line\">    diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);</span><br><span class=\"line\"></span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个?</span></span><br><span class=\"line\">    Resource&lt;T&gt; result = loadFromCache(resultKey.getOriginalKey());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"缓存处理过后的图片\"><a href=\"#缓存处理过后的图片\" class=\"headerlink\" title=\"缓存处理过后的图片\"></a>缓存处理过后的图片</h4><p>EngineRunnable.decodeFromSource()<br>-&gt; EngineRunnable.decodeFromSource()<br>-&gt; DecodeJob.decodeFromSource()<br>-&gt; DecodeJob.transformEncodeAndTranscode<br>-&gt; DecodeJob.writeTransformedToCache</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;Z&gt; <span class=\"title\">transformEncodeAndTranscode</span><span class=\"params\">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 先转换图片</span></span><br><span class=\"line\">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class=\"line\">    <span class=\"comment\">// 写入磁盘</span></span><br><span class=\"line\">    writeTransformedToCache(transformed);</span><br><span class=\"line\"></span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 转码</span></span><br><span class=\"line\">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeTransformedToCache</span><span class=\"params\">(Resource&lt;T&gt; transformed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transformed == <span class=\"keyword\">null</span> || !diskCacheStrategy.cacheResult()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    SourceWriter&lt;Resource&lt;T&gt;&gt; writer = <span class=\"keyword\">new</span> SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed);</span><br><span class=\"line\">    diskCacheProvider.getDiskCache().put(resultKey, writer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Glide的配置\"><a href=\"#Glide的配置\" class=\"headerlink\" title=\"Glide的配置\"></a>Glide的配置</h2><p>在实例化Glide的时候, 对很多重要的部分做了初始化.</p>","more":"\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 起始入口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;String&gt; <span class=\"title\">load</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">... <span class=\"comment\">// 省略中间步骤</span></span><br></pre></td></tr></table></figure>\n<p>一直向下追溯, 可以找到Glide类的这个方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Glide <span class=\"title\">createGlide</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sourceService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化加载网络图片的线程池</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> cores = Math.max(<span class=\"number\">1</span>, Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">        sourceService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(cores);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diskCacheService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化加载磁盘缓存的线程池</span></span><br><span class=\"line\">        diskCacheService = <span class=\"keyword\">new</span> FifoPriorityThreadPoolExecutor(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化内存缓存池, 可以看到, 是一个lrucache</span></span><br><span class=\"line\">    MemorySizeCalculator calculator = <span class=\"keyword\">new</span> MemorySizeCalculator(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bitmapPool == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> size = calculator.getBitmapPoolSize();</span><br><span class=\"line\">            bitmapPool = <span class=\"keyword\">new</span> LruBitmapPool(size);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            bitmapPool = <span class=\"keyword\">new</span> BitmapPoolAdapter();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memoryCache == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        memoryCache = <span class=\"keyword\">new</span> LruResourceCache(calculator.getMemoryCacheSize());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (diskCacheFactory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        diskCacheFactory = <span class=\"keyword\">new</span> InternalCacheDiskCacheFactory(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (engine == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实例化Glide Engine</span></span><br><span class=\"line\">        engine = <span class=\"keyword\">new</span> Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (decodeFormat == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        decodeFormat = DecodeFormat.DEFAULT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Glide(engine, memoryCache, bitmapPool, context, decodeFormat);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"内存缓存\"><a href=\"#内存缓存\" class=\"headerlink\" title=\"内存缓存\"></a>内存缓存</h2><h3 id=\"Engine-load\"><a href=\"#Engine-load\" class=\"headerlink\" title=\"Engine-load\"></a>Engine-load</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;Key, WeakReference&lt;EngineResource&lt;?&gt;&gt;&gt; activeResources;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 组装key</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();</span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class=\"line\">            transcoder, loadProvider.getSourceEncoder());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 先从内存cache中获取</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(cached);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从ActiveResources获取</span></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(active);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 后面的内容暂时和内存缓存无关</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob current = jobs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当已经存在相同的图片加载job, 直接添加新的callback即可</span></span><br><span class=\"line\">        current.addCallback(cb);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class=\"line\">    <span class=\"comment\">// 具体的图片请求工作在这个runnable中</span></span><br><span class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(runnable);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以出来一个策略就是先从内存cache中获取, 然后从activeResource中获取.<br>ActivityResource是一个Map, 用弱引用存储正在使用的图片资源. 关于这个集合:</p>\n<ul>\n<li>为什么需要这样一个集合, 而不是把所有的图片资源都加入到cache中:<br>使用activeResources来缓存正在使用中的图片，可以保护这些图片不会被LruCache算法回收掉。</li>\n<li>存储的正在使用的图片资源的<strong>弱引用</strong>: 官方的解释是对于ActiveResources中的资源的释放并没有严格约束, 为了防止内存泄漏, 使用弱引用</li>\n</ul>\n<p>来看看对lrucache和ActiveResources的操作</p>\n<h3 id=\"内存cache的获取\"><a href=\"#内存cache的获取\" class=\"headerlink\" title=\"内存cache的获取\"></a>内存cache的获取</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从cache中获取</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; loadFromCache(Key key, <span class=\"keyword\">boolean</span> isMemoryCacheable) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查内存缓存是否被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMemoryCacheable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = getEngineResourceFromCache(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// cache命中, 从lrucache中取出后放入ActiveResources</span></span><br><span class=\"line\">        cached.acquire();</span><br><span class=\"line\">        activeResources.put(key, <span class=\"keyword\">new</span> ResourceWeakReference(key, cached, getReferenceQueue()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cached;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从cache中获取资源</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意这里是直接remove的</span></span><br><span class=\"line\">    Resource&lt;?&gt; cached = cache.remove(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> EngineResource result;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cached <span class=\"keyword\">instanceof</span> EngineResource) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Save an object allocation if we've cached an EngineResource (the typical case).</span></span><br><span class=\"line\">        result = (EngineResource) cached;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> EngineResource(cached, <span class=\"keyword\">true</span> <span class=\"comment\">/*isCacheable*/</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> EngineResource&lt;?&gt; loadFromActiveResources(Key key, <span class=\"keyword\">boolean</span> isMemoryCacheable) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 检查内存cache是否被禁用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isMemoryCacheable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    WeakReference&lt;EngineResource&lt;?&gt;&gt; activeRef = activeResources.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activeRef != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        active = activeRef.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ActiveResource命中</span></span><br><span class=\"line\">            active.acquire();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 弱引用的对象被释放了, 直接remove</span></span><br><span class=\"line\">            activeResources.remove(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> active;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内存cache的释放\"><a href=\"#内存cache的释放\" class=\"headerlink\" title=\"内存cache的释放\"></a>内存cache的释放</h3><p>先来看看resource中如何表示图片需要被释放<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EngineResource</span>&lt;<span class=\"title\">Z</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Resource</span>&lt;<span class=\"title\">Z</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> acquired;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ... <span class=\"comment\">// 省略异常处理</span></span><br><span class=\"line\">        ++acquired;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ... <span class=\"comment\">// 省略异常处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (--acquired == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当acquired为0的使用, 表示当前图片没有被引用</span></span><br><span class=\"line\">            listener.onResourceReleased(key, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>resource中listener的回调是在EngineJob类中实现的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 图片的引用为0, 图片没有在使用了, 所以从ActiveResource中移除, 添加进lrucache</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReleased</span><span class=\"params\">(Key cacheKey, EngineResource resource)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    activeResources.remove(cacheKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resource.isCacheable()) &#123;</span><br><span class=\"line\">        cache.put(cacheKey, resource);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resourceRecycler.recycle(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"磁盘缓存\"><a href=\"#磁盘缓存\" class=\"headerlink\" title=\"磁盘缓存\"></a>磁盘缓存</h2><p>首先要明确一点, 就是磁盘缓存不止一种. 在配置Glide的磁盘缓存的时候, 可以配置单独缓存原始图片, 还是单独缓存转化后的图片. 所以Glide的内部, 肯定对原始图片的缓存 和 转化后图片的缓存都做了处理.</p>\n<h3 id=\"入口\"><a href=\"#入口\" class=\"headerlink\" title=\"入口\"></a>入口</h3><p>内存cache的工作在Engine的load方法中已经做完了. 磁盘cache在Runnable的decode()方法中</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Resource&lt;?&gt; decode() <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDecodingFromCache()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decodeFromCache();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> decodeFromSource();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从磁盘缓存中获取图片, 先尝试获取处理后的图片, 再尝试获取原始图片</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Resource&lt;?&gt; decodeFromCache() <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    Resource&lt;?&gt; result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        result = decodeJob.decodeResultFromCache();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class=\"line\">            Log.d(TAG, <span class=\"string\">\"Exception decoding result from cache: \"</span> + e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        result = decodeJob.decodeSourceFromCache();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"磁盘cache读取\"><a href=\"#磁盘cache读取\" class=\"headerlink\" title=\"磁盘cache读取\"></a>磁盘cache读取</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Z&gt; <span class=\"title\">decodeResultFromCache</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!diskCacheStrategy.cacheResult()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;T&gt; transformed = loadFromCache(resultKey);</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Resource&lt;Z&gt; <span class=\"title\">decodeSourceFromCache</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!diskCacheStrategy.cacheSource()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformEncodeAndTranscode(decoded);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">loadFromCache</span><span class=\"params\">(Key key)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    File cacheFile = diskCacheProvider.getDiskCache().get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheFile == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Resource&lt;T&gt; result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        result = loadProvider.getCacheDecoder().decode(cacheFile, width, height);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            diskCacheProvider.getDiskCache().delete(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>磁盘缓存读取这里挺好懂的</p>\n<h3 id=\"磁盘cache写入\"><a href=\"#磁盘cache写入\" class=\"headerlink\" title=\"磁盘cache写入\"></a>磁盘cache写入</h3><h4 id=\"缓存原始图片\"><a href=\"#缓存原始图片\" class=\"headerlink\" title=\"缓存原始图片\"></a>缓存原始图片</h4><p>直接贴调用过程吧</p>\n<p>EngineRunnable.decodeFromSource()<br>-&gt; EngineRunnable.decodeFromSource()<br>-&gt; DecodeJob.decodeFromSource()<br>-&gt; DecodeJob.decodeSource()<br>-&gt; DecodeJob.decodeFromSourceData()<br>-&gt; DecodeJob.cacheAndDecodeSourceData</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">decodeSource</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    Resource&lt;T&gt; decoded = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">        <span class=\"comment\">// 从网络获取图片</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> A data = fetcher.loadData(priority);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        decoded = decodeFromSourceData(data);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        fetcher.cleanup();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decoded;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;T&gt; <span class=\"title\">cacheAndDecodeSourceData</span><span class=\"params\">(A data)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    SourceWriter&lt;A&gt; writer = <span class=\"keyword\">new</span> SourceWriter&lt;A&gt;(loadProvider.getSourceEncoder(), data);</span><br><span class=\"line\">    diskCacheProvider.getDiskCache().put(resultKey.getOriginalKey(), writer);</span><br><span class=\"line\"></span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// ?? 才刚放进去之后又拿出来? 为什么不直接用放进去的那个?</span></span><br><span class=\"line\">    Resource&lt;T&gt; result = loadFromCache(resultKey.getOriginalKey());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"缓存处理过后的图片\"><a href=\"#缓存处理过后的图片\" class=\"headerlink\" title=\"缓存处理过后的图片\"></a>缓存处理过后的图片</h4><p>EngineRunnable.decodeFromSource()<br>-&gt; EngineRunnable.decodeFromSource()<br>-&gt; DecodeJob.decodeFromSource()<br>-&gt; DecodeJob.transformEncodeAndTranscode<br>-&gt; DecodeJob.writeTransformedToCache</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Resource&lt;Z&gt; <span class=\"title\">transformEncodeAndTranscode</span><span class=\"params\">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 先转换图片</span></span><br><span class=\"line\">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class=\"line\">    <span class=\"comment\">// 写入磁盘</span></span><br><span class=\"line\">    writeTransformedToCache(transformed);</span><br><span class=\"line\"></span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"comment\">// 转码</span></span><br><span class=\"line\">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeTransformedToCache</span><span class=\"params\">(Resource&lt;T&gt; transformed)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (transformed == <span class=\"keyword\">null</span> || !diskCacheStrategy.cacheResult()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\">    SourceWriter&lt;Resource&lt;T&gt;&gt; writer = <span class=\"keyword\">new</span> SourceWriter&lt;Resource&lt;T&gt;&gt;(loadProvider.getEncoder(), transformed);</span><br><span class=\"line\">    diskCacheProvider.getDiskCache().put(resultKey, writer);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"OkHttp3源码-CacheInterceptor","date":"2019-11-14T12:17:52.000Z","_content":"\n# OkHttp3源码-CacheInterceptor\n\nokhttp3的cache管理部分比较复杂, 我一上来是一脸懵逼的, 结合网上的博客, 先上个伪代码吧..\n\n## 伪代码\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    // 1. 从Interceptor类的成员变量cache中尝试获取cache\n    // 这里的cache是OkHttpClient在build用户手动添加的, 默认为null\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    // 从请求策略中获取缓存的 网络请求 和 response\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    //2 如果缓存策略禁止使用网络请求并且缓存的response为null, 则返回一个504的response\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response(504);\n    }\n\n    //3 如果缓存策略禁止使用网络请求但是缓存的response不为null, 返回cache\n    if (networkRequest == null) {\n      return cacheResponse;\n    }\n\n    //4 到达这里表示没有可用的缓存, 继续责任链的下一个结点, 继续请求网络\n    networkResponse = chain.proceed(networkRequest);\n\n    //5 如果cache不为null, 并且服务器返回的response.code为HTTP_NOT_MODIFIED, 则返回cache中的response\n    // (304: 客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户端缓存可以使用)\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        Response response = cacheResponse.newBuilder()\n        return response;\n      } \n    }\n\n    //6 决定使用网络获取的response\n    Response response = networkResponse;\n\n    //7 将response装入cache中, 这里是用户添加的那个cache\n    cache.put(response);\n\n    return response;\n}\n```\n\n## interceptor的详细过程\n\n看过伪代码, 现在来看详细过程, 就好多了\n\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    //默认cache为null,可以配置cache,不为空尝试获取缓存中的response\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    long now = System.currentTimeMillis();\n    //根据response,time,request创建一个缓存策略，用于判断怎样使用缓存\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    if (cache != null) {\n      cache.trackResponse(strategy);\n    }\n\n    if (cacheCandidate != null && cacheResponse == null) {\n      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\n    }\n\n    // If we're forbidden from using the network and the cache is insufficient, fail.\n    //如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response.Builder()\n          .request(chain.request())\n          .protocol(Protocol.HTTP_1_1)\n          .code(504)\n          .message(\"Unsatisfiable Request (only-if-cached)\")\n          .body(Util.EMPTY_RESPONSE)\n          .sentRequestAtMillis(-1L)\n          .receivedResponseAtMillis(System.currentTimeMillis())\n          .build();\n    }\n\n    // If we don't need the network, we're done.\n    //不使用网络，但是有缓存，直接返回缓存\n    if (networkRequest == null) {\n      return cacheResponse.newBuilder()\n          .cacheResponse(stripBody(cacheResponse))\n          .build();\n    }\n\n    Response networkResponse = null;\n    try {\n      //直接走后续拦截器\n      networkResponse = chain.proceed(networkRequest);\n    } finally {\n      // If we're crashing on I/O or otherwise, don't leak the cache body.\n      if (networkResponse == null && cacheCandidate != null) {\n        closeQuietly(cacheCandidate.body());\n      }\n    }\n\n    // If we have a cache response too, then we're doing a conditional get.\n    // 当缓存响应和网络响应同时存在的时候，选择用哪个\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        // 如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求\n        // (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).\n        // 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应\n        Response response = cacheResponse.newBuilder()\n            .headers(combine(cacheResponse.headers(), networkResponse.headers()))\n            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n            .cacheResponse(stripBody(cacheResponse))\n            .networkResponse(stripBody(networkResponse))\n            .build();\n        networkResponse.body().close();\n\n        // Update the cache after combining headers but before stripping the\n        // Content-Encoding header (as performed by initContentStream()).\n        cache.trackConditionalCacheHit();\n        cache.update(cacheResponse, response);\n        return response;\n      } else {\n        closeQuietly(cacheResponse.body());\n      }\n    }\n    //使用网络响应\n    Response response = networkResponse.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n\n    //所以默认创建的OkHttpClient是没有缓存的\n    if (cache != null) {\n      // 缓存response\n      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {\n        // Offer this request to the cache.\n        // 缓存Resposne的Header信息\n        CacheRequest cacheRequest = cache.put(response);\n        // 缓存body\n        return cacheWritingResponse(cacheRequest, response);\n      }\n      // 只能okhttp3只能缓存GET请求....不然从cache中移除request\n      // 很奇怪, 为什么要在这里加一个判断\n      if (HttpMethod.invalidatesCache(networkRequest.method())) {\n        try {\n          cache.remove(networkRequest);\n        } catch (IOException ignored) {\n          // The cache cannot be written.\n        }\n      }\n    }\n\n    return response;\n}\n```\n\n## Cache\n\n**OkHttpClient创建时添加cache:**\n```java\nOkHttpClient.Builder builder = new OkHttpClient.Builder()\n    .connectTimeout(15, TimeUnit.SECONDS)\n    .writeTimeout(20, TimeUnit.SECONDS)\n    .readTimeout(20, TimeUnit.SECONDS)\n    .cache(new Cache(context.getExternalCacheDir(), 10*1024*1024));\n```\n\n**InternalCache和Cache:**\n\nInternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量\n\n**实现原理:**\n\n封装了对DiskLruCach的操作\n\n**注意点:**\n**Cache类只能缓存get请求.** 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低.\n\n## CacheStrategy\n\n**构造方法**\n```java\nCacheStrategy(Request networkRequest, Response cacheResponse)\n```\n生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。\n\n**CacheStrategy.Factory**\n```java\npublic Factory(long nowMillis, Request request, Response cacheResponse) \n```\n\n这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy\n\nrequest参数中附带有用户对缓存策略的配置: ( .cacheControl)\n\n类如:\n```java\nRequest request = new Request.Builder()\n       .cacheControl(new CacheControl.Builder().noCache().build())\n       .url(\"http://publicobject.com/helloworld.txt\")\n       .build();\n```\n\n\n\n\n\n\n\n\n","source":"_posts/Android/源码解析/OkHttp3源码-CacheInterceptor.md","raw":"---\ntitle: OkHttp3源码-CacheInterceptor\ndate: 2019-11-14 20:17:52\ntags:\n- okhttp3\n- 源码解析\ncategories:\n- Android\n---\n\n# OkHttp3源码-CacheInterceptor\n\nokhttp3的cache管理部分比较复杂, 我一上来是一脸懵逼的, 结合网上的博客, 先上个伪代码吧..\n\n## 伪代码\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    // 1. 从Interceptor类的成员变量cache中尝试获取cache\n    // 这里的cache是OkHttpClient在build用户手动添加的, 默认为null\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    // 从请求策略中获取缓存的 网络请求 和 response\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    //2 如果缓存策略禁止使用网络请求并且缓存的response为null, 则返回一个504的response\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response(504);\n    }\n\n    //3 如果缓存策略禁止使用网络请求但是缓存的response不为null, 返回cache\n    if (networkRequest == null) {\n      return cacheResponse;\n    }\n\n    //4 到达这里表示没有可用的缓存, 继续责任链的下一个结点, 继续请求网络\n    networkResponse = chain.proceed(networkRequest);\n\n    //5 如果cache不为null, 并且服务器返回的response.code为HTTP_NOT_MODIFIED, 则返回cache中的response\n    // (304: 客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户端缓存可以使用)\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        Response response = cacheResponse.newBuilder()\n        return response;\n      } \n    }\n\n    //6 决定使用网络获取的response\n    Response response = networkResponse;\n\n    //7 将response装入cache中, 这里是用户添加的那个cache\n    cache.put(response);\n\n    return response;\n}\n```\n\n## interceptor的详细过程\n\n看过伪代码, 现在来看详细过程, 就好多了\n\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    //默认cache为null,可以配置cache,不为空尝试获取缓存中的response\n    Response cacheCandidate = cache != null\n        ? cache.get(chain.request())\n        : null;\n\n    long now = System.currentTimeMillis();\n    //根据response,time,request创建一个缓存策略，用于判断怎样使用缓存\n    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();\n    Request networkRequest = strategy.networkRequest;\n    Response cacheResponse = strategy.cacheResponse;\n\n    if (cache != null) {\n      cache.trackResponse(strategy);\n    }\n\n    if (cacheCandidate != null && cacheResponse == null) {\n      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.\n    }\n\n    // If we're forbidden from using the network and the cache is insufficient, fail.\n    //如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504\n    if (networkRequest == null && cacheResponse == null) {\n      return new Response.Builder()\n          .request(chain.request())\n          .protocol(Protocol.HTTP_1_1)\n          .code(504)\n          .message(\"Unsatisfiable Request (only-if-cached)\")\n          .body(Util.EMPTY_RESPONSE)\n          .sentRequestAtMillis(-1L)\n          .receivedResponseAtMillis(System.currentTimeMillis())\n          .build();\n    }\n\n    // If we don't need the network, we're done.\n    //不使用网络，但是有缓存，直接返回缓存\n    if (networkRequest == null) {\n      return cacheResponse.newBuilder()\n          .cacheResponse(stripBody(cacheResponse))\n          .build();\n    }\n\n    Response networkResponse = null;\n    try {\n      //直接走后续拦截器\n      networkResponse = chain.proceed(networkRequest);\n    } finally {\n      // If we're crashing on I/O or otherwise, don't leak the cache body.\n      if (networkResponse == null && cacheCandidate != null) {\n        closeQuietly(cacheCandidate.body());\n      }\n    }\n\n    // If we have a cache response too, then we're doing a conditional get.\n    // 当缓存响应和网络响应同时存在的时候，选择用哪个\n    if (cacheResponse != null) {\n      if (networkResponse.code() == HTTP_NOT_MODIFIED) {\n        // 如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求\n        // (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).\n        // 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应\n        Response response = cacheResponse.newBuilder()\n            .headers(combine(cacheResponse.headers(), networkResponse.headers()))\n            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())\n            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())\n            .cacheResponse(stripBody(cacheResponse))\n            .networkResponse(stripBody(networkResponse))\n            .build();\n        networkResponse.body().close();\n\n        // Update the cache after combining headers but before stripping the\n        // Content-Encoding header (as performed by initContentStream()).\n        cache.trackConditionalCacheHit();\n        cache.update(cacheResponse, response);\n        return response;\n      } else {\n        closeQuietly(cacheResponse.body());\n      }\n    }\n    //使用网络响应\n    Response response = networkResponse.newBuilder()\n        .cacheResponse(stripBody(cacheResponse))\n        .networkResponse(stripBody(networkResponse))\n        .build();\n\n    //所以默认创建的OkHttpClient是没有缓存的\n    if (cache != null) {\n      // 缓存response\n      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {\n        // Offer this request to the cache.\n        // 缓存Resposne的Header信息\n        CacheRequest cacheRequest = cache.put(response);\n        // 缓存body\n        return cacheWritingResponse(cacheRequest, response);\n      }\n      // 只能okhttp3只能缓存GET请求....不然从cache中移除request\n      // 很奇怪, 为什么要在这里加一个判断\n      if (HttpMethod.invalidatesCache(networkRequest.method())) {\n        try {\n          cache.remove(networkRequest);\n        } catch (IOException ignored) {\n          // The cache cannot be written.\n        }\n      }\n    }\n\n    return response;\n}\n```\n\n## Cache\n\n**OkHttpClient创建时添加cache:**\n```java\nOkHttpClient.Builder builder = new OkHttpClient.Builder()\n    .connectTimeout(15, TimeUnit.SECONDS)\n    .writeTimeout(20, TimeUnit.SECONDS)\n    .readTimeout(20, TimeUnit.SECONDS)\n    .cache(new Cache(context.getExternalCacheDir(), 10*1024*1024));\n```\n\n**InternalCache和Cache:**\n\nInternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量\n\n**实现原理:**\n\n封装了对DiskLruCach的操作\n\n**注意点:**\n**Cache类只能缓存get请求.** 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低.\n\n## CacheStrategy\n\n**构造方法**\n```java\nCacheStrategy(Request networkRequest, Response cacheResponse)\n```\n生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。\n\n**CacheStrategy.Factory**\n```java\npublic Factory(long nowMillis, Request request, Response cacheResponse) \n```\n\n这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy\n\nrequest参数中附带有用户对缓存策略的配置: ( .cacheControl)\n\n类如:\n```java\nRequest request = new Request.Builder()\n       .cacheControl(new CacheControl.Builder().noCache().build())\n       .url(\"http://publicobject.com/helloworld.txt\")\n       .build();\n```\n\n\n\n\n\n\n\n\n","slug":"Android/源码解析/OkHttp3源码-CacheInterceptor","published":1,"updated":"2021-10-03T01:57:41.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9s005wg0jer9zlw2qu","content":"<h1 id=\"OkHttp3源码-CacheInterceptor\"><a href=\"#OkHttp3源码-CacheInterceptor\" class=\"headerlink\" title=\"OkHttp3源码-CacheInterceptor\"></a>OkHttp3源码-CacheInterceptor</h1><a id=\"more\"></a><p>okhttp3的cache管理部分比较复杂, 我一上来是一脸懵逼的, 结合网上的博客, 先上个伪代码吧..</p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 从Interceptor类的成员变量cache中尝试获取cache</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里的cache是OkHttpClient在build用户手动添加的, 默认为null</span></span><br><span class=\"line\">    Response cacheCandidate = cache != <span class=\"keyword\">null</span></span><br><span class=\"line\">        ? cache.get(chain.request())</span><br><span class=\"line\">        : <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从请求策略中获取缓存的 网络请求 和 response</span></span><br><span class=\"line\">    CacheStrategy strategy = <span class=\"keyword\">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class=\"line\">    Request networkRequest = strategy.networkRequest;</span><br><span class=\"line\">    Response cacheResponse = strategy.cacheResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2 如果缓存策略禁止使用网络请求并且缓存的response为null, 则返回一个504的response</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response(<span class=\"number\">504</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3 如果缓存策略禁止使用网络请求但是缓存的response不为null, 返回cache</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cacheResponse;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//4 到达这里表示没有可用的缓存, 继续责任链的下一个结点, 继续请求网络</span></span><br><span class=\"line\">    networkResponse = chain.proceed(networkRequest);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//5 如果cache不为null, 并且服务器返回的response.code为HTTP_NOT_MODIFIED, 则返回cache中的response</span></span><br><span class=\"line\">    <span class=\"comment\">// (304: 客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户端缓存可以使用)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class=\"line\">        Response response = cacheResponse.newBuilder()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//6 决定使用网络获取的response</span></span><br><span class=\"line\">    Response response = networkResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//7 将response装入cache中, 这里是用户添加的那个cache</span></span><br><span class=\"line\">    cache.put(response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"interceptor的详细过程\"><a href=\"#interceptor的详细过程\" class=\"headerlink\" title=\"interceptor的详细过程\"></a>interceptor的详细过程</h2><p>看过伪代码, 现在来看详细过程, 就好多了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//默认cache为null,可以配置cache,不为空尝试获取缓存中的response</span></span><br><span class=\"line\">    Response cacheCandidate = cache != <span class=\"keyword\">null</span></span><br><span class=\"line\">        ? cache.get(chain.request())</span><br><span class=\"line\">        : <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">//根据response,time,request创建一个缓存策略，用于判断怎样使用缓存</span></span><br><span class=\"line\">    CacheStrategy strategy = <span class=\"keyword\">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class=\"line\">    Request networkRequest = strategy.networkRequest;</span><br><span class=\"line\">    Response cacheResponse = strategy.cacheResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      cache.trackResponse(strategy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheCandidate != <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      closeQuietly(cacheCandidate.body()); <span class=\"comment\">// The cache candidate wasn't applicable. Close it.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response.Builder()</span><br><span class=\"line\">          .request(chain.request())</span><br><span class=\"line\">          .protocol(Protocol.HTTP_1_1)</span><br><span class=\"line\">          .code(<span class=\"number\">504</span>)</span><br><span class=\"line\">          .message(<span class=\"string\">\"Unsatisfiable Request (only-if-cached)\"</span>)</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .sentRequestAtMillis(-<span class=\"number\">1L</span>)</span><br><span class=\"line\">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we don't need the network, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">//不使用网络，但是有缓存，直接返回缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cacheResponse.newBuilder()</span><br><span class=\"line\">          .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Response networkResponse = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//直接走后续拦截器</span></span><br><span class=\"line\">      networkResponse = chain.proceed(networkRequest);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse == <span class=\"keyword\">null</span> &amp;&amp; cacheCandidate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        closeQuietly(cacheCandidate.body());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class=\"line\">    <span class=\"comment\">// 当缓存响应和网络响应同时存在的时候，选择用哪个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求</span></span><br><span class=\"line\">        <span class=\"comment\">// (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).</span></span><br><span class=\"line\">        <span class=\"comment\">// 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应</span></span><br><span class=\"line\">        Response response = cacheResponse.newBuilder()</span><br><span class=\"line\">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class=\"line\">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class=\"line\">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class=\"line\">            .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">            .networkResponse(stripBody(networkResponse))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">        networkResponse.body().close();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Update the cache after combining headers but before stripping the</span></span><br><span class=\"line\">        <span class=\"comment\">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class=\"line\">        cache.trackConditionalCacheHit();</span><br><span class=\"line\">        cache.update(cacheResponse, response);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        closeQuietly(cacheResponse.body());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//使用网络响应</span></span><br><span class=\"line\">    Response response = networkResponse.newBuilder()</span><br><span class=\"line\">        .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">        .networkResponse(stripBody(networkResponse))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所以默认创建的OkHttpClient是没有缓存的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 缓存response</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Offer this request to the cache.</span></span><br><span class=\"line\">        <span class=\"comment\">// 缓存Resposne的Header信息</span></span><br><span class=\"line\">        CacheRequest cacheRequest = cache.put(response);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存body</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 只能okhttp3只能缓存GET请求....不然从cache中移除request</span></span><br><span class=\"line\">      <span class=\"comment\">// 很奇怪, 为什么要在这里加一个判断</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          cache.remove(networkRequest);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// The cache cannot be written.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache\"></a>Cache</h2><p><strong>OkHttpClient创建时添加cache:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient.Builder builder = <span class=\"keyword\">new</span> OkHttpClient.Builder()</span><br><span class=\"line\">    .connectTimeout(<span class=\"number\">15</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .writeTimeout(<span class=\"number\">20</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .readTimeout(<span class=\"number\">20</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .cache(<span class=\"keyword\">new</span> Cache(context.getExternalCacheDir(), <span class=\"number\">10</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>));</span><br></pre></td></tr></table></figure></p>\n<p><strong>InternalCache和Cache:</strong></p>\n<p>InternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量</p>\n<p><strong>实现原理:</strong></p>\n<p>封装了对DiskLruCach的操作</p>\n<p><strong>注意点:</strong><br><strong>Cache类只能缓存get请求.</strong> 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低.</p>\n<h2 id=\"CacheStrategy\"><a href=\"#CacheStrategy\" class=\"headerlink\" title=\"CacheStrategy\"></a>CacheStrategy</h2><p><strong>构造方法</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CacheStrategy(Request networkRequest, Response cacheResponse)</span><br></pre></td></tr></table></figure></p>\n<p>生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。</p>\n<p><strong>CacheStrategy.Factory</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Factory</span><span class=\"params\">(<span class=\"keyword\">long</span> nowMillis, Request request, Response cacheResponse)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy</p>\n<p>request参数中附带有用户对缓存策略的配置: ( .cacheControl)</p>\n<p>类如:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request request = <span class=\"keyword\">new</span> Request.Builder()</span><br><span class=\"line\">       .cacheControl(<span class=\"keyword\">new</span> CacheControl.Builder().noCache().build())</span><br><span class=\"line\">       .url(<span class=\"string\">\"http://publicobject.com/helloworld.txt\"</span>)</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"OkHttp3源码-CacheInterceptor\"><a href=\"#OkHttp3源码-CacheInterceptor\" class=\"headerlink\" title=\"OkHttp3源码-CacheInterceptor\"></a>OkHttp3源码-CacheInterceptor</h1>","more":"<p>okhttp3的cache管理部分比较复杂, 我一上来是一脸懵逼的, 结合网上的博客, 先上个伪代码吧..</p>\n<h2 id=\"伪代码\"><a href=\"#伪代码\" class=\"headerlink\" title=\"伪代码\"></a>伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 从Interceptor类的成员变量cache中尝试获取cache</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里的cache是OkHttpClient在build用户手动添加的, 默认为null</span></span><br><span class=\"line\">    Response cacheCandidate = cache != <span class=\"keyword\">null</span></span><br><span class=\"line\">        ? cache.get(chain.request())</span><br><span class=\"line\">        : <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从请求策略中获取缓存的 网络请求 和 response</span></span><br><span class=\"line\">    CacheStrategy strategy = <span class=\"keyword\">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class=\"line\">    Request networkRequest = strategy.networkRequest;</span><br><span class=\"line\">    Response cacheResponse = strategy.cacheResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2 如果缓存策略禁止使用网络请求并且缓存的response为null, 则返回一个504的response</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response(<span class=\"number\">504</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3 如果缓存策略禁止使用网络请求但是缓存的response不为null, 返回cache</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cacheResponse;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//4 到达这里表示没有可用的缓存, 继续责任链的下一个结点, 继续请求网络</span></span><br><span class=\"line\">    networkResponse = chain.proceed(networkRequest);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//5 如果cache不为null, 并且服务器返回的response.code为HTTP_NOT_MODIFIED, 则返回cache中的response</span></span><br><span class=\"line\">    <span class=\"comment\">// (304: 客户端有缓冲的文档并发出了一个条件性的请求, 服务器告诉客户端缓存可以使用)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class=\"line\">        Response response = cacheResponse.newBuilder()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//6 决定使用网络获取的response</span></span><br><span class=\"line\">    Response response = networkResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//7 将response装入cache中, 这里是用户添加的那个cache</span></span><br><span class=\"line\">    cache.put(response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"interceptor的详细过程\"><a href=\"#interceptor的详细过程\" class=\"headerlink\" title=\"interceptor的详细过程\"></a>interceptor的详细过程</h2><p>看过伪代码, 现在来看详细过程, 就好多了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//默认cache为null,可以配置cache,不为空尝试获取缓存中的response</span></span><br><span class=\"line\">    Response cacheCandidate = cache != <span class=\"keyword\">null</span></span><br><span class=\"line\">        ? cache.get(chain.request())</span><br><span class=\"line\">        : <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"comment\">//根据response,time,request创建一个缓存策略，用于判断怎样使用缓存</span></span><br><span class=\"line\">    CacheStrategy strategy = <span class=\"keyword\">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class=\"line\">    Request networkRequest = strategy.networkRequest;</span><br><span class=\"line\">    Response cacheResponse = strategy.cacheResponse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      cache.trackResponse(strategy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheCandidate != <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      closeQuietly(cacheCandidate.body()); <span class=\"comment\">// The cache candidate wasn't applicable. Close it.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果缓存策略中禁止使用网络，并且缓存又为空，则构建一个Resposne直接返回，注意返回码=504</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span> &amp;&amp; cacheResponse == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response.Builder()</span><br><span class=\"line\">          .request(chain.request())</span><br><span class=\"line\">          .protocol(Protocol.HTTP_1_1)</span><br><span class=\"line\">          .code(<span class=\"number\">504</span>)</span><br><span class=\"line\">          .message(<span class=\"string\">\"Unsatisfiable Request (only-if-cached)\"</span>)</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .sentRequestAtMillis(-<span class=\"number\">1L</span>)</span><br><span class=\"line\">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we don't need the network, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">//不使用网络，但是有缓存，直接返回缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (networkRequest == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> cacheResponse.newBuilder()</span><br><span class=\"line\">          .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Response networkResponse = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//直接走后续拦截器</span></span><br><span class=\"line\">      networkResponse = chain.proceed(networkRequest);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse == <span class=\"keyword\">null</span> &amp;&amp; cacheCandidate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        closeQuietly(cacheCandidate.body());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we have a cache response too, then we're doing a conditional get.</span></span><br><span class=\"line\">    <span class=\"comment\">// 当缓存响应和网络响应同时存在的时候，选择用哪个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果返回码是304，客户端有缓冲的文档并发出了一个条件性的请求</span></span><br><span class=\"line\">        <span class=\"comment\">// (一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档).</span></span><br><span class=\"line\">        <span class=\"comment\">// 服务器告诉客户，原来缓冲的文档还可以继续使用。则使用缓存的响应</span></span><br><span class=\"line\">        Response response = cacheResponse.newBuilder()</span><br><span class=\"line\">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class=\"line\">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class=\"line\">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class=\"line\">            .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">            .networkResponse(stripBody(networkResponse))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">        networkResponse.body().close();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Update the cache after combining headers but before stripping the</span></span><br><span class=\"line\">        <span class=\"comment\">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class=\"line\">        cache.trackConditionalCacheHit();</span><br><span class=\"line\">        cache.update(cacheResponse, response);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        closeQuietly(cacheResponse.body());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//使用网络响应</span></span><br><span class=\"line\">    Response response = networkResponse.newBuilder()</span><br><span class=\"line\">        .cacheResponse(stripBody(cacheResponse))</span><br><span class=\"line\">        .networkResponse(stripBody(networkResponse))</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//所以默认创建的OkHttpClient是没有缓存的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cache != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 缓存response</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Offer this request to the cache.</span></span><br><span class=\"line\">        <span class=\"comment\">// 缓存Resposne的Header信息</span></span><br><span class=\"line\">        CacheRequest cacheRequest = cache.put(response);</span><br><span class=\"line\">        <span class=\"comment\">// 缓存body</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 只能okhttp3只能缓存GET请求....不然从cache中移除request</span></span><br><span class=\"line\">      <span class=\"comment\">// 很奇怪, 为什么要在这里加一个判断</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          cache.remove(networkRequest);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ignored) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// The cache cannot be written.</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Cache\"><a href=\"#Cache\" class=\"headerlink\" title=\"Cache\"></a>Cache</h2><p><strong>OkHttpClient创建时添加cache:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient.Builder builder = <span class=\"keyword\">new</span> OkHttpClient.Builder()</span><br><span class=\"line\">    .connectTimeout(<span class=\"number\">15</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .writeTimeout(<span class=\"number\">20</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .readTimeout(<span class=\"number\">20</span>, TimeUnit.SECONDS)</span><br><span class=\"line\">    .cache(<span class=\"keyword\">new</span> Cache(context.getExternalCacheDir(), <span class=\"number\">10</span>*<span class=\"number\">1024</span>*<span class=\"number\">1024</span>));</span><br></pre></td></tr></table></figure></p>\n<p><strong>InternalCache和Cache:</strong></p>\n<p>InternalCache时在框架内部进行调用的接口, Cache类中有InternalCache的成员变量</p>\n<p><strong>实现原理:</strong></p>\n<p>封装了对DiskLruCach的操作</p>\n<p><strong>注意点:</strong><br><strong>Cache类只能缓存get请求.</strong> 在put方法的注释中提到, 从技术上来说, 是可以缓存post方法的response的, 但是这样的代价太高, 效率很低.</p>\n<h2 id=\"CacheStrategy\"><a href=\"#CacheStrategy\" class=\"headerlink\" title=\"CacheStrategy\"></a>CacheStrategy</h2><p><strong>构造方法</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CacheStrategy(Request networkRequest, Response cacheResponse)</span><br></pre></td></tr></table></figure></p>\n<p>生成的CacheStrategy中有2个变量，networkRequest和cacheResponse，如果networkRequest为null，则表示不进行网络请求；而如果cacheResponse为null，则表示没有有效的缓存。</p>\n<p><strong>CacheStrategy.Factory</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Factory</span><span class=\"params\">(<span class=\"keyword\">long</span> nowMillis, Request request, Response cacheResponse)</span></span></span><br></pre></td></tr></table></figure></p>\n<p>这是CacheStrategy的一个静态内部类, 代码就不贴了. 主要作用是根据参数和创建CacheStrategy</p>\n<p>request参数中附带有用户对缓存策略的配置: ( .cacheControl)</p>\n<p>类如:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request request = <span class=\"keyword\">new</span> Request.Builder()</span><br><span class=\"line\">       .cacheControl(<span class=\"keyword\">new</span> CacheControl.Builder().noCache().build())</span><br><span class=\"line\">       .url(<span class=\"string\">\"http://publicobject.com/helloworld.txt\"</span>)</span><br><span class=\"line\">       .build();</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Glide源码-主要流程","date":"2019-11-17T18:00:05.000Z","_content":"\n## API调用\n\n```java\nGlide.with(fragment)\n    .load(myUrl)\n    .into(imageView);\n```\n\n## with过程\n\n### 主要工作\n\n将图片加载和对应的生命周期绑定(如activity, fragment等)\n绑定生命周期的优点:\n* 在activity, fragment等销毁的时候, 停止对应的图片加载. \n* 避免消耗资源\n* 防止空指针问题的出现\n\n### Glide\n```java\n    public static RequestManager with(Context context) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(context);\n    }\n\n    public static RequestManager with(Activity activity) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(activity);\n    }\n    \n    public static RequestManager with(FragmentActivity activity) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(activity);\n    }\n    \n    public static RequestManager with(android.app.Fragment fragment) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(fragment);\n    }\n    \n    public static RequestManager with(Fragment fragment) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(fragment);\n    }\n```\n\n### RequestManagerRetriever\n\n前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:\n默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了.\n\n```java\npublic RequestManager get(Context context) {\n    if (context == null) {\n        throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n    } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n        if (context instanceof FragmentActivity) {\n            return get((FragmentActivity) context);\n        } else if (context instanceof Activity) {\n            return get((Activity) context);\n        } else if (context instanceof ContextWrapper) {\n            return get(((ContextWrapper) context).getBaseContext());\n        }\n    }\n\n    return getApplicationManager(context);\n}\n\n// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定\nprivate RequestManager getApplicationManager(Context context) {\n    // Either an application context or we're on a background thread.\n    if (applicationManager == null) {\n        synchronized (this) {\n            if (applicationManager == null) {\n                // Normally pause/resume is taken care of by the fragment we add to the fragment or activity.\n                // However, in this case since the manager attached to the application will not receive lifecycle\n                // events, we must force the manager to start resumed using ApplicationLifecycle.\n\n                // 双校验锁 懒汉单例\n                // 将资源加载与整个APP的生命周期绑定\n                applicationManager = new RequestManager(context.getApplicationContext(),\n                        new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());\n            }\n        }\n    }\n\n    return applicationManager;\n}\n\n// 获取RequestManager\npublic RequestManager get(Activity activity) {\n    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n        return get(activity.getApplicationContext());\n    } else {\n        assertNotDestroyed(activity);\n        android.app.FragmentManager fm = activity.getFragmentManager();\n        return fragmentGet(activity, fm);\n    }\n}\n\n.... // 省略其他的重载方法\n\n// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定\nRequestManager fragmentGet(Context context, android.app.FragmentManager fm) {\n    RequestManagerFragment current = getRequestManagerFragment(fm);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());\n        current.setRequestManager(requestManager);\n    }\n    return requestManager;\n}\n\n// 创建并添加RequestManagerFragment\nRequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {\n    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n    if (current == null) {\n        // pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的\n        current = pendingRequestManagerFragments.get(fm);\n        if (current == null) {\n            // 使用FragmentManager添加fragment\n            current = new RequestManagerFragment();\n            pendingRequestManagerFragments.put(fm, current);\n            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();\n        }\n    }\n    return current;\n}\n\n```\n\n## load过程\n\n### RequestManager-load\n\n```java\npublic DrawableTypeRequest<String> load(String string) {\n    return (DrawableTypeRequest<String>) fromString().load(string);\n}\n```\n\n### GenericRequestBuilder\n\nRequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法. \n跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了\n\n```java    \n// ModelType是一个泛型通配符, model是加载的参数\npublic GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {\n    this.model = model;\n    isModelSet = true;\n    return this;\n}\n\n```\n\n## into过程\n\n### GenericRequestBuilder-into\n\n```java\npublic Target<TranscodeType> into(ImageView view) {\n    Util.assertMainThread();\n    if (view == null) {\n        throw new IllegalArgumentException(\"You must pass in a non null View\");\n    }\n\n    // ...省略代码\n\n    return into(glide.buildImageViewTarget(view, transcodeClass));\n}\n\npublic <Y extends Target<TranscodeType>> Y into(Y target) {\n    Util.assertMainThread();\n    \n    ... // 省略代码\n\n    Request previous = target.getRequest();\n\n    // 清楚target上旧的图片请求\n    if (previous != null) {\n        previous.clear();\n        requestTracker.removeRequest(previous);\n        previous.recycle();\n    }\n\n    Request request = buildRequest(target);\n    target.setRequest(request);\n    lifecycle.addListener(target);\n    // 开始请求图片\n    requestTracker.runRequest(request);\n\n    return target;\n}\n```\n\n**为什么要清楚target上旧的图片请求:**\n\n由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。\n\n在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象\n\n### GenericRequestBuilder-runRequest\n\n```java\npublic void runRequest(Request request) {\n    requests.add(request);\n    if (!isPaused) {\n        // 请求加载没有暂停, 则开始请求\n        request.begin();\n    } else {\n        // 请求加载暂停了, 则放入到等待队列中去\n        pendingRequests.add(request);\n    }\n}\n```\n\n```java\n@Override\npublic void begin() {\n    startTime = LogTime.getLogTime();\n    if (model == null) {\n        onException(null);\n        return;\n    }\n\n    status = Status.WAITING_FOR_SIZE;\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n        // 如果用户在调用API时配置了图片的大小, 直接下一步\n        // onSizeReady这个方法很重要\n        onSizeReady(overrideWidth, overrideHeight);\n    } else {\n        // 如果没有, 则获取ImageView的大小\n        // 这个方法最终也会走到onSizeReady方法\n        target.getSize(this);\n    }\n\n    if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {\n        target.onLoadStarted(getPlaceholderDrawable());\n    }\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime));\n    }\n}\n```\n\n```java\n@Override\npublic void onSizeReady(int width, int height) {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"Got onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n    if (status != Status.WAITING_FOR_SIZE) {\n        return;\n    }\n    status = Status.RUNNING;\n\n    width = Math.round(sizeMultiplier * width);\n    height = Math.round(sizeMultiplier * height);\n\n    ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();\n    final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);\n\n    if (dataFetcher == null) {\n        onException(new Exception(\"Failed to load model: \\'\" + model + \"\\'\"));\n        return;\n    }\n    ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished setup for calling load in \" + LogTime.getElapsedMillis(startTime));\n    }\n    loadedFromMemoryCache = true;\n    // 前面的代码都不知道在讲啥, 反正这个engine.load是重点\n    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,\n            priority, isMemoryCacheable, diskCacheStrategy, this);\n    loadedFromMemoryCache = resource != null;\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n}\n```\n\n### Engine-load\n\n获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. \n\n```java\npublic <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n        DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n\n    final String id = fetcher.getId();\n    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n            transcoder, loadProvider.getSourceEncoder());\n\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n        cb.onResourceReady(cached);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n        }\n        return null;\n    }\n\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n        cb.onResourceReady(active);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n        }\n        return null;\n    }\n\n    EngineJob current = jobs.get(key);\n    if (current != null) {\n        current.addCallback(cb);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Added to existing load\", startTime, key);\n        }\n        return new LoadStatus(cb, current);\n    }\n\n    // 前面的缓存策略, 只有再说\n\n    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n    DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n            transcoder, diskCacheProvider, diskCacheStrategy, priority);\n    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n    jobs.put(key, engineJob);\n    engineJob.addCallback(cb);\n    engineJob.start(runnable);\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Started new load\", startTime, key);\n    }\n    return new LoadStatus(cb, engineJob);\n}\n```\n\n### EngineRunnable\n\n获取网络图片, 并编解码\n\n```java\n@Override\npublic void run() {\n    if (isCancelled) {\n        return;\n    }\n\n    Exception exception = null;\n    Resource<?> resource = null;\n    try {\n        // decode()方法是重点\n        // decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等\n        // 这里就不分析了, 太麻烦\n        resource = decode();\n    } catch (OutOfMemoryError e) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Out Of Memory Error decoding\", e);\n        }\n        exception = new ErrorWrappingGlideException(e);\n    } catch (Exception e) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Exception decoding\", e);\n        }\n        exception = e;\n    }\n\n    if (isCancelled) {\n        if (resource != null) {\n            resource.recycle();\n        }\n        return;\n    }\n\n    if (resource == null) {\n        onLoadFailed(exception);\n    } else {\n        onLoadComplete(resource);\n    }\n}\n\nprivate void onLoadComplete(Resource resource) {\n    // manager是一个EngineJob对象\n    manager.onResourceReady(resource);\n}\n```\n\n### EngineJob\n\n```java\n@Override\npublic void onResourceReady(final Resource<?> resource) {\n    this.resource = resource;\n    // 这个handler最终会执行到handleResultOnMainThread方法\n    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();\n}\n\nprivate void handleResultOnMainThread() {\n    if (isCancelled) {\n        resource.recycle();\n        return;\n    } else if (cbs.isEmpty()) {\n        throw new IllegalStateException(\"Received a resource without any callbacks to notify\");\n    }\n    engineResource = engineResourceFactory.build(resource, isCacheable);\n    hasResource = true;\n\n    // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it\n    // synchronously released by one of the callbacks.\n    engineResource.acquire();\n    listener.onEngineJobComplete(key, engineResource);\n\n    for (ResourceCallback cb : cbs) {\n        if (!isInIgnoredCallbacks(cb)) {\n            engineResource.acquire();\n            cb.onResourceReady(engineResource);\n        }\n    }\n    // Our request is complete, so we can release the resource.\n    engineResource.release();\n}\n```\n\n就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了\n\n\n\n\n","source":"_posts/Android/源码解析/Glide源码-主要流程.md","raw":"---\ntitle: Glide源码-主要流程\ndate: 2019-11-18 02:00:05\ntags:\n- glide\n- 源码解析\ncategories:\n- Android\n---\n\n## API调用\n\n```java\nGlide.with(fragment)\n    .load(myUrl)\n    .into(imageView);\n```\n\n## with过程\n\n### 主要工作\n\n将图片加载和对应的生命周期绑定(如activity, fragment等)\n绑定生命周期的优点:\n* 在activity, fragment等销毁的时候, 停止对应的图片加载. \n* 避免消耗资源\n* 防止空指针问题的出现\n\n### Glide\n```java\n    public static RequestManager with(Context context) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(context);\n    }\n\n    public static RequestManager with(Activity activity) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(activity);\n    }\n    \n    public static RequestManager with(FragmentActivity activity) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(activity);\n    }\n    \n    public static RequestManager with(android.app.Fragment fragment) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(fragment);\n    }\n    \n    public static RequestManager with(Fragment fragment) {\n        RequestManagerRetriever retriever = RequestManagerRetriever.get();\n        return retriever.get(fragment);\n    }\n```\n\n### RequestManagerRetriever\n\n前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:\n默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了.\n\n```java\npublic RequestManager get(Context context) {\n    if (context == null) {\n        throw new IllegalArgumentException(\"You cannot start a load on a null Context\");\n    } else if (Util.isOnMainThread() && !(context instanceof Application)) {\n        if (context instanceof FragmentActivity) {\n            return get((FragmentActivity) context);\n        } else if (context instanceof Activity) {\n            return get((Activity) context);\n        } else if (context instanceof ContextWrapper) {\n            return get(((ContextWrapper) context).getBaseContext());\n        }\n    }\n\n    return getApplicationManager(context);\n}\n\n// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定\nprivate RequestManager getApplicationManager(Context context) {\n    // Either an application context or we're on a background thread.\n    if (applicationManager == null) {\n        synchronized (this) {\n            if (applicationManager == null) {\n                // Normally pause/resume is taken care of by the fragment we add to the fragment or activity.\n                // However, in this case since the manager attached to the application will not receive lifecycle\n                // events, we must force the manager to start resumed using ApplicationLifecycle.\n\n                // 双校验锁 懒汉单例\n                // 将资源加载与整个APP的生命周期绑定\n                applicationManager = new RequestManager(context.getApplicationContext(),\n                        new ApplicationLifecycle(), new EmptyRequestManagerTreeNode());\n            }\n        }\n    }\n\n    return applicationManager;\n}\n\n// 获取RequestManager\npublic RequestManager get(Activity activity) {\n    if (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB) {\n        return get(activity.getApplicationContext());\n    } else {\n        assertNotDestroyed(activity);\n        android.app.FragmentManager fm = activity.getFragmentManager();\n        return fragmentGet(activity, fm);\n    }\n}\n\n.... // 省略其他的重载方法\n\n// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定\nRequestManager fragmentGet(Context context, android.app.FragmentManager fm) {\n    RequestManagerFragment current = getRequestManagerFragment(fm);\n    RequestManager requestManager = current.getRequestManager();\n    if (requestManager == null) {\n        requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());\n        current.setRequestManager(requestManager);\n    }\n    return requestManager;\n}\n\n// 创建并添加RequestManagerFragment\nRequestManagerFragment getRequestManagerFragment(final android.app.FragmentManager fm) {\n    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);\n    if (current == null) {\n        // pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的\n        current = pendingRequestManagerFragments.get(fm);\n        if (current == null) {\n            // 使用FragmentManager添加fragment\n            current = new RequestManagerFragment();\n            pendingRequestManagerFragments.put(fm, current);\n            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();\n            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();\n        }\n    }\n    return current;\n}\n\n```\n\n## load过程\n\n### RequestManager-load\n\n```java\npublic DrawableTypeRequest<String> load(String string) {\n    return (DrawableTypeRequest<String>) fromString().load(string);\n}\n```\n\n### GenericRequestBuilder\n\nRequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法. \n跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了\n\n```java    \n// ModelType是一个泛型通配符, model是加载的参数\npublic GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> load(ModelType model) {\n    this.model = model;\n    isModelSet = true;\n    return this;\n}\n\n```\n\n## into过程\n\n### GenericRequestBuilder-into\n\n```java\npublic Target<TranscodeType> into(ImageView view) {\n    Util.assertMainThread();\n    if (view == null) {\n        throw new IllegalArgumentException(\"You must pass in a non null View\");\n    }\n\n    // ...省略代码\n\n    return into(glide.buildImageViewTarget(view, transcodeClass));\n}\n\npublic <Y extends Target<TranscodeType>> Y into(Y target) {\n    Util.assertMainThread();\n    \n    ... // 省略代码\n\n    Request previous = target.getRequest();\n\n    // 清楚target上旧的图片请求\n    if (previous != null) {\n        previous.clear();\n        requestTracker.removeRequest(previous);\n        previous.recycle();\n    }\n\n    Request request = buildRequest(target);\n    target.setRequest(request);\n    lifecycle.addListener(target);\n    // 开始请求图片\n    requestTracker.runRequest(request);\n\n    return target;\n}\n```\n\n**为什么要清楚target上旧的图片请求:**\n\n由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。\n\n在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象\n\n### GenericRequestBuilder-runRequest\n\n```java\npublic void runRequest(Request request) {\n    requests.add(request);\n    if (!isPaused) {\n        // 请求加载没有暂停, 则开始请求\n        request.begin();\n    } else {\n        // 请求加载暂停了, 则放入到等待队列中去\n        pendingRequests.add(request);\n    }\n}\n```\n\n```java\n@Override\npublic void begin() {\n    startTime = LogTime.getLogTime();\n    if (model == null) {\n        onException(null);\n        return;\n    }\n\n    status = Status.WAITING_FOR_SIZE;\n    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {\n        // 如果用户在调用API时配置了图片的大小, 直接下一步\n        // onSizeReady这个方法很重要\n        onSizeReady(overrideWidth, overrideHeight);\n    } else {\n        // 如果没有, 则获取ImageView的大小\n        // 这个方法最终也会走到onSizeReady方法\n        target.getSize(this);\n    }\n\n    if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {\n        target.onLoadStarted(getPlaceholderDrawable());\n    }\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished run method in \" + LogTime.getElapsedMillis(startTime));\n    }\n}\n```\n\n```java\n@Override\npublic void onSizeReady(int width, int height) {\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"Got onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n    if (status != Status.WAITING_FOR_SIZE) {\n        return;\n    }\n    status = Status.RUNNING;\n\n    width = Math.round(sizeMultiplier * width);\n    height = Math.round(sizeMultiplier * height);\n\n    ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();\n    final DataFetcher<T> dataFetcher = modelLoader.getResourceFetcher(model, width, height);\n\n    if (dataFetcher == null) {\n        onException(new Exception(\"Failed to load model: \\'\" + model + \"\\'\"));\n        return;\n    }\n    ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished setup for calling load in \" + LogTime.getElapsedMillis(startTime));\n    }\n    loadedFromMemoryCache = true;\n    // 前面的代码都不知道在讲啥, 反正这个engine.load是重点\n    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,\n            priority, isMemoryCacheable, diskCacheStrategy, this);\n    loadedFromMemoryCache = resource != null;\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logV(\"finished onSizeReady in \" + LogTime.getElapsedMillis(startTime));\n    }\n}\n```\n\n### Engine-load\n\n获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. \n\n```java\npublic <T, Z, R> LoadStatus load(Key signature, int width, int height, DataFetcher<T> fetcher,\n        DataLoadProvider<T, Z> loadProvider, Transformation<Z> transformation, ResourceTranscoder<Z, R> transcoder,\n        Priority priority, boolean isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb) {\n    Util.assertMainThread();\n    long startTime = LogTime.getLogTime();\n\n    final String id = fetcher.getId();\n    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),\n            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),\n            transcoder, loadProvider.getSourceEncoder());\n\n    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);\n    if (cached != null) {\n        cb.onResourceReady(cached);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from cache\", startTime, key);\n        }\n        return null;\n    }\n\n    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);\n    if (active != null) {\n        cb.onResourceReady(active);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Loaded resource from active resources\", startTime, key);\n        }\n        return null;\n    }\n\n    EngineJob current = jobs.get(key);\n    if (current != null) {\n        current.addCallback(cb);\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            logWithTimeAndKey(\"Added to existing load\", startTime, key);\n        }\n        return new LoadStatus(cb, current);\n    }\n\n    // 前面的缓存策略, 只有再说\n\n    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);\n    DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, fetcher, loadProvider, transformation,\n            transcoder, diskCacheProvider, diskCacheStrategy, priority);\n    EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);\n    jobs.put(key, engineJob);\n    engineJob.addCallback(cb);\n    engineJob.start(runnable);\n\n    if (Log.isLoggable(TAG, Log.VERBOSE)) {\n        logWithTimeAndKey(\"Started new load\", startTime, key);\n    }\n    return new LoadStatus(cb, engineJob);\n}\n```\n\n### EngineRunnable\n\n获取网络图片, 并编解码\n\n```java\n@Override\npublic void run() {\n    if (isCancelled) {\n        return;\n    }\n\n    Exception exception = null;\n    Resource<?> resource = null;\n    try {\n        // decode()方法是重点\n        // decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等\n        // 这里就不分析了, 太麻烦\n        resource = decode();\n    } catch (OutOfMemoryError e) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Out Of Memory Error decoding\", e);\n        }\n        exception = new ErrorWrappingGlideException(e);\n    } catch (Exception e) {\n        if (Log.isLoggable(TAG, Log.VERBOSE)) {\n            Log.v(TAG, \"Exception decoding\", e);\n        }\n        exception = e;\n    }\n\n    if (isCancelled) {\n        if (resource != null) {\n            resource.recycle();\n        }\n        return;\n    }\n\n    if (resource == null) {\n        onLoadFailed(exception);\n    } else {\n        onLoadComplete(resource);\n    }\n}\n\nprivate void onLoadComplete(Resource resource) {\n    // manager是一个EngineJob对象\n    manager.onResourceReady(resource);\n}\n```\n\n### EngineJob\n\n```java\n@Override\npublic void onResourceReady(final Resource<?> resource) {\n    this.resource = resource;\n    // 这个handler最终会执行到handleResultOnMainThread方法\n    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();\n}\n\nprivate void handleResultOnMainThread() {\n    if (isCancelled) {\n        resource.recycle();\n        return;\n    } else if (cbs.isEmpty()) {\n        throw new IllegalStateException(\"Received a resource without any callbacks to notify\");\n    }\n    engineResource = engineResourceFactory.build(resource, isCacheable);\n    hasResource = true;\n\n    // Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it\n    // synchronously released by one of the callbacks.\n    engineResource.acquire();\n    listener.onEngineJobComplete(key, engineResource);\n\n    for (ResourceCallback cb : cbs) {\n        if (!isInIgnoredCallbacks(cb)) {\n            engineResource.acquire();\n            cb.onResourceReady(engineResource);\n        }\n    }\n    // Our request is complete, so we can release the resource.\n    engineResource.release();\n}\n```\n\n就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了\n\n\n\n\n","slug":"Android/源码解析/Glide源码-主要流程","published":1,"updated":"2021-10-03T01:57:41.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9s0060g0je5i5s7umw","content":"<h2 id=\"API调用\"><a href=\"#API调用\" class=\"headerlink\" title=\"API调用\"></a>API调用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide.with(fragment)</span><br><span class=\"line\">    .load(myUrl)</span><br><span class=\"line\">    .into(imageView);</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<h2 id=\"with过程\"><a href=\"#with过程\" class=\"headerlink\" title=\"with过程\"></a>with过程</h2><h3 id=\"主要工作\"><a href=\"#主要工作\" class=\"headerlink\" title=\"主要工作\"></a>主要工作</h3><p>将图片加载和对应的生命周期绑定(如activity, fragment等)<br>绑定生命周期的优点:</p>\n<ul>\n<li>在activity, fragment等销毁的时候, 停止对应的图片加载. </li>\n<li>避免消耗资源</li>\n<li>防止空指针问题的出现</li>\n</ul>\n<h3 id=\"Glide\"><a href=\"#Glide\" class=\"headerlink\" title=\"Glide\"></a>Glide</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(activity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(activity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(android.app.Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(fragment);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(fragment);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RequestManagerRetriever\"><a href=\"#RequestManagerRetriever\" class=\"headerlink\" title=\"RequestManagerRetriever\"></a>RequestManagerRetriever</h3><p>前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:<br>默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You cannot start a load on a null Context\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class=\"keyword\">instanceof</span> Application)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> FragmentActivity) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get((FragmentActivity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get((Activity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> ContextWrapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getApplicationManager(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">getApplicationManager</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Either an application context or we're on a background thread.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Normally pause/resume is taken care of by the fragment we add to the fragment or activity.</span></span><br><span class=\"line\">                <span class=\"comment\">// However, in this case since the manager attached to the application will not receive lifecycle</span></span><br><span class=\"line\">                <span class=\"comment\">// events, we must force the manager to start resumed using ApplicationLifecycle.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 双校验锁 懒汉单例</span></span><br><span class=\"line\">                <span class=\"comment\">// 将资源加载与整个APP的生命周期绑定</span></span><br><span class=\"line\">                applicationManager = <span class=\"keyword\">new</span> RequestManager(context.getApplicationContext(),</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> ApplicationLifecycle(), <span class=\"keyword\">new</span> EmptyRequestManagerTreeNode());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> applicationManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取RequestManager</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get(activity.getApplicationContext());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        assertNotDestroyed(activity);</span><br><span class=\"line\">        android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fragmentGet(activity, fm);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.... <span class=\"comment\">// 省略其他的重载方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定</span></span><br><span class=\"line\"><span class=\"function\">RequestManager <span class=\"title\">fragmentGet</span><span class=\"params\">(Context context, android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerFragment current = getRequestManagerFragment(fm);</span><br><span class=\"line\">    RequestManager requestManager = current.getRequestManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        requestManager = <span class=\"keyword\">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class=\"line\">        current.setRequestManager(requestManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并添加RequestManagerFragment</span></span><br><span class=\"line\"><span class=\"function\">RequestManagerFragment <span class=\"title\">getRequestManagerFragment</span><span class=\"params\">(<span class=\"keyword\">final</span> android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的</span></span><br><span class=\"line\">        current = pendingRequestManagerFragments.get(fm);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用FragmentManager添加fragment</span></span><br><span class=\"line\">            current = <span class=\"keyword\">new</span> RequestManagerFragment();</span><br><span class=\"line\">            pendingRequestManagerFragments.put(fm, current);</span><br><span class=\"line\">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class=\"line\">            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"load过程\"><a href=\"#load过程\" class=\"headerlink\" title=\"load过程\"></a>load过程</h2><h3 id=\"RequestManager-load\"><a href=\"#RequestManager-load\" class=\"headerlink\" title=\"RequestManager-load\"></a>RequestManager-load</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;String&gt; <span class=\"title\">load</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GenericRequestBuilder\"><a href=\"#GenericRequestBuilder\" class=\"headerlink\" title=\"GenericRequestBuilder\"></a>GenericRequestBuilder</h3><p>RequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法.<br>跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ModelType是一个泛型通配符, model是加载的参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; <span class=\"title\">load</span><span class=\"params\">(ModelType model)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.model = model;</span><br><span class=\"line\">    isModelSet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"into过程\"><a href=\"#into过程\" class=\"headerlink\" title=\"into过程\"></a>into过程</h2><h3 id=\"GenericRequestBuilder-into\"><a href=\"#GenericRequestBuilder-into\" class=\"headerlink\" title=\"GenericRequestBuilder-into\"></a>GenericRequestBuilder-into</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Target&lt;TranscodeType&gt; <span class=\"title\">into</span><span class=\"params\">(ImageView view)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must pass in a non null View\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(Y target)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    </span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清楚target上旧的图片请求</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        previous.clear();</span><br><span class=\"line\">        requestTracker.removeRequest(previous);</span><br><span class=\"line\">        previous.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Request request = buildRequest(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    lifecycle.addListener(target);</span><br><span class=\"line\">    <span class=\"comment\">// 开始请求图片</span></span><br><span class=\"line\">    requestTracker.runRequest(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>为什么要清楚target上旧的图片请求:</strong></p>\n<p>由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。</p>\n<p>在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象</p>\n<h3 id=\"GenericRequestBuilder-runRequest\"><a href=\"#GenericRequestBuilder-runRequest\" class=\"headerlink\" title=\"GenericRequestBuilder-runRequest\"></a>GenericRequestBuilder-runRequest</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runRequest</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    requests.add(request);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPaused) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求加载没有暂停, 则开始请求</span></span><br><span class=\"line\">        request.begin();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求加载暂停了, 则放入到等待队列中去</span></span><br><span class=\"line\">        pendingRequests.add(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (model == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onException(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    status = Status.WAITING_FOR_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果用户在调用API时配置了图片的大小, 直接下一步</span></span><br><span class=\"line\">        <span class=\"comment\">// onSizeReady这个方法很重要</span></span><br><span class=\"line\">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有, 则获取ImageView的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 这个方法最终也会走到onSizeReady方法</span></span><br><span class=\"line\">        target.getSize(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class=\"line\">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished run method in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeReady</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"Got onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    status = Status.RUNNING;</span><br><span class=\"line\"></span><br><span class=\"line\">    width = Math.round(sizeMultiplier * width);</span><br><span class=\"line\">    height = Math.round(sizeMultiplier * height);</span><br><span class=\"line\"></span><br><span class=\"line\">    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dataFetcher == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onException(<span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Failed to load model: \\'\"</span> + model + <span class=\"string\">\"\\'\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished setup for calling load in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    loadedFromMemoryCache = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 前面的代码都不知道在讲啥, 反正这个engine.load是重点</span></span><br><span class=\"line\">    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</span><br><span class=\"line\">            priority, isMemoryCacheable, diskCacheStrategy, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    loadedFromMemoryCache = resource != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Engine-load\"><a href=\"#Engine-load\" class=\"headerlink\" title=\"Engine-load\"></a>Engine-load</h3><p>获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();</span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class=\"line\">            transcoder, loadProvider.getSourceEncoder());</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(cached);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(active);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob current = jobs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        current.addCallback(cb);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前面的缓存策略, 只有再说</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EngineRunnable\"><a href=\"#EngineRunnable\" class=\"headerlink\" title=\"EngineRunnable\"></a>EngineRunnable</h3><p>获取网络图片, 并编解码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Exception exception = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Resource&lt;?&gt; resource = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// decode()方法是重点</span></span><br><span class=\"line\">        <span class=\"comment\">// decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里就不分析了, 太麻烦</span></span><br><span class=\"line\">        resource = decode();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">\"Out Of Memory Error decoding\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exception = <span class=\"keyword\">new</span> ErrorWrappingGlideException(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">\"Exception decoding\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exception = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resource != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            resource.recycle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resource == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onLoadFailed(exception);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        onLoadComplete(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoadComplete</span><span class=\"params\">(Resource resource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// manager是一个EngineJob对象</span></span><br><span class=\"line\">    manager.onResourceReady(resource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EngineJob\"><a href=\"#EngineJob\" class=\"headerlink\" title=\"EngineJob\"></a>EngineJob</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(<span class=\"keyword\">final</span> Resource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resource = resource;</span><br><span class=\"line\">    <span class=\"comment\">// 这个handler最终会执行到handleResultOnMainThread方法</span></span><br><span class=\"line\">    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, <span class=\"keyword\">this</span>).sendToTarget();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResultOnMainThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        resource.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cbs.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Received a resource without any callbacks to notify\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    engineResource = engineResourceFactory.build(resource, isCacheable);</span><br><span class=\"line\">    hasResource = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it</span></span><br><span class=\"line\">    <span class=\"comment\">// synchronously released by one of the callbacks.</span></span><br><span class=\"line\">    engineResource.acquire();</span><br><span class=\"line\">    listener.onEngineJobComplete(key, engineResource);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceCallback cb : cbs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isInIgnoredCallbacks(cb)) &#123;</span><br><span class=\"line\">            engineResource.acquire();</span><br><span class=\"line\">            cb.onResourceReady(engineResource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Our request is complete, so we can release the resource.</span></span><br><span class=\"line\">    engineResource.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"API调用\"><a href=\"#API调用\" class=\"headerlink\" title=\"API调用\"></a>API调用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Glide.with(fragment)</span><br><span class=\"line\">    .load(myUrl)</span><br><span class=\"line\">    .into(imageView);</span><br></pre></td></tr></table></figure>","more":"\n<h2 id=\"with过程\"><a href=\"#with过程\" class=\"headerlink\" title=\"with过程\"></a>with过程</h2><h3 id=\"主要工作\"><a href=\"#主要工作\" class=\"headerlink\" title=\"主要工作\"></a>主要工作</h3><p>将图片加载和对应的生命周期绑定(如activity, fragment等)<br>绑定生命周期的优点:</p>\n<ul>\n<li>在activity, fragment等销毁的时候, 停止对应的图片加载. </li>\n<li>避免消耗资源</li>\n<li>防止空指针问题的出现</li>\n</ul>\n<h3 id=\"Glide\"><a href=\"#Glide\" class=\"headerlink\" title=\"Glide\"></a>Glide</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(activity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(FragmentActivity activity)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(activity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(android.app.Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(fragment);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestManager <span class=\"title\">with</span><span class=\"params\">(Fragment fragment)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retriever.get(fragment);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RequestManagerRetriever\"><a href=\"#RequestManagerRetriever\" class=\"headerlink\" title=\"RequestManagerRetriever\"></a>RequestManagerRetriever</h3><p>前面说了要监控生命周期的变化, 那么Glide如何监控activity和fragment的生命周期呢? 做法是:<br>默认添加一个自定义的fragment, 因为fragment和activity或者父fragment的生命周期是绑定的, 所以只要监控Glide自定义的那个fragment就可以了.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You cannot start a load on a null Context\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class=\"keyword\">instanceof</span> Application)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> FragmentActivity) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get((FragmentActivity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> Activity) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get((Activity) context);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (context <span class=\"keyword\">instanceof</span> ContextWrapper) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getApplicationManager(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 若调用的get方法, 传入的参数是一个ApplicationContext, 则将图片加载和整个APP的生命周期绑定</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RequestManager <span class=\"title\">getApplicationManager</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Either an application context or we're on a background thread.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (applicationManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Normally pause/resume is taken care of by the fragment we add to the fragment or activity.</span></span><br><span class=\"line\">                <span class=\"comment\">// However, in this case since the manager attached to the application will not receive lifecycle</span></span><br><span class=\"line\">                <span class=\"comment\">// events, we must force the manager to start resumed using ApplicationLifecycle.</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 双校验锁 懒汉单例</span></span><br><span class=\"line\">                <span class=\"comment\">// 将资源加载与整个APP的生命周期绑定</span></span><br><span class=\"line\">                applicationManager = <span class=\"keyword\">new</span> RequestManager(context.getApplicationContext(),</span><br><span class=\"line\">                        <span class=\"keyword\">new</span> ApplicationLifecycle(), <span class=\"keyword\">new</span> EmptyRequestManagerTreeNode());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> applicationManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取RequestManager</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RequestManager <span class=\"title\">get</span><span class=\"params\">(Activity activity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get(activity.getApplicationContext());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        assertNotDestroyed(activity);</span><br><span class=\"line\">        android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fragmentGet(activity, fm);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.... <span class=\"comment\">// 省略其他的重载方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加监控生命周期的fragment, 并将RequestManager创建并和fragment绑定</span></span><br><span class=\"line\"><span class=\"function\">RequestManager <span class=\"title\">fragmentGet</span><span class=\"params\">(Context context, android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerFragment current = getRequestManagerFragment(fm);</span><br><span class=\"line\">    RequestManager requestManager = current.getRequestManager();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requestManager == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        requestManager = <span class=\"keyword\">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class=\"line\">        current.setRequestManager(requestManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> requestManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并添加RequestManagerFragment</span></span><br><span class=\"line\"><span class=\"function\">RequestManagerFragment <span class=\"title\">getRequestManagerFragment</span><span class=\"params\">(<span class=\"keyword\">final</span> android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class=\"line\">    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// pendingRequestManagerFragments是fragment的一个map集合, 没懂用来干什么的</span></span><br><span class=\"line\">        current = pendingRequestManagerFragments.get(fm);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (current == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 使用FragmentManager添加fragment</span></span><br><span class=\"line\">            current = <span class=\"keyword\">new</span> RequestManagerFragment();</span><br><span class=\"line\">            pendingRequestManagerFragments.put(fm, current);</span><br><span class=\"line\">            fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class=\"line\">            handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"load过程\"><a href=\"#load过程\" class=\"headerlink\" title=\"load过程\"></a>load过程</h2><h3 id=\"RequestManager-load\"><a href=\"#RequestManager-load\" class=\"headerlink\" title=\"RequestManager-load\"></a>RequestManager-load</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DrawableTypeRequest&lt;String&gt; <span class=\"title\">load</span><span class=\"params\">(String string)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GenericRequestBuilder\"><a href=\"#GenericRequestBuilder\" class=\"headerlink\" title=\"GenericRequestBuilder\"></a>GenericRequestBuilder</h3><p>RequestManager的load方法跟踪之后来到了GenericRequestBuilder的load方法.<br>跳过中间的过程, GenericRequestBuilder中有placeHolder, centerCrop的Glide加载的配置方法, 知道就好了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ModelType是一个泛型通配符, model是加载的参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; <span class=\"title\">load</span><span class=\"params\">(ModelType model)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.model = model;</span><br><span class=\"line\">    isModelSet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"into过程\"><a href=\"#into过程\" class=\"headerlink\" title=\"into过程\"></a>into过程</h2><h3 id=\"GenericRequestBuilder-into\"><a href=\"#GenericRequestBuilder-into\" class=\"headerlink\" title=\"GenericRequestBuilder-into\"></a>GenericRequestBuilder-into</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Target&lt;TranscodeType&gt; <span class=\"title\">into</span><span class=\"params\">(ImageView view)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (view == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"You must pass in a non null View\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> into(glide.buildImageViewTarget(view, transcodeClass));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class=\"function\">Y <span class=\"title\">into</span><span class=\"params\">(Y target)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    </span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Request previous = target.getRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 清楚target上旧的图片请求</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (previous != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        previous.clear();</span><br><span class=\"line\">        requestTracker.removeRequest(previous);</span><br><span class=\"line\">        previous.recycle();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Request request = buildRequest(target);</span><br><span class=\"line\">    target.setRequest(request);</span><br><span class=\"line\">    lifecycle.addListener(target);</span><br><span class=\"line\">    <span class=\"comment\">// 开始请求图片</span></span><br><span class=\"line\">    requestTracker.runRequest(request);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>为什么要清楚target上旧的图片请求:</strong></p>\n<p>由于ListView中Item的复用机制，会导致网络图片加载的错位或者闪烁。那我们解决这个问题的办法也很简单，就是给当前的ImageView设置tag，这个tag可以是图片的URL等等。当从网络中获取到图片时判断这个ImageVIew中的tag是否是这个图片的URL，如果是就加载图片，如果不是则跳过。</p>\n<p>在有了Glide之后，我们处理ListView或者Recyclerview中的图片加载就很无脑了，根本不需要作任何多余的操作，直接正常使用就行了。这其中的原理是Glide给我们处理了这些判断. 判断的方法和我们平常的思路相同, 同样是添加tag, Glide中给view添加的tag是Request对象</p>\n<h3 id=\"GenericRequestBuilder-runRequest\"><a href=\"#GenericRequestBuilder-runRequest\" class=\"headerlink\" title=\"GenericRequestBuilder-runRequest\"></a>GenericRequestBuilder-runRequest</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runRequest</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    requests.add(request);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isPaused) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求加载没有暂停, 则开始请求</span></span><br><span class=\"line\">        request.begin();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求加载暂停了, 则放入到等待队列中去</span></span><br><span class=\"line\">        pendingRequests.add(request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">begin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    startTime = LogTime.getLogTime();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (model == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onException(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    status = Status.WAITING_FOR_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果用户在调用API时配置了图片的大小, 直接下一步</span></span><br><span class=\"line\">        <span class=\"comment\">// onSizeReady这个方法很重要</span></span><br><span class=\"line\">        onSizeReady(overrideWidth, overrideHeight);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果没有, 则获取ImageView的大小</span></span><br><span class=\"line\">        <span class=\"comment\">// 这个方法最终也会走到onSizeReady方法</span></span><br><span class=\"line\">        target.getSize(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isComplete() &amp;&amp; !isFailed() &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class=\"line\">        target.onLoadStarted(getPlaceholderDrawable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished run method in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSizeReady</span><span class=\"params\">(<span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"Got onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    status = Status.RUNNING;</span><br><span class=\"line\"></span><br><span class=\"line\">    width = Math.round(sizeMultiplier * width);</span><br><span class=\"line\">    height = Math.round(sizeMultiplier * height);</span><br><span class=\"line\"></span><br><span class=\"line\">    ModelLoader&lt;A, T&gt; modelLoader = loadProvider.getModelLoader();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> DataFetcher&lt;T&gt; dataFetcher = modelLoader.getResourceFetcher(model, width, height);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dataFetcher == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onException(<span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Failed to load model: \\'\"</span> + model + <span class=\"string\">\"\\'\"</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ResourceTranscoder&lt;Z, R&gt; transcoder = loadProvider.getTranscoder();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished setup for calling load in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    loadedFromMemoryCache = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 前面的代码都不知道在讲啥, 反正这个engine.load是重点</span></span><br><span class=\"line\">    loadStatus = engine.load(signature, width, height, dataFetcher, loadProvider, transformation, transcoder,</span><br><span class=\"line\">            priority, isMemoryCacheable, diskCacheStrategy, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    loadedFromMemoryCache = resource != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logV(<span class=\"string\">\"finished onSizeReady in \"</span> + LogTime.getElapsedMillis(startTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Engine-load\"><a href=\"#Engine-load\" class=\"headerlink\" title=\"Engine-load\"></a>Engine-load</h3><p>获取资源图片, 这里要考虑到缓存, 具体的策略之后再说吧. </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T, Z, R&gt; <span class=\"function\">LoadStatus <span class=\"title\">load</span><span class=\"params\">(Key signature, <span class=\"keyword\">int</span> width, <span class=\"keyword\">int</span> height, DataFetcher&lt;T&gt; fetcher,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        DataLoadProvider&lt;T, Z&gt; loadProvider, Transformation&lt;Z&gt; transformation, ResourceTranscoder&lt;Z, R&gt; transcoder,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        Priority priority, <span class=\"keyword\">boolean</span> isMemoryCacheable, DiskCacheStrategy diskCacheStrategy, ResourceCallback cb)</span> </span>&#123;</span><br><span class=\"line\">    Util.assertMainThread();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = LogTime.getLogTime();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = fetcher.getId();</span><br><span class=\"line\">    EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class=\"line\">            loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class=\"line\">            transcoder, loadProvider.getSourceEncoder());</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cached != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(cached);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from cache\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (active != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cb.onResourceReady(active);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Loaded resource from active resources\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob current = jobs.get(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (current != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        current.addCallback(cb);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            logWithTimeAndKey(<span class=\"string\">\"Added to existing load\"</span>, startTime, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, current);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前面的缓存策略, 只有再说</span></span><br><span class=\"line\"></span><br><span class=\"line\">    EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class=\"line\">    DecodeJob&lt;T, Z, R&gt; decodeJob = <span class=\"keyword\">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class=\"line\">            transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class=\"line\">    EngineRunnable runnable = <span class=\"keyword\">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class=\"line\">    jobs.put(key, engineJob);</span><br><span class=\"line\">    engineJob.addCallback(cb);</span><br><span class=\"line\">    engineJob.start(runnable);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">        logWithTimeAndKey(<span class=\"string\">\"Started new load\"</span>, startTime, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LoadStatus(cb, engineJob);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EngineRunnable\"><a href=\"#EngineRunnable\" class=\"headerlink\" title=\"EngineRunnable\"></a>EngineRunnable</h3><p>获取网络图片, 并编解码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Exception exception = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Resource&lt;?&gt; resource = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// decode()方法是重点</span></span><br><span class=\"line\">        <span class=\"comment\">// decode()中会有 访问网络, 编码, 解码, 根据缓存策略决定是否缓存等</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里就不分析了, 太麻烦</span></span><br><span class=\"line\">        resource = decode();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">\"Out Of Memory Error decoding\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exception = <span class=\"keyword\">new</span> ErrorWrappingGlideException(e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class=\"line\">            Log.v(TAG, <span class=\"string\">\"Exception decoding\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        exception = e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (resource != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            resource.recycle();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resource == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        onLoadFailed(exception);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        onLoadComplete(resource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">onLoadComplete</span><span class=\"params\">(Resource resource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// manager是一个EngineJob对象</span></span><br><span class=\"line\">    manager.onResourceReady(resource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"EngineJob\"><a href=\"#EngineJob\" class=\"headerlink\" title=\"EngineJob\"></a>EngineJob</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResourceReady</span><span class=\"params\">(<span class=\"keyword\">final</span> Resource&lt;?&gt; resource)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.resource = resource;</span><br><span class=\"line\">    <span class=\"comment\">// 这个handler最终会执行到handleResultOnMainThread方法</span></span><br><span class=\"line\">    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, <span class=\"keyword\">this</span>).sendToTarget();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handleResultOnMainThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isCancelled) &#123;</span><br><span class=\"line\">        resource.recycle();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cbs.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Received a resource without any callbacks to notify\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    engineResource = engineResourceFactory.build(resource, isCacheable);</span><br><span class=\"line\">    hasResource = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Hold on to resource for duration of request so we don't recycle it in the middle of notifying if it</span></span><br><span class=\"line\">    <span class=\"comment\">// synchronously released by one of the callbacks.</span></span><br><span class=\"line\">    engineResource.acquire();</span><br><span class=\"line\">    listener.onEngineJobComplete(key, engineResource);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ResourceCallback cb : cbs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isInIgnoredCallbacks(cb)) &#123;</span><br><span class=\"line\">            engineResource.acquire();</span><br><span class=\"line\">            cb.onResourceReady(engineResource);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Our request is complete, so we can release the resource.</span></span><br><span class=\"line\">    engineResource.release();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>就是简单的通知每个调用每个callback.onResourceReady, 后面的逻辑都很简单了</p>\n"},{"title":"Fresco源码解析","date":"2020-03-20T07:24:32.000Z","_content":"\n## 1. 介绍：\nfresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。\n* 支持加载网络，本地存储和资源图片；\n* 提供三级缓存（二级memory和一级internal storage）；\n* 支持JPEGs，PNGs，GIFs，WEBPs等，还支持Progressive JPEG，优秀的动画支持；\n* 图片圆角，scale，自定义背景，overlays等等；\n* 优秀的内存管理, 在安卓低版本中会将缓存保存至特殊区域, 而不是java heap, 从而避免oom；\n\n## 2. 主要组成部分\n\n![fresco基本结构](/images/fresco基本结构.jpg)\n* DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由ViewHolder负责。\n* DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。\n* DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。\n* DraweeHolder：统筹管理Hierarchy与DraweeController。\n* ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。\n* Producer/Consumer：Producer也有很多种，是完成具体工作的类. 它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。\n* IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。\n\n## 3. 发起图片请求的主要流程\n### 3.1 流程图\n![fresco发起请求的主要流程](/images/fresco发起请求的流程.jpg)\n\n### 3.2 源码分析\n\n#### 3.2.1 DraweeView\n我们常用的类是SimpleDraweeView, 继承关系如下\nSimpleDraweeView -> GenericDraweeView -> DraweeView -> ImageView\n**注意: 虽然上述的类都是继承于ImageView的, 但是使用时最好不要调用ImageView本身的任何属性和方法, 不然的话使用不了Fresco的功能**\n\n* DraweeView: 持有ViewHolder, ViewHolder管理DraweeController和DraweeHierarchy\n* GenericDraweeView: 解析xml属性, 创建DraweeHierarchy\n* SimpleDraweeView: 我们一般使用的类, 接受请求, 创建爱你DraweeController\n\n**SimpleDraweeView.setImageURI**\n```java\n/**\n* Displays an image given by the uri.\n*\n* @param uri uri of the image\n* @param callerContext caller context\n*/\npublic void setImageURI(Uri uri, @Nullable Object callerContext) {\nDraweeController controller =\n    mControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\nsetController(controller);\n}\n```\nmControllerBuilder在setUri方法中创建了ImageRequest, 在build的过程中构建好了请求, cache, 编码, 解码等流程. 最后setController启动请求流程\n\n#### 3.2.2 DraweeControllerBuilder.build\n\n在DraweeControllerBuilder.build方法中创建了DataSource. DataSource类似于Java里的Futures，代表数据的来源\n\n```\n-> AbstractDraweeControllerBuilder.build\n--> AbstractDraweeControllerBuilder.buildController\n----> PipelineDraweeControllerBuilder.obtainController // 创建controller并return\n-----> AbstractDraweeControllerBuilder.obtainDataSourceSupplier\n------> AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest // 创建了Supplier<DataSource<IMAGE>>, 调用supplier.get方法就会创建Data\nSource\n```\n\n#### 3.2.3 setController\n\n```\n-> DraweeView.setController\n--> DraweeHolder.setController\n----> DraweeController.setHierarchy\n----> DraweeHolder.attachController\n-----> AbstractDraweeController.onAttach\n------> AbstractDraweeController.submitRequest\n```\n\n```java\nprotected void submitRequest() {\n    ...\n    final T closeableImage = getCachedImage(); // DataSource还没有start,已经开始获取缓存了\n    if (closeableImage != null) {\n      ...\n      return;\n    }\n    ...\n    mDataSource = getDataSource(); // 获取DataSource\n    final String id = mId;\n    final boolean wasImmediate = mDataSource.hasResult();\n    // 注册并处理结果\n    final DataSubscriber<T> dataSubscriber =\n        new BaseDataSubscriber<T>() {\n          @Override\n          public void onNewResultImpl(DataSource<T> dataSource) {\n            boolean isFinished = dataSource.isFinished();\n            boolean hasMultipleResults = dataSource.hasMultipleResults();\n            float progress = dataSource.getProgress();\n            T image = dataSource.getResult();\n            if (image != null) {\n              onNewResultInternal(\n                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);\n            } else if (isFinished) {\n              onFailureInternal(id, dataSource, new NullPointerException(), /* isFinished */ true);\n            }\n          }\n\n          @Override\n          public void onFailureImpl(DataSource<T> dataSource) {\n            ...\n          }\n\n          @Override\n          public void onProgressUpdate(DataSource<T> dataSource) {\n            ...\n          }\n        };\n    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);\n}\n\n@Override\nprotected DataSource<CloseableReference<CloseableImage>> getDataSource() {\n    // 这里的mDataSouceSupplier是controller在创建时有构造方法传入\n    DataSource<CloseableReference<CloseableImage>> result = mDataSourceSupplier.get();\n    return result;\n}\n```\n\n还有一个问题, DataSource是什么时候启动的? 我们在DraweeController.build创建过程中发现创建了Supplier<DataSource<>>,  controller的getDataSource实际上就是从Supplier获取的DataSource\n\n\n```\n-------> PipelineDraweeControllerBuilder.getDataSourceForRequest\n--------> ImagePipeline.fetchDecodedImage // 在这个方法中创建了producerSequence\n---------> ImagePipeline.submitFetchRequest\n----------> CloseableProducerToDataSourceAdapter<T>.craete\n-----------> new CloseableProducerToDataSourceAdapter\n```\n**featchDecodeImage**\n```java\npublic DataSource<CloseableReference<CloseableImage>> fetchDecodedImage(\n      ImageRequest imageRequest,\n      Object callerContext,\n      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,\n      @Nullable RequestListener requestListener) {\n    try {\n      // 创建Producer序列\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext,\n          requestListener);\n    } catch (Exception exception) {\n      return DataSources.immediateFailedDataSource(exception);\n    }\n}\n```\n\n**CloseableProducerToDataSourceAdapter的构造方法**\n这个构造方法只是简单的调用父类的构造方法\n```java\nprotected AbstractProducerToDataSourceAdapter(\n      Producer<T> producer,\n      SettableProducerContext settableProducerContext,\n      RequestListener requestListener) {\n    \n    mSettableProducerContext = settableProducerContext;\n    mRequestListener = requestListener;\n\n    mRequestListener.onRequestStart(\n        settableProducerContext.getImageRequest(),\n        mSettableProducerContext.getCallerContext(),\n        mSettableProducerContext.getId(),\n        mSettableProducerContext.isPrefetch());\n    if (FrescoSystrace.isTracing()) {\n      FrescoSystrace.endSection();\n    }\n\n    // procuder序列启动\n    producer.produceResults(createConsumer(), settableProducerContext);\n}\n```\n**原来DataSource一创建就会启动produer的工作流程**\n\n## 3. Producer序列的工作流程\n### 3.1 Producer/Consumer的基本概念\n**模板代码**\n```java\npublic class XXXXProducer implements Producer{\n\n    private final Producer mInputProducer;\n\n    public BitmapMemoryCacheProducer(Producer inputProducer) {\n        mInputProducer = inputProducer;\n    }\n\n    @Override\n    public void produceResults(\n        final Consumer consumer,\n        final ProducerContext producerContext) {\n\n        ... 尝试直接得到结果\n        if(已经获取到结果){\n            consumer.onNewResult(result, status);\n            return ;\n        }\n\n        Consumer newConsumer = new DelegatingConsumer(consumer){\n            @Override\n            public void onNewResultImpl(newResult, int status) {\n                ... 处理上一阶段返回的结果\n                if(isLast){\n                    // 将自己处理完成的数据交给上一层producer\n                    // 这里的getConsumer是构造方法传入的consumer, 也就是上一层producer创建的DelegatingConsumer\n                    getConsumer().onNewResult();\n                }\n            }\n        }\n        // 进行下一阶段\n        mInputProducer.produceResults(newConsumer, producerContext);\n    }\n}\n```\n\n**Consumer的onNewResult方法**\nonNewResult会直接调用自己的onNewResultImpl方法\n```java\n@Override\npublic synchronized void onNewResult(@Nullable T newResult, @Status int status) {\n    if (mIsFinished) {\n      return;\n    }\n    mIsFinished = isLast(status);\n    try {\n      onNewResultImpl(newResult, status);\n    } catch (Exception e) {\n      onUnhandledException(e);\n    }\n}\n```\n\n按照这样类似责任链的设计模式, 实际上, 往后加入的producer越晚执行\n\n### 3.2 主要的producer内容梳理\n\n* BitmapMemoryCacheGetProducer\n从内存中获取已解码的图片, 因为是直接从内存中获取可以用的, 所以是即时的, 在UI线程中就可以做\n* BackgroundThreadHandoffProducer\n将任务移交给子线程, 这里仅仅是转移线程而已, 具体的工作在具体的线程中完成\n* BitmapMemoryCacheKeyMultiplexProducer\n将多个拥有相同已解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据\n* BitmapMemoryCacheProducer\n又一次获取内存缓存? 我觉得主要是将下一阶段获取的已解码图片存储到缓存中\n* DecodeProducer\n解码\n* ResizeAndRotateProducer\n旋转, 缩放\n* AddImageTransformMetaProducer\n添加MetaData\n* EncodeCacheKeyMutiplexProducer\n将多个拥有相同未解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据；\n* EncodedMemoryCacheProducer\n查找未解码的图片缓存, 将下一步得到的未解码图片保存到缓存中\n* DiskCacheReadProducer\n读磁盘缓存, 有分MainCache和SmallCache, SmallCache存储小图片, 避免大图片被挤出缓存. 启动task并扔进线程池\n* DiskCacheWriteProducer\n存入磁盘缓存, 同样是在线程池中操作\n* newNetworkFetchProducer\n从网络中获取图片\n\n","source":"_posts/Android/源码解析/Fresco源码解析.md","raw":"---\ntitle: Fresco源码解析\ndate: 2020-03-20 15:24:32\ntags: \n- Fresco\n- 源码解析\ncategories:\n- Android\n---\n\n## 1. 介绍：\nfresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。\n* 支持加载网络，本地存储和资源图片；\n* 提供三级缓存（二级memory和一级internal storage）；\n* 支持JPEGs，PNGs，GIFs，WEBPs等，还支持Progressive JPEG，优秀的动画支持；\n* 图片圆角，scale，自定义背景，overlays等等；\n* 优秀的内存管理, 在安卓低版本中会将缓存保存至特殊区域, 而不是java heap, 从而避免oom；\n\n## 2. 主要组成部分\n\n![fresco基本结构](/images/fresco基本结构.jpg)\n* DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由ViewHolder负责。\n* DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。\n* DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。\n* DraweeHolder：统筹管理Hierarchy与DraweeController。\n* ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。\n* Producer/Consumer：Producer也有很多种，是完成具体工作的类. 它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。\n* IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。\n\n## 3. 发起图片请求的主要流程\n### 3.1 流程图\n![fresco发起请求的主要流程](/images/fresco发起请求的流程.jpg)\n\n### 3.2 源码分析\n\n#### 3.2.1 DraweeView\n我们常用的类是SimpleDraweeView, 继承关系如下\nSimpleDraweeView -> GenericDraweeView -> DraweeView -> ImageView\n**注意: 虽然上述的类都是继承于ImageView的, 但是使用时最好不要调用ImageView本身的任何属性和方法, 不然的话使用不了Fresco的功能**\n\n* DraweeView: 持有ViewHolder, ViewHolder管理DraweeController和DraweeHierarchy\n* GenericDraweeView: 解析xml属性, 创建DraweeHierarchy\n* SimpleDraweeView: 我们一般使用的类, 接受请求, 创建爱你DraweeController\n\n**SimpleDraweeView.setImageURI**\n```java\n/**\n* Displays an image given by the uri.\n*\n* @param uri uri of the image\n* @param callerContext caller context\n*/\npublic void setImageURI(Uri uri, @Nullable Object callerContext) {\nDraweeController controller =\n    mControllerBuilder\n        .setCallerContext(callerContext)\n        .setUri(uri)\n        .setOldController(getController())\n        .build();\nsetController(controller);\n}\n```\nmControllerBuilder在setUri方法中创建了ImageRequest, 在build的过程中构建好了请求, cache, 编码, 解码等流程. 最后setController启动请求流程\n\n#### 3.2.2 DraweeControllerBuilder.build\n\n在DraweeControllerBuilder.build方法中创建了DataSource. DataSource类似于Java里的Futures，代表数据的来源\n\n```\n-> AbstractDraweeControllerBuilder.build\n--> AbstractDraweeControllerBuilder.buildController\n----> PipelineDraweeControllerBuilder.obtainController // 创建controller并return\n-----> AbstractDraweeControllerBuilder.obtainDataSourceSupplier\n------> AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest // 创建了Supplier<DataSource<IMAGE>>, 调用supplier.get方法就会创建Data\nSource\n```\n\n#### 3.2.3 setController\n\n```\n-> DraweeView.setController\n--> DraweeHolder.setController\n----> DraweeController.setHierarchy\n----> DraweeHolder.attachController\n-----> AbstractDraweeController.onAttach\n------> AbstractDraweeController.submitRequest\n```\n\n```java\nprotected void submitRequest() {\n    ...\n    final T closeableImage = getCachedImage(); // DataSource还没有start,已经开始获取缓存了\n    if (closeableImage != null) {\n      ...\n      return;\n    }\n    ...\n    mDataSource = getDataSource(); // 获取DataSource\n    final String id = mId;\n    final boolean wasImmediate = mDataSource.hasResult();\n    // 注册并处理结果\n    final DataSubscriber<T> dataSubscriber =\n        new BaseDataSubscriber<T>() {\n          @Override\n          public void onNewResultImpl(DataSource<T> dataSource) {\n            boolean isFinished = dataSource.isFinished();\n            boolean hasMultipleResults = dataSource.hasMultipleResults();\n            float progress = dataSource.getProgress();\n            T image = dataSource.getResult();\n            if (image != null) {\n              onNewResultInternal(\n                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);\n            } else if (isFinished) {\n              onFailureInternal(id, dataSource, new NullPointerException(), /* isFinished */ true);\n            }\n          }\n\n          @Override\n          public void onFailureImpl(DataSource<T> dataSource) {\n            ...\n          }\n\n          @Override\n          public void onProgressUpdate(DataSource<T> dataSource) {\n            ...\n          }\n        };\n    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);\n}\n\n@Override\nprotected DataSource<CloseableReference<CloseableImage>> getDataSource() {\n    // 这里的mDataSouceSupplier是controller在创建时有构造方法传入\n    DataSource<CloseableReference<CloseableImage>> result = mDataSourceSupplier.get();\n    return result;\n}\n```\n\n还有一个问题, DataSource是什么时候启动的? 我们在DraweeController.build创建过程中发现创建了Supplier<DataSource<>>,  controller的getDataSource实际上就是从Supplier获取的DataSource\n\n\n```\n-------> PipelineDraweeControllerBuilder.getDataSourceForRequest\n--------> ImagePipeline.fetchDecodedImage // 在这个方法中创建了producerSequence\n---------> ImagePipeline.submitFetchRequest\n----------> CloseableProducerToDataSourceAdapter<T>.craete\n-----------> new CloseableProducerToDataSourceAdapter\n```\n**featchDecodeImage**\n```java\npublic DataSource<CloseableReference<CloseableImage>> fetchDecodedImage(\n      ImageRequest imageRequest,\n      Object callerContext,\n      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,\n      @Nullable RequestListener requestListener) {\n    try {\n      // 创建Producer序列\n      Producer<CloseableReference<CloseableImage>> producerSequence =\n          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);\n      return submitFetchRequest(\n          producerSequence,\n          imageRequest,\n          lowestPermittedRequestLevelOnSubmit,\n          callerContext,\n          requestListener);\n    } catch (Exception exception) {\n      return DataSources.immediateFailedDataSource(exception);\n    }\n}\n```\n\n**CloseableProducerToDataSourceAdapter的构造方法**\n这个构造方法只是简单的调用父类的构造方法\n```java\nprotected AbstractProducerToDataSourceAdapter(\n      Producer<T> producer,\n      SettableProducerContext settableProducerContext,\n      RequestListener requestListener) {\n    \n    mSettableProducerContext = settableProducerContext;\n    mRequestListener = requestListener;\n\n    mRequestListener.onRequestStart(\n        settableProducerContext.getImageRequest(),\n        mSettableProducerContext.getCallerContext(),\n        mSettableProducerContext.getId(),\n        mSettableProducerContext.isPrefetch());\n    if (FrescoSystrace.isTracing()) {\n      FrescoSystrace.endSection();\n    }\n\n    // procuder序列启动\n    producer.produceResults(createConsumer(), settableProducerContext);\n}\n```\n**原来DataSource一创建就会启动produer的工作流程**\n\n## 3. Producer序列的工作流程\n### 3.1 Producer/Consumer的基本概念\n**模板代码**\n```java\npublic class XXXXProducer implements Producer{\n\n    private final Producer mInputProducer;\n\n    public BitmapMemoryCacheProducer(Producer inputProducer) {\n        mInputProducer = inputProducer;\n    }\n\n    @Override\n    public void produceResults(\n        final Consumer consumer,\n        final ProducerContext producerContext) {\n\n        ... 尝试直接得到结果\n        if(已经获取到结果){\n            consumer.onNewResult(result, status);\n            return ;\n        }\n\n        Consumer newConsumer = new DelegatingConsumer(consumer){\n            @Override\n            public void onNewResultImpl(newResult, int status) {\n                ... 处理上一阶段返回的结果\n                if(isLast){\n                    // 将自己处理完成的数据交给上一层producer\n                    // 这里的getConsumer是构造方法传入的consumer, 也就是上一层producer创建的DelegatingConsumer\n                    getConsumer().onNewResult();\n                }\n            }\n        }\n        // 进行下一阶段\n        mInputProducer.produceResults(newConsumer, producerContext);\n    }\n}\n```\n\n**Consumer的onNewResult方法**\nonNewResult会直接调用自己的onNewResultImpl方法\n```java\n@Override\npublic synchronized void onNewResult(@Nullable T newResult, @Status int status) {\n    if (mIsFinished) {\n      return;\n    }\n    mIsFinished = isLast(status);\n    try {\n      onNewResultImpl(newResult, status);\n    } catch (Exception e) {\n      onUnhandledException(e);\n    }\n}\n```\n\n按照这样类似责任链的设计模式, 实际上, 往后加入的producer越晚执行\n\n### 3.2 主要的producer内容梳理\n\n* BitmapMemoryCacheGetProducer\n从内存中获取已解码的图片, 因为是直接从内存中获取可以用的, 所以是即时的, 在UI线程中就可以做\n* BackgroundThreadHandoffProducer\n将任务移交给子线程, 这里仅仅是转移线程而已, 具体的工作在具体的线程中完成\n* BitmapMemoryCacheKeyMultiplexProducer\n将多个拥有相同已解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据\n* BitmapMemoryCacheProducer\n又一次获取内存缓存? 我觉得主要是将下一阶段获取的已解码图片存储到缓存中\n* DecodeProducer\n解码\n* ResizeAndRotateProducer\n旋转, 缩放\n* AddImageTransformMetaProducer\n添加MetaData\n* EncodeCacheKeyMutiplexProducer\n将多个拥有相同未解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据；\n* EncodedMemoryCacheProducer\n查找未解码的图片缓存, 将下一步得到的未解码图片保存到缓存中\n* DiskCacheReadProducer\n读磁盘缓存, 有分MainCache和SmallCache, SmallCache存储小图片, 避免大图片被挤出缓存. 启动task并扔进线程池\n* DiskCacheWriteProducer\n存入磁盘缓存, 同样是在线程池中操作\n* newNetworkFetchProducer\n从网络中获取图片\n\n","slug":"Android/源码解析/Fresco源码解析","published":1,"updated":"2022-02-26T11:18:53.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9t0063g0jedwnnwu2i","content":"<h2 id=\"1-介绍：\"><a href=\"#1-介绍：\" class=\"headerlink\" title=\"1. 介绍：\"></a>1. 介绍：</h2><p>fresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。</p><a id=\"more\"></a>\n<ul>\n<li>支持加载网络，本地存储和资源图片；</li>\n<li>提供三级缓存（二级memory和一级internal storage）；</li>\n<li>支持JPEGs，PNGs，GIFs，WEBPs等，还支持Progressive JPEG，优秀的动画支持；</li>\n<li>图片圆角，scale，自定义背景，overlays等等；</li>\n<li>优秀的内存管理, 在安卓低版本中会将缓存保存至特殊区域, 而不是java heap, 从而避免oom；</li>\n</ul>\n<h2 id=\"2-主要组成部分\"><a href=\"#2-主要组成部分\" class=\"headerlink\" title=\"2. 主要组成部分\"></a>2. 主要组成部分</h2><p><img src=\"/images/fresco基本结构.jpg\" alt=\"fresco基本结构\"></p>\n<ul>\n<li>DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由ViewHolder负责。</li>\n<li>DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。</li>\n<li>DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。</li>\n<li>DraweeHolder：统筹管理Hierarchy与DraweeController。</li>\n<li>ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。</li>\n<li>Producer/Consumer：Producer也有很多种，是完成具体工作的类. 它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。</li>\n<li>IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。</li>\n</ul>\n<h2 id=\"3-发起图片请求的主要流程\"><a href=\"#3-发起图片请求的主要流程\" class=\"headerlink\" title=\"3. 发起图片请求的主要流程\"></a>3. 发起图片请求的主要流程</h2><h3 id=\"3-1-流程图\"><a href=\"#3-1-流程图\" class=\"headerlink\" title=\"3.1 流程图\"></a>3.1 流程图</h3><p><img src=\"/images/fresco发起请求的流程.jpg\" alt=\"fresco发起请求的主要流程\"></p>\n<h3 id=\"3-2-源码分析\"><a href=\"#3-2-源码分析\" class=\"headerlink\" title=\"3.2 源码分析\"></a>3.2 源码分析</h3><h4 id=\"3-2-1-DraweeView\"><a href=\"#3-2-1-DraweeView\" class=\"headerlink\" title=\"3.2.1 DraweeView\"></a>3.2.1 DraweeView</h4><p>我们常用的类是SimpleDraweeView, 继承关系如下<br>SimpleDraweeView -&gt; GenericDraweeView -&gt; DraweeView -&gt; ImageView<br><strong>注意: 虽然上述的类都是继承于ImageView的, 但是使用时最好不要调用ImageView本身的任何属性和方法, 不然的话使用不了Fresco的功能</strong></p>\n<ul>\n<li>DraweeView: 持有ViewHolder, ViewHolder管理DraweeController和DraweeHierarchy</li>\n<li>GenericDraweeView: 解析xml属性, 创建DraweeHierarchy</li>\n<li>SimpleDraweeView: 我们一般使用的类, 接受请求, 创建爱你DraweeController</li>\n</ul>\n<p><strong>SimpleDraweeView.setImageURI</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Displays an image given by the uri.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> uri uri of the image</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> callerContext caller context</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageURI</span><span class=\"params\">(Uri uri, @Nullable Object callerContext)</span> </span>&#123;</span><br><span class=\"line\">DraweeController controller =</span><br><span class=\"line\">    mControllerBuilder</span><br><span class=\"line\">        .setCallerContext(callerContext)</span><br><span class=\"line\">        .setUri(uri)</span><br><span class=\"line\">        .setOldController(getController())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">setController(controller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mControllerBuilder在setUri方法中创建了ImageRequest, 在build的过程中构建好了请求, cache, 编码, 解码等流程. 最后setController启动请求流程</p>\n<h4 id=\"3-2-2-DraweeControllerBuilder-build\"><a href=\"#3-2-2-DraweeControllerBuilder-build\" class=\"headerlink\" title=\"3.2.2 DraweeControllerBuilder.build\"></a>3.2.2 DraweeControllerBuilder.build</h4><p>在DraweeControllerBuilder.build方法中创建了DataSource. DataSource类似于Java里的Futures，代表数据的来源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; AbstractDraweeControllerBuilder.build</span><br><span class=\"line\">--&gt; AbstractDraweeControllerBuilder.buildController</span><br><span class=\"line\">----&gt; PipelineDraweeControllerBuilder.obtainController // 创建controller并return</span><br><span class=\"line\">-----&gt; AbstractDraweeControllerBuilder.obtainDataSourceSupplier</span><br><span class=\"line\">------&gt; AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest // 创建了Supplier&lt;DataSource&lt;IMAGE&gt;&gt;, 调用supplier.get方法就会创建Data</span><br><span class=\"line\">Source</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-setController\"><a href=\"#3-2-3-setController\" class=\"headerlink\" title=\"3.2.3 setController\"></a>3.2.3 setController</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; DraweeView.setController</span><br><span class=\"line\">--&gt; DraweeHolder.setController</span><br><span class=\"line\">----&gt; DraweeController.setHierarchy</span><br><span class=\"line\">----&gt; DraweeHolder.attachController</span><br><span class=\"line\">-----&gt; AbstractDraweeController.onAttach</span><br><span class=\"line\">------&gt; AbstractDraweeController.submitRequest</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">submitRequest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T closeableImage = getCachedImage(); <span class=\"comment\">// DataSource还没有start,已经开始获取缓存了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closeableImage != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mDataSource = getDataSource(); <span class=\"comment\">// 获取DataSource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = mId;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> wasImmediate = mDataSource.hasResult();</span><br><span class=\"line\">    <span class=\"comment\">// 注册并处理结果</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> DataSubscriber&lt;T&gt; dataSubscriber =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> BaseDataSubscriber&lt;T&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResultImpl</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isFinished = dataSource.isFinished();</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> hasMultipleResults = dataSource.hasMultipleResults();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> progress = dataSource.getProgress();</span><br><span class=\"line\">            T image = dataSource.getResult();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (image != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              onNewResultInternal(</span><br><span class=\"line\">                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFinished) &#123;</span><br><span class=\"line\">              onFailureInternal(id, dataSource, <span class=\"keyword\">new</span> NullPointerException(), <span class=\"comment\">/* isFinished */</span> <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailureImpl</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDataSource() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的mDataSouceSupplier是controller在创建时有构造方法传入</span></span><br><span class=\"line\">    DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; result = mDataSourceSupplier.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个问题, DataSource是什么时候启动的? 我们在DraweeController.build创建过程中发现创建了Supplier&lt;DataSource&lt;&gt;&gt;,  controller的getDataSource实际上就是从Supplier获取的DataSource</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------&gt; PipelineDraweeControllerBuilder.getDataSourceForRequest</span><br><span class=\"line\">--------&gt; ImagePipeline.fetchDecodedImage // 在这个方法中创建了producerSequence</span><br><span class=\"line\">---------&gt; ImagePipeline.submitFetchRequest</span><br><span class=\"line\">----------&gt; CloseableProducerToDataSourceAdapter&lt;T&gt;.craete</span><br><span class=\"line\">-----------&gt; new CloseableProducerToDataSourceAdapter</span><br></pre></td></tr></table></figure>\n<p><strong>featchDecodeImage</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; fetchDecodedImage(</span><br><span class=\"line\">      ImageRequest imageRequest,</span><br><span class=\"line\">      Object callerContext,</span><br><span class=\"line\">      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,</span><br><span class=\"line\">      <span class=\"meta\">@Nullable</span> RequestListener requestListener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建Producer序列</span></span><br><span class=\"line\">      Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</span><br><span class=\"line\">          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> submitFetchRequest(</span><br><span class=\"line\">          producerSequence,</span><br><span class=\"line\">          imageRequest,</span><br><span class=\"line\">          lowestPermittedRequestLevelOnSubmit,</span><br><span class=\"line\">          callerContext,</span><br><span class=\"line\">          requestListener);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> DataSources.immediateFailedDataSource(exception);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>CloseableProducerToDataSourceAdapter的构造方法</strong><br>这个构造方法只是简单的调用父类的构造方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractProducerToDataSourceAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Producer&lt;T&gt; producer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      SettableProducerContext settableProducerContext,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      RequestListener requestListener)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mSettableProducerContext = settableProducerContext;</span><br><span class=\"line\">    mRequestListener = requestListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    mRequestListener.onRequestStart(</span><br><span class=\"line\">        settableProducerContext.getImageRequest(),</span><br><span class=\"line\">        mSettableProducerContext.getCallerContext(),</span><br><span class=\"line\">        mSettableProducerContext.getId(),</span><br><span class=\"line\">        mSettableProducerContext.isPrefetch());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class=\"line\">      FrescoSystrace.endSection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// procuder序列启动</span></span><br><span class=\"line\">    producer.produceResults(createConsumer(), settableProducerContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>原来DataSource一创建就会启动produer的工作流程</strong></p>\n<h2 id=\"3-Producer序列的工作流程\"><a href=\"#3-Producer序列的工作流程\" class=\"headerlink\" title=\"3. Producer序列的工作流程\"></a>3. Producer序列的工作流程</h2><h3 id=\"3-1-Producer-Consumer的基本概念\"><a href=\"#3-1-Producer-Consumer的基本概念\" class=\"headerlink\" title=\"3.1 Producer/Consumer的基本概念\"></a>3.1 Producer/Consumer的基本概念</h3><p><strong>模板代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXXProducer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Producer</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Producer mInputProducer;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BitmapMemoryCacheProducer</span><span class=\"params\">(Producer inputProducer)</span> </span>&#123;</span><br><span class=\"line\">        mInputProducer = inputProducer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produceResults</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">final</span> Consumer consumer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">final</span> ProducerContext producerContext)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... 尝试直接得到结果</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(已经获取到结果)&#123;</span><br><span class=\"line\">            consumer.onNewResult(result, status);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer newConsumer = <span class=\"keyword\">new</span> DelegatingConsumer(consumer)&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResultImpl</span><span class=\"params\">(newResult, <span class=\"keyword\">int</span> status)</span> </span>&#123;</span><br><span class=\"line\">                ... 处理上一阶段返回的结果</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isLast)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 将自己处理完成的数据交给上一层producer</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里的getConsumer是构造方法传入的consumer, 也就是上一层producer创建的DelegatingConsumer</span></span><br><span class=\"line\">                    getConsumer().onNewResult();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 进行下一阶段</span></span><br><span class=\"line\">        mInputProducer.produceResults(newConsumer, producerContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Consumer的onNewResult方法</strong><br>onNewResult会直接调用自己的onNewResultImpl方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResult</span><span class=\"params\">(@Nullable T newResult, @Status <span class=\"keyword\">int</span> status)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsFinished) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mIsFinished = isLast(status);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      onNewResultImpl(newResult, status);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      onUnhandledException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按照这样类似责任链的设计模式, 实际上, 往后加入的producer越晚执行</p>\n<h3 id=\"3-2-主要的producer内容梳理\"><a href=\"#3-2-主要的producer内容梳理\" class=\"headerlink\" title=\"3.2 主要的producer内容梳理\"></a>3.2 主要的producer内容梳理</h3><ul>\n<li>BitmapMemoryCacheGetProducer<br>从内存中获取已解码的图片, 因为是直接从内存中获取可以用的, 所以是即时的, 在UI线程中就可以做</li>\n<li>BackgroundThreadHandoffProducer<br>将任务移交给子线程, 这里仅仅是转移线程而已, 具体的工作在具体的线程中完成</li>\n<li>BitmapMemoryCacheKeyMultiplexProducer<br>将多个拥有相同已解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据</li>\n<li>BitmapMemoryCacheProducer<br>又一次获取内存缓存? 我觉得主要是将下一阶段获取的已解码图片存储到缓存中</li>\n<li>DecodeProducer<br>解码</li>\n<li>ResizeAndRotateProducer<br>旋转, 缩放</li>\n<li>AddImageTransformMetaProducer<br>添加MetaData</li>\n<li>EncodeCacheKeyMutiplexProducer<br>将多个拥有相同未解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据；</li>\n<li>EncodedMemoryCacheProducer<br>查找未解码的图片缓存, 将下一步得到的未解码图片保存到缓存中</li>\n<li>DiskCacheReadProducer<br>读磁盘缓存, 有分MainCache和SmallCache, SmallCache存储小图片, 避免大图片被挤出缓存. 启动task并扔进线程池</li>\n<li>DiskCacheWriteProducer<br>存入磁盘缓存, 同样是在线程池中操作</li>\n<li>newNetworkFetchProducer<br>从网络中获取图片</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-介绍：\"><a href=\"#1-介绍：\" class=\"headerlink\" title=\"1. 介绍：\"></a>1. 介绍：</h2><p>fresco，facebook开源的针对android应用的图片加载框架，高效和功能齐全。</p>","more":"\n<ul>\n<li>支持加载网络，本地存储和资源图片；</li>\n<li>提供三级缓存（二级memory和一级internal storage）；</li>\n<li>支持JPEGs，PNGs，GIFs，WEBPs等，还支持Progressive JPEG，优秀的动画支持；</li>\n<li>图片圆角，scale，自定义背景，overlays等等；</li>\n<li>优秀的内存管理, 在安卓低版本中会将缓存保存至特殊区域, 而不是java heap, 从而避免oom；</li>\n</ul>\n<h2 id=\"2-主要组成部分\"><a href=\"#2-主要组成部分\" class=\"headerlink\" title=\"2. 主要组成部分\"></a>2. 主要组成部分</h2><p><img src=\"/images/fresco基本结构.jpg\" alt=\"fresco基本结构\"></p>\n<ul>\n<li>DraweeView：继承于ImageView，只是简单的读取xml文件的一些属性值和做一些初始化的工作，图层管理交由Hierarchy负责，图层数据获取交由ViewHolder负责。</li>\n<li>DraweeHierarchy：由多层Drawable组成，每层Drawable提供某种功能（例如：缩放、圆角）。</li>\n<li>DraweeController：控制数据的获取与图片加载，向pipeline发出请求，并接收相应事件，并根据不同事件控制Hierarchy，从DraweeView接收用户的事件，然后执行取消网络请求、回收资源等操作。</li>\n<li>DraweeHolder：统筹管理Hierarchy与DraweeController。</li>\n<li>ImagePipeline：Fresco的核心模块，用来以各种方式（内存、磁盘、网络等）获取图像。</li>\n<li>Producer/Consumer：Producer也有很多种，是完成具体工作的类. 它用来完成网络数据获取，缓存数据获取、图片解码等多种工作，它产生的结果由Consumer进行消费。</li>\n<li>IO/Data：这一层便是数据层了，负责实现内存缓存、磁盘缓存、网络缓存和其他IO相关的功能。</li>\n</ul>\n<h2 id=\"3-发起图片请求的主要流程\"><a href=\"#3-发起图片请求的主要流程\" class=\"headerlink\" title=\"3. 发起图片请求的主要流程\"></a>3. 发起图片请求的主要流程</h2><h3 id=\"3-1-流程图\"><a href=\"#3-1-流程图\" class=\"headerlink\" title=\"3.1 流程图\"></a>3.1 流程图</h3><p><img src=\"/images/fresco发起请求的流程.jpg\" alt=\"fresco发起请求的主要流程\"></p>\n<h3 id=\"3-2-源码分析\"><a href=\"#3-2-源码分析\" class=\"headerlink\" title=\"3.2 源码分析\"></a>3.2 源码分析</h3><h4 id=\"3-2-1-DraweeView\"><a href=\"#3-2-1-DraweeView\" class=\"headerlink\" title=\"3.2.1 DraweeView\"></a>3.2.1 DraweeView</h4><p>我们常用的类是SimpleDraweeView, 继承关系如下<br>SimpleDraweeView -&gt; GenericDraweeView -&gt; DraweeView -&gt; ImageView<br><strong>注意: 虽然上述的类都是继承于ImageView的, 但是使用时最好不要调用ImageView本身的任何属性和方法, 不然的话使用不了Fresco的功能</strong></p>\n<ul>\n<li>DraweeView: 持有ViewHolder, ViewHolder管理DraweeController和DraweeHierarchy</li>\n<li>GenericDraweeView: 解析xml属性, 创建DraweeHierarchy</li>\n<li>SimpleDraweeView: 我们一般使用的类, 接受请求, 创建爱你DraweeController</li>\n</ul>\n<p><strong>SimpleDraweeView.setImageURI</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Displays an image given by the uri.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> uri uri of the image</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> callerContext caller context</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setImageURI</span><span class=\"params\">(Uri uri, @Nullable Object callerContext)</span> </span>&#123;</span><br><span class=\"line\">DraweeController controller =</span><br><span class=\"line\">    mControllerBuilder</span><br><span class=\"line\">        .setCallerContext(callerContext)</span><br><span class=\"line\">        .setUri(uri)</span><br><span class=\"line\">        .setOldController(getController())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\">setController(controller);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>mControllerBuilder在setUri方法中创建了ImageRequest, 在build的过程中构建好了请求, cache, 编码, 解码等流程. 最后setController启动请求流程</p>\n<h4 id=\"3-2-2-DraweeControllerBuilder-build\"><a href=\"#3-2-2-DraweeControllerBuilder-build\" class=\"headerlink\" title=\"3.2.2 DraweeControllerBuilder.build\"></a>3.2.2 DraweeControllerBuilder.build</h4><p>在DraweeControllerBuilder.build方法中创建了DataSource. DataSource类似于Java里的Futures，代表数据的来源</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; AbstractDraweeControllerBuilder.build</span><br><span class=\"line\">--&gt; AbstractDraweeControllerBuilder.buildController</span><br><span class=\"line\">----&gt; PipelineDraweeControllerBuilder.obtainController // 创建controller并return</span><br><span class=\"line\">-----&gt; AbstractDraweeControllerBuilder.obtainDataSourceSupplier</span><br><span class=\"line\">------&gt; AbstractDraweeControllerBuilder.getDataSourceSupplierForRequest // 创建了Supplier&lt;DataSource&lt;IMAGE&gt;&gt;, 调用supplier.get方法就会创建Data</span><br><span class=\"line\">Source</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-setController\"><a href=\"#3-2-3-setController\" class=\"headerlink\" title=\"3.2.3 setController\"></a>3.2.3 setController</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; DraweeView.setController</span><br><span class=\"line\">--&gt; DraweeHolder.setController</span><br><span class=\"line\">----&gt; DraweeController.setHierarchy</span><br><span class=\"line\">----&gt; DraweeHolder.attachController</span><br><span class=\"line\">-----&gt; AbstractDraweeController.onAttach</span><br><span class=\"line\">------&gt; AbstractDraweeController.submitRequest</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">submitRequest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">final</span> T closeableImage = getCachedImage(); <span class=\"comment\">// DataSource还没有start,已经开始获取缓存了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closeableImage != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    mDataSource = getDataSource(); <span class=\"comment\">// 获取DataSource</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String id = mId;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> wasImmediate = mDataSource.hasResult();</span><br><span class=\"line\">    <span class=\"comment\">// 注册并处理结果</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> DataSubscriber&lt;T&gt; dataSubscriber =</span><br><span class=\"line\">        <span class=\"keyword\">new</span> BaseDataSubscriber&lt;T&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResultImpl</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> isFinished = dataSource.isFinished();</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> hasMultipleResults = dataSource.hasMultipleResults();</span><br><span class=\"line\">            <span class=\"keyword\">float</span> progress = dataSource.getProgress();</span><br><span class=\"line\">            T image = dataSource.getResult();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (image != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              onNewResultInternal(</span><br><span class=\"line\">                  id, dataSource, image, progress, isFinished, wasImmediate, hasMultipleResults);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isFinished) &#123;</span><br><span class=\"line\">              onFailureInternal(id, dataSource, <span class=\"keyword\">new</span> NullPointerException(), <span class=\"comment\">/* isFinished */</span> <span class=\"keyword\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailureImpl</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onProgressUpdate</span><span class=\"params\">(DataSource&lt;T&gt; dataSource)</span> </span>&#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; getDataSource() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的mDataSouceSupplier是controller在创建时有构造方法传入</span></span><br><span class=\"line\">    DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; result = mDataSourceSupplier.get();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个问题, DataSource是什么时候启动的? 我们在DraweeController.build创建过程中发现创建了Supplier&lt;DataSource&lt;&gt;&gt;,  controller的getDataSource实际上就是从Supplier获取的DataSource</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------&gt; PipelineDraweeControllerBuilder.getDataSourceForRequest</span><br><span class=\"line\">--------&gt; ImagePipeline.fetchDecodedImage // 在这个方法中创建了producerSequence</span><br><span class=\"line\">---------&gt; ImagePipeline.submitFetchRequest</span><br><span class=\"line\">----------&gt; CloseableProducerToDataSourceAdapter&lt;T&gt;.craete</span><br><span class=\"line\">-----------&gt; new CloseableProducerToDataSourceAdapter</span><br></pre></td></tr></table></figure>\n<p><strong>featchDecodeImage</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; fetchDecodedImage(</span><br><span class=\"line\">      ImageRequest imageRequest,</span><br><span class=\"line\">      Object callerContext,</span><br><span class=\"line\">      ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,</span><br><span class=\"line\">      <span class=\"meta\">@Nullable</span> RequestListener requestListener) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 创建Producer序列</span></span><br><span class=\"line\">      Producer&lt;CloseableReference&lt;CloseableImage&gt;&gt; producerSequence =</span><br><span class=\"line\">          mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> submitFetchRequest(</span><br><span class=\"line\">          producerSequence,</span><br><span class=\"line\">          imageRequest,</span><br><span class=\"line\">          lowestPermittedRequestLevelOnSubmit,</span><br><span class=\"line\">          callerContext,</span><br><span class=\"line\">          requestListener);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception exception) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> DataSources.immediateFailedDataSource(exception);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>CloseableProducerToDataSourceAdapter的构造方法</strong><br>这个构造方法只是简单的调用父类的构造方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractProducerToDataSourceAdapter</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Producer&lt;T&gt; producer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      SettableProducerContext settableProducerContext,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      RequestListener requestListener)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    mSettableProducerContext = settableProducerContext;</span><br><span class=\"line\">    mRequestListener = requestListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    mRequestListener.onRequestStart(</span><br><span class=\"line\">        settableProducerContext.getImageRequest(),</span><br><span class=\"line\">        mSettableProducerContext.getCallerContext(),</span><br><span class=\"line\">        mSettableProducerContext.getId(),</span><br><span class=\"line\">        mSettableProducerContext.isPrefetch());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FrescoSystrace.isTracing()) &#123;</span><br><span class=\"line\">      FrescoSystrace.endSection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// procuder序列启动</span></span><br><span class=\"line\">    producer.produceResults(createConsumer(), settableProducerContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>原来DataSource一创建就会启动produer的工作流程</strong></p>\n<h2 id=\"3-Producer序列的工作流程\"><a href=\"#3-Producer序列的工作流程\" class=\"headerlink\" title=\"3. Producer序列的工作流程\"></a>3. Producer序列的工作流程</h2><h3 id=\"3-1-Producer-Consumer的基本概念\"><a href=\"#3-1-Producer-Consumer的基本概念\" class=\"headerlink\" title=\"3.1 Producer/Consumer的基本概念\"></a>3.1 Producer/Consumer的基本概念</h3><p><strong>模板代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XXXXProducer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Producer</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Producer mInputProducer;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BitmapMemoryCacheProducer</span><span class=\"params\">(Producer inputProducer)</span> </span>&#123;</span><br><span class=\"line\">        mInputProducer = inputProducer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">produceResults</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">final</span> Consumer consumer,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">final</span> ProducerContext producerContext)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... 尝试直接得到结果</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(已经获取到结果)&#123;</span><br><span class=\"line\">            consumer.onNewResult(result, status);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Consumer newConsumer = <span class=\"keyword\">new</span> DelegatingConsumer(consumer)&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResultImpl</span><span class=\"params\">(newResult, <span class=\"keyword\">int</span> status)</span> </span>&#123;</span><br><span class=\"line\">                ... 处理上一阶段返回的结果</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isLast)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 将自己处理完成的数据交给上一层producer</span></span><br><span class=\"line\">                    <span class=\"comment\">// 这里的getConsumer是构造方法传入的consumer, 也就是上一层producer创建的DelegatingConsumer</span></span><br><span class=\"line\">                    getConsumer().onNewResult();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 进行下一阶段</span></span><br><span class=\"line\">        mInputProducer.produceResults(newConsumer, producerContext);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Consumer的onNewResult方法</strong><br>onNewResult会直接调用自己的onNewResultImpl方法<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">onNewResult</span><span class=\"params\">(@Nullable T newResult, @Status <span class=\"keyword\">int</span> status)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mIsFinished) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mIsFinished = isLast(status);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      onNewResultImpl(newResult, status);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      onUnhandledException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>按照这样类似责任链的设计模式, 实际上, 往后加入的producer越晚执行</p>\n<h3 id=\"3-2-主要的producer内容梳理\"><a href=\"#3-2-主要的producer内容梳理\" class=\"headerlink\" title=\"3.2 主要的producer内容梳理\"></a>3.2 主要的producer内容梳理</h3><ul>\n<li>BitmapMemoryCacheGetProducer<br>从内存中获取已解码的图片, 因为是直接从内存中获取可以用的, 所以是即时的, 在UI线程中就可以做</li>\n<li>BackgroundThreadHandoffProducer<br>将任务移交给子线程, 这里仅仅是转移线程而已, 具体的工作在具体的线程中完成</li>\n<li>BitmapMemoryCacheKeyMultiplexProducer<br>将多个拥有相同已解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据</li>\n<li>BitmapMemoryCacheProducer<br>又一次获取内存缓存? 我觉得主要是将下一阶段获取的已解码图片存储到缓存中</li>\n<li>DecodeProducer<br>解码</li>\n<li>ResizeAndRotateProducer<br>旋转, 缩放</li>\n<li>AddImageTransformMetaProducer<br>添加MetaData</li>\n<li>EncodeCacheKeyMutiplexProducer<br>将多个拥有相同未解码内存缓存键的ImageRequest进行“合并”，若缓存命中，它们都会获取到该数据；</li>\n<li>EncodedMemoryCacheProducer<br>查找未解码的图片缓存, 将下一步得到的未解码图片保存到缓存中</li>\n<li>DiskCacheReadProducer<br>读磁盘缓存, 有分MainCache和SmallCache, SmallCache存储小图片, 避免大图片被挤出缓存. 启动task并扔进线程池</li>\n<li>DiskCacheWriteProducer<br>存入磁盘缓存, 同样是在线程池中操作</li>\n<li>newNetworkFetchProducer<br>从网络中获取图片</li>\n</ul>\n"},{"title":"OkHttp3源码-责任链的分析","date":"2019-11-14T07:52:46.000Z","_content":"\n# okhttp3源码-责任链的分析\n\nokhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程\n\n## getResponseWithInterceptorChain()\n\n```java\nResponse getResponseWithInterceptorChain() throws IOException {\n    // Build a full stack of interceptors.\n    List<Interceptor> interceptors = new ArrayList<>();\n    interceptors.addAll(client.interceptors());\n    interceptors.add(retryAndFollowUpInterceptor);\n    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n    interceptors.add(new CacheInterceptor(client.internalCache()));\n    interceptors.add(new ConnectInterceptor(client));\n    if (!forWebSocket) {\n      interceptors.addAll(client.networkInterceptors());\n    }\n    interceptors.add(new CallServerInterceptor(forWebSocket));\n\n    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n        originalRequest, this, eventListener, client.connectTimeoutMillis(),\n        client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n    Response response = chain.proceed(originalRequest);\n    if (retryAndFollowUpInterceptor.isCanceled()) {\n      closeQuietly(response);\n      throw new IOException(\"Canceled\");\n    }\n    return response;\n  }\n}\n```\n\n### 每个拦截器的简单说明:\n* 1. 用户拦截器：通过Builder的addInterceptor方法添加的拦截器。\n* 2. RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。\n* 3. BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。\n* 4. CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程\n* 5. ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。\n* 6. CallServerInterceptor：和服务器通信，完成Http请求。\n所以我们可以总结出网络请求的调用流程：\n\nChain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类\n\n### RealInterceptorChian\n\n```java\n@Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n}\n\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n    RealConnection connection) throws IOException {\n    if (index >= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    ... // 省略一些异常处理的代码\n\n    // Call the next interceptor in the chain.\n    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n        writeTimeout);\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n        throw new IllegalStateException(\"network interceptor \" + interceptor\n            + \" must call proceed() exactly once\");\n    }\n\n    // Confirm that the intercepted response isn't null.\n    if (response == null) {\n        throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n    }\n\n    if (response.body() == null) {\n        throw new IllegalStateException(\n            \"interceptor \" + interceptor + \" returned a response with no body\");\n    }\n\n    return response;\n}\n```\n\n### interceptor.intercept(chain)\n\n**伪代码**\n```java\n@Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Call call = realChain.call();\n\n    ... // 处理request\n\n    Response response;\n    try {\n        // 继续责任链的下一个结点\n        response = realChain.proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n    } catch (Exception e) {\n        ... //\n    }\n\n    ... // 处理response\n}\n```\n\n梳理一下这个责任链模式的流程: (' -> '表示调用关系)\n-> getResponseWithInterceptorChain()\n-> chain.process(request)\n-> interceptor.intercept(nextChain)\n-> chain.process(request)\n-> interceptor.intercept(nextChain)\n-> ... // 循环直至责任链最后一个结点\n\n\n\n\n","source":"_posts/Android/源码解析/OkHttp3源码-责任链的分析.md","raw":"---\ntitle: OkHttp3源码-责任链的分析\ndate: 2019-11-14 15:52:46\ntags:\n- okhttp3\n- 源码分析\ncategories:\n- Android\n---\n\n# okhttp3源码-责任链的分析\n\nokhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程\n\n## getResponseWithInterceptorChain()\n\n```java\nResponse getResponseWithInterceptorChain() throws IOException {\n    // Build a full stack of interceptors.\n    List<Interceptor> interceptors = new ArrayList<>();\n    interceptors.addAll(client.interceptors());\n    interceptors.add(retryAndFollowUpInterceptor);\n    interceptors.add(new BridgeInterceptor(client.cookieJar()));\n    interceptors.add(new CacheInterceptor(client.internalCache()));\n    interceptors.add(new ConnectInterceptor(client));\n    if (!forWebSocket) {\n      interceptors.addAll(client.networkInterceptors());\n    }\n    interceptors.add(new CallServerInterceptor(forWebSocket));\n\n    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,\n        originalRequest, this, eventListener, client.connectTimeoutMillis(),\n        client.readTimeoutMillis(), client.writeTimeoutMillis());\n\n    Response response = chain.proceed(originalRequest);\n    if (retryAndFollowUpInterceptor.isCanceled()) {\n      closeQuietly(response);\n      throw new IOException(\"Canceled\");\n    }\n    return response;\n  }\n}\n```\n\n### 每个拦截器的简单说明:\n* 1. 用户拦截器：通过Builder的addInterceptor方法添加的拦截器。\n* 2. RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。\n* 3. BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。\n* 4. CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程\n* 5. ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。\n* 6. CallServerInterceptor：和服务器通信，完成Http请求。\n所以我们可以总结出网络请求的调用流程：\n\nChain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类\n\n### RealInterceptorChian\n\n```java\n@Override public Response proceed(Request request) throws IOException {\n    return proceed(request, streamAllocation, httpCodec, connection);\n}\n\npublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,\n    RealConnection connection) throws IOException {\n    if (index >= interceptors.size()) throw new AssertionError();\n\n    calls++;\n\n    ... // 省略一些异常处理的代码\n\n    // Call the next interceptor in the chain.\n    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,\n        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,\n        writeTimeout);\n    Interceptor interceptor = interceptors.get(index);\n    Response response = interceptor.intercept(next);\n\n    // Confirm that the next interceptor made its required call to chain.proceed().\n    if (httpCodec != null && index + 1 < interceptors.size() && next.calls != 1) {\n        throw new IllegalStateException(\"network interceptor \" + interceptor\n            + \" must call proceed() exactly once\");\n    }\n\n    // Confirm that the intercepted response isn't null.\n    if (response == null) {\n        throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\");\n    }\n\n    if (response.body() == null) {\n        throw new IllegalStateException(\n            \"interceptor \" + interceptor + \" returned a response with no body\");\n    }\n\n    return response;\n}\n```\n\n### interceptor.intercept(chain)\n\n**伪代码**\n```java\n@Override public Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Call call = realChain.call();\n\n    ... // 处理request\n\n    Response response;\n    try {\n        // 继续责任链的下一个结点\n        response = realChain.proceed(request, streamAllocation, null, null);\n        releaseConnection = false;\n    } catch (Exception e) {\n        ... //\n    }\n\n    ... // 处理response\n}\n```\n\n梳理一下这个责任链模式的流程: (' -> '表示调用关系)\n-> getResponseWithInterceptorChain()\n-> chain.process(request)\n-> interceptor.intercept(nextChain)\n-> chain.process(request)\n-> interceptor.intercept(nextChain)\n-> ... // 循环直至责任链最后一个结点\n\n\n\n\n","slug":"Android/源码解析/OkHttp3源码-责任链的分析","published":1,"updated":"2021-10-03T01:57:41.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9u0065g0je2adafet9","content":"<h1 id=\"okhttp3源码-责任链的分析\"><a href=\"#okhttp3源码-责任链的分析\" class=\"headerlink\" title=\"okhttp3源码-责任链的分析\"></a>okhttp3源码-责任链的分析</h1><p>okhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程</p><a id=\"more\"></a>\n<h2 id=\"getResponseWithInterceptorChain\"><a href=\"#getResponseWithInterceptorChain\" class=\"headerlink\" title=\"getResponseWithInterceptorChain()\"></a>getResponseWithInterceptorChain()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Response <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Build a full stack of interceptors.</span></span><br><span class=\"line\">    List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    interceptors.addAll(client.interceptors());</span><br><span class=\"line\">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CacheInterceptor(client.internalCache()));</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> ConnectInterceptor(client));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!forWebSocket) &#123;</span><br><span class=\"line\">      interceptors.addAll(client.networkInterceptors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CallServerInterceptor(forWebSocket));</span><br><span class=\"line\"></span><br><span class=\"line\">    Interceptor.Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        originalRequest, <span class=\"keyword\">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class=\"line\">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = chain.proceed(originalRequest);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class=\"line\">      closeQuietly(response);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"每个拦截器的简单说明\"><a href=\"#每个拦截器的简单说明\" class=\"headerlink\" title=\"每个拦截器的简单说明:\"></a>每个拦截器的简单说明:</h3><ul>\n<li><ol>\n<li>用户拦截器：通过Builder的addInterceptor方法添加的拦截器。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>CallServerInterceptor：和服务器通信，完成Http请求。<br>所以我们可以总结出网络请求的调用流程：</li>\n</ol>\n</li>\n</ul>\n<p>Chain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类</p>\n<h3 id=\"RealInterceptorChian\"><a href=\"#RealInterceptorChian\" class=\"headerlink\" title=\"RealInterceptorChian\"></a>RealInterceptorChian</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    RealConnection connection)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= interceptors.size()) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\"></span><br><span class=\"line\">    calls++;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略一些异常处理的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call the next interceptor in the chain.</span></span><br><span class=\"line\">    RealInterceptorChain next = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class=\"line\">        connection, index + <span class=\"number\">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout);</span><br><span class=\"line\">    Interceptor interceptor = interceptors.get(index);</span><br><span class=\"line\">    Response response = interceptor.intercept(next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpCodec != <span class=\"keyword\">null</span> &amp;&amp; index + <span class=\"number\">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptor</span><br><span class=\"line\">            + <span class=\"string\">\" must call proceed() exactly once\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Confirm that the intercepted response isn't null.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.body() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">            <span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned a response with no body\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"interceptor-intercept-chain\"><a href=\"#interceptor-intercept-chain\" class=\"headerlink\" title=\"interceptor.intercept(chain)\"></a>interceptor.intercept(chain)</h3><p><strong>伪代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Call call = realChain.call();</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 处理request</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Response response;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 继续责任链的下一个结点</span></span><br><span class=\"line\">        response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ... <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 处理response</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>梳理一下这个责任链模式的流程: (‘ -&gt; ‘表示调用关系)<br>-&gt; getResponseWithInterceptorChain()<br>-&gt; chain.process(request)<br>-&gt; interceptor.intercept(nextChain)<br>-&gt; chain.process(request)<br>-&gt; interceptor.intercept(nextChain)<br>-&gt; … // 循环直至责任链最后一个结点</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"okhttp3源码-责任链的分析\"><a href=\"#okhttp3源码-责任链的分析\" class=\"headerlink\" title=\"okhttp3源码-责任链的分析\"></a>okhttp3源码-责任链的分析</h1><p>okhttp3中一个请求封装为一个call, 无论是一个同步的Realcall还是一个异步的AsyncCall, 最终都是辗转调用自己的getResponseWithInterceptorChain()方法, 开始请求的操作流程</p>","more":"\n<h2 id=\"getResponseWithInterceptorChain\"><a href=\"#getResponseWithInterceptorChain\" class=\"headerlink\" title=\"getResponseWithInterceptorChain()\"></a>getResponseWithInterceptorChain()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Response <span class=\"title\">getResponseWithInterceptorChain</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Build a full stack of interceptors.</span></span><br><span class=\"line\">    List&lt;Interceptor&gt; interceptors = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    interceptors.addAll(client.interceptors());</span><br><span class=\"line\">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CacheInterceptor(client.internalCache()));</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> ConnectInterceptor(client));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!forWebSocket) &#123;</span><br><span class=\"line\">      interceptors.addAll(client.networkInterceptors());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    interceptors.add(<span class=\"keyword\">new</span> CallServerInterceptor(forWebSocket));</span><br><span class=\"line\"></span><br><span class=\"line\">    Interceptor.Chain chain = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">        originalRequest, <span class=\"keyword\">this</span>, eventListener, client.connectTimeoutMillis(),</span><br><span class=\"line\">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class=\"line\"></span><br><span class=\"line\">    Response response = chain.proceed(originalRequest);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class=\"line\">      closeQuietly(response);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"每个拦截器的简单说明\"><a href=\"#每个拦截器的简单说明\" class=\"headerlink\" title=\"每个拦截器的简单说明:\"></a>每个拦截器的简单说明:</h3><ul>\n<li><ol>\n<li>用户拦截器：通过Builder的addInterceptor方法添加的拦截器。</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>RetryAndFollowUpInterceptor：负责失败自动重连和必要的重定向。</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>BridgeInterceptor：负责将用户的Request转换成一个实际的网络请求Request，再调用下一个拦截器获取Response，然后将Response转换成用户的Response。</li>\n</ol>\n</li>\n<li><ol start=\"4\">\n<li>CacheInterceptor：负责控制缓存，缓存的逻辑就在这里面。如果发现有缓存的话, 就直接返回response了, 不会进行后面的流程</li>\n</ol>\n</li>\n<li><ol start=\"5\">\n<li>ConnectInterceptor：负责进行连接主机，在这里会完成socket连接，并将连接返回。</li>\n</ol>\n</li>\n<li><ol start=\"6\">\n<li>CallServerInterceptor：和服务器通信，完成Http请求。<br>所以我们可以总结出网络请求的调用流程：</li>\n</ol>\n</li>\n</ul>\n<p>Chain是Interceptor声明在Interceptor内部的一个接口. RealInterceptorChian实现了Chain接口, 来看看这个类</p>\n<h3 id=\"RealInterceptorChian\"><a href=\"#RealInterceptorChian\" class=\"headerlink\" title=\"RealInterceptorChian\"></a>RealInterceptorChian</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">proceed</span><span class=\"params\">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    RealConnection connection)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt;= interceptors.size()) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError();</span><br><span class=\"line\"></span><br><span class=\"line\">    calls++;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略一些异常处理的代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Call the next interceptor in the chain.</span></span><br><span class=\"line\">    RealInterceptorChain next = <span class=\"keyword\">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class=\"line\">        connection, index + <span class=\"number\">1</span>, request, call, eventListener, connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout);</span><br><span class=\"line\">    Interceptor interceptor = interceptors.get(index);</span><br><span class=\"line\">    Response response = interceptor.intercept(next);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Confirm that the next interceptor made its required call to chain.proceed().</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (httpCodec != <span class=\"keyword\">null</span> &amp;&amp; index + <span class=\"number\">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"network interceptor \"</span> + interceptor</span><br><span class=\"line\">            + <span class=\"string\">\" must call proceed() exactly once\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Confirm that the intercepted response isn't null.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned null\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response.body() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">            <span class=\"string\">\"interceptor \"</span> + interceptor + <span class=\"string\">\" returned a response with no body\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"interceptor-intercept-chain\"><a href=\"#interceptor-intercept-chain\" class=\"headerlink\" title=\"interceptor.intercept(chain)\"></a>interceptor.intercept(chain)</h3><p><strong>伪代码</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Call call = realChain.call();</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 处理request</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Response response;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 继续责任链的下一个结点</span></span><br><span class=\"line\">        response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        ... <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 处理response</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>梳理一下这个责任链模式的流程: (‘ -&gt; ‘表示调用关系)<br>-&gt; getResponseWithInterceptorChain()<br>-&gt; chain.process(request)<br>-&gt; interceptor.intercept(nextChain)<br>-&gt; chain.process(request)<br>-&gt; interceptor.intercept(nextChain)<br>-&gt; … // 循环直至责任链最后一个结点</p>\n"},{"title":"Retrofit源码解析","date":"2022-06-12T10:21:16.000Z","_content":"\n```java\npublic interface RetrofitService {\n    @GET(\"query\")\n    Observable<PostInfo> getPostInfoRx(@Query(\"type\") String type, @Query(\"postid\") String postid);\n}\n\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"http://www.kuaidi100.com/\")\n        .addConverterFactory(GsonConverterFactory.create())\n        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 支持RxJava\n        .build();\n        \nRetrofitService service = retrofit.create(XxxInterface.class);\nCall<PostInfo> call = service.getPostInfo(\"yuantong\", \"11111111111\");\ncall.enqueue(new Callback<PostInfo>() {\n    @Override\n    public void onResponse(Call<PostInfo> call, Response<PostInfo> response) {\n        Log.i(\"http返回：\", response.body().toString() + \"\");\n    }\n\n    @Override\n    public void onFailure(Call<PostInfo> call, Throwable t) {\n\n    }\n});\n```\n\n上面是 Retrofit 的主要用法，主要重要的东西有 ConverterFactory , CallAdapterFactory , retrofit.create(XxxInterface.class) 三个东西\n\n## Retrofit.Builder()\n\nbuilder就是一个常见的建造者模式，没什么好说的。 有一个点需要注意一下\n```java\n   public Retrofit build() {\n      okhttp3.Call.Factory callFactory = this.callFactory;\n      if (callFactory == null) {\n        callFactory = new OkHttpClient();\n      }\n\n      Executor callbackExecutor = this.callbackExecutor;\n      if (callbackExecutor == null) {\n          // 默认callback回调是执行在主线程的\n        callbackExecutor = platform.defaultCallbackExecutor();\n      }\n\n      List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);\n      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));\n\n      List<Converter.Factory> converterFactories = new ArrayList<>(\n          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());\n\n      // Add the built-in converter factory first. This prevents overriding its behavior but also\n      // ensures correct behavior when using converters that consume all types.\n      converterFactories.add(new BuiltInConverters());\n      converterFactories.addAll(this.converterFactories);\n      converterFactories.addAll(platform.defaultConverterFactories());\n\n      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),\n          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);\n    }\n```\n\n```java\nfinal class BuiltInConverters extends Converter.Factory {\n    @Override\n    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,\n        Retrofit retrofit) {\n    if (type == ResponseBody.class) {\n        return Utils.isAnnotationPresent(annotations, Streaming.class)\n            ? StreamingResponseBodyConverter.INSTANCE\n            : BufferingResponseBodyConverter.INSTANCE;\n    }\n    if (type == Void.class) {\n        return VoidResponseBodyConverter.INSTANCE;\n    }\n    return null;\n    }\n\n    ...\n}\n```\n这里首先插入了一个 BuiltInConverters 内置的转换器。 当返回类型是 ResponseBody 的时候就会使用 BuiltInConverters ，返回 ResponseBody 就和 okhttp 的返回一致了。\n\n## retrofit.create(XxxInterface.class)\n\n```java\n  public <T> T create(final Class<T> service) {\n    ...\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n          private final Object[] emptyArgs = new Object[0];\n\n          @Override public @Nullable Object invoke(Object proxy, Method method,\n              @Nullable Object[] args) throws Throwable {\n            ...\n            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n          }\n        });\n  }\n```\n\n这里使用了动态代理，create方法返回的接口对象是一个动态代理的实例\n\n## loadServiceMethod\n\n```java\n  ServiceMethod<?> loadServiceMethod(Method method) {\n    ServiceMethod<?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        result = ServiceMethod.parseAnnotations(this, method);\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n```\n\n缓存 + 解析Method\n\n## ServiceMethod.parseAnnotations\n\n```java\nabstract class ServiceMethod<T> {\n  static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {\n    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n    ...\n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract @Nullable T invoke(Object[] args);\n}\n```\n\n在抽象父类里先调用了 `RequestFactory.parseAnnotations(retrofit, method);` 去解析方法参数的注解。\n`HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);` 里解析了返回类型，并匹配 CallAdapter 和 Converter\n。。。抽象父类的静态方法区调用了子类的静态方法。。。有些迷惑\n\n## HttpServiceMethod.parseAnnotations\n\nRequestFactory.parseAnnotations 都是一些注解的处理，不说了\n\n```java\nstatic <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(\n      Retrofit retrofit, Method method, RequestFactory requestFactory) {\n    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;\n    boolean continuationWantsResponse = false;\n    boolean continuationBodyNullable = false;\n\n    Annotation[] annotations = method.getAnnotations();\n    Type adapterType;\n    if (isKotlinSuspendFunction) {\n    // 是协程suspend方法调用\n    // kotli的suspend方法转成java之后会在方法参数上生成一个Continuation类型的参数\n      Type[] parameterTypes = method.getGenericParameterTypes(); // 获取方法的所有参数类型\n      Type responseType = Utils.getParameterLowerBound(0,\n          (ParameterizedType) parameterTypes[parameterTypes.length - 1]); // 获取最后一个 Continuation 类型参数的泛型\n      if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) {\n        // Unwrap the actual body type from Response<T>.\n        // 获取 Response<T> 中泛型T的类型\n        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);\n        continuationWantsResponse = true;\n      } else {\n      }\n\n    // 这里把suspend方法的返回类型的 AdapterType 当做 Call<T> 来处理了\n      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);\n      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);\n    } else {\n    // 如果是非suspend方法，那直接取返回类型就可以了\n      adapterType = method.getGenericReturnType();\n    }\n\n    // 寻找合适的 CallAdapterFactory 生产 CallAdapter\n    CallAdapter<ResponseT, ReturnT> callAdapter =\n        createCallAdapter(retrofit, method, adapterType, annotations);\n    Type responseType = callAdapter.responseType();\n    ...\n\n    // 寻找合适的 ConverterFactory 生产 Converter\n    Converter<ResponseBody, ResponseT> responseConverter =\n        createResponseConverter(retrofit, method, responseType);\n\n    // CallFactory 实质上就是 OkHttpClient\n    okhttp3.Call.Factory callFactory = retrofit.callFactory; \n\n    // 下面是返回 HttpServiceMethod 的子类，这三个子类其实就是 CallAdapted wrap 了一层。 SuspendForResponse 和 SuspendForBody 调用了协程的 await 方法去等待协程的完成（其实就是加了个Continuation的回调）\n    if (!isKotlinSuspendFunction) {\n      return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);\n    } else if (continuationWantsResponse) {\n      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.\n      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory,\n          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter);\n    } else {\n      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.\n      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory,\n          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter,\n          continuationBodyNullable);\n    }\n  }\n```\n\n## ServiceMethod.invode\n\n```java\n/**\nHttpServiceMethod\n**/\n  @Override final @Nullable ReturnT invoke(Object[] args) {\n    Call<ResponseT> call = new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);\n    return adapt(call, args);\n  }\n\n  protected abstract @Nullable ReturnT adapt(Call<ResponseT> call, Object[] args);\n```\n\nOkHttpCall 实现了 Retrofit 的 call 到 OkHttpCall 的转换\nadapt 最终会调用 CallAdapter 的 adapt\n\n```java\n @Override \n public void enqueue(final Callback<T> callback) {\n    okhttp3.Call call;\n    Throwable failure;\n\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already executed.\");\n      executed = true;\n\n      call = rawCall;\n      failure = creationFailure;\n      if (call == null && failure == null) {\n          // 懒加载 rawCall\n          // 传入真实请求参数，构建真正发起请求的 okhttp 的 Call 对象\n          call = rawCall = createRawCall();\n      }\n    }\n    ...\n\n    call.enqueue(new okhttp3.Callback() {\n      @Override \n      public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {\n        Response<T> response;\n        // 调用 Converter 解析返回类型\n        response = parseResponse(rawResponse);\n        callback.onResponse(OkHttpCall.this, response);\n      }\n\n      @Override public void onFailure(okhttp3.Call call, IOException e) {\n        callback.onFailure(OkHttpCall.this, e);\n      }\n    });\n  }\n```\n\n\n可以看一下默认的 DefaultCallAdapterFactory 是怎么实现的\n```java\n/**\nDefaultCallAdapterFactory\n**/\n  @Override public @Nullable CallAdapter<?, ?> get(\n      Type returnType, Annotation[] annotations, Retrofit retrofit) {\n    if (getRawType(returnType) != Call.class) {\n      return null;\n    }\n    ...\n    // 获取 Call<T> 的具体类型\n    final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);\n\n    // 是否有 SkipCallbackExecutor 这个注解，一般是没有的\n    final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)\n        ? null\n        : callbackExecutor;\n\n    return new CallAdapter<Object, Call<?>>() {\n      @Override public Type responseType() {\n        return responseType;\n      }\n\n      @Override public Call<Object> adapt(Call<Object> call) {\n        return executor == null\n            ? call\n            : new ExecutorCallbackCall<>(executor, call);\n      }\n    };\n  }\n```\n\n```java\n  static final class ExecutorCallbackCall<T> implements Call<T> {\n    final Executor callbackExecutor;\n    final Call<T> delegate;\n\n    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {\n      this.callbackExecutor = callbackExecutor;\n      this.delegate = delegate;\n    }\n\n    @Override public void enqueue(final Callback<T> callback) {\n      delegate.enqueue(new Callback<T>() {\n        @Override public void onResponse(Call<T> call, final Response<T> response) {\n          callbackExecutor.execute(new Runnable() {\n            ...\n          });\n        }\n\n        @Override public void onFailure(Call<T> call, final Throwable t) {\n          callbackExecutor.execute(new Runnable() {\n            ...\n          });\n        }\n      });\n    }\n\n    @Override public Response<T> execute() throws IOException {\n      return delegate.execute();\n    }\n```\n\nenqueue 里的返回 onResponse 和 onFailure 都是在 callbackExecutor\ncallbackExecutor 也是在 retrofit 构建时传入的， 默认是 `Android.MainThreadExecutor` 也就是说默认 enqueue 的 callback 默认是执行在主线程的\n\n\n\n\n\n","source":"_posts/Android/源码解析/Retrofit源码解析.md","raw":"---\ntitle: Retrofit源码解析\ndate: 2022-06-12 18:21:16\ntags:\n---\n\n```java\npublic interface RetrofitService {\n    @GET(\"query\")\n    Observable<PostInfo> getPostInfoRx(@Query(\"type\") String type, @Query(\"postid\") String postid);\n}\n\nRetrofit retrofit = new Retrofit.Builder()\n        .baseUrl(\"http://www.kuaidi100.com/\")\n        .addConverterFactory(GsonConverterFactory.create())\n        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 支持RxJava\n        .build();\n        \nRetrofitService service = retrofit.create(XxxInterface.class);\nCall<PostInfo> call = service.getPostInfo(\"yuantong\", \"11111111111\");\ncall.enqueue(new Callback<PostInfo>() {\n    @Override\n    public void onResponse(Call<PostInfo> call, Response<PostInfo> response) {\n        Log.i(\"http返回：\", response.body().toString() + \"\");\n    }\n\n    @Override\n    public void onFailure(Call<PostInfo> call, Throwable t) {\n\n    }\n});\n```\n\n上面是 Retrofit 的主要用法，主要重要的东西有 ConverterFactory , CallAdapterFactory , retrofit.create(XxxInterface.class) 三个东西\n\n## Retrofit.Builder()\n\nbuilder就是一个常见的建造者模式，没什么好说的。 有一个点需要注意一下\n```java\n   public Retrofit build() {\n      okhttp3.Call.Factory callFactory = this.callFactory;\n      if (callFactory == null) {\n        callFactory = new OkHttpClient();\n      }\n\n      Executor callbackExecutor = this.callbackExecutor;\n      if (callbackExecutor == null) {\n          // 默认callback回调是执行在主线程的\n        callbackExecutor = platform.defaultCallbackExecutor();\n      }\n\n      List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);\n      callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));\n\n      List<Converter.Factory> converterFactories = new ArrayList<>(\n          1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());\n\n      // Add the built-in converter factory first. This prevents overriding its behavior but also\n      // ensures correct behavior when using converters that consume all types.\n      converterFactories.add(new BuiltInConverters());\n      converterFactories.addAll(this.converterFactories);\n      converterFactories.addAll(platform.defaultConverterFactories());\n\n      return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),\n          unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);\n    }\n```\n\n```java\nfinal class BuiltInConverters extends Converter.Factory {\n    @Override\n    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,\n        Retrofit retrofit) {\n    if (type == ResponseBody.class) {\n        return Utils.isAnnotationPresent(annotations, Streaming.class)\n            ? StreamingResponseBodyConverter.INSTANCE\n            : BufferingResponseBodyConverter.INSTANCE;\n    }\n    if (type == Void.class) {\n        return VoidResponseBodyConverter.INSTANCE;\n    }\n    return null;\n    }\n\n    ...\n}\n```\n这里首先插入了一个 BuiltInConverters 内置的转换器。 当返回类型是 ResponseBody 的时候就会使用 BuiltInConverters ，返回 ResponseBody 就和 okhttp 的返回一致了。\n\n## retrofit.create(XxxInterface.class)\n\n```java\n  public <T> T create(final Class<T> service) {\n    ...\n    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n        new InvocationHandler() {\n          private final Platform platform = Platform.get();\n          private final Object[] emptyArgs = new Object[0];\n\n          @Override public @Nullable Object invoke(Object proxy, Method method,\n              @Nullable Object[] args) throws Throwable {\n            ...\n            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);\n          }\n        });\n  }\n```\n\n这里使用了动态代理，create方法返回的接口对象是一个动态代理的实例\n\n## loadServiceMethod\n\n```java\n  ServiceMethod<?> loadServiceMethod(Method method) {\n    ServiceMethod<?> result = serviceMethodCache.get(method);\n    if (result != null) return result;\n\n    synchronized (serviceMethodCache) {\n      result = serviceMethodCache.get(method);\n      if (result == null) {\n        result = ServiceMethod.parseAnnotations(this, method);\n        serviceMethodCache.put(method, result);\n      }\n    }\n    return result;\n  }\n```\n\n缓存 + 解析Method\n\n## ServiceMethod.parseAnnotations\n\n```java\nabstract class ServiceMethod<T> {\n  static <T> ServiceMethod<T> parseAnnotations(Retrofit retrofit, Method method) {\n    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);\n    ...\n    return HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);\n  }\n\n  abstract @Nullable T invoke(Object[] args);\n}\n```\n\n在抽象父类里先调用了 `RequestFactory.parseAnnotations(retrofit, method);` 去解析方法参数的注解。\n`HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);` 里解析了返回类型，并匹配 CallAdapter 和 Converter\n。。。抽象父类的静态方法区调用了子类的静态方法。。。有些迷惑\n\n## HttpServiceMethod.parseAnnotations\n\nRequestFactory.parseAnnotations 都是一些注解的处理，不说了\n\n```java\nstatic <ResponseT, ReturnT> HttpServiceMethod<ResponseT, ReturnT> parseAnnotations(\n      Retrofit retrofit, Method method, RequestFactory requestFactory) {\n    boolean isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;\n    boolean continuationWantsResponse = false;\n    boolean continuationBodyNullable = false;\n\n    Annotation[] annotations = method.getAnnotations();\n    Type adapterType;\n    if (isKotlinSuspendFunction) {\n    // 是协程suspend方法调用\n    // kotli的suspend方法转成java之后会在方法参数上生成一个Continuation类型的参数\n      Type[] parameterTypes = method.getGenericParameterTypes(); // 获取方法的所有参数类型\n      Type responseType = Utils.getParameterLowerBound(0,\n          (ParameterizedType) parameterTypes[parameterTypes.length - 1]); // 获取最后一个 Continuation 类型参数的泛型\n      if (getRawType(responseType) == Response.class && responseType instanceof ParameterizedType) {\n        // Unwrap the actual body type from Response<T>.\n        // 获取 Response<T> 中泛型T的类型\n        responseType = Utils.getParameterUpperBound(0, (ParameterizedType) responseType);\n        continuationWantsResponse = true;\n      } else {\n      }\n\n    // 这里把suspend方法的返回类型的 AdapterType 当做 Call<T> 来处理了\n      adapterType = new Utils.ParameterizedTypeImpl(null, Call.class, responseType);\n      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);\n    } else {\n    // 如果是非suspend方法，那直接取返回类型就可以了\n      adapterType = method.getGenericReturnType();\n    }\n\n    // 寻找合适的 CallAdapterFactory 生产 CallAdapter\n    CallAdapter<ResponseT, ReturnT> callAdapter =\n        createCallAdapter(retrofit, method, adapterType, annotations);\n    Type responseType = callAdapter.responseType();\n    ...\n\n    // 寻找合适的 ConverterFactory 生产 Converter\n    Converter<ResponseBody, ResponseT> responseConverter =\n        createResponseConverter(retrofit, method, responseType);\n\n    // CallFactory 实质上就是 OkHttpClient\n    okhttp3.Call.Factory callFactory = retrofit.callFactory; \n\n    // 下面是返回 HttpServiceMethod 的子类，这三个子类其实就是 CallAdapted wrap 了一层。 SuspendForResponse 和 SuspendForBody 调用了协程的 await 方法去等待协程的完成（其实就是加了个Continuation的回调）\n    if (!isKotlinSuspendFunction) {\n      return new CallAdapted<>(requestFactory, callFactory, responseConverter, callAdapter);\n    } else if (continuationWantsResponse) {\n      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.\n      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForResponse<>(requestFactory,\n          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter);\n    } else {\n      //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.\n      return (HttpServiceMethod<ResponseT, ReturnT>) new SuspendForBody<>(requestFactory,\n          callFactory, responseConverter, (CallAdapter<ResponseT, Call<ResponseT>>) callAdapter,\n          continuationBodyNullable);\n    }\n  }\n```\n\n## ServiceMethod.invode\n\n```java\n/**\nHttpServiceMethod\n**/\n  @Override final @Nullable ReturnT invoke(Object[] args) {\n    Call<ResponseT> call = new OkHttpCall<>(requestFactory, args, callFactory, responseConverter);\n    return adapt(call, args);\n  }\n\n  protected abstract @Nullable ReturnT adapt(Call<ResponseT> call, Object[] args);\n```\n\nOkHttpCall 实现了 Retrofit 的 call 到 OkHttpCall 的转换\nadapt 最终会调用 CallAdapter 的 adapt\n\n```java\n @Override \n public void enqueue(final Callback<T> callback) {\n    okhttp3.Call call;\n    Throwable failure;\n\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already executed.\");\n      executed = true;\n\n      call = rawCall;\n      failure = creationFailure;\n      if (call == null && failure == null) {\n          // 懒加载 rawCall\n          // 传入真实请求参数，构建真正发起请求的 okhttp 的 Call 对象\n          call = rawCall = createRawCall();\n      }\n    }\n    ...\n\n    call.enqueue(new okhttp3.Callback() {\n      @Override \n      public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) {\n        Response<T> response;\n        // 调用 Converter 解析返回类型\n        response = parseResponse(rawResponse);\n        callback.onResponse(OkHttpCall.this, response);\n      }\n\n      @Override public void onFailure(okhttp3.Call call, IOException e) {\n        callback.onFailure(OkHttpCall.this, e);\n      }\n    });\n  }\n```\n\n\n可以看一下默认的 DefaultCallAdapterFactory 是怎么实现的\n```java\n/**\nDefaultCallAdapterFactory\n**/\n  @Override public @Nullable CallAdapter<?, ?> get(\n      Type returnType, Annotation[] annotations, Retrofit retrofit) {\n    if (getRawType(returnType) != Call.class) {\n      return null;\n    }\n    ...\n    // 获取 Call<T> 的具体类型\n    final Type responseType = Utils.getParameterUpperBound(0, (ParameterizedType) returnType);\n\n    // 是否有 SkipCallbackExecutor 这个注解，一般是没有的\n    final Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)\n        ? null\n        : callbackExecutor;\n\n    return new CallAdapter<Object, Call<?>>() {\n      @Override public Type responseType() {\n        return responseType;\n      }\n\n      @Override public Call<Object> adapt(Call<Object> call) {\n        return executor == null\n            ? call\n            : new ExecutorCallbackCall<>(executor, call);\n      }\n    };\n  }\n```\n\n```java\n  static final class ExecutorCallbackCall<T> implements Call<T> {\n    final Executor callbackExecutor;\n    final Call<T> delegate;\n\n    ExecutorCallbackCall(Executor callbackExecutor, Call<T> delegate) {\n      this.callbackExecutor = callbackExecutor;\n      this.delegate = delegate;\n    }\n\n    @Override public void enqueue(final Callback<T> callback) {\n      delegate.enqueue(new Callback<T>() {\n        @Override public void onResponse(Call<T> call, final Response<T> response) {\n          callbackExecutor.execute(new Runnable() {\n            ...\n          });\n        }\n\n        @Override public void onFailure(Call<T> call, final Throwable t) {\n          callbackExecutor.execute(new Runnable() {\n            ...\n          });\n        }\n      });\n    }\n\n    @Override public Response<T> execute() throws IOException {\n      return delegate.execute();\n    }\n```\n\nenqueue 里的返回 onResponse 和 onFailure 都是在 callbackExecutor\ncallbackExecutor 也是在 retrofit 构建时传入的， 默认是 `Android.MainThreadExecutor` 也就是说默认 enqueue 的 callback 默认是执行在主线程的\n\n\n\n\n\n","slug":"Android/源码解析/Retrofit源码解析","published":1,"updated":"2022-06-14T16:27:13.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9v0069g0jed0l6535x","content":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RetrofitService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"query\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Observable&lt;PostInfo&gt; <span class=\"title\">getPostInfoRx</span><span class=\"params\">(@Query(<span class=\"string\">\"type\"</span>)</span> String type, @<span class=\"title\">Query</span><span class=\"params\">(<span class=\"string\">\"postid\"</span>)</span> String postid)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"http://www.kuaidi100.com/\"</span>)</span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class=\"comment\">// 支持RxJava</span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\">        </span><br><span class=\"line\">RetrofitService service = retrofit.create(XxxInterface.class);</span><br><span class=\"line\">Call&lt;PostInfo&gt; call = service.getPostInfo(<span class=\"string\">\"yuantong\"</span>, <span class=\"string\">\"11111111111\"</span>);</span><br><span class=\"line\">call.enqueue(<span class=\"keyword\">new</span> Callback&lt;PostInfo&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;PostInfo&gt; call, Response&lt;PostInfo&gt; response)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"http返回：\"</span>, response.body().toString() + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;PostInfo&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure><a id=\"more\"></a>\n<p>上面是 Retrofit 的主要用法，主要重要的东西有 ConverterFactory , CallAdapterFactory , retrofit.create(XxxInterface.class) 三个东西</p>\n<h2 id=\"Retrofit-Builder\"><a href=\"#Retrofit-Builder\" class=\"headerlink\" title=\"Retrofit.Builder()\"></a>Retrofit.Builder()</h2><p>builder就是一个常见的建造者模式，没什么好说的。 有一个点需要注意一下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Retrofit <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   okhttp3.Call.Factory callFactory = <span class=\"keyword\">this</span>.callFactory;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (callFactory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">     callFactory = <span class=\"keyword\">new</span> OkHttpClient();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   Executor callbackExecutor = <span class=\"keyword\">this</span>.callbackExecutor;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (callbackExecutor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 默认callback回调是执行在主线程的</span></span><br><span class=\"line\">     callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"keyword\">this</span>.callAdapterFactories);</span><br><span class=\"line\">   callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class=\"line\"></span><br><span class=\"line\">   List&lt;Converter.Factory&gt; converterFactories = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(</span><br><span class=\"line\">       <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class=\"line\">   <span class=\"comment\">// ensures correct behavior when using converters that consume all types.</span></span><br><span class=\"line\">   converterFactories.add(<span class=\"keyword\">new</span> BuiltInConverters());</span><br><span class=\"line\">   converterFactories.addAll(<span class=\"keyword\">this</span>.converterFactories);</span><br><span class=\"line\">   converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class=\"line\">       unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuiltInConverters</span> <span class=\"keyword\">extends</span> <span class=\"title\">Converter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class=\"line\">        Retrofit retrofit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == ResponseBody.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class=\"line\">            ? StreamingResponseBodyConverter.INSTANCE</span><br><span class=\"line\">            : BufferingResponseBodyConverter.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == Void.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里首先插入了一个 BuiltInConverters 内置的转换器。 当返回类型是 ResponseBody 的时候就会使用 BuiltInConverters ，返回 ResponseBody 就和 okhttp 的返回一致了。</p>\n<h2 id=\"retrofit-create-XxxInterface-class\"><a href=\"#retrofit-create-XxxInterface-class\" class=\"headerlink\" title=\"retrofit.create(XxxInterface.class)\"></a>retrofit.create(XxxInterface.class)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">      <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @Nullable Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">          <span class=\"keyword\">return</span> loadServiceMethod(method).invoke(args != <span class=\"keyword\">null</span> ? args : emptyArgs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里使用了动态代理，create方法返回的接口对象是一个动态代理的实例</p>\n<h2 id=\"loadServiceMethod\"><a href=\"#loadServiceMethod\" class=\"headerlink\" title=\"loadServiceMethod\"></a>loadServiceMethod</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (serviceMethodCache) &#123;</span><br><span class=\"line\">    result = serviceMethodCache.get(method);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      result = ServiceMethod.parseAnnotations(<span class=\"keyword\">this</span>, method);</span><br><span class=\"line\">      serviceMethodCache.put(method, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缓存 + 解析Method</p>\n<h2 id=\"ServiceMethod-parseAnnotations\"><a href=\"#ServiceMethod-parseAnnotations\" class=\"headerlink\" title=\"ServiceMethod.parseAnnotations\"></a>ServiceMethod.parseAnnotations</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ServiceMethod&lt;T&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">T <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在抽象父类里先调用了 <code>RequestFactory.parseAnnotations(retrofit, method);</code> 去解析方法参数的注解。<br><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</code> 里解析了返回类型，并匹配 CallAdapter 和 Converter<br>。。。抽象父类的静态方法区调用了子类的静态方法。。。有些迷惑</p>\n<h2 id=\"HttpServiceMethod-parseAnnotations\"><a href=\"#HttpServiceMethod-parseAnnotations\" class=\"headerlink\" title=\"HttpServiceMethod.parseAnnotations\"></a>HttpServiceMethod.parseAnnotations</h2><p>RequestFactory.parseAnnotations 都是一些注解的处理，不说了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> continuationWantsResponse = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> continuationBodyNullable = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">    Type adapterType;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是协程suspend方法调用</span></span><br><span class=\"line\">    <span class=\"comment\">// kotli的suspend方法转成java之后会在方法参数上生成一个Continuation类型的参数</span></span><br><span class=\"line\">      Type[] parameterTypes = method.getGenericParameterTypes(); <span class=\"comment\">// 获取方法的所有参数类型</span></span><br><span class=\"line\">      Type responseType = Utils.getParameterLowerBound(<span class=\"number\">0</span>,</span><br><span class=\"line\">          (ParameterizedType) parameterTypes[parameterTypes.length - <span class=\"number\">1</span>]); <span class=\"comment\">// 获取最后一个 Continuation 类型参数的泛型</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class=\"keyword\">instanceof</span> ParameterizedType) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取 Response&lt;T&gt; 中泛型T的类型</span></span><br><span class=\"line\">        responseType = Utils.getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) responseType);</span><br><span class=\"line\">        continuationWantsResponse = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里把suspend方法的返回类型的 AdapterType 当做 Call&lt;T&gt; 来处理了</span></span><br><span class=\"line\">      adapterType = <span class=\"keyword\">new</span> Utils.ParameterizedTypeImpl(<span class=\"keyword\">null</span>, Call.class, responseType);</span><br><span class=\"line\">      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是非suspend方法，那直接取返回类型就可以了</span></span><br><span class=\"line\">      adapterType = method.getGenericReturnType();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 寻找合适的 CallAdapterFactory 生产 CallAdapter</span></span><br><span class=\"line\">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class=\"line\">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class=\"line\">    Type responseType = callAdapter.responseType();</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 寻找合适的 ConverterFactory 生产 Converter</span></span><br><span class=\"line\">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class=\"line\">        createResponseConverter(retrofit, method, responseType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CallFactory 实质上就是 OkHttpClient</span></span><br><span class=\"line\">    okhttp3.Call.Factory callFactory = retrofit.callFactory; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下面是返回 HttpServiceMethod 的子类，这三个子类其实就是 CallAdapted wrap 了一层。 SuspendForResponse 和 SuspendForBody 调用了协程的 await 方法去等待协程的完成（其实就是加了个Continuation的回调）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (continuationWantsResponse) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class=\"keyword\">new</span> SuspendForResponse&lt;&gt;(requestFactory,</span><br><span class=\"line\">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class=\"keyword\">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class=\"line\">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class=\"line\">          continuationBodyNullable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ServiceMethod-invode\"><a href=\"#ServiceMethod-invode\" class=\"headerlink\" title=\"ServiceMethod.invode\"></a>ServiceMethod.invode</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">HttpServiceMethod</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"keyword\">final</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">ReturnT <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    Call&lt;ResponseT&gt; call = <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> adapt(call, args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">ReturnT <span class=\"title\">adapt</span><span class=\"params\">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>OkHttpCall 实现了 Retrofit 的 call 到 OkHttpCall 的转换<br>adapt 最终会调用 CallAdapter 的 adapt</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\">   okhttp3.Call call;</span><br><span class=\"line\">   Throwable failure;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already executed.\"</span>);</span><br><span class=\"line\">     executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     call = rawCall;</span><br><span class=\"line\">     failure = creationFailure;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (call == <span class=\"keyword\">null</span> &amp;&amp; failure == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 懒加载 rawCall</span></span><br><span class=\"line\">         <span class=\"comment\">// 传入真实请求参数，构建真正发起请求的 okhttp 的 Call 对象</span></span><br><span class=\"line\">         call = rawCall = createRawCall();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   ...</span><br><span class=\"line\"></span><br><span class=\"line\">   call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class=\"line\">       Response&lt;T&gt; response;</span><br><span class=\"line\">       <span class=\"comment\">// 调用 Converter 解析返回类型</span></span><br><span class=\"line\">       response = parseResponse(rawResponse);</span><br><span class=\"line\">       callback.onResponse(OkHttpCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class=\"line\">       callback.onFailure(OkHttpCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看一下默认的 DefaultCallAdapterFactory 是怎么实现的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">DefaultCallAdapterFactory</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class=\"line\">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 获取 Call&lt;T&gt; 的具体类型</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Type responseType = Utils.getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否有 SkipCallbackExecutor 这个注解，一般是没有的</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class=\"line\">        ? <span class=\"keyword\">null</span></span><br><span class=\"line\">        : callbackExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call&lt;Object&gt; <span class=\"title\">adapt</span><span class=\"params\">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> executor == <span class=\"keyword\">null</span></span><br><span class=\"line\">            ? call</span><br><span class=\"line\">            : <span class=\"keyword\">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorCallbackCall</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Call</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Executor callbackExecutor;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Call&lt;T&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callbackExecutor = callbackExecutor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.delegate = delegate;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\">    delegate.enqueue(<span class=\"keyword\">new</span> Callback&lt;T&gt;() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;T&gt; call, <span class=\"keyword\">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">        callbackExecutor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;T&gt; call, <span class=\"keyword\">final</span> Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        callbackExecutor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response&lt;T&gt; <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delegate.execute();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>enqueue 里的返回 onResponse 和 onFailure 都是在 callbackExecutor<br>callbackExecutor 也是在 retrofit 构建时传入的， 默认是 <code>Android.MainThreadExecutor</code> 也就是说默认 enqueue 的 callback 默认是执行在主线程的</p>\n","site":{"data":{}},"excerpt":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RetrofitService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"query\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Observable&lt;PostInfo&gt; <span class=\"title\">getPostInfoRx</span><span class=\"params\">(@Query(<span class=\"string\">\"type\"</span>)</span> String type, @<span class=\"title\">Query</span><span class=\"params\">(<span class=\"string\">\"postid\"</span>)</span> String postid)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"http://www.kuaidi100.com/\"</span>)</span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class=\"comment\">// 支持RxJava</span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\">        </span><br><span class=\"line\">RetrofitService service = retrofit.create(XxxInterface.class);</span><br><span class=\"line\">Call&lt;PostInfo&gt; call = service.getPostInfo(<span class=\"string\">\"yuantong\"</span>, <span class=\"string\">\"11111111111\"</span>);</span><br><span class=\"line\">call.enqueue(<span class=\"keyword\">new</span> Callback&lt;PostInfo&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;PostInfo&gt; call, Response&lt;PostInfo&gt; response)</span> </span>&#123;</span><br><span class=\"line\">        Log.i(<span class=\"string\">\"http返回：\"</span>, response.body().toString() + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;PostInfo&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","more":"\n<p>上面是 Retrofit 的主要用法，主要重要的东西有 ConverterFactory , CallAdapterFactory , retrofit.create(XxxInterface.class) 三个东西</p>\n<h2 id=\"Retrofit-Builder\"><a href=\"#Retrofit-Builder\" class=\"headerlink\" title=\"Retrofit.Builder()\"></a>Retrofit.Builder()</h2><p>builder就是一个常见的建造者模式，没什么好说的。 有一个点需要注意一下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Retrofit <span class=\"title\">build</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   okhttp3.Call.Factory callFactory = <span class=\"keyword\">this</span>.callFactory;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (callFactory == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">     callFactory = <span class=\"keyword\">new</span> OkHttpClient();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   Executor callbackExecutor = <span class=\"keyword\">this</span>.callbackExecutor;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (callbackExecutor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 默认callback回调是执行在主线程的</span></span><br><span class=\"line\">     callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"keyword\">this</span>.callAdapterFactories);</span><br><span class=\"line\">   callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class=\"line\"></span><br><span class=\"line\">   List&lt;Converter.Factory&gt; converterFactories = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(</span><br><span class=\"line\">       <span class=\"number\">1</span> + <span class=\"keyword\">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class=\"line\">   <span class=\"comment\">// ensures correct behavior when using converters that consume all types.</span></span><br><span class=\"line\">   converterFactories.add(<span class=\"keyword\">new</span> BuiltInConverters());</span><br><span class=\"line\">   converterFactories.addAll(<span class=\"keyword\">this</span>.converterFactories);</span><br><span class=\"line\">   converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class=\"line\">       unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuiltInConverters</span> <span class=\"keyword\">extends</span> <span class=\"title\">Converter</span>.<span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class=\"line\">        Retrofit retrofit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == ResponseBody.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class=\"line\">            ? StreamingResponseBodyConverter.INSTANCE</span><br><span class=\"line\">            : BufferingResponseBodyConverter.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == Void.class) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里首先插入了一个 BuiltInConverters 内置的转换器。 当返回类型是 ResponseBody 的时候就会使用 BuiltInConverters ，返回 ResponseBody 就和 okhttp 的返回一致了。</p>\n<h2 id=\"retrofit-create-XxxInterface-class\"><a href=\"#retrofit-create-XxxInterface-class\" class=\"headerlink\" title=\"retrofit.create(XxxInterface.class)\"></a>retrofit.create(XxxInterface.class)</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">      <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] emptyArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            @Nullable Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">          <span class=\"keyword\">return</span> loadServiceMethod(method).invoke(args != <span class=\"keyword\">null</span> ? args : emptyArgs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里使用了动态代理，create方法返回的接口对象是一个动态代理的实例</p>\n<h2 id=\"loadServiceMethod\"><a href=\"#loadServiceMethod\" class=\"headerlink\" title=\"loadServiceMethod\"></a>loadServiceMethod</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class=\"line\">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (serviceMethodCache) &#123;</span><br><span class=\"line\">    result = serviceMethodCache.get(method);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      result = ServiceMethod.parseAnnotations(<span class=\"keyword\">this</span>, method);</span><br><span class=\"line\">      serviceMethodCache.put(method, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缓存 + 解析Method</p>\n<h2 id=\"ServiceMethod-parseAnnotations\"><a href=\"#ServiceMethod-parseAnnotations\" class=\"headerlink\" title=\"ServiceMethod.parseAnnotations\"></a>ServiceMethod.parseAnnotations</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceMethod</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ServiceMethod&lt;T&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class=\"line\">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">T <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在抽象父类里先调用了 <code>RequestFactory.parseAnnotations(retrofit, method);</code> 去解析方法参数的注解。<br><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</code> 里解析了返回类型，并匹配 CallAdapter 和 Converter<br>。。。抽象父类的静态方法区调用了子类的静态方法。。。有些迷惑</p>\n<h2 id=\"HttpServiceMethod-parseAnnotations\"><a href=\"#HttpServiceMethod-parseAnnotations\" class=\"headerlink\" title=\"HttpServiceMethod.parseAnnotations\"></a>HttpServiceMethod.parseAnnotations</h2><p>RequestFactory.parseAnnotations 都是一些注解的处理，不说了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;ResponseT, ReturnT&gt; <span class=\"function\">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class=\"title\">parseAnnotations</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> continuationWantsResponse = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> continuationBodyNullable = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Annotation[] annotations = method.getAnnotations();</span><br><span class=\"line\">    Type adapterType;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是协程suspend方法调用</span></span><br><span class=\"line\">    <span class=\"comment\">// kotli的suspend方法转成java之后会在方法参数上生成一个Continuation类型的参数</span></span><br><span class=\"line\">      Type[] parameterTypes = method.getGenericParameterTypes(); <span class=\"comment\">// 获取方法的所有参数类型</span></span><br><span class=\"line\">      Type responseType = Utils.getParameterLowerBound(<span class=\"number\">0</span>,</span><br><span class=\"line\">          (ParameterizedType) parameterTypes[parameterTypes.length - <span class=\"number\">1</span>]); <span class=\"comment\">// 获取最后一个 Continuation 类型参数的泛型</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class=\"keyword\">instanceof</span> ParameterizedType) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class=\"line\">        <span class=\"comment\">// 获取 Response&lt;T&gt; 中泛型T的类型</span></span><br><span class=\"line\">        responseType = Utils.getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) responseType);</span><br><span class=\"line\">        continuationWantsResponse = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里把suspend方法的返回类型的 AdapterType 当做 Call&lt;T&gt; 来处理了</span></span><br><span class=\"line\">      adapterType = <span class=\"keyword\">new</span> Utils.ParameterizedTypeImpl(<span class=\"keyword\">null</span>, Call.class, responseType);</span><br><span class=\"line\">      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果是非suspend方法，那直接取返回类型就可以了</span></span><br><span class=\"line\">      adapterType = method.getGenericReturnType();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 寻找合适的 CallAdapterFactory 生产 CallAdapter</span></span><br><span class=\"line\">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class=\"line\">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class=\"line\">    Type responseType = callAdapter.responseType();</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 寻找合适的 ConverterFactory 生产 Converter</span></span><br><span class=\"line\">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class=\"line\">        createResponseConverter(retrofit, method, responseType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CallFactory 实质上就是 OkHttpClient</span></span><br><span class=\"line\">    okhttp3.Call.Factory callFactory = retrofit.callFactory; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下面是返回 HttpServiceMethod 的子类，这三个子类其实就是 CallAdapted wrap 了一层。 SuspendForResponse 和 SuspendForBody 调用了协程的 await 方法去等待协程的完成（其实就是加了个Continuation的回调）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (continuationWantsResponse) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class=\"keyword\">new</span> SuspendForResponse&lt;&gt;(requestFactory,</span><br><span class=\"line\">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class=\"keyword\">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class=\"line\">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class=\"line\">          continuationBodyNullable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ServiceMethod-invode\"><a href=\"#ServiceMethod-invode\" class=\"headerlink\" title=\"ServiceMethod.invode\"></a>ServiceMethod.invode</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">HttpServiceMethod</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"keyword\">final</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">ReturnT <span class=\"title\">invoke</span><span class=\"params\">(Object[] args)</span> </span>&#123;</span><br><span class=\"line\">    Call&lt;ResponseT&gt; call = <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> adapt(call, args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"meta\">@Nullable</span> <span class=\"function\">ReturnT <span class=\"title\">adapt</span><span class=\"params\">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>OkHttpCall 实现了 Retrofit 的 call 到 OkHttpCall 的转换<br>adapt 最终会调用 CallAdapter 的 adapt</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\">   okhttp3.Call call;</span><br><span class=\"line\">   Throwable failure;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already executed.\"</span>);</span><br><span class=\"line\">     executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">     call = rawCall;</span><br><span class=\"line\">     failure = creationFailure;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (call == <span class=\"keyword\">null</span> &amp;&amp; failure == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 懒加载 rawCall</span></span><br><span class=\"line\">         <span class=\"comment\">// 传入真实请求参数，构建真正发起请求的 okhttp 的 Call 对象</span></span><br><span class=\"line\">         call = rawCall = createRawCall();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   ...</span><br><span class=\"line\"></span><br><span class=\"line\">   call.enqueue(<span class=\"keyword\">new</span> okhttp3.Callback() &#123;</span><br><span class=\"line\">     <span class=\"meta\">@Override</span> </span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class=\"line\">       Response&lt;T&gt; response;</span><br><span class=\"line\">       <span class=\"comment\">// 调用 Converter 解析返回类型</span></span><br><span class=\"line\">       response = parseResponse(rawResponse);</span><br><span class=\"line\">       callback.onResponse(OkHttpCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class=\"line\">       callback.onFailure(OkHttpCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看一下默认的 DefaultCallAdapterFactory 是怎么实现的<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">DefaultCallAdapterFactory</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> <span class=\"meta\">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class=\"line\">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 获取 Call&lt;T&gt; 的具体类型</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Type responseType = Utils.getParameterUpperBound(<span class=\"number\">0</span>, (ParameterizedType) returnType);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 是否有 SkipCallbackExecutor 这个注解，一般是没有的</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class=\"line\">        ? <span class=\"keyword\">null</span></span><br><span class=\"line\">        : callbackExecutor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Type <span class=\"title\">responseType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> responseType;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call&lt;Object&gt; <span class=\"title\">adapt</span><span class=\"params\">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> executor == <span class=\"keyword\">null</span></span><br><span class=\"line\">            ? call</span><br><span class=\"line\">            : <span class=\"keyword\">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExecutorCallbackCall</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Call</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Executor callbackExecutor;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Call&lt;T&gt; delegate;</span><br><span class=\"line\"></span><br><span class=\"line\">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callbackExecutor = callbackExecutor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.delegate = delegate;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(<span class=\"keyword\">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class=\"line\">    delegate.enqueue(<span class=\"keyword\">new</span> Callback&lt;T&gt;() &#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;T&gt; call, <span class=\"keyword\">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class=\"line\">        callbackExecutor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;T&gt; call, <span class=\"keyword\">final</span> Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        callbackExecutor.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response&lt;T&gt; <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> delegate.execute();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>enqueue 里的返回 onResponse 和 onFailure 都是在 callbackExecutor<br>callbackExecutor 也是在 retrofit 构建时传入的， 默认是 <code>Android.MainThreadExecutor</code> 也就是说默认 enqueue 的 callback 默认是执行在主线程的</p>\n"},{"title":"OkHttp3源码-RetryAndInterceptor和BridgeInterceptor","date":"2019-11-14T08:54:17.000Z","_content":"\n# OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor\n\n## RetryAndInterceptor\n\n**主要功能:**\n失败重连, 重定向\n\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Call call = realChain.call();\n    EventListener eventListener = realChain.eventListener();\n\n    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),\n        createAddress(request.url()), call, eventListener, callStackTrace);\n    this.streamAllocation = streamAllocation;\n\n    int followUpCount = 0;\n    // priorResponse表示在重定向时, 上一次request的response\n    Response priorResponse = null;\n    // while死循环, 在请求失败或者重定向之后重新发起请求\n    while (true) {\n        if (canceled) {\n            streamAllocation.release();\n            throw new IOException(\"Canceled\");\n        }\n\n        Response response;\n        boolean releaseConnection = true;\n        try {\n            // 进入责任链的下一个结点\n            response = realChain.proceed(request, streamAllocation, null, null);\n            releaseConnection = false;\n        } catch (RouteException e) {\n            // The attempt to connect via a route failed. The request will not have been sent.\n            // recover方法判断这个request是否可以失败重连\n            // 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false\n            if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {\n                throw e.getFirstConnectException();\n            }\n            releaseConnection = false;\n            // 进入下一个while迭代, 开始失败重连\n            continue;\n        } catch (IOException e) {\n            // An attempt to communicate with a server failed. The request may have been sent.\n            boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n            if (!recover(e, streamAllocation, requestSendStarted, request))\n                throw e;\n            releaseConnection = false;\n            continue;\n        } finally {\n            // We're throwing an unchecked exception. Release any resources.\n            if (releaseConnection) {\n                streamAllocation.streamFailed(null);\n                streamAllocation.release();\n            }\n        }\n\n        // Attach the prior response if it exists. Such responses never have a body.\n        // 如果priorResponse不为null, 将其加入到当前response中\n        if (priorResponse != null) {\n            response = response.newBuilder()\n                .priorResponse(priorResponse.newBuilder()\n                        .body(null)\n                        .build())\n                .build();\n        }\n\n        // followUp意思是重定向\n        Request followUp;\n        try {\n            // followUpRequest方法: 重定向时根据response构建新的request\n            followUp = followUpRequest(response, streamAllocation.route());\n        } catch (IOException e) {\n            streamAllocation.release();\n            throw e;\n        }\n\n        // followUp为空, 表示没有重定向了, 当前response为最终结果, return\n        if (followUp == null) {\n            streamAllocation.release();\n            return response;\n        }\n\n        // 有重定向, 关闭响应流\n        closeQuietly(response.body());\n\n        // 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常\n        if (++followUpCount > MAX_FOLLOW_UPS) {\n            streamAllocation.release();\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n\n        // 判断是否是不可重定向的类型\n        if (followUp.body() instanceof UnrepeatableRequestBody) {\n            streamAllocation.release();\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n        }\n\n        if (!sameConnection(response, followUp.url())) {\n            streamAllocation.release();\n            streamAllocation = new StreamAllocation(client.connectionPool(),\n                createAddress(followUp.url()), call, eventListener, callStackTrace);\n            this.streamAllocation = streamAllocation;\n        } else if (streamAllocation.codec() != null) {\n            throw new IllegalStateException(\"Closing the body of \" + response\n                + \" didn't close its backing stream. Bad interceptor?\");\n        }\n\n        // 更新request 和 priorResponse\n        request = followUp;\n        priorResponse = response;\n    }\n}\n```\n\n## RetryAndInterceptor伪代码\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    Response response;\n    Request request = chain.request;\n    StreamAllocation streamAllocation = new StreamAllocation();\n\n    int followUpCount = 0;\n    while(true){\n        try{\n            response = realChain.proceed(request, streamAllocation, null, null);\n        }catch(OkhttpException e){\n            if (!recover())\n                throw e;\n            continue;\n        }catch(OtherException e){\n            throw e;\n        }\n\n        Request followUp;\n        try {\n            followUp = followUpRequest(response, streamAllocation.route());\n        } catch (IOException e) {\n            throw e;\n        }\n\n        if(followUp == null)\n            return response;\n        \n        if (++followUpCount > MAX_FOLLOW_UPS) {\n            throw new Exception(\"Too many follow-up requests: \" + followUpCount);\n        }\n\n        request = followUp;\n    }\n}\n```\n\n## BridgeInterceptor\n\n这个拦截器比较简单, 提一下源代码上的注释吧\n\n```java\n/**\n* Bridges from application code to network code. First it builds a network request from a user\n* request. Then it proceeds to call the network. Finally it builds a user response from the network\n* response.\n*/\n\n/**\n* 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求\n* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。\n*/\n```\n","source":"_posts/Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor.md","raw":"---\ntitle: OkHttp3源码-RetryAndInterceptor和BridgeInterceptor\ndate: 2019-11-14 16:54:17\ntags:\n- okhttp3\n- 源码解析\ncategories:\n- Android\n---\n\n# OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor\n\n## RetryAndInterceptor\n\n**主要功能:**\n失败重连, 重定向\n\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    Request request = chain.request();\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Call call = realChain.call();\n    EventListener eventListener = realChain.eventListener();\n\n    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),\n        createAddress(request.url()), call, eventListener, callStackTrace);\n    this.streamAllocation = streamAllocation;\n\n    int followUpCount = 0;\n    // priorResponse表示在重定向时, 上一次request的response\n    Response priorResponse = null;\n    // while死循环, 在请求失败或者重定向之后重新发起请求\n    while (true) {\n        if (canceled) {\n            streamAllocation.release();\n            throw new IOException(\"Canceled\");\n        }\n\n        Response response;\n        boolean releaseConnection = true;\n        try {\n            // 进入责任链的下一个结点\n            response = realChain.proceed(request, streamAllocation, null, null);\n            releaseConnection = false;\n        } catch (RouteException e) {\n            // The attempt to connect via a route failed. The request will not have been sent.\n            // recover方法判断这个request是否可以失败重连\n            // 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false\n            if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {\n                throw e.getFirstConnectException();\n            }\n            releaseConnection = false;\n            // 进入下一个while迭代, 开始失败重连\n            continue;\n        } catch (IOException e) {\n            // An attempt to communicate with a server failed. The request may have been sent.\n            boolean requestSendStarted = !(e instanceof ConnectionShutdownException);\n            if (!recover(e, streamAllocation, requestSendStarted, request))\n                throw e;\n            releaseConnection = false;\n            continue;\n        } finally {\n            // We're throwing an unchecked exception. Release any resources.\n            if (releaseConnection) {\n                streamAllocation.streamFailed(null);\n                streamAllocation.release();\n            }\n        }\n\n        // Attach the prior response if it exists. Such responses never have a body.\n        // 如果priorResponse不为null, 将其加入到当前response中\n        if (priorResponse != null) {\n            response = response.newBuilder()\n                .priorResponse(priorResponse.newBuilder()\n                        .body(null)\n                        .build())\n                .build();\n        }\n\n        // followUp意思是重定向\n        Request followUp;\n        try {\n            // followUpRequest方法: 重定向时根据response构建新的request\n            followUp = followUpRequest(response, streamAllocation.route());\n        } catch (IOException e) {\n            streamAllocation.release();\n            throw e;\n        }\n\n        // followUp为空, 表示没有重定向了, 当前response为最终结果, return\n        if (followUp == null) {\n            streamAllocation.release();\n            return response;\n        }\n\n        // 有重定向, 关闭响应流\n        closeQuietly(response.body());\n\n        // 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常\n        if (++followUpCount > MAX_FOLLOW_UPS) {\n            streamAllocation.release();\n            throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount);\n        }\n\n        // 判断是否是不可重定向的类型\n        if (followUp.body() instanceof UnrepeatableRequestBody) {\n            streamAllocation.release();\n            throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code());\n        }\n\n        if (!sameConnection(response, followUp.url())) {\n            streamAllocation.release();\n            streamAllocation = new StreamAllocation(client.connectionPool(),\n                createAddress(followUp.url()), call, eventListener, callStackTrace);\n            this.streamAllocation = streamAllocation;\n        } else if (streamAllocation.codec() != null) {\n            throw new IllegalStateException(\"Closing the body of \" + response\n                + \" didn't close its backing stream. Bad interceptor?\");\n        }\n\n        // 更新request 和 priorResponse\n        request = followUp;\n        priorResponse = response;\n    }\n}\n```\n\n## RetryAndInterceptor伪代码\n```java\n@Override \npublic Response intercept(Chain chain) throws IOException {\n    Response response;\n    Request request = chain.request;\n    StreamAllocation streamAllocation = new StreamAllocation();\n\n    int followUpCount = 0;\n    while(true){\n        try{\n            response = realChain.proceed(request, streamAllocation, null, null);\n        }catch(OkhttpException e){\n            if (!recover())\n                throw e;\n            continue;\n        }catch(OtherException e){\n            throw e;\n        }\n\n        Request followUp;\n        try {\n            followUp = followUpRequest(response, streamAllocation.route());\n        } catch (IOException e) {\n            throw e;\n        }\n\n        if(followUp == null)\n            return response;\n        \n        if (++followUpCount > MAX_FOLLOW_UPS) {\n            throw new Exception(\"Too many follow-up requests: \" + followUpCount);\n        }\n\n        request = followUp;\n    }\n}\n```\n\n## BridgeInterceptor\n\n这个拦截器比较简单, 提一下源代码上的注释吧\n\n```java\n/**\n* Bridges from application code to network code. First it builds a network request from a user\n* request. Then it proceeds to call the network. Finally it builds a user response from the network\n* response.\n*/\n\n/**\n* 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求\n* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。\n*/\n```\n","slug":"Android/源码解析/OkHttp3源码-RetryAndInterceptor和BridgeInterceptor","published":1,"updated":"2021-10-03T01:57:41.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9v006cg0jejjdog472","content":"<h1 id=\"OkHttp3-源码-RetryAndInterceptor-和-BridgeInterceptor\"><a href=\"#OkHttp3-源码-RetryAndInterceptor-和-BridgeInterceptor\" class=\"headerlink\" title=\"OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor\"></a>OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor</h1><a id=\"more\"></a><h2 id=\"RetryAndInterceptor\"><a href=\"#RetryAndInterceptor\" class=\"headerlink\" title=\"RetryAndInterceptor\"></a>RetryAndInterceptor</h2><p><strong>主要功能:</strong><br>失败重连, 重定向</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Call call = realChain.call();</span><br><span class=\"line\">    EventListener eventListener = realChain.eventListener();</span><br><span class=\"line\"></span><br><span class=\"line\">    StreamAllocation streamAllocation = <span class=\"keyword\">new</span> StreamAllocation(client.connectionPool(),</span><br><span class=\"line\">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.streamAllocation = streamAllocation;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> followUpCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// priorResponse表示在重定向时, 上一次request的response</span></span><br><span class=\"line\">    Response priorResponse = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// while死循环, 在请求失败或者重定向之后重新发起请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canceled) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Response response;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> releaseConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 进入责任链的下一个结点</span></span><br><span class=\"line\">            response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RouteException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class=\"line\">            <span class=\"comment\">// recover方法判断这个request是否可以失败重连</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class=\"keyword\">false</span>, request)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e.getFirstConnectException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 进入下一个while迭代, 开始失败重连</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> requestSendStarted = !(e <span class=\"keyword\">instanceof</span> ConnectionShutdownException);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover(e, streamAllocation, requestSendStarted, request))</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (releaseConnection) &#123;</span><br><span class=\"line\">                streamAllocation.streamFailed(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                streamAllocation.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果priorResponse不为null, 将其加入到当前response中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (priorResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            response = response.newBuilder()</span><br><span class=\"line\">                .priorResponse(priorResponse.newBuilder()</span><br><span class=\"line\">                        .body(<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        .build())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// followUp意思是重定向</span></span><br><span class=\"line\">        Request followUp;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// followUpRequest方法: 重定向时根据response构建新的request</span></span><br><span class=\"line\">            followUp = followUpRequest(response, streamAllocation.route());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// followUp为空, 表示没有重定向了, 当前response为最终结果, return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (followUp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 有重定向, 关闭响应流</span></span><br><span class=\"line\">        closeQuietly(response.body());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(<span class=\"string\">\"Too many follow-up requests: \"</span> + followUpCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是不可重定向的类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (followUp.body() <span class=\"keyword\">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HttpRetryException(<span class=\"string\">\"Cannot retry streamed HTTP body\"</span>, response.code());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            streamAllocation = <span class=\"keyword\">new</span> StreamAllocation(client.connectionPool(),</span><br><span class=\"line\">                createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.streamAllocation = streamAllocation;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (streamAllocation.codec() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Closing the body of \"</span> + response</span><br><span class=\"line\">                + <span class=\"string\">\" didn't close its backing stream. Bad interceptor?\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新request 和 priorResponse</span></span><br><span class=\"line\">        request = followUp;</span><br><span class=\"line\">        priorResponse = response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RetryAndInterceptor伪代码\"><a href=\"#RetryAndInterceptor伪代码\" class=\"headerlink\" title=\"RetryAndInterceptor伪代码\"></a>RetryAndInterceptor伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Response response;</span><br><span class=\"line\">    Request request = chain.request;</span><br><span class=\"line\">    StreamAllocation streamAllocation = <span class=\"keyword\">new</span> StreamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> followUpCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(OkhttpException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(OtherException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Request followUp;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            followUp = followUpRequest(response, streamAllocation.route());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(followUp == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Too many follow-up requests: \"</span> + followUpCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        request = followUp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"BridgeInterceptor\"><a href=\"#BridgeInterceptor\" class=\"headerlink\" title=\"BridgeInterceptor\"></a>BridgeInterceptor</h2><p>这个拦截器比较简单, 提一下源代码上的注释吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Bridges from application code to network code. First it builds a network request from a user</span></span><br><span class=\"line\"><span class=\"comment\">* request. Then it proceeds to call the network. Finally it builds a user response from the network</span></span><br><span class=\"line\"><span class=\"comment\">* response.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求</span></span><br><span class=\"line\"><span class=\"comment\">* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"OkHttp3-源码-RetryAndInterceptor-和-BridgeInterceptor\"><a href=\"#OkHttp3-源码-RetryAndInterceptor-和-BridgeInterceptor\" class=\"headerlink\" title=\"OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor\"></a>OkHttp3 源码-RetryAndInterceptor 和 BridgeInterceptor</h1>","more":"<h2 id=\"RetryAndInterceptor\"><a href=\"#RetryAndInterceptor\" class=\"headerlink\" title=\"RetryAndInterceptor\"></a>RetryAndInterceptor</h2><p><strong>主要功能:</strong><br>失败重连, 重定向</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Request request = chain.request();</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Call call = realChain.call();</span><br><span class=\"line\">    EventListener eventListener = realChain.eventListener();</span><br><span class=\"line\"></span><br><span class=\"line\">    StreamAllocation streamAllocation = <span class=\"keyword\">new</span> StreamAllocation(client.connectionPool(),</span><br><span class=\"line\">        createAddress(request.url()), call, eventListener, callStackTrace);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.streamAllocation = streamAllocation;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> followUpCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// priorResponse表示在重定向时, 上一次request的response</span></span><br><span class=\"line\">    Response priorResponse = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// while死循环, 在请求失败或者重定向之后重新发起请求</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canceled) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Response response;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> releaseConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 进入责任链的下一个结点</span></span><br><span class=\"line\">            response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (RouteException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class=\"line\">            <span class=\"comment\">// recover方法判断这个request是否可以失败重连</span></span><br><span class=\"line\">            <span class=\"comment\">// 注意: client的Builder可以配置拒绝失败重连, 这样的话, recover方法会直接返回false</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover(e.getLastConnectException(), streamAllocation, <span class=\"keyword\">false</span>, request)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e.getFirstConnectException();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 进入下一个while迭代, 开始失败重连</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> requestSendStarted = !(e <span class=\"keyword\">instanceof</span> ConnectionShutdownException);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover(e, streamAllocation, requestSendStarted, request))</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            releaseConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (releaseConnection) &#123;</span><br><span class=\"line\">                streamAllocation.streamFailed(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">                streamAllocation.release();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果priorResponse不为null, 将其加入到当前response中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (priorResponse != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            response = response.newBuilder()</span><br><span class=\"line\">                .priorResponse(priorResponse.newBuilder()</span><br><span class=\"line\">                        .body(<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                        .build())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// followUp意思是重定向</span></span><br><span class=\"line\">        Request followUp;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// followUpRequest方法: 重定向时根据response构建新的request</span></span><br><span class=\"line\">            followUp = followUpRequest(response, streamAllocation.route());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// followUp为空, 表示没有重定向了, 当前response为最终结果, return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (followUp == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 有重定向, 关闭响应流</span></span><br><span class=\"line\">        closeQuietly(response.body());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重定向次数+1, 当超过MAX_FOLLOW_UPS时, 抛出异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(<span class=\"string\">\"Too many follow-up requests: \"</span> + followUpCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是不可重定向的类型</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (followUp.body() <span class=\"keyword\">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HttpRetryException(<span class=\"string\">\"Cannot retry streamed HTTP body\"</span>, response.code());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class=\"line\">            streamAllocation.release();</span><br><span class=\"line\">            streamAllocation = <span class=\"keyword\">new</span> StreamAllocation(client.connectionPool(),</span><br><span class=\"line\">                createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.streamAllocation = streamAllocation;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (streamAllocation.codec() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Closing the body of \"</span> + response</span><br><span class=\"line\">                + <span class=\"string\">\" didn't close its backing stream. Bad interceptor?\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新request 和 priorResponse</span></span><br><span class=\"line\">        request = followUp;</span><br><span class=\"line\">        priorResponse = response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"RetryAndInterceptor伪代码\"><a href=\"#RetryAndInterceptor伪代码\" class=\"headerlink\" title=\"RetryAndInterceptor伪代码\"></a>RetryAndInterceptor伪代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    Response response;</span><br><span class=\"line\">    Request request = chain.request;</span><br><span class=\"line\">    StreamAllocation streamAllocation = <span class=\"keyword\">new</span> StreamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> followUpCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            response = realChain.proceed(request, streamAllocation, <span class=\"keyword\">null</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(OkhttpException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!recover())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(OtherException e)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Request followUp;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            followUp = followUpRequest(response, streamAllocation.route());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(followUp == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"Too many follow-up requests: \"</span> + followUpCount);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        request = followUp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"BridgeInterceptor\"><a href=\"#BridgeInterceptor\" class=\"headerlink\" title=\"BridgeInterceptor\"></a>BridgeInterceptor</h2><p>这个拦截器比较简单, 提一下源代码上的注释吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Bridges from application code to network code. First it builds a network request from a user</span></span><br><span class=\"line\"><span class=\"comment\">* request. Then it proceeds to call the network. Finally it builds a user response from the network</span></span><br><span class=\"line\"><span class=\"comment\">* response.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 从应用程序代码到网络代码的桥梁。首先，它建立用户的网络请求</span></span><br><span class=\"line\"><span class=\"comment\">* 请求，然后继续呼叫网络，最后建立来自网络的用户响应回应。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n"},{"title":"OkHttp3源码-ConnectInterceptor","date":"2019-11-15T15:45:15.000Z","_content":"\nConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.\n\n## 参考链接:\n[https://www.jianshu.com/p/4bf4c796db6f](okhttp源码分析（四）-ConnectInterceptor过滤器)\n[https://juejin.im/post/5b73abe55188256142142d89](OkHttp3源码解析(三)——连接池复用)\n\n## intercept\n\n```java\n@Override public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Request request = realChain.request();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n\n    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);\n    RealConnection connection = streamAllocation.connection();\n\n    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n}\n```\n\nConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单.\n\n## StreamAllocation\n\n### 流, 连接, 请求\nHTTP通信执行网络\"请求\"需要在\"连接\"上建立一个新的\"流\". StreamAllocation称之流的桥梁，它负责为一次\"请求\"寻找\"连接\"并建立\"流\"\n来看看StreamAllocation源代码上的官方注释:\n```java\n/**\n * <ul>\n *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are\n *         potentially slow to establish so it is necessary to be able to cancel a connection\n *         currently being connected.\n *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on\n *         connections. Each connection has its own allocation limit, which defines how many\n *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream\n *         at a time, HTTP/2 typically carry multiple.\n *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and\n *         its follow up requests. We prefer to keep all streams of a single call on the same\n *         connection for better behavior and locality.\n * </ul>\n */\n```\n**翻译:**\n* Connection:\n    到远端服务器的物理连接. Socket连接的具体工作者\n* Stream:\n    在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个.\n    在okhttp3的流是HttpCodec表示\n* Call: \n    对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中\n\n### newStream, findHealthyConnection\n\n#### newStream\n\n获取合适的连接, 从连接中获取流\n```java\n  public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n    int connectTimeout = client.connectTimeoutMillis();\n    int readTimeout = client.readTimeoutMillis();\n    int writeTimeout = client.writeTimeoutMillis();\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n      //获取一个连接\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n      //实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec\n      HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  }\n```\n\n#### findHealthyConnecton\n\n不断循环, 直到获取一个healthy?的连接\n健康的连接, 大概意思是socket能正常使用的意思吧\n\n```java\n  /**\n   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated\n   * until a healthy connection is found.\n   */\n  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n      throws IOException {\n    while (true) {\n      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n          connectionRetryEnabled);\n\n      // If this is a brand new connection, we can skip the extensive health checks.\n      synchronized (connectionPool) {\n        if (candidate.successCount == 0) {\n          return candidate;\n        }\n      }\n\n      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n      // isn't, take it out of the pool and start again.\n      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n        // 如果这个连接不健康, \n        // 禁用这条连接, 重复寻找可用的连接\n        noNewStreams();\n        continue;\n      }\n\n      return candidate;\n    }\n  }\n```\n\n### findConnection-重点\n\n```java\n /**\n   * Returns a connection to host a new stream. This prefers the existing connection if it exists,\n   * then the pool, finally building a new connection.\n   */\n /**\n   * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接\n   */\nprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled) throws IOException {\n    boolean foundPooledConnection = false;\n    RealConnection result = null;\n    Route selectedRoute = null;\n    Connection releasedConnection;\n    Socket toClose;\n    synchronized (connectionPool) {\n      ... // 省略代码\n\n      // Attempt to use an already-allocated connection. We need to be careful here because our\n      // already-allocated connection may have been restricted from creating new streams.\n      releasedConnection = this.connection;\n      toClose = releaseIfNoNewStreams();\n      if (this.connection != null) {\n        //如果当前connection不为空可以直接使用\n        // We had an already-allocated connection and it's good.\n        result = this.connection;\n        releasedConnection = null;\n      }\n      if (!reportedAcquired) {\n        // If the connection was never reported acquired, don't report it as released!\n        releasedConnection = null;\n      }\n\n      //当前这个connection不能使用，尝试从连接池里面获取一个请求\n      if (result == null) {\n        // Attempt to get a connection from the pool.\n        // Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法\n        Internal.instance.get(connectionPool, address, this, null);\n        if (connection != null) {\n          foundPooledConnection = true;\n          result = connection;\n        } else {\n          selectedRoute = route;\n        }\n      }\n    }\n    closeQuietly(toClose);\n\n    ... // 省略代码\n\n    if (result != null) {\n      // 找到一条可复用的连接\n      // If we found an already-allocated or pooled connection, we're done.\n      return result;\n    }\n\n    // 到达这里表示没有找到\n    // 切换路由再在连接池里面找下，如果有则返回\n\n    // If we need a route selection, make one. This is a blocking operation.\n    boolean newRouteSelection = false;\n    // 检查是否有其他路由\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\n      newRouteSelection = true;\n      routeSelection = routeSelector.next();\n    }\n\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(\"Canceled\");\n\n      if (newRouteSelection) {\n        // Now that we have a set of IP addresses, make another attempt at getting a connection from\n        // the pool. This could match due to connection coalescing.\n        // 有其他路由, 遍历RooteSelector\n        List<Route> routes = routeSelection.getAll();\n        for (int i = 0, size = routes.size(); i < size; i++) {\n          Route route = routes.get(i);\n          Internal.instance.get(connectionPool, address, this, route);\n          if (connection != null) {\n            foundPooledConnection = true;\n            result = connection;\n            this.route = route;\n            break;\n          }\n        }\n      }\n\n      if (!foundPooledConnection) {\n        //没找到则创建一条\n        if (selectedRoute == null) {\n          selectedRoute = routeSelection.next();\n        }\n\n        // Create a connection and assign it to this allocation immediately. This makes it possible\n        // for an asynchronous cancel() to interrupt the handshake we're about to do.\n        route = selectedRoute;\n        refusedStreamCount = 0;\n        result = new RealConnection(connectionPool, selectedRoute);\n        //往连接中增加流\n        acquire(result, false);\n      }\n    }\n\n    // If we found a pooled connection on the 2nd time around, we're done.\n    //如果第二次找到了可以复用的，则返回\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n      return result;\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    // 建立连接,开始握手\n    result.connect(\n        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);\n    // 将这条路由从错误缓存中清除\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      reportedAcquired = true;\n\n      // Pool the connection.\n      //将这个请求加入连接池\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      // 如果是多路复用，则合并\n      if (result.isMultiplexed()) {\n        // 返回的是一个重复的socket\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    // 关闭重复的socket\n    closeQuietly(socket);\n\n    eventListener.connectionAcquired(call, result);\n    return result;\n  }\n```\n\n## CollectionPool\n\n### 主要成员变量\n\n```java\n/**\n* Background threads are used to cleanup expired connections. There will be at most a single\n* thread running per connection pool. The thread pool executor permits the pool itself to be\n* garbage collected.\n*/\n/**\n被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). \n*/\nprivate static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,\n    Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,\n    new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp ConnectionPool\", true));\n\n/** The maximum number of idle connections for each address. */\n// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5\nprivate final int maxIdleConnections;\n// 允许的线程空闲的最大时间, 默认为5分钟\nprivate final long keepAliveDurationNs;\n// 清理的task\nprivate final Runnable cleanupRunnable = new Runnable() {\n    @Override public void run() {\n        while (true) {\n            long waitNanos = cleanup(System.nanoTime());\n            if (waitNanos == -1) return;\n            if (waitNanos > 0) {\n                long waitMillis = waitNanos / 1000000L;\n                waitNanos -= (waitMillis * 1000000L);\n                synchronized (ConnectionPool.this) {\n                    try {\n                        ConnectionPool.this.wait(waitMillis, (int) waitNanos);\n                    } catch (InterruptedException ignored) {\n                    }\n                }\n            }\n        }\n    }\n};\n// 连接池中的连接集合\nprivate final Deque<RealConnection> connections = new ArrayDeque<>();\n// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...\nfinal RouteDatabase routeDatabase = new RouteDatabase();\n// 标记清理线程是否在运行\nboolean cleanupRunning;\n```\n\n**ConnectionPool创建的位置:**\nConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs)\n\n\n### cleanUpRunnable\n\n会被放入线程池的清理任务\n\n```java\nprivate final Runnable cleanupRunnable = new Runnable() {\n    @Override public void run() {\n        while (true) {\n            // cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间\n            long waitNanos = cleanup(System.nanoTime());\n            if (waitNanos == -1) return;\n            if (waitNanos > 0) {\n                long waitMillis = waitNanos / 1000000L;\n                waitNanos -= (waitMillis * 1000000L);\n                synchronized (ConnectionPool.this) {\n                    try {\n                        // 挂起清理线程\n                        ConnectionPool.this.wait(waitMillis, (int) waitNanos);\n                    } catch (InterruptedException ignored) {\n                    }\n                }\n            }\n        }\n    }\n};\n```\n\n### cleanUp\n\n找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间.\n\n```java\n/**\n* Performs maintenance on this pool, evicting the connection that has been idle the longest if\n* either it has exceeded the keep alive limit or the idle connections limit.\n*\n* <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns\n* -1 if no further cleanups are required.\n*/\n\nlong cleanup(long now) {\n    int inUseConnectionCount = 0;\n    int idleConnectionCount = 0;\n    RealConnection longestIdleConnection = null;\n    long longestIdleDurationNs = Long.MIN_VALUE;\n\n    // Find either a connection to evict, or the time that the next eviction is due.\n    // 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection\n    synchronized (this) {\n      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {\n        RealConnection connection = i.next();\n\n        // If the connection is in use, keep searching.\n        // pruneAndGetAllocationCount方法判断当前connection是否正在使用中\n        if (pruneAndGetAllocationCount(connection, now) > 0) {\n          inUseConnectionCount++;\n          continue;\n        }\n\n        idleConnectionCount++;\n\n        // If the connection is ready to be evicted, we're done.\n        long idleDurationNs = now - connection.idleAtNanos;\n        // 记录空闲最长的那个connection, 并且记录空闲的最长时间\n        if (idleDurationNs > longestIdleDurationNs) {\n          longestIdleDurationNs = idleDurationNs;\n          longestIdleConnection = connection;\n        }\n      }\n\n      if (longestIdleDurationNs >= this.keepAliveDurationNs\n          || idleConnectionCount > this.maxIdleConnections) {\n        // We've found a connection to evict. Remove it from the list, then close it below (outside\n        // of the synchronized block).\n        \n        // 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制\n        // 从connections集合中remove掉该connection\n        connections.remove(longestIdleConnection);\n      } else if (idleConnectionCount > 0) {\n        // A connection will be ready to evict soon.\n        // 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间\n        return keepAliveDurationNs - longestIdleDurationNs;\n      } else if (inUseConnectionCount > 0) {\n        // All connections are in use. It'll be at least the keep alive duration 'til we run again.\n        // 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理\n        return keepAliveDurationNs;\n      } else {\n        // No connections, idle or in use.\n        // 根本没有connection, 返回-1, 直接终止清理任务\n        cleanupRunning = false;\n        return -1;\n      }\n    }\n\n    closeQuietly(longestIdleConnection.socket());\n\n    // Cleanup again immediately.\n    return 0;\n}\n```\n\n### pruneAndGetAllocationCount\n\n判断该连接是否是空闲的\n\n```java\nprivate int pruneAndGetAllocationCount(RealConnection connection, long now) {\n    List<Reference<StreamAllocation>> references = connection.allocations;\n    for (int i = 0; i < references.size(); ) {\n        Reference<StreamAllocation> reference = references.get(i);\n    \n        //如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation\n        if (reference.get() != null) {\n            i++;\n            continue;\n        }\n\n        ... // 省略代码\n        \n        //如果没有引用，就移除\n        references.remove(i);\n        connection.noNewStreams = true;\n\n        //如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接\n        if (references.isEmpty()) {\n            connection.idleAtNanos = now - keepAliveDurationNs;\n            return 0;\n        }\n    }\n    //遍历结束后，返回引用的数量，说明当前连接是活跃连接\n    return references.size();\n}\n```\n\n**判断连接是否空闲过程:**\nRealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用...), 若集合为空, 则该连接时空闲的. \n\n### get和put\n\n**get:**\n```java\nRealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      //判断这个连接是否符合address和route, 判断过程很麻烦\n      if (connection.isEligible(address, route)) {\n        // 将streamAllocation和这个connection绑定\n        streamAllocation.acquire(connection, true);\n        return connection;\n      }\n    }\n    return null;\n}\n```\n\n**put:**\n```java\n  void put(RealConnection connection) {\n    assert (Thread.holdsLock(this));\n    if (!cleanupRunning) {\n      // 当清理任务没有工作的时候, 将任务放入线程池中运行\n      // 因为当connections集合为空时, 清理任务会终止\n      // ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ???\n      cleanupRunning = true;\n      executor.execute(cleanupRunnable);\n    }\n    connections.add(connection);\n  }\n```\n\n","source":"_posts/Android/源码解析/OkHttp3源码-ConnectInterceptor.md","raw":"---\ntitle: OkHttp3源码-ConnectInterceptor\ndate: 2019-11-15 23:45:15\ntags:\n- okhttp3\n- 源码解析\ncategories:\n- Android\n---\n\nConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.\n\n## 参考链接:\n[https://www.jianshu.com/p/4bf4c796db6f](okhttp源码分析（四）-ConnectInterceptor过滤器)\n[https://juejin.im/post/5b73abe55188256142142d89](OkHttp3源码解析(三)——连接池复用)\n\n## intercept\n\n```java\n@Override public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    Request request = realChain.request();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n\n    // We need the network to satisfy this request. Possibly for validating a conditional GET.\n    boolean doExtensiveHealthChecks = !request.method().equals(\"GET\");\n    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);\n    RealConnection connection = streamAllocation.connection();\n\n    return realChain.proceed(request, streamAllocation, httpCodec, connection);\n}\n```\n\nConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单.\n\n## StreamAllocation\n\n### 流, 连接, 请求\nHTTP通信执行网络\"请求\"需要在\"连接\"上建立一个新的\"流\". StreamAllocation称之流的桥梁，它负责为一次\"请求\"寻找\"连接\"并建立\"流\"\n来看看StreamAllocation源代码上的官方注释:\n```java\n/**\n * <ul>\n *     <li><strong>Connections:</strong> physical socket connections to remote servers. These are\n *         potentially slow to establish so it is necessary to be able to cancel a connection\n *         currently being connected.\n *     <li><strong>Streams:</strong> logical HTTP request/response pairs that are layered on\n *         connections. Each connection has its own allocation limit, which defines how many\n *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream\n *         at a time, HTTP/2 typically carry multiple.\n *     <li><strong>Calls:</strong> a logical sequence of streams, typically an initial request and\n *         its follow up requests. We prefer to keep all streams of a single call on the same\n *         connection for better behavior and locality.\n * </ul>\n */\n```\n**翻译:**\n* Connection:\n    到远端服务器的物理连接. Socket连接的具体工作者\n* Stream:\n    在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个.\n    在okhttp3的流是HttpCodec表示\n* Call: \n    对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中\n\n### newStream, findHealthyConnection\n\n#### newStream\n\n获取合适的连接, 从连接中获取流\n```java\n  public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {\n    int connectTimeout = client.connectTimeoutMillis();\n    int readTimeout = client.readTimeoutMillis();\n    int writeTimeout = client.writeTimeoutMillis();\n    boolean connectionRetryEnabled = client.retryOnConnectionFailure();\n\n    try {\n      //获取一个连接\n      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,\n          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);\n      //实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec\n      HttpCodec resultCodec = resultConnection.newCodec(client, this);\n\n      synchronized (connectionPool) {\n        codec = resultCodec;\n        return resultCodec;\n      }\n    } catch (IOException e) {\n      throw new RouteException(e);\n    }\n  }\n```\n\n#### findHealthyConnecton\n\n不断循环, 直到获取一个healthy?的连接\n健康的连接, 大概意思是socket能正常使用的意思吧\n\n```java\n  /**\n   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated\n   * until a healthy connection is found.\n   */\n  private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,\n      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)\n      throws IOException {\n    while (true) {\n      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,\n          connectionRetryEnabled);\n\n      // If this is a brand new connection, we can skip the extensive health checks.\n      synchronized (connectionPool) {\n        if (candidate.successCount == 0) {\n          return candidate;\n        }\n      }\n\n      // Do a (potentially slow) check to confirm that the pooled connection is still good. If it\n      // isn't, take it out of the pool and start again.\n      if (!candidate.isHealthy(doExtensiveHealthChecks)) {\n        // 如果这个连接不健康, \n        // 禁用这条连接, 重复寻找可用的连接\n        noNewStreams();\n        continue;\n      }\n\n      return candidate;\n    }\n  }\n```\n\n### findConnection-重点\n\n```java\n /**\n   * Returns a connection to host a new stream. This prefers the existing connection if it exists,\n   * then the pool, finally building a new connection.\n   */\n /**\n   * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接\n   */\nprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,\n      boolean connectionRetryEnabled) throws IOException {\n    boolean foundPooledConnection = false;\n    RealConnection result = null;\n    Route selectedRoute = null;\n    Connection releasedConnection;\n    Socket toClose;\n    synchronized (connectionPool) {\n      ... // 省略代码\n\n      // Attempt to use an already-allocated connection. We need to be careful here because our\n      // already-allocated connection may have been restricted from creating new streams.\n      releasedConnection = this.connection;\n      toClose = releaseIfNoNewStreams();\n      if (this.connection != null) {\n        //如果当前connection不为空可以直接使用\n        // We had an already-allocated connection and it's good.\n        result = this.connection;\n        releasedConnection = null;\n      }\n      if (!reportedAcquired) {\n        // If the connection was never reported acquired, don't report it as released!\n        releasedConnection = null;\n      }\n\n      //当前这个connection不能使用，尝试从连接池里面获取一个请求\n      if (result == null) {\n        // Attempt to get a connection from the pool.\n        // Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法\n        Internal.instance.get(connectionPool, address, this, null);\n        if (connection != null) {\n          foundPooledConnection = true;\n          result = connection;\n        } else {\n          selectedRoute = route;\n        }\n      }\n    }\n    closeQuietly(toClose);\n\n    ... // 省略代码\n\n    if (result != null) {\n      // 找到一条可复用的连接\n      // If we found an already-allocated or pooled connection, we're done.\n      return result;\n    }\n\n    // 到达这里表示没有找到\n    // 切换路由再在连接池里面找下，如果有则返回\n\n    // If we need a route selection, make one. This is a blocking operation.\n    boolean newRouteSelection = false;\n    // 检查是否有其他路由\n    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {\n      newRouteSelection = true;\n      routeSelection = routeSelector.next();\n    }\n\n    synchronized (connectionPool) {\n      if (canceled) throw new IOException(\"Canceled\");\n\n      if (newRouteSelection) {\n        // Now that we have a set of IP addresses, make another attempt at getting a connection from\n        // the pool. This could match due to connection coalescing.\n        // 有其他路由, 遍历RooteSelector\n        List<Route> routes = routeSelection.getAll();\n        for (int i = 0, size = routes.size(); i < size; i++) {\n          Route route = routes.get(i);\n          Internal.instance.get(connectionPool, address, this, route);\n          if (connection != null) {\n            foundPooledConnection = true;\n            result = connection;\n            this.route = route;\n            break;\n          }\n        }\n      }\n\n      if (!foundPooledConnection) {\n        //没找到则创建一条\n        if (selectedRoute == null) {\n          selectedRoute = routeSelection.next();\n        }\n\n        // Create a connection and assign it to this allocation immediately. This makes it possible\n        // for an asynchronous cancel() to interrupt the handshake we're about to do.\n        route = selectedRoute;\n        refusedStreamCount = 0;\n        result = new RealConnection(connectionPool, selectedRoute);\n        //往连接中增加流\n        acquire(result, false);\n      }\n    }\n\n    // If we found a pooled connection on the 2nd time around, we're done.\n    //如果第二次找到了可以复用的，则返回\n    if (foundPooledConnection) {\n      eventListener.connectionAcquired(call, result);\n      return result;\n    }\n\n    // Do TCP + TLS handshakes. This is a blocking operation.\n    // 建立连接,开始握手\n    result.connect(\n        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);\n    // 将这条路由从错误缓存中清除\n    routeDatabase().connected(result.route());\n\n    Socket socket = null;\n    synchronized (connectionPool) {\n      reportedAcquired = true;\n\n      // Pool the connection.\n      //将这个请求加入连接池\n      Internal.instance.put(connectionPool, result);\n\n      // If another multiplexed connection to the same address was created concurrently, then\n      // release this connection and acquire that one.\n      // 如果是多路复用，则合并\n      if (result.isMultiplexed()) {\n        // 返回的是一个重复的socket\n        socket = Internal.instance.deduplicate(connectionPool, address, this);\n        result = connection;\n      }\n    }\n    // 关闭重复的socket\n    closeQuietly(socket);\n\n    eventListener.connectionAcquired(call, result);\n    return result;\n  }\n```\n\n## CollectionPool\n\n### 主要成员变量\n\n```java\n/**\n* Background threads are used to cleanup expired connections. There will be at most a single\n* thread running per connection pool. The thread pool executor permits the pool itself to be\n* garbage collected.\n*/\n/**\n被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). \n*/\nprivate static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,\n    Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS,\n    new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp ConnectionPool\", true));\n\n/** The maximum number of idle connections for each address. */\n// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5\nprivate final int maxIdleConnections;\n// 允许的线程空闲的最大时间, 默认为5分钟\nprivate final long keepAliveDurationNs;\n// 清理的task\nprivate final Runnable cleanupRunnable = new Runnable() {\n    @Override public void run() {\n        while (true) {\n            long waitNanos = cleanup(System.nanoTime());\n            if (waitNanos == -1) return;\n            if (waitNanos > 0) {\n                long waitMillis = waitNanos / 1000000L;\n                waitNanos -= (waitMillis * 1000000L);\n                synchronized (ConnectionPool.this) {\n                    try {\n                        ConnectionPool.this.wait(waitMillis, (int) waitNanos);\n                    } catch (InterruptedException ignored) {\n                    }\n                }\n            }\n        }\n    }\n};\n// 连接池中的连接集合\nprivate final Deque<RealConnection> connections = new ArrayDeque<>();\n// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...\nfinal RouteDatabase routeDatabase = new RouteDatabase();\n// 标记清理线程是否在运行\nboolean cleanupRunning;\n```\n\n**ConnectionPool创建的位置:**\nConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs)\n\n\n### cleanUpRunnable\n\n会被放入线程池的清理任务\n\n```java\nprivate final Runnable cleanupRunnable = new Runnable() {\n    @Override public void run() {\n        while (true) {\n            // cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间\n            long waitNanos = cleanup(System.nanoTime());\n            if (waitNanos == -1) return;\n            if (waitNanos > 0) {\n                long waitMillis = waitNanos / 1000000L;\n                waitNanos -= (waitMillis * 1000000L);\n                synchronized (ConnectionPool.this) {\n                    try {\n                        // 挂起清理线程\n                        ConnectionPool.this.wait(waitMillis, (int) waitNanos);\n                    } catch (InterruptedException ignored) {\n                    }\n                }\n            }\n        }\n    }\n};\n```\n\n### cleanUp\n\n找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间.\n\n```java\n/**\n* Performs maintenance on this pool, evicting the connection that has been idle the longest if\n* either it has exceeded the keep alive limit or the idle connections limit.\n*\n* <p>Returns the duration in nanos to sleep until the next scheduled call to this method. Returns\n* -1 if no further cleanups are required.\n*/\n\nlong cleanup(long now) {\n    int inUseConnectionCount = 0;\n    int idleConnectionCount = 0;\n    RealConnection longestIdleConnection = null;\n    long longestIdleDurationNs = Long.MIN_VALUE;\n\n    // Find either a connection to evict, or the time that the next eviction is due.\n    // 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection\n    synchronized (this) {\n      for (Iterator<RealConnection> i = connections.iterator(); i.hasNext(); ) {\n        RealConnection connection = i.next();\n\n        // If the connection is in use, keep searching.\n        // pruneAndGetAllocationCount方法判断当前connection是否正在使用中\n        if (pruneAndGetAllocationCount(connection, now) > 0) {\n          inUseConnectionCount++;\n          continue;\n        }\n\n        idleConnectionCount++;\n\n        // If the connection is ready to be evicted, we're done.\n        long idleDurationNs = now - connection.idleAtNanos;\n        // 记录空闲最长的那个connection, 并且记录空闲的最长时间\n        if (idleDurationNs > longestIdleDurationNs) {\n          longestIdleDurationNs = idleDurationNs;\n          longestIdleConnection = connection;\n        }\n      }\n\n      if (longestIdleDurationNs >= this.keepAliveDurationNs\n          || idleConnectionCount > this.maxIdleConnections) {\n        // We've found a connection to evict. Remove it from the list, then close it below (outside\n        // of the synchronized block).\n        \n        // 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制\n        // 从connections集合中remove掉该connection\n        connections.remove(longestIdleConnection);\n      } else if (idleConnectionCount > 0) {\n        // A connection will be ready to evict soon.\n        // 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间\n        return keepAliveDurationNs - longestIdleDurationNs;\n      } else if (inUseConnectionCount > 0) {\n        // All connections are in use. It'll be at least the keep alive duration 'til we run again.\n        // 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理\n        return keepAliveDurationNs;\n      } else {\n        // No connections, idle or in use.\n        // 根本没有connection, 返回-1, 直接终止清理任务\n        cleanupRunning = false;\n        return -1;\n      }\n    }\n\n    closeQuietly(longestIdleConnection.socket());\n\n    // Cleanup again immediately.\n    return 0;\n}\n```\n\n### pruneAndGetAllocationCount\n\n判断该连接是否是空闲的\n\n```java\nprivate int pruneAndGetAllocationCount(RealConnection connection, long now) {\n    List<Reference<StreamAllocation>> references = connection.allocations;\n    for (int i = 0; i < references.size(); ) {\n        Reference<StreamAllocation> reference = references.get(i);\n    \n        //如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation\n        if (reference.get() != null) {\n            i++;\n            continue;\n        }\n\n        ... // 省略代码\n        \n        //如果没有引用，就移除\n        references.remove(i);\n        connection.noNewStreams = true;\n\n        //如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接\n        if (references.isEmpty()) {\n            connection.idleAtNanos = now - keepAliveDurationNs;\n            return 0;\n        }\n    }\n    //遍历结束后，返回引用的数量，说明当前连接是活跃连接\n    return references.size();\n}\n```\n\n**判断连接是否空闲过程:**\nRealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用...), 若集合为空, 则该连接时空闲的. \n\n### get和put\n\n**get:**\n```java\nRealConnection get(Address address, StreamAllocation streamAllocation, Route route) {\n    assert (Thread.holdsLock(this));\n    for (RealConnection connection : connections) {\n      //判断这个连接是否符合address和route, 判断过程很麻烦\n      if (connection.isEligible(address, route)) {\n        // 将streamAllocation和这个connection绑定\n        streamAllocation.acquire(connection, true);\n        return connection;\n      }\n    }\n    return null;\n}\n```\n\n**put:**\n```java\n  void put(RealConnection connection) {\n    assert (Thread.holdsLock(this));\n    if (!cleanupRunning) {\n      // 当清理任务没有工作的时候, 将任务放入线程池中运行\n      // 因为当connections集合为空时, 清理任务会终止\n      // ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ???\n      cleanupRunning = true;\n      executor.execute(cleanupRunnable);\n    }\n    connections.add(connection);\n  }\n```\n\n","slug":"Android/源码解析/OkHttp3源码-ConnectInterceptor","published":1,"updated":"2021-10-03T01:57:41.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9w006fg0jeprl2o9du","content":"<p>ConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.</p><a id=\"more\"></a>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接:\"></a>参考链接:</h2><p><a href=\"okhttp源码分析（四）-ConnectInterceptor过滤器\">https://www.jianshu.com/p/4bf4c796db6f</a><br><a href=\"OkHttp3源码解析(三\">https://juejin.im/post/5b73abe55188256142142d89</a>——连接池复用)</p>\n<h2 id=\"intercept\"><a href=\"#intercept\" class=\"headerlink\" title=\"intercept\"></a>intercept</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class=\"line\">    RealConnection connection = streamAllocation.connection();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单.</p>\n<h2 id=\"StreamAllocation\"><a href=\"#StreamAllocation\" class=\"headerlink\" title=\"StreamAllocation\"></a>StreamAllocation</h2><h3 id=\"流-连接-请求\"><a href=\"#流-连接-请求\" class=\"headerlink\" title=\"流, 连接, 请求\"></a>流, 连接, 请求</h3><p>HTTP通信执行网络”请求”需要在”连接”上建立一个新的”流”. StreamAllocation称之流的桥梁，它负责为一次”请求”寻找”连接”并建立”流”<br>来看看StreamAllocation源代码上的官方注释:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Connections:&lt;/strong&gt; physical socket connections to remote servers. These are</span></span><br><span class=\"line\"><span class=\"comment\"> *         potentially slow to establish so it is necessary to be able to cancel a connection</span></span><br><span class=\"line\"><span class=\"comment\"> *         currently being connected.</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Streams:&lt;/strong&gt; logical HTTP request/response pairs that are layered on</span></span><br><span class=\"line\"><span class=\"comment\"> *         connections. Each connection has its own allocation limit, which defines how many</span></span><br><span class=\"line\"><span class=\"comment\"> *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream</span></span><br><span class=\"line\"><span class=\"comment\"> *         at a time, HTTP/2 typically carry multiple.</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Calls:&lt;/strong&gt; a logical sequence of streams, typically an initial request and</span></span><br><span class=\"line\"><span class=\"comment\"> *         its follow up requests. We prefer to keep all streams of a single call on the same</span></span><br><span class=\"line\"><span class=\"comment\"> *         connection for better behavior and locality.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>翻译:</strong></p>\n<ul>\n<li>Connection:<br>  到远端服务器的物理连接. Socket连接的具体工作者</li>\n<li>Stream:<br>  在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个.<br>  在okhttp3的流是HttpCodec表示</li>\n<li>Call:<br>  对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中</li>\n</ul>\n<h3 id=\"newStream-findHealthyConnection\"><a href=\"#newStream-findHealthyConnection\" class=\"headerlink\" title=\"newStream, findHealthyConnection\"></a>newStream, findHealthyConnection</h3><h4 id=\"newStream\"><a href=\"#newStream\" class=\"headerlink\" title=\"newStream\"></a>newStream</h4><p>获取合适的连接, 从连接中获取流<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HttpCodec <span class=\"title\">newStream</span><span class=\"params\">(OkHttpClient client, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> connectTimeout = client.connectTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> readTimeout = client.readTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> writeTimeout = client.writeTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取一个连接</span></span><br><span class=\"line\">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class=\"line\">    <span class=\"comment\">//实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec</span></span><br><span class=\"line\">    HttpCodec resultCodec = resultConnection.newCodec(client, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      codec = resultCodec;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resultCodec;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RouteException(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"findHealthyConnecton\"><a href=\"#findHealthyConnecton\" class=\"headerlink\" title=\"findHealthyConnecton\"></a>findHealthyConnecton</h4><p>不断循环, 直到获取一个healthy?的连接<br>健康的连接, 大概意思是socket能正常使用的意思吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</span></span><br><span class=\"line\"><span class=\"comment\"> * until a healthy connection is found.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findHealthyConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">int</span> writeTimeout, <span class=\"keyword\">boolean</span> connectionRetryEnabled, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class=\"line\">        connectionRetryEnabled);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (candidate.successCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class=\"line\">    <span class=\"comment\">// isn't, take it out of the pool and start again.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果这个连接不健康, </span></span><br><span class=\"line\">      <span class=\"comment\">// 禁用这条连接, 重复寻找可用的连接</span></span><br><span class=\"line\">      noNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"findConnection-重点\"><a href=\"#findConnection-重点\" class=\"headerlink\" title=\"findConnection-重点\"></a>findConnection-重点</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span></span><br><span class=\"line\"><span class=\"comment\">   * then the pool, finally building a new connection.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout, <span class=\"keyword\">int</span> writeTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> connectionRetryEnabled)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> foundPooledConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    RealConnection result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Route selectedRoute = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Connection releasedConnection;</span><br><span class=\"line\">    Socket toClose;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Attempt to use an already-allocated connection. We need to be careful here because our</span></span><br><span class=\"line\">      <span class=\"comment\">// already-allocated connection may have been restricted from creating new streams.</span></span><br><span class=\"line\">      releasedConnection = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">      toClose = releaseIfNoNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前connection不为空可以直接使用</span></span><br><span class=\"line\">        <span class=\"comment\">// We had an already-allocated connection and it's good.</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!reportedAcquired) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the connection was never reported acquired, don't report it as released!</span></span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//当前这个connection不能使用，尝试从连接池里面获取一个请求</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Attempt to get a connection from the pool.</span></span><br><span class=\"line\">        <span class=\"comment\">// Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法</span></span><br><span class=\"line\">        Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          result = connection;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          selectedRoute = route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeQuietly(toClose);</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找到一条可复用的连接</span></span><br><span class=\"line\">      <span class=\"comment\">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 到达这里表示没有找到</span></span><br><span class=\"line\">    <span class=\"comment\">// 切换路由再在连接池里面找下，如果有则返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> newRouteSelection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 检查是否有其他路由</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span> &amp;&amp; (routeSelection == <span class=\"keyword\">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class=\"line\">      newRouteSelection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      routeSelection = routeSelector.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newRouteSelection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class=\"line\">        <span class=\"comment\">// the pool. This could match due to connection coalescing.</span></span><br><span class=\"line\">        <span class=\"comment\">// 有其他路由, 遍历RooteSelector</span></span><br><span class=\"line\">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">          Route route = routes.get(i);</span><br><span class=\"line\">          Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, route);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            result = connection;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.route = route;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!foundPooledConnection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//没找到则创建一条</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          selectedRoute = routeSelection.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class=\"line\">        <span class=\"comment\">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class=\"line\">        route = selectedRoute;</span><br><span class=\"line\">        refusedStreamCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class=\"line\">        <span class=\"comment\">//往连接中增加流</span></span><br><span class=\"line\">        acquire(result, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果第二次找到了可以复用的，则返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"comment\">// 建立连接,开始握手</span></span><br><span class=\"line\">    result.connect(</span><br><span class=\"line\">        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);</span><br><span class=\"line\">    <span class=\"comment\">// 将这条路由从错误缓存中清除</span></span><br><span class=\"line\">    routeDatabase().connected(result.route());</span><br><span class=\"line\"></span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      reportedAcquired = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Pool the connection.</span></span><br><span class=\"line\">      <span class=\"comment\">//将这个请求加入连接池</span></span><br><span class=\"line\">      Internal.instance.put(connectionPool, result);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class=\"line\">      <span class=\"comment\">// release this connection and acquire that one.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果是多路复用，则合并</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回的是一个重复的socket</span></span><br><span class=\"line\">        socket = Internal.instance.deduplicate(connectionPool, address, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        result = connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭重复的socket</span></span><br><span class=\"line\">    closeQuietly(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CollectionPool\"><a href=\"#CollectionPool\" class=\"headerlink\" title=\"CollectionPool\"></a>CollectionPool</h2><h3 id=\"主要成员变量\"><a href=\"#主要成员变量\" class=\"headerlink\" title=\"主要成员变量\"></a>主要成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Background threads are used to cleanup expired connections. There will be at most a single</span></span><br><span class=\"line\"><span class=\"comment\">* thread running per connection pool. The thread pool executor permits the pool itself to be</span></span><br><span class=\"line\"><span class=\"comment\">* garbage collected.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor executor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span> <span class=\"comment\">/* corePoolSize */</span>,</span><br><span class=\"line\">    Integer.MAX_VALUE <span class=\"comment\">/* maximumPoolSize */</span>, <span class=\"number\">60L</span> <span class=\"comment\">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class=\"string\">\"OkHttp ConnectionPool\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** The maximum number of idle connections for each address. */</span></span><br><span class=\"line\"><span class=\"comment\">// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxIdleConnections;</span><br><span class=\"line\"><span class=\"comment\">// 允许的线程空闲的最大时间, 默认为5分钟</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> keepAliveDurationNs;</span><br><span class=\"line\"><span class=\"comment\">// 清理的task</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable cleanupRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> waitMillis = waitNanos / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">                waitNanos -= (waitMillis * <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ConnectionPool.<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        ConnectionPool.<span class=\"keyword\">this</span>.wait(waitMillis, (<span class=\"keyword\">int</span>) waitNanos);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 连接池中的连接集合</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;RealConnection&gt; connections = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> RouteDatabase routeDatabase = <span class=\"keyword\">new</span> RouteDatabase();</span><br><span class=\"line\"><span class=\"comment\">// 标记清理线程是否在运行</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> cleanupRunning;</span><br></pre></td></tr></table></figure>\n<p><strong>ConnectionPool创建的位置:</strong><br>ConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs)</p>\n<h3 id=\"cleanUpRunnable\"><a href=\"#cleanUpRunnable\" class=\"headerlink\" title=\"cleanUpRunnable\"></a>cleanUpRunnable</h3><p>会被放入线程池的清理任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable cleanupRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> waitMillis = waitNanos / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">                waitNanos -= (waitMillis * <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ConnectionPool.<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 挂起清理线程</span></span><br><span class=\"line\">                        ConnectionPool.<span class=\"keyword\">this</span>.wait(waitMillis, (<span class=\"keyword\">int</span>) waitNanos);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cleanUp\"><a href=\"#cleanUp\" class=\"headerlink\" title=\"cleanUp\"></a>cleanUp</h3><p>找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Performs maintenance on this pool, evicting the connection that has been idle the longest if</span></span><br><span class=\"line\"><span class=\"comment\">* either it has exceeded the keep alive limit or the idle connections limit.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;p&gt;Returns the duration in nanos to sleep until the next scheduled call to this method. Returns</span></span><br><span class=\"line\"><span class=\"comment\">* -1 if no further cleanups are required.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">cleanup</span><span class=\"params\">(<span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> inUseConnectionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idleConnectionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    RealConnection longestIdleConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class=\"line\">    <span class=\"comment\">// 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">        RealConnection connection = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the connection is in use, keep searching.</span></span><br><span class=\"line\">        <span class=\"comment\">// pruneAndGetAllocationCount方法判断当前connection是否正在使用中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          inUseConnectionCount++;</span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        idleConnectionCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the connection is ready to be evicted, we're done.</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class=\"line\">        <span class=\"comment\">// 记录空闲最长的那个connection, 并且记录空闲的最长时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class=\"line\">          longestIdleDurationNs = idleDurationNs;</span><br><span class=\"line\">          longestIdleConnection = connection;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (longestIdleDurationNs &gt;= <span class=\"keyword\">this</span>.keepAliveDurationNs</span><br><span class=\"line\">          || idleConnectionCount &gt; <span class=\"keyword\">this</span>.maxIdleConnections) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We've found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class=\"line\">        <span class=\"comment\">// of the synchronized block).</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制</span></span><br><span class=\"line\">        <span class=\"comment\">// 从connections集合中remove掉该connection</span></span><br><span class=\"line\">        connections.remove(longestIdleConnection);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (idleConnectionCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// A connection will be ready to evict soon.</span></span><br><span class=\"line\">        <span class=\"comment\">// 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inUseConnectionCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span></span><br><span class=\"line\">        <span class=\"comment\">// 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keepAliveDurationNs;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// No connections, idle or in use.</span></span><br><span class=\"line\">        <span class=\"comment\">// 根本没有connection, 返回-1, 直接终止清理任务</span></span><br><span class=\"line\">        cleanupRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    closeQuietly(longestIdleConnection.socket());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Cleanup again immediately.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pruneAndGetAllocationCount\"><a href=\"#pruneAndGetAllocationCount\" class=\"headerlink\" title=\"pruneAndGetAllocationCount\"></a>pruneAndGetAllocationCount</h3><p>判断该连接是否是空闲的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">pruneAndGetAllocationCount</span><span class=\"params\">(RealConnection connection, <span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; references.size(); ) &#123;</span><br><span class=\"line\">        Reference&lt;StreamAllocation&gt; reference = references.get(i);</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reference.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//如果没有引用，就移除</span></span><br><span class=\"line\">        references.remove(i);</span><br><span class=\"line\">        connection.noNewStreams = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (references.isEmpty()) &#123;</span><br><span class=\"line\">            connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遍历结束后，返回引用的数量，说明当前连接是活跃连接</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> references.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>判断连接是否空闲过程:</strong><br>RealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用…), 若集合为空, 则该连接时空闲的. </p>\n<h3 id=\"get和put\"><a href=\"#get和put\" class=\"headerlink\" title=\"get和put\"></a>get和put</h3><p><strong>get:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">RealConnection <span class=\"title\">get</span><span class=\"params\">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RealConnection connection : connections) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//判断这个连接是否符合address和route, 判断过程很麻烦</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将streamAllocation和这个connection绑定</span></span><br><span class=\"line\">        streamAllocation.acquire(connection, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>put:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(RealConnection connection)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!cleanupRunning) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当清理任务没有工作的时候, 将任务放入线程池中运行</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为当connections集合为空时, 清理任务会终止</span></span><br><span class=\"line\">    <span class=\"comment\">// ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ???</span></span><br><span class=\"line\">    cleanupRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    executor.execute(cleanupRunnable);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  connections.add(connection);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>ConnectInterceptor的主要工作是创建一个连接. 由于建立连接涉及到tcp握手之类的操作, 所以开销是很大的, okhttp的一个特色在创建连接时使用到了ConnectionPool, 实现了连接的复用.</p>","more":"\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接:\"></a>参考链接:</h2><p><a href=\"okhttp源码分析（四）-ConnectInterceptor过滤器\">https://www.jianshu.com/p/4bf4c796db6f</a><br><a href=\"OkHttp3源码解析(三\">https://juejin.im/post/5b73abe55188256142142d89</a>——连接池复用)</p>\n<h2 id=\"intercept\"><a href=\"#intercept\" class=\"headerlink\" title=\"intercept\"></a>intercept</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\">    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br><span class=\"line\">    RealConnection connection = streamAllocation.connection();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ConnectInterceptor中的逻辑很简单, 只有那么一点点代码, 主要的功能都在StreamAllocation这个类里面. StreamAllocation这个类真的是一点都不简单.</p>\n<h2 id=\"StreamAllocation\"><a href=\"#StreamAllocation\" class=\"headerlink\" title=\"StreamAllocation\"></a>StreamAllocation</h2><h3 id=\"流-连接-请求\"><a href=\"#流-连接-请求\" class=\"headerlink\" title=\"流, 连接, 请求\"></a>流, 连接, 请求</h3><p>HTTP通信执行网络”请求”需要在”连接”上建立一个新的”流”. StreamAllocation称之流的桥梁，它负责为一次”请求”寻找”连接”并建立”流”<br>来看看StreamAllocation源代码上的官方注释:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Connections:&lt;/strong&gt; physical socket connections to remote servers. These are</span></span><br><span class=\"line\"><span class=\"comment\"> *         potentially slow to establish so it is necessary to be able to cancel a connection</span></span><br><span class=\"line\"><span class=\"comment\"> *         currently being connected.</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Streams:&lt;/strong&gt; logical HTTP request/response pairs that are layered on</span></span><br><span class=\"line\"><span class=\"comment\"> *         connections. Each connection has its own allocation limit, which defines how many</span></span><br><span class=\"line\"><span class=\"comment\"> *         concurrent streams that connection can carry. HTTP/1.x connections can carry 1 stream</span></span><br><span class=\"line\"><span class=\"comment\"> *         at a time, HTTP/2 typically carry multiple.</span></span><br><span class=\"line\"><span class=\"comment\"> *     &lt;li&gt;&lt;strong&gt;Calls:&lt;/strong&gt; a logical sequence of streams, typically an initial request and</span></span><br><span class=\"line\"><span class=\"comment\"> *         its follow up requests. We prefer to keep all streams of a single call on the same</span></span><br><span class=\"line\"><span class=\"comment\"> *         connection for better behavior and locality.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>翻译:</strong></p>\n<ul>\n<li>Connection:<br>  到远端服务器的物理连接. Socket连接的具体工作者</li>\n<li>Stream:<br>  在连接上建立的http请求和返回的逻辑流. 关于同一时刻能够携带的流的数量, 不同的连接有不同的限制. http/1.x连接能够同时建立一个流, http/2能够同时建立多个.<br>  在okhttp3的流是HttpCodec表示</li>\n<li>Call:<br>  对一系列逻辑流的封装. 有可能是一个单独的请求, 有可能包含多个重定向. 为了更好的性能表现, 我们更希望将一个call中的多个流包含在一个连接中</li>\n</ul>\n<h3 id=\"newStream-findHealthyConnection\"><a href=\"#newStream-findHealthyConnection\" class=\"headerlink\" title=\"newStream, findHealthyConnection\"></a>newStream, findHealthyConnection</h3><h4 id=\"newStream\"><a href=\"#newStream\" class=\"headerlink\" title=\"newStream\"></a>newStream</h4><p>获取合适的连接, 从连接中获取流<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> HttpCodec <span class=\"title\">newStream</span><span class=\"params\">(OkHttpClient client, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> connectTimeout = client.connectTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> readTimeout = client.readTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> writeTimeout = client.writeTimeoutMillis();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取一个连接</span></span><br><span class=\"line\">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class=\"line\">        writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class=\"line\">    <span class=\"comment\">//实例化HttpCodec,如果是HTTP/2则是Http2Codec否则是Http1Codec</span></span><br><span class=\"line\">    HttpCodec resultCodec = resultConnection.newCodec(client, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      codec = resultCodec;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> resultCodec;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RouteException(e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"findHealthyConnecton\"><a href=\"#findHealthyConnecton\" class=\"headerlink\" title=\"findHealthyConnecton\"></a>findHealthyConnecton</h4><p>不断循环, 直到获取一个healthy?的连接<br>健康的连接, 大概意思是socket能正常使用的意思吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</span></span><br><span class=\"line\"><span class=\"comment\"> * until a healthy connection is found.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findHealthyConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">int</span> writeTimeout, <span class=\"keyword\">boolean</span> connectionRetryEnabled, <span class=\"keyword\">boolean</span> doExtensiveHealthChecks)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class=\"line\">        connectionRetryEnabled);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (candidate.successCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class=\"line\">    <span class=\"comment\">// isn't, take it out of the pool and start again.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果这个连接不健康, </span></span><br><span class=\"line\">      <span class=\"comment\">// 禁用这条连接, 重复寻找可用的连接</span></span><br><span class=\"line\">      noNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"findConnection-重点\"><a href=\"#findConnection-重点\" class=\"headerlink\" title=\"findConnection-重点\"></a>findConnection-重点</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span></span><br><span class=\"line\"><span class=\"comment\">   * then the pool, finally building a new connection.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 返回一个连接. 优先使用已存在的连接, 其次是从连接池中获取, 最后新建一个连接</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> RealConnection <span class=\"title\">findConnection</span><span class=\"params\">(<span class=\"keyword\">int</span> connectTimeout, <span class=\"keyword\">int</span> readTimeout, <span class=\"keyword\">int</span> writeTimeout,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">boolean</span> connectionRetryEnabled)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> foundPooledConnection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    RealConnection result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Route selectedRoute = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    Connection releasedConnection;</span><br><span class=\"line\">    Socket toClose;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Attempt to use an already-allocated connection. We need to be careful here because our</span></span><br><span class=\"line\">      <span class=\"comment\">// already-allocated connection may have been restricted from creating new streams.</span></span><br><span class=\"line\">      releasedConnection = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">      toClose = releaseIfNoNewStreams();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前connection不为空可以直接使用</span></span><br><span class=\"line\">        <span class=\"comment\">// We had an already-allocated connection and it's good.</span></span><br><span class=\"line\">        result = <span class=\"keyword\">this</span>.connection;</span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!reportedAcquired) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the connection was never reported acquired, don't report it as released!</span></span><br><span class=\"line\">        releasedConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//当前这个connection不能使用，尝试从连接池里面获取一个请求</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Attempt to get a connection from the pool.</span></span><br><span class=\"line\">        <span class=\"comment\">// Internal是一个抽象类，instance是在OkHttpClient中实现的，get方法实现的时候从pool的get方法</span></span><br><span class=\"line\">        Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">          result = connection;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          selectedRoute = route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    closeQuietly(toClose);</span><br><span class=\"line\"></span><br><span class=\"line\">    ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 找到一条可复用的连接</span></span><br><span class=\"line\">      <span class=\"comment\">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 到达这里表示没有找到</span></span><br><span class=\"line\">    <span class=\"comment\">// 切换路由再在连接池里面找下，如果有则返回</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> newRouteSelection = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 检查是否有其他路由</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span> &amp;&amp; (routeSelection == <span class=\"keyword\">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class=\"line\">      newRouteSelection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      routeSelection = routeSelector.next();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (canceled) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newRouteSelection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class=\"line\">        <span class=\"comment\">// the pool. This could match due to connection coalescing.</span></span><br><span class=\"line\">        <span class=\"comment\">// 有其他路由, 遍历RooteSelector</span></span><br><span class=\"line\">        List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">          Route route = routes.get(i);</span><br><span class=\"line\">          Internal.instance.get(connectionPool, address, <span class=\"keyword\">this</span>, route);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            foundPooledConnection = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            result = connection;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.route = route;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!foundPooledConnection) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//没找到则创建一条</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (selectedRoute == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          selectedRoute = routeSelection.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class=\"line\">        <span class=\"comment\">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class=\"line\">        route = selectedRoute;</span><br><span class=\"line\">        refusedStreamCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class=\"line\">        <span class=\"comment\">//往连接中增加流</span></span><br><span class=\"line\">        acquire(result, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class=\"line\">    <span class=\"comment\">//如果第二次找到了可以复用的，则返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (foundPooledConnection) &#123;</span><br><span class=\"line\">      eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class=\"line\">    <span class=\"comment\">// 建立连接,开始握手</span></span><br><span class=\"line\">    result.connect(</span><br><span class=\"line\">        connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, call, eventListener);</span><br><span class=\"line\">    <span class=\"comment\">// 将这条路由从错误缓存中清除</span></span><br><span class=\"line\">    routeDatabase().connected(result.route());</span><br><span class=\"line\"></span><br><span class=\"line\">    Socket socket = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (connectionPool) &#123;</span><br><span class=\"line\">      reportedAcquired = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Pool the connection.</span></span><br><span class=\"line\">      <span class=\"comment\">//将这个请求加入连接池</span></span><br><span class=\"line\">      Internal.instance.put(connectionPool, result);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// If another multiplexed connection to the same address was created concurrently, then</span></span><br><span class=\"line\">      <span class=\"comment\">// release this connection and acquire that one.</span></span><br><span class=\"line\">      <span class=\"comment\">// 如果是多路复用，则合并</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (result.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回的是一个重复的socket</span></span><br><span class=\"line\">        socket = Internal.instance.deduplicate(connectionPool, address, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        result = connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭重复的socket</span></span><br><span class=\"line\">    closeQuietly(socket);</span><br><span class=\"line\"></span><br><span class=\"line\">    eventListener.connectionAcquired(call, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CollectionPool\"><a href=\"#CollectionPool\" class=\"headerlink\" title=\"CollectionPool\"></a>CollectionPool</h2><h3 id=\"主要成员变量\"><a href=\"#主要成员变量\" class=\"headerlink\" title=\"主要成员变量\"></a>主要成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Background threads are used to cleanup expired connections. There will be at most a single</span></span><br><span class=\"line\"><span class=\"comment\">* thread running per connection pool. The thread pool executor permits the pool itself to be</span></span><br><span class=\"line\"><span class=\"comment\">* garbage collected.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">被用来清理超时连接的后台线程. 在每个连接池中最多只会有一个这样的线程(虽然它是个线程池). </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor executor = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span> <span class=\"comment\">/* corePoolSize */</span>,</span><br><span class=\"line\">    Integer.MAX_VALUE <span class=\"comment\">/* maximumPoolSize */</span>, <span class=\"number\">60L</span> <span class=\"comment\">/* keepAliveTime */</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class=\"string\">\"OkHttp ConnectionPool\"</span>, <span class=\"keyword\">true</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** The maximum number of idle connections for each address. */</span></span><br><span class=\"line\"><span class=\"comment\">// 允许的每个host地址可以维持的最大空闲连接数量, 默认为5</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxIdleConnections;</span><br><span class=\"line\"><span class=\"comment\">// 允许的线程空闲的最大时间, 默认为5分钟</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> keepAliveDurationNs;</span><br><span class=\"line\"><span class=\"comment\">// 清理的task</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable cleanupRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> waitMillis = waitNanos / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">                waitNanos -= (waitMillis * <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ConnectionPool.<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        ConnectionPool.<span class=\"keyword\">this</span>.wait(waitMillis, (<span class=\"keyword\">int</span>) waitNanos);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 连接池中的连接集合</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;RealConnection&gt; connections = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 用来记录连接失败的路线名单 ?? 暂时没懂啥意思...</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> RouteDatabase routeDatabase = <span class=\"keyword\">new</span> RouteDatabase();</span><br><span class=\"line\"><span class=\"comment\">// 标记清理线程是否在运行</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> cleanupRunning;</span><br></pre></td></tr></table></figure>\n<p><strong>ConnectionPool创建的位置:</strong><br>ConnectionPool是在OkhttpClient在build是创建的, 默认就会创建连接池, 使用默认的参数. 当然, 也可以自己设置连接池, 修改默认参数(maxIdleConnections, keepAliveDurationNs)</p>\n<h3 id=\"cleanUpRunnable\"><a href=\"#cleanUpRunnable\" class=\"headerlink\" title=\"cleanUpRunnable\"></a>cleanUpRunnable</h3><p>会被放入线程池的清理任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Runnable cleanupRunnable = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// cleanUp方法做connection的清理工作, 会返回一个long值, 表示清理线程之后将要挂起的时间</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitNanos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> waitMillis = waitNanos / <span class=\"number\">1000000L</span>;</span><br><span class=\"line\">                waitNanos -= (waitMillis * <span class=\"number\">1000000L</span>);</span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (ConnectionPool.<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 挂起清理线程</span></span><br><span class=\"line\">                        ConnectionPool.<span class=\"keyword\">this</span>.wait(waitMillis, (<span class=\"keyword\">int</span>) waitNanos);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"cleanUp\"><a href=\"#cleanUp\" class=\"headerlink\" title=\"cleanUp\"></a>cleanUp</h3><p>找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Performs maintenance on this pool, evicting the connection that has been idle the longest if</span></span><br><span class=\"line\"><span class=\"comment\">* either it has exceeded the keep alive limit or the idle connections limit.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* &lt;p&gt;Returns the duration in nanos to sleep until the next scheduled call to this method. Returns</span></span><br><span class=\"line\"><span class=\"comment\">* -1 if no further cleanups are required.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">cleanup</span><span class=\"params\">(<span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> inUseConnectionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> idleConnectionCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    RealConnection longestIdleConnection = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class=\"line\">    <span class=\"comment\">// 找到需要清理的connection, 如果没有找到, 那么确定下次清理的时间. 也就是说, 只会清理一个合适的connection</span></span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">        RealConnection connection = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the connection is in use, keep searching.</span></span><br><span class=\"line\">        <span class=\"comment\">// pruneAndGetAllocationCount方法判断当前connection是否正在使用中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          inUseConnectionCount++;</span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        idleConnectionCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// If the connection is ready to be evicted, we're done.</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class=\"line\">        <span class=\"comment\">// 记录空闲最长的那个connection, 并且记录空闲的最长时间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class=\"line\">          longestIdleDurationNs = idleDurationNs;</span><br><span class=\"line\">          longestIdleConnection = connection;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (longestIdleDurationNs &gt;= <span class=\"keyword\">this</span>.keepAliveDurationNs</span><br><span class=\"line\">          || idleConnectionCount &gt; <span class=\"keyword\">this</span>.maxIdleConnections) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// We've found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class=\"line\">        <span class=\"comment\">// of the synchronized block).</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果 最长空闲的connection空闲时间超过限制, 或者 如果空闲的connection数量超过限制</span></span><br><span class=\"line\">        <span class=\"comment\">// 从connections集合中remove掉该connection</span></span><br><span class=\"line\">        connections.remove(longestIdleConnection);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (idleConnectionCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// A connection will be ready to evict soon.</span></span><br><span class=\"line\">        <span class=\"comment\">// 最长空闲的connection没有超出时间限制, 返回下次开启清理的时间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inUseConnectionCount &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span></span><br><span class=\"line\">        <span class=\"comment\">// 没有空闲的connection, 等待keepAliveDurationNs时间之后再次清理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> keepAliveDurationNs;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// No connections, idle or in use.</span></span><br><span class=\"line\">        <span class=\"comment\">// 根本没有connection, 返回-1, 直接终止清理任务</span></span><br><span class=\"line\">        cleanupRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    closeQuietly(longestIdleConnection.socket());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Cleanup again immediately.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pruneAndGetAllocationCount\"><a href=\"#pruneAndGetAllocationCount\" class=\"headerlink\" title=\"pruneAndGetAllocationCount\"></a>pruneAndGetAllocationCount</h3><p>判断该连接是否是空闲的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">pruneAndGetAllocationCount</span><span class=\"params\">(RealConnection connection, <span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; references.size(); ) &#123;</span><br><span class=\"line\">        Reference&lt;StreamAllocation&gt; reference = references.get(i);</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">//如果存在引用，就说明是活跃连接，就继续看下一个StreamAllocation</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (reference.get() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ... <span class=\"comment\">// 省略代码</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//如果没有引用，就移除</span></span><br><span class=\"line\">        references.remove(i);</span><br><span class=\"line\">        connection.noNewStreams = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果列表为空，就说明此连接上没有StreamAllocation引用了，就返回0，表示是空闲的连接</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (references.isEmpty()) &#123;</span><br><span class=\"line\">            connection.idleAtNanos = now - keepAliveDurationNs;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//遍历结束后，返回引用的数量，说明当前连接是活跃连接</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> references.size();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>判断连接是否空闲过程:</strong><br>RealConnection中有该连接所有的StreamAllocation的弱引用集合, 去除集合中为null的元素(弱引用…), 若集合为空, 则该连接时空闲的. </p>\n<h3 id=\"get和put\"><a href=\"#get和put\" class=\"headerlink\" title=\"get和put\"></a>get和put</h3><p><strong>get:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">RealConnection <span class=\"title\">get</span><span class=\"params\">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (RealConnection connection : connections) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//判断这个连接是否符合address和route, 判断过程很麻烦</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将streamAllocation和这个connection绑定</span></span><br><span class=\"line\">        streamAllocation.acquire(connection, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connection;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>put:</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(RealConnection connection)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!cleanupRunning) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当清理任务没有工作的时候, 将任务放入线程池中运行</span></span><br><span class=\"line\">    <span class=\"comment\">// 因为当connections集合为空时, 清理任务会终止</span></span><br><span class=\"line\">    <span class=\"comment\">// ? 既然只有一个清理线程存在, 那使用线程池的意义是什么 ???</span></span><br><span class=\"line\">    cleanupRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    executor.execute(cleanupRunnable);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  connections.add(connection);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"OkHttp3源码-CallServerInterceptor","date":"2019-11-16T17:10:03.000Z","_content":"\nCallServerInterceptor主要负责具体的访问服务端\n\n```java\n/** This is the last interceptor in the chain. It makes a network call to the server. */\n\n  @Override \n  public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    HttpCodec httpCodec = realChain.httpStream();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n    RealConnection connection = (RealConnection) realChain.connection();\n    Request request = realChain.request();\n\n    long sentRequestMillis = System.currentTimeMillis();\n\n    realChain.eventListener().requestHeadersStart(realChain.call());\n    // HttpCodec相当于流, 将请求header写入流\n    httpCodec.writeRequestHeaders(request);\n    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n    Response.Builder responseBuilder = null;\n    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n      // Continue\" response before transmitting the request body. If we don't get that, return\n      // what we did get (such as a 4xx response) without ever transmitting the request body.\n      // 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流.\n      // \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体\n      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n        // 发送请求头\n        httpCodec.flushRequest();\n        realChain.eventListener().responseHeadersStart(realChain.call());\n        // 读取response\n        responseBuilder = httpCodec.readResponseHeaders(true);\n      }\n\n      // 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, \n      // 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体\n      if (responseBuilder == null) {\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        // 将请求体写入流\n        realChain.eventListener().requestBodyStart(realChain.call());\n        long contentLength = request.body().contentLength();\n        CountingSink requestBodyOut =\n            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\n        request.body().writeTo(bufferedRequestBody);\n        bufferedRequestBody.close();\n        realChain.eventListener()\n            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n      } else if (!connection.isMultiplexed()) {\n        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n        // from being reused. Otherwise we're still obligated to transmit the request body to\n        // leave the connection in a consistent state.\n\n        // 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接)\n        streamAllocation.noNewStreams();\n      }\n    }\n\n    // 结束发送请求\n    httpCodec.finishRequest();\n\n    if (responseBuilder == null) {\n      realChain.eventListener().responseHeadersStart(realChain.call());\n      // 读取response的头\n      responseBuilder = httpCodec.readResponseHeaders(false);\n    }\n\n    // 构建带响应头的响应体\n    Response response = responseBuilder\n        .request(request)\n        .handshake(streamAllocation.connection().handshake())\n        .sentRequestAtMillis(sentRequestMillis)\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build();\n\n    int code = response.code();\n    if (code == 100) {\n      // server sent a 100-continue even though we did not request one.\n      // try again to read the actual response\n      responseBuilder = httpCodec.readResponseHeaders(false);\n\n      response = responseBuilder\n              .request(request)\n              .handshake(streamAllocation.connection().handshake())\n              .sentRequestAtMillis(sentRequestMillis)\n              .receivedResponseAtMillis(System.currentTimeMillis())\n              .build();\n\n      code = response.code();\n    }\n\n    realChain.eventListener()\n            .responseHeadersEnd(realChain.call(), response);\n\n    if (forWebSocket && code == 101) {\n      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n      response = response.newBuilder()\n          .body(Util.EMPTY_RESPONSE)\n          .build();\n    } else {\n      // 构建响应体\n      response = response.newBuilder()\n          .body(httpCodec.openResponseBody(response))\n          .build();\n    }\n\n    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n\n    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n      throw new ProtocolException(\n          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n    }\n\n    return response;\n  }\n```","source":"_posts/Android/源码解析/OkHttp3源码-CallServerInterceptor.md","raw":"---\ntitle: OkHttp3源码-CallServerInterceptor\ndate: 2019-11-17 01:10:03\ntags:\n- okhttp3\n- 源码解析\ncategories:\n- Android\n---\n\nCallServerInterceptor主要负责具体的访问服务端\n\n```java\n/** This is the last interceptor in the chain. It makes a network call to the server. */\n\n  @Override \n  public Response intercept(Chain chain) throws IOException {\n    RealInterceptorChain realChain = (RealInterceptorChain) chain;\n    HttpCodec httpCodec = realChain.httpStream();\n    StreamAllocation streamAllocation = realChain.streamAllocation();\n    RealConnection connection = (RealConnection) realChain.connection();\n    Request request = realChain.request();\n\n    long sentRequestMillis = System.currentTimeMillis();\n\n    realChain.eventListener().requestHeadersStart(realChain.call());\n    // HttpCodec相当于流, 将请求header写入流\n    httpCodec.writeRequestHeaders(request);\n    realChain.eventListener().requestHeadersEnd(realChain.call(), request);\n\n    Response.Builder responseBuilder = null;\n    if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {\n      // If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100\n      // Continue\" response before transmitting the request body. If we don't get that, return\n      // what we did get (such as a 4xx response) without ever transmitting the request body.\n      // 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流.\n      // \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体\n      if (\"100-continue\".equalsIgnoreCase(request.header(\"Expect\"))) {\n        // 发送请求头\n        httpCodec.flushRequest();\n        realChain.eventListener().responseHeadersStart(realChain.call());\n        // 读取response\n        responseBuilder = httpCodec.readResponseHeaders(true);\n      }\n\n      // 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, \n      // 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体\n      if (responseBuilder == null) {\n        // Write the request body if the \"Expect: 100-continue\" expectation was met.\n        // 将请求体写入流\n        realChain.eventListener().requestBodyStart(realChain.call());\n        long contentLength = request.body().contentLength();\n        CountingSink requestBodyOut =\n            new CountingSink(httpCodec.createRequestBody(request, contentLength));\n        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);\n\n        request.body().writeTo(bufferedRequestBody);\n        bufferedRequestBody.close();\n        realChain.eventListener()\n            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);\n      } else if (!connection.isMultiplexed()) {\n        // If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection\n        // from being reused. Otherwise we're still obligated to transmit the request body to\n        // leave the connection in a consistent state.\n\n        // 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接)\n        streamAllocation.noNewStreams();\n      }\n    }\n\n    // 结束发送请求\n    httpCodec.finishRequest();\n\n    if (responseBuilder == null) {\n      realChain.eventListener().responseHeadersStart(realChain.call());\n      // 读取response的头\n      responseBuilder = httpCodec.readResponseHeaders(false);\n    }\n\n    // 构建带响应头的响应体\n    Response response = responseBuilder\n        .request(request)\n        .handshake(streamAllocation.connection().handshake())\n        .sentRequestAtMillis(sentRequestMillis)\n        .receivedResponseAtMillis(System.currentTimeMillis())\n        .build();\n\n    int code = response.code();\n    if (code == 100) {\n      // server sent a 100-continue even though we did not request one.\n      // try again to read the actual response\n      responseBuilder = httpCodec.readResponseHeaders(false);\n\n      response = responseBuilder\n              .request(request)\n              .handshake(streamAllocation.connection().handshake())\n              .sentRequestAtMillis(sentRequestMillis)\n              .receivedResponseAtMillis(System.currentTimeMillis())\n              .build();\n\n      code = response.code();\n    }\n\n    realChain.eventListener()\n            .responseHeadersEnd(realChain.call(), response);\n\n    if (forWebSocket && code == 101) {\n      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.\n      response = response.newBuilder()\n          .body(Util.EMPTY_RESPONSE)\n          .build();\n    } else {\n      // 构建响应体\n      response = response.newBuilder()\n          .body(httpCodec.openResponseBody(response))\n          .build();\n    }\n\n    if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\"))\n        || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) {\n      streamAllocation.noNewStreams();\n    }\n\n    if ((code == 204 || code == 205) && response.body().contentLength() > 0) {\n      throw new ProtocolException(\n          \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength());\n    }\n\n    return response;\n  }\n```","slug":"Android/源码解析/OkHttp3源码-CallServerInterceptor","published":1,"updated":"2021-10-03T01:57:41.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9x006ig0jeawynr8bm","content":"<p>CallServerInterceptor主要负责具体的访问服务端</p><a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** This is the last interceptor in the chain. It makes a network call to the server. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class=\"line\">    <span class=\"comment\">// HttpCodec相当于流, 将请求header写入流</span></span><br><span class=\"line\">    httpCodec.writeRequestHeaders(request);</span><br><span class=\"line\">    realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class=\"line\"></span><br><span class=\"line\">    Response.Builder responseBuilder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100</span></span><br><span class=\"line\">      <span class=\"comment\">// Continue\" response before transmitting the request body. If we don't get that, return</span></span><br><span class=\"line\">      <span class=\"comment\">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class=\"line\">      <span class=\"comment\">// 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流.</span></span><br><span class=\"line\">      <span class=\"comment\">// \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发送请求头</span></span><br><span class=\"line\">        httpCodec.flushRequest();</span><br><span class=\"line\">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">        <span class=\"comment\">// 读取response</span></span><br><span class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, </span></span><br><span class=\"line\">      <span class=\"comment\">// 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write the request body if the \"Expect: 100-continue\" expectation was met.</span></span><br><span class=\"line\">        <span class=\"comment\">// 将请求体写入流</span></span><br><span class=\"line\">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> contentLength = request.body().contentLength();</span><br><span class=\"line\">        CountingSink requestBodyOut =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class=\"line\">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class=\"line\"></span><br><span class=\"line\">        request.body().writeTo(bufferedRequestBody);</span><br><span class=\"line\">        bufferedRequestBody.close();</span><br><span class=\"line\">        realChain.eventListener()</span><br><span class=\"line\">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class=\"line\">        <span class=\"comment\">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class=\"line\">        <span class=\"comment\">// leave the connection in a consistent state.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接)</span></span><br><span class=\"line\">        streamAllocation.noNewStreams();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 结束发送请求</span></span><br><span class=\"line\">    httpCodec.finishRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">      <span class=\"comment\">// 读取response的头</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建带响应头的响应体</span></span><br><span class=\"line\">    Response response = responseBuilder</span><br><span class=\"line\">        .request(request)</span><br><span class=\"line\">        .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> code = response.code();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// server sent a 100-continue even though we did not request one.</span></span><br><span class=\"line\">      <span class=\"comment\">// try again to read the actual response</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      response = responseBuilder</span><br><span class=\"line\">              .request(request)</span><br><span class=\"line\">              .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">              .build();</span><br><span class=\"line\"></span><br><span class=\"line\">      code = response.code();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener()</span><br><span class=\"line\">            .responseHeadersEnd(realChain.call(), response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forWebSocket &amp;&amp; code == <span class=\"number\">101</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 构建响应体</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(httpCodec.openResponseBody(response))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.request().header(<span class=\"string\">\"Connection\"</span>))</span><br><span class=\"line\">        || <span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.header(<span class=\"string\">\"Connection\"</span>))) &#123;</span><br><span class=\"line\">      streamAllocation.noNewStreams();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(</span><br><span class=\"line\">          <span class=\"string\">\"HTTP \"</span> + code + <span class=\"string\">\" had non-zero Content-Length: \"</span> + response.body().contentLength());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>CallServerInterceptor主要负责具体的访问服务端</p>","more":"\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** This is the last interceptor in the chain. It makes a network call to the server. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">intercept</span><span class=\"params\">(Chain chain)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class=\"line\">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class=\"line\">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class=\"line\">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class=\"line\">    Request request = realChain.request();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener().requestHeadersStart(realChain.call());</span><br><span class=\"line\">    <span class=\"comment\">// HttpCodec相当于流, 将请求header写入流</span></span><br><span class=\"line\">    httpCodec.writeRequestHeaders(request);</span><br><span class=\"line\">    realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class=\"line\"></span><br><span class=\"line\">    Response.Builder responseBuilder = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// If there's a \"Expect: 100-continue\" header on the request, wait for a \"HTTP/1.1 100</span></span><br><span class=\"line\">      <span class=\"comment\">// Continue\" response before transmitting the request body. If we don't get that, return</span></span><br><span class=\"line\">      <span class=\"comment\">// what we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class=\"line\">      <span class=\"comment\">// 当请求头包含\"Expect: 100-continue\"字段, 先发送请求头, 若服务端返回code 100, 继续发送请求体. 若返回code 4xx, 关闭流.</span></span><br><span class=\"line\">      <span class=\"comment\">// \"Expect: 100-continue\": http协议里的, 表示先发送请求头, 若服务端同意, 再发送请求体</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">\"100-continue\"</span>.equalsIgnoreCase(request.header(<span class=\"string\">\"Expect\"</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发送请求头</span></span><br><span class=\"line\">        httpCodec.flushRequest();</span><br><span class=\"line\">        realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">        <span class=\"comment\">// 读取response</span></span><br><span class=\"line\">        responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 当responseBuilder为null, 则表示没有\"Expect: 100-continue\"头, </span></span><br><span class=\"line\">      <span class=\"comment\">// 或者有\"Expect: 100-continue\", 但是服务端同意继续发送请求体</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Write the request body if the \"Expect: 100-continue\" expectation was met.</span></span><br><span class=\"line\">        <span class=\"comment\">// 将请求体写入流</span></span><br><span class=\"line\">        realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> contentLength = request.body().contentLength();</span><br><span class=\"line\">        CountingSink requestBodyOut =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class=\"line\">        BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class=\"line\"></span><br><span class=\"line\">        request.body().writeTo(bufferedRequestBody);</span><br><span class=\"line\">        bufferedRequestBody.close();</span><br><span class=\"line\">        realChain.eventListener()</span><br><span class=\"line\">            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// If the \"Expect: 100-continue\" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class=\"line\">        <span class=\"comment\">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class=\"line\">        <span class=\"comment\">// leave the connection in a consistent state.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 包含\"Expect: 100-continue\"的请求没有得到请求头允许, 如果是http1.x, 则关闭流(http1.1 不允许多个流同时复用一个http连接)</span></span><br><span class=\"line\">        streamAllocation.noNewStreams();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 结束发送请求</span></span><br><span class=\"line\">    httpCodec.finishRequest();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (responseBuilder == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class=\"line\">      <span class=\"comment\">// 读取response的头</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构建带响应头的响应体</span></span><br><span class=\"line\">    Response response = responseBuilder</span><br><span class=\"line\">        .request(request)</span><br><span class=\"line\">        .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> code = response.code();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (code == <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// server sent a 100-continue even though we did not request one.</span></span><br><span class=\"line\">      <span class=\"comment\">// try again to read the actual response</span></span><br><span class=\"line\">      responseBuilder = httpCodec.readResponseHeaders(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      response = responseBuilder</span><br><span class=\"line\">              .request(request)</span><br><span class=\"line\">              .handshake(streamAllocation.connection().handshake())</span><br><span class=\"line\">              .sentRequestAtMillis(sentRequestMillis)</span><br><span class=\"line\">              .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class=\"line\">              .build();</span><br><span class=\"line\"></span><br><span class=\"line\">      code = response.code();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    realChain.eventListener()</span><br><span class=\"line\">            .responseHeadersEnd(realChain.call(), response);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (forWebSocket &amp;&amp; code == <span class=\"number\">101</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(Util.EMPTY_RESPONSE)</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 构建响应体</span></span><br><span class=\"line\">      response = response.newBuilder()</span><br><span class=\"line\">          .body(httpCodec.openResponseBody(response))</span><br><span class=\"line\">          .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.request().header(<span class=\"string\">\"Connection\"</span>))</span><br><span class=\"line\">        || <span class=\"string\">\"close\"</span>.equalsIgnoreCase(response.header(<span class=\"string\">\"Connection\"</span>))) &#123;</span><br><span class=\"line\">      streamAllocation.noNewStreams();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((code == <span class=\"number\">204</span> || code == <span class=\"number\">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ProtocolException(</span><br><span class=\"line\">          <span class=\"string\">\"HTTP \"</span> + code + <span class=\"string\">\" had non-zero Content-Length: \"</span> + response.body().contentLength());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>"},{"title":"OkHttp3源码-发起请求的主要流程","date":"2019-11-13T13:21:04.000Z","_content":"\n# OkHttp3源码解析-发起请求的主要流程\n\n结合网上的博客和自己看的源码, 写的简单理解.\n\n## 主要的类:\n* OkHttpClient:\n    用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等\n* Request:\n    用户对单次请求的数据进行配置, uur, 数据参数等. \n* Call:\n    在框架内部表示对请求的封装\n* Dispatcher:\n    在框架内部对请求进行分发\n\n## OkHttpClient:\n\n主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用.\n\n```java\n/**\n* Prepares the {@code request} to be executed at some point in the future.\n*/\n@Override public Call newCall(Request request) {\n    return RealCall.newRealCall(this, request, false /* for web socket */);\n}\n```\n\n## Call:\n\n### 构造方法\n```java\n  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    this.client = client;\n    this.originalRequest = originalRequest;\n    this.forWebSocket = forWebSocket;\n    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);\n    this.timeout = new AsyncTimeout() {\n      @Override protected void timedOut() {\n        cancel();\n      }\n    };\n    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);\n  }\n\n  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    // Safely publish the Call instance to the EventListener.\n    RealCall call = new RealCall(client, originalRequest, forWebSocket);\n    call.eventListener = client.eventListenerFactory().create(call);\n    return call;\n  }\n```\n\n### 同步执行一个call\n\n在RealCall中有一个execute方法, 这里发起一个同步请求\n```java\n  @Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    timeout.enter();\n    eventListener.callStart(this);\n    try {\n      client.dispatcher().executed(this);\n      // getResponseWithInterceptorChain()是具体的请求的操作过程\n      Response result = getResponseWithInterceptorChain();\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } catch (IOException e) {\n      e = timeoutExit(e);\n      eventListener.callFailed(this, e);\n      throw e;\n    } finally {\n      client.dispatcher().finished(this);\n    }\n  }\n```\n\n**getResponseWithInterceptorChain()方法是请求发出的最终执行方法.** 也就是说RealCall中调用execute()就已经直接同步开始了请求操作.\n\n但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? \n\n详细的内容可以看Dispatcher的源码解析.\n\n### 异步执行一个call\n\nRealCall中的enqueue方法, 发起一个异步请求\n```java\n  @Override public void enqueue(Callback responseCallback) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    eventListener.callStart(this);\n    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n```\n可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类\n\n**AsyncCall中的executeOn, execute**\n```java\n/**\n* Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up\n* if the executor has been shut down by reporting the call as failed.\n*/\nvoid executeOn(ExecutorService executorService) {\n      assert (!Thread.holdsLock(client.dispatcher()));\n      boolean success = false;\n      try {\n        executorService.execute(this);\n        success = true;\n      } catch (RejectedExecutionException e) {\n        InterruptedIOException ioException = new InterruptedIOException(\"executor rejected\");\n        ioException.initCause(e);\n        eventListener.callFailed(RealCall.this, ioException);\n        responseCallback.onFailure(RealCall.this, ioException);\n      } finally {\n        if (!success) {\n          client.dispatcher().finished(this); // This call is no longer running!\n        }\n      }\n    }\n\n@Override protected void execute() {\n  boolean signalledCallback = false;\n  timeout.enter();\n  try {\n    Response response = getResponseWithInterceptorChain();\n    signalledCallback = true;\n    responseCallback.onResponse(RealCall.this, response);\n  } catch (IOException e) {\n    e = timeoutExit(e);\n    if (signalledCallback) {\n      // Do not signal the callback twice!\n      Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n    } else {\n      eventListener.callFailed(RealCall.this, e);\n      responseCallback.onFailure(RealCall.this, e);\n    }\n  } finally {\n    client.dispatcher().finished(this);\n  }\n}\n```\n再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行.\n\n\n## Dispatcher\n\n### 重要的成员变量\n\n```java\n  private int maxRequests = 64;\n  private int maxRequestsPerHost = 5;\n  private @Nullable Runnable idleCallback;\n\n  /** Executes calls. Created lazily. */\n  // 这是一个线程池, 并且实现了懒加载\n  private @Nullable ExecutorService executorService;\n\n  /** Ready async calls in the order they'll be run. */\n  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n\n  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\n  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n```\n\n**为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:**\n答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列.\n\n### ExcutorService\n\n```java\npublic synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n    }\n    return executorService;\n}\n```\n\n这个线程池其实是一个CacheThreadPool. 他的特点是: \n* 底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)\n* 通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定时间，则该线程会被销毁。\n* 适用：执行很多短期异步的小程序或者负载较轻的服务器\n\n检查调用executorService()方法的地方, 是一个promoteAndExecute()方法\n\n### enqueue(AsyncCall call)\n\n```java\nvoid enqueue(AsyncCall call) {\n    synchronized (this) {\n      readyAsyncCalls.add(call);\n    }\n    promoteAndExecute();\n}\n```\n上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步\n\n### promoteAndExecute()\n\n```java\n\n  /**\n   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs\n   * them on the executor service. Must not be called with synchronization because executing calls\n   * can call into user code.\n   *\n   * @return true if the dispatcher is currently running calls.\n   */\n  // 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call\n  // 如果成功执行上面的操作, 返回true\n  private boolean promoteAndExecute() {\n    assert (!Thread.holdsLock(this));\n\n    List<AsyncCall> executableCalls = new ArrayList<>();\n    boolean isRunning;\n    synchronized (this) {\n      // 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去\n      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n        AsyncCall asyncCall = i.next();\n\n        // 到达了max限制, break\n        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.\n        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.\n\n        i.remove();\n        executableCalls.add(asyncCall);\n        runningAsyncCalls.add(asyncCall);\n      }\n      isRunning = runningCallsCount() > 0;\n    }\n\n\n    for (int i = 0, size = executableCalls.size(); i < size; i++) {\n      AsyncCall asyncCall = executableCalls.get(i);\n      // 在线程池中执行这个call\n      asyncCall.executeOn(executorService());\n    }\n\n    return isRunning;\n  }\n```\n\npromoteAndExecute()方法的解析直接看上面源码的注释. \n\n结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行. \n想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢? \n想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法\n\n### finished(Deque<T> calls, T call)\n\n```java\nprivate <T> void finished(Deque<T> calls, T call) {\n    Runnable idleCallback;\n    synchronized (this) {\n        if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\");\n        idleCallback = this.idleCallback;\n    }\n\n    boolean isRunning = promoteAndExecute();\n\n    if (!isRunning && idleCallback != null) {\n        idleCallback.run();\n    }\n}\n```\n在RealCall和AsyncCall代码中, 能看到在调用了责任链完成一次请求之后，调用了`despatcher.finished`方法从readyAsyncCalls集合里获取下一个call来执行\n\n### executed(RealCall call)\n```java\nsynchronized void executed(RealCall call) {\n    runningSyncCalls.add(call);\n}\n```\n可以看到只是做了一个把 call 加入到 runningSyncCalls 里\n\n\n\n### 同步的call\n\n```java\n/** Used by {@code Call#execute} to signal it is in-flight. */\nsynchronized void executed(RealCall call) {\n    runningSyncCalls.add(call);\n}\n```\n\n同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已. \n\n\n\n\n\n\n\n","source":"_posts/Android/源码解析/OkHttp3源码-发起请求的主要流程.md","raw":"---\ntitle: OkHttp3源码-发起请求的主要流程\ndate: 2019-11-13 21:21:04\ntags:\n- Okhttp3\n- 源码解析\ncategories:\n- Android\n---\n\n# OkHttp3源码解析-发起请求的主要流程\n\n结合网上的博客和自己看的源码, 写的简单理解.\n\n## 主要的类:\n* OkHttpClient:\n    用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等\n* Request:\n    用户对单次请求的数据进行配置, uur, 数据参数等. \n* Call:\n    在框架内部表示对请求的封装\n* Dispatcher:\n    在框架内部对请求进行分发\n\n## OkHttpClient:\n\n主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用.\n\n```java\n/**\n* Prepares the {@code request} to be executed at some point in the future.\n*/\n@Override public Call newCall(Request request) {\n    return RealCall.newRealCall(this, request, false /* for web socket */);\n}\n```\n\n## Call:\n\n### 构造方法\n```java\n  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    this.client = client;\n    this.originalRequest = originalRequest;\n    this.forWebSocket = forWebSocket;\n    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);\n    this.timeout = new AsyncTimeout() {\n      @Override protected void timedOut() {\n        cancel();\n      }\n    };\n    this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);\n  }\n\n  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {\n    // Safely publish the Call instance to the EventListener.\n    RealCall call = new RealCall(client, originalRequest, forWebSocket);\n    call.eventListener = client.eventListenerFactory().create(call);\n    return call;\n  }\n```\n\n### 同步执行一个call\n\n在RealCall中有一个execute方法, 这里发起一个同步请求\n```java\n  @Override public Response execute() throws IOException {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    timeout.enter();\n    eventListener.callStart(this);\n    try {\n      client.dispatcher().executed(this);\n      // getResponseWithInterceptorChain()是具体的请求的操作过程\n      Response result = getResponseWithInterceptorChain();\n      if (result == null) throw new IOException(\"Canceled\");\n      return result;\n    } catch (IOException e) {\n      e = timeoutExit(e);\n      eventListener.callFailed(this, e);\n      throw e;\n    } finally {\n      client.dispatcher().finished(this);\n    }\n  }\n```\n\n**getResponseWithInterceptorChain()方法是请求发出的最终执行方法.** 也就是说RealCall中调用execute()就已经直接同步开始了请求操作.\n\n但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? \n\n详细的内容可以看Dispatcher的源码解析.\n\n### 异步执行一个call\n\nRealCall中的enqueue方法, 发起一个异步请求\n```java\n  @Override public void enqueue(Callback responseCallback) {\n    synchronized (this) {\n      if (executed) throw new IllegalStateException(\"Already Executed\");\n      executed = true;\n    }\n    captureCallStackTrace();\n    eventListener.callStart(this);\n    client.dispatcher().enqueue(new AsyncCall(responseCallback));\n  }\n```\n可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类\n\n**AsyncCall中的executeOn, execute**\n```java\n/**\n* Attempt to enqueue this async call on {@code executorService}. This will attempt to clean up\n* if the executor has been shut down by reporting the call as failed.\n*/\nvoid executeOn(ExecutorService executorService) {\n      assert (!Thread.holdsLock(client.dispatcher()));\n      boolean success = false;\n      try {\n        executorService.execute(this);\n        success = true;\n      } catch (RejectedExecutionException e) {\n        InterruptedIOException ioException = new InterruptedIOException(\"executor rejected\");\n        ioException.initCause(e);\n        eventListener.callFailed(RealCall.this, ioException);\n        responseCallback.onFailure(RealCall.this, ioException);\n      } finally {\n        if (!success) {\n          client.dispatcher().finished(this); // This call is no longer running!\n        }\n      }\n    }\n\n@Override protected void execute() {\n  boolean signalledCallback = false;\n  timeout.enter();\n  try {\n    Response response = getResponseWithInterceptorChain();\n    signalledCallback = true;\n    responseCallback.onResponse(RealCall.this, response);\n  } catch (IOException e) {\n    e = timeoutExit(e);\n    if (signalledCallback) {\n      // Do not signal the callback twice!\n      Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e);\n    } else {\n      eventListener.callFailed(RealCall.this, e);\n      responseCallback.onFailure(RealCall.this, e);\n    }\n  } finally {\n    client.dispatcher().finished(this);\n  }\n}\n```\n再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行.\n\n\n## Dispatcher\n\n### 重要的成员变量\n\n```java\n  private int maxRequests = 64;\n  private int maxRequestsPerHost = 5;\n  private @Nullable Runnable idleCallback;\n\n  /** Executes calls. Created lazily. */\n  // 这是一个线程池, 并且实现了懒加载\n  private @Nullable ExecutorService executorService;\n\n  /** Ready async calls in the order they'll be run. */\n  private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();\n\n  /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */\n  private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();\n\n  /** Running synchronous calls. Includes canceled calls that haven't finished yet. */\n  private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();\n```\n\n**为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:**\n答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列.\n\n### ExcutorService\n\n```java\npublic synchronized ExecutorService executorService() {\n    if (executorService == null) {\n      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n          new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n    }\n    return executorService;\n}\n```\n\n这个线程池其实是一个CacheThreadPool. 他的特点是: \n* 底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)\n* 通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定时间，则该线程会被销毁。\n* 适用：执行很多短期异步的小程序或者负载较轻的服务器\n\n检查调用executorService()方法的地方, 是一个promoteAndExecute()方法\n\n### enqueue(AsyncCall call)\n\n```java\nvoid enqueue(AsyncCall call) {\n    synchronized (this) {\n      readyAsyncCalls.add(call);\n    }\n    promoteAndExecute();\n}\n```\n上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步\n\n### promoteAndExecute()\n\n```java\n\n  /**\n   * Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs\n   * them on the executor service. Must not be called with synchronization because executing calls\n   * can call into user code.\n   *\n   * @return true if the dispatcher is currently running calls.\n   */\n  // 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call\n  // 如果成功执行上面的操作, 返回true\n  private boolean promoteAndExecute() {\n    assert (!Thread.holdsLock(this));\n\n    List<AsyncCall> executableCalls = new ArrayList<>();\n    boolean isRunning;\n    synchronized (this) {\n      // 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去\n      for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n        AsyncCall asyncCall = i.next();\n\n        // 到达了max限制, break\n        if (runningAsyncCalls.size() >= maxRequests) break; // Max capacity.\n        if (runningCallsForHost(asyncCall) >= maxRequestsPerHost) continue; // Host max capacity.\n\n        i.remove();\n        executableCalls.add(asyncCall);\n        runningAsyncCalls.add(asyncCall);\n      }\n      isRunning = runningCallsCount() > 0;\n    }\n\n\n    for (int i = 0, size = executableCalls.size(); i < size; i++) {\n      AsyncCall asyncCall = executableCalls.get(i);\n      // 在线程池中执行这个call\n      asyncCall.executeOn(executorService());\n    }\n\n    return isRunning;\n  }\n```\n\npromoteAndExecute()方法的解析直接看上面源码的注释. \n\n结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行. \n想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢? \n想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法\n\n### finished(Deque<T> calls, T call)\n\n```java\nprivate <T> void finished(Deque<T> calls, T call) {\n    Runnable idleCallback;\n    synchronized (this) {\n        if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\");\n        idleCallback = this.idleCallback;\n    }\n\n    boolean isRunning = promoteAndExecute();\n\n    if (!isRunning && idleCallback != null) {\n        idleCallback.run();\n    }\n}\n```\n在RealCall和AsyncCall代码中, 能看到在调用了责任链完成一次请求之后，调用了`despatcher.finished`方法从readyAsyncCalls集合里获取下一个call来执行\n\n### executed(RealCall call)\n```java\nsynchronized void executed(RealCall call) {\n    runningSyncCalls.add(call);\n}\n```\n可以看到只是做了一个把 call 加入到 runningSyncCalls 里\n\n\n\n### 同步的call\n\n```java\n/** Used by {@code Call#execute} to signal it is in-flight. */\nsynchronized void executed(RealCall call) {\n    runningSyncCalls.add(call);\n}\n```\n\n同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已. \n\n\n\n\n\n\n\n","slug":"Android/源码解析/OkHttp3源码-发起请求的主要流程","published":1,"updated":"2022-06-12T06:54:54.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl4edno9y006lg0jeb05uk0a3","content":"<h1 id=\"OkHttp3源码解析-发起请求的主要流程\"><a href=\"#OkHttp3源码解析-发起请求的主要流程\" class=\"headerlink\" title=\"OkHttp3源码解析-发起请求的主要流程\"></a>OkHttp3源码解析-发起请求的主要流程</h1><a id=\"more\"></a><p>结合网上的博客和自己看的源码, 写的简单理解.</p>\n<h2 id=\"主要的类\"><a href=\"#主要的类\" class=\"headerlink\" title=\"主要的类:\"></a>主要的类:</h2><ul>\n<li>OkHttpClient:<br>  用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等</li>\n<li>Request:<br>  用户对单次请求的数据进行配置, uur, 数据参数等. </li>\n<li>Call:<br>  在框架内部表示对请求的封装</li>\n<li>Dispatcher:<br>  在框架内部对请求进行分发</li>\n</ul>\n<h2 id=\"OkHttpClient\"><a href=\"#OkHttpClient\" class=\"headerlink\" title=\"OkHttpClient:\"></a>OkHttpClient:</h2><p>主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Prepares the &#123;<span class=\"doctag\">@code</span> request&#125; to be executed at some point in the future.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call <span class=\"title\">newCall</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RealCall.newRealCall(<span class=\"keyword\">this</span>, request, <span class=\"keyword\">false</span> <span class=\"comment\">/* for web socket */</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Call\"><a href=\"#Call\" class=\"headerlink\" title=\"Call:\"></a>Call:</h2><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">RealCall</span><span class=\"params\">(OkHttpClient client, Request originalRequest, <span class=\"keyword\">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.originalRequest = originalRequest;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.forWebSocket = forWebSocket;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.retryAndFollowUpInterceptor = <span class=\"keyword\">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout = <span class=\"keyword\">new</span> AsyncTimeout() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">timedOut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> RealCall <span class=\"title\">newRealCall</span><span class=\"params\">(OkHttpClient client, Request originalRequest, <span class=\"keyword\">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Safely publish the Call instance to the EventListener.</span></span><br><span class=\"line\">  RealCall call = <span class=\"keyword\">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class=\"line\">  call.eventListener = client.eventListenerFactory().create(call);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> call;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步执行一个call\"><a href=\"#同步执行一个call\" class=\"headerlink\" title=\"同步执行一个call\"></a>同步执行一个call</h3><p>在RealCall中有一个execute方法, 这里发起一个同步请求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">    executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  captureCallStackTrace();</span><br><span class=\"line\">  timeout.enter();</span><br><span class=\"line\">  eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    client.dispatcher().executed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">// getResponseWithInterceptorChain()是具体的请求的操作过程</span></span><br><span class=\"line\">    Response result = getResponseWithInterceptorChain();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e = timeoutExit(e);</span><br><span class=\"line\">    eventListener.callFailed(<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>getResponseWithInterceptorChain()方法是请求发出的最终执行方法.</strong> 也就是说RealCall中调用execute()就已经直接同步开始了请求操作.</p>\n<p>但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? </p>\n<p>详细的内容可以看Dispatcher的源码解析.</p>\n<h3 id=\"异步执行一个call\"><a href=\"#异步执行一个call\" class=\"headerlink\" title=\"异步执行一个call\"></a>异步执行一个call</h3><p>RealCall中的enqueue方法, 发起一个异步请求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Callback responseCallback)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">    executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  captureCallStackTrace();</span><br><span class=\"line\">  eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  client.dispatcher().enqueue(<span class=\"keyword\">new</span> AsyncCall(responseCallback));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类</p>\n<p><strong>AsyncCall中的executeOn, execute</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Attempt to enqueue this async call on &#123;<span class=\"doctag\">@code</span> executorService&#125;. This will attempt to clean up</span></span><br><span class=\"line\"><span class=\"comment\">* if the executor has been shut down by reporting the call as failed.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executeOn</span><span class=\"params\">(ExecutorService executorService)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        executorService.execute(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        success = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</span><br><span class=\"line\">        InterruptedIOException ioException = <span class=\"keyword\">new</span> InterruptedIOException(<span class=\"string\">\"executor rejected\"</span>);</span><br><span class=\"line\">        ioException.initCause(e);</span><br><span class=\"line\">        eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, ioException);</span><br><span class=\"line\">        responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, ioException);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">          client.dispatcher().finished(<span class=\"keyword\">this</span>); <span class=\"comment\">// This call is no longer running!</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> signalledCallback = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  timeout.enter();</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Response response = getResponseWithInterceptorChain();</span><br><span class=\"line\">    signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    responseCallback.onResponse(RealCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e = timeoutExit(e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (signalledCallback) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Do not signal the callback twice!</span></span><br><span class=\"line\">      Platform.get().log(INFO, <span class=\"string\">\"Callback failure for \"</span> + toLoggableString(), e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">      responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行.</p>\n<h2 id=\"Dispatcher\"><a href=\"#Dispatcher\" class=\"headerlink\" title=\"Dispatcher\"></a>Dispatcher</h2><h3 id=\"重要的成员变量\"><a href=\"#重要的成员变量\" class=\"headerlink\" title=\"重要的成员变量\"></a>重要的成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequests = <span class=\"number\">64</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequestsPerHost = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> Runnable idleCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Executes calls. Created lazily. */</span></span><br><span class=\"line\"><span class=\"comment\">// 这是一个线程池, 并且实现了懒加载</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> ExecutorService executorService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Ready async calls in the order they'll be run. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p><strong>为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:</strong><br>答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列.</p>\n<h3 id=\"ExcutorService\"><a href=\"#ExcutorService\" class=\"headerlink\" title=\"ExcutorService\"></a>ExcutorService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> ExecutorService <span class=\"title\">executorService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executorService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      executorService = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE, <span class=\"number\">60</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">          <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class=\"string\">\"OkHttp Dispatcher\"</span>, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executorService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个线程池其实是一个CacheThreadPool. 他的特点是: </p>\n<ul>\n<li>底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</li>\n<li>通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定时间，则该线程会被销毁。</li>\n<li>适用：执行很多短期异步的小程序或者负载较轻的服务器</li>\n</ul>\n<p>检查调用executorService()方法的地方, 是一个promoteAndExecute()方法</p>\n<h3 id=\"enqueue-AsyncCall-call\"><a href=\"#enqueue-AsyncCall-call\" class=\"headerlink\" title=\"enqueue(AsyncCall call)\"></a>enqueue(AsyncCall call)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(AsyncCall call)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      readyAsyncCalls.add(call);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    promoteAndExecute();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步</p>\n<h3 id=\"promoteAndExecute\"><a href=\"#promoteAndExecute\" class=\"headerlink\" title=\"promoteAndExecute()\"></a>promoteAndExecute()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Promotes eligible calls from &#123;<span class=\"doctag\">@link</span> #readyAsyncCalls&#125; to &#123;<span class=\"doctag\">@link</span> #runningAsyncCalls&#125; and runs</span></span><br><span class=\"line\"><span class=\"comment\"> * them on the executor service. Must not be called with synchronization because executing calls</span></span><br><span class=\"line\"><span class=\"comment\"> * can call into user code.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if the dispatcher is currently running calls.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call</span></span><br><span class=\"line\"><span class=\"comment\">// 如果成功执行上面的操作, 返回true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">promoteAndExecute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (!Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  List&lt;AsyncCall&gt; executableCalls = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> isRunning;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">      AsyncCall asyncCall = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 到达了max限制, break</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class=\"keyword\">break</span>; <span class=\"comment\">// Max capacity.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class=\"keyword\">continue</span>; <span class=\"comment\">// Host max capacity.</span></span><br><span class=\"line\"></span><br><span class=\"line\">      i.remove();</span><br><span class=\"line\">      executableCalls.add(asyncCall);</span><br><span class=\"line\">      runningAsyncCalls.add(asyncCall);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    isRunning = runningCallsCount() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">    AsyncCall asyncCall = executableCalls.get(i);</span><br><span class=\"line\">    <span class=\"comment\">// 在线程池中执行这个call</span></span><br><span class=\"line\">    asyncCall.executeOn(executorService());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> isRunning;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>promoteAndExecute()方法的解析直接看上面源码的注释. </p>\n<p>结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行.<br>想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢?<br>想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法</p>\n<h3 id=\"finished-Deque-calls-T-call\"><a href=\"#finished-Deque-calls-T-call\" class=\"headerlink\" title=\"finished(Deque calls, T call)\"></a>finished(Deque<t> calls, T call)</t></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class=\"line\">    Runnable idleCallback;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!calls.remove(call)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Call wasn't in-flight!\"</span>);</span><br><span class=\"line\">        idleCallback = <span class=\"keyword\">this</span>.idleCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isRunning = promoteAndExecute();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isRunning &amp;&amp; idleCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        idleCallback.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在RealCall和AsyncCall代码中, 能看到在调用了责任链完成一次请求之后，调用了<code>despatcher.finished</code>方法从readyAsyncCalls集合里获取下一个call来执行</p>\n<h3 id=\"executed-RealCall-call\"><a href=\"#executed-RealCall-call\" class=\"headerlink\" title=\"executed(RealCall call)\"></a>executed(RealCall call)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">executed</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    runningSyncCalls.add(call);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到只是做了一个把 call 加入到 runningSyncCalls 里</p>\n<h3 id=\"同步的call\"><a href=\"#同步的call\" class=\"headerlink\" title=\"同步的call\"></a>同步的call</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Used by &#123;<span class=\"doctag\">@code</span> Call#execute&#125; to signal it is in-flight. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">executed</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    runningSyncCalls.add(call);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已. </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"OkHttp3源码解析-发起请求的主要流程\"><a href=\"#OkHttp3源码解析-发起请求的主要流程\" class=\"headerlink\" title=\"OkHttp3源码解析-发起请求的主要流程\"></a>OkHttp3源码解析-发起请求的主要流程</h1>","more":"<p>结合网上的博客和自己看的源码, 写的简单理解.</p>\n<h2 id=\"主要的类\"><a href=\"#主要的类\" class=\"headerlink\" title=\"主要的类:\"></a>主要的类:</h2><ul>\n<li>OkHttpClient:<br>  用户对请求进行配置的类, 配置拦截器, cache管理, 超时时间等</li>\n<li>Request:<br>  用户对单次请求的数据进行配置, uur, 数据参数等. </li>\n<li>Call:<br>  在框架内部表示对请求的封装</li>\n<li>Dispatcher:<br>  在框架内部对请求进行分发</li>\n</ul>\n<h2 id=\"OkHttpClient\"><a href=\"#OkHttpClient\" class=\"headerlink\" title=\"OkHttpClient:\"></a>OkHttpClient:</h2><p>主要是一些请求的配置操作, 这里没什么好说的. 看一下最常用的方法newCall的调用.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Prepares the &#123;<span class=\"doctag\">@code</span> request&#125; to be executed at some point in the future.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Call <span class=\"title\">newCall</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RealCall.newRealCall(<span class=\"keyword\">this</span>, request, <span class=\"keyword\">false</span> <span class=\"comment\">/* for web socket */</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Call\"><a href=\"#Call\" class=\"headerlink\" title=\"Call:\"></a>Call:</h2><h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">RealCall</span><span class=\"params\">(OkHttpClient client, Request originalRequest, <span class=\"keyword\">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.client = client;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.originalRequest = originalRequest;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.forWebSocket = forWebSocket;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.retryAndFollowUpInterceptor = <span class=\"keyword\">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout = <span class=\"keyword\">new</span> AsyncTimeout() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">timedOut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      cancel();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> RealCall <span class=\"title\">newRealCall</span><span class=\"params\">(OkHttpClient client, Request originalRequest, <span class=\"keyword\">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Safely publish the Call instance to the EventListener.</span></span><br><span class=\"line\">  RealCall call = <span class=\"keyword\">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class=\"line\">  call.eventListener = client.eventListenerFactory().create(call);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> call;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"同步执行一个call\"><a href=\"#同步执行一个call\" class=\"headerlink\" title=\"同步执行一个call\"></a>同步执行一个call</h3><p>在RealCall中有一个execute方法, 这里发起一个同步请求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Response <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">    executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  captureCallStackTrace();</span><br><span class=\"line\">  timeout.enter();</span><br><span class=\"line\">  eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    client.dispatcher().executed(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"comment\">// getResponseWithInterceptorChain()是具体的请求的操作过程</span></span><br><span class=\"line\">    Response result = getResponseWithInterceptorChain();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Canceled\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e = timeoutExit(e);</span><br><span class=\"line\">    eventListener.callFailed(<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>getResponseWithInterceptorChain()方法是请求发出的最终执行方法.</strong> 也就是说RealCall中调用execute()就已经直接同步开始了请求操作.</p>\n<p>但是dispatcher是请求的分发类, 如果, 直接开始了请求操作, 那么在dispatcher.executed方法和dispatcher.finished方法都干了什么呢? </p>\n<p>详细的内容可以看Dispatcher的源码解析.</p>\n<h3 id=\"异步执行一个call\"><a href=\"#异步执行一个call\" class=\"headerlink\" title=\"异步执行一个call\"></a>异步执行一个call</h3><p>RealCall中的enqueue方法, 发起一个异步请求<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(Callback responseCallback)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executed) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Already Executed\"</span>);</span><br><span class=\"line\">    executed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  captureCallStackTrace();</span><br><span class=\"line\">  eventListener.callStart(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  client.dispatcher().enqueue(<span class=\"keyword\">new</span> AsyncCall(responseCallback));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到和同步方法不同: 异步方法没有直接调用getResponseWithInterceptorChain方法开始发起请求, 而是老老实实的交给dispatcher()去调度. 还有就是, 调用dispatcher.enqueue方法, 参数是一个AsyncCall, 这个类是RealCall的内部类</p>\n<p><strong>AsyncCall中的executeOn, execute</strong><br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Attempt to enqueue this async call on &#123;<span class=\"doctag\">@code</span> executorService&#125;. This will attempt to clean up</span></span><br><span class=\"line\"><span class=\"comment\">* if the executor has been shut down by reporting the call as failed.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">executeOn</span><span class=\"params\">(ExecutorService executorService)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">assert</span> (!Thread.holdsLock(client.dispatcher()));</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> success = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        executorService.execute(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        success = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</span><br><span class=\"line\">        InterruptedIOException ioException = <span class=\"keyword\">new</span> InterruptedIOException(<span class=\"string\">\"executor rejected\"</span>);</span><br><span class=\"line\">        ioException.initCause(e);</span><br><span class=\"line\">        eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, ioException);</span><br><span class=\"line\">        responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, ioException);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!success) &#123;</span><br><span class=\"line\">          client.dispatcher().finished(<span class=\"keyword\">this</span>); <span class=\"comment\">// This call is no longer running!</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> signalledCallback = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  timeout.enter();</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Response response = getResponseWithInterceptorChain();</span><br><span class=\"line\">    signalledCallback = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    responseCallback.onResponse(RealCall.<span class=\"keyword\">this</span>, response);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e = timeoutExit(e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (signalledCallback) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Do not signal the callback twice!</span></span><br><span class=\"line\">      Platform.get().log(INFO, <span class=\"string\">\"Callback failure for \"</span> + toLoggableString(), e);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      eventListener.callFailed(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">      responseCallback.onFailure(RealCall.<span class=\"keyword\">this</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    client.dispatcher().finished(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>再execute方法中同样看到了getResponseWithInterceptorChain, 说明, 异步call交给dispatcher调度之后, 兜兜转转, 最终还是回到了call内部的方法来最终执行.</p>\n<h2 id=\"Dispatcher\"><a href=\"#Dispatcher\" class=\"headerlink\" title=\"Dispatcher\"></a>Dispatcher</h2><h3 id=\"重要的成员变量\"><a href=\"#重要的成员变量\" class=\"headerlink\" title=\"重要的成员变量\"></a>重要的成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequests = <span class=\"number\">64</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxRequestsPerHost = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> Runnable idleCallback;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Executes calls. Created lazily. */</span></span><br><span class=\"line\"><span class=\"comment\">// 这是一个线程池, 并且实现了懒加载</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Nullable</span> ExecutorService executorService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Ready async calls in the order they'll be run. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p><strong>为什么异步的call需要readyAsyncCalls和runningAsyncCalls两个队列:</strong><br>答案: 因为需要控制maxRequests, 当running队列的size小于maxRequests时, 才会将ready队列的call取出扔到线程池并放入running队列.</p>\n<h3 id=\"ExcutorService\"><a href=\"#ExcutorService\" class=\"headerlink\" title=\"ExcutorService\"></a>ExcutorService</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> ExecutorService <span class=\"title\">executorService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executorService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      executorService = <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE, <span class=\"number\">60</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">          <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class=\"string\">\"OkHttp Dispatcher\"</span>, <span class=\"keyword\">false</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> executorService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个线程池其实是一个CacheThreadPool. 他的特点是: </p>\n<ul>\n<li>底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</li>\n<li>通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定时间，则该线程会被销毁。</li>\n<li>适用：执行很多短期异步的小程序或者负载较轻的服务器</li>\n</ul>\n<p>检查调用executorService()方法的地方, 是一个promoteAndExecute()方法</p>\n<h3 id=\"enqueue-AsyncCall-call\"><a href=\"#enqueue-AsyncCall-call\" class=\"headerlink\" title=\"enqueue(AsyncCall call)\"></a>enqueue(AsyncCall call)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">enqueue</span><span class=\"params\">(AsyncCall call)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">      readyAsyncCalls.add(call);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    promoteAndExecute();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的逻辑很简单, 将call加入到准备队列中, 然后进行下一步</p>\n<h3 id=\"promoteAndExecute\"><a href=\"#promoteAndExecute\" class=\"headerlink\" title=\"promoteAndExecute()\"></a>promoteAndExecute()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Promotes eligible calls from &#123;<span class=\"doctag\">@link</span> #readyAsyncCalls&#125; to &#123;<span class=\"doctag\">@link</span> #runningAsyncCalls&#125; and runs</span></span><br><span class=\"line\"><span class=\"comment\"> * them on the executor service. Must not be called with synchronization because executing calls</span></span><br><span class=\"line\"><span class=\"comment\"> * can call into user code.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true if the dispatcher is currently running calls.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// 将符合条件的calls从readyAysncCalls转移到runningAsyncCalls中去, 并且在线程池中run这个call</span></span><br><span class=\"line\"><span class=\"comment\">// 如果成功执行上面的操作, 返回true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">promoteAndExecute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">assert</span> (!Thread.holdsLock(<span class=\"keyword\">this</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  List&lt;AsyncCall&gt; executableCalls = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> isRunning;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将readyAsyncCalls中符合条件的call转移到runningAsyncCalls去</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class=\"line\">      AsyncCall asyncCall = i.next();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 到达了max限制, break</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class=\"keyword\">break</span>; <span class=\"comment\">// Max capacity.</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (runningCallsForHost(asyncCall) &gt;= maxRequestsPerHost) <span class=\"keyword\">continue</span>; <span class=\"comment\">// Host max capacity.</span></span><br><span class=\"line\"></span><br><span class=\"line\">      i.remove();</span><br><span class=\"line\">      executableCalls.add(asyncCall);</span><br><span class=\"line\">      runningAsyncCalls.add(asyncCall);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    isRunning = runningCallsCount() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = executableCalls.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">    AsyncCall asyncCall = executableCalls.get(i);</span><br><span class=\"line\">    <span class=\"comment\">// 在线程池中执行这个call</span></span><br><span class=\"line\">    asyncCall.executeOn(executorService());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> isRunning;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>promoteAndExecute()方法的解析直接看上面源码的注释. </p>\n<p>结合之前说的, 在enqueue(call), 还有 exectorService() (线程池初始化)时候回调用这个方法, 将准备队列中合适的call扔到线程池中执行.<br>想一个问题, 就是当running队列的call都执行完了, 要怎么自动从ready队列中取call来执行呢?<br>想到这个问题, 然后再检查promoteAndExecute()方法调用的时机, 发现还有一个finished方法</p>\n<h3 id=\"finished-Deque-calls-T-call\"><a href=\"#finished-Deque-calls-T-call\" class=\"headerlink\" title=\"finished(Deque calls, T call)\"></a>finished(Deque<t> calls, T call)</t></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">finished</span><span class=\"params\">(Deque&lt;T&gt; calls, T call)</span> </span>&#123;</span><br><span class=\"line\">    Runnable idleCallback;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!calls.remove(call)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> AssertionError(<span class=\"string\">\"Call wasn't in-flight!\"</span>);</span><br><span class=\"line\">        idleCallback = <span class=\"keyword\">this</span>.idleCallback;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isRunning = promoteAndExecute();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isRunning &amp;&amp; idleCallback != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        idleCallback.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在RealCall和AsyncCall代码中, 能看到在调用了责任链完成一次请求之后，调用了<code>despatcher.finished</code>方法从readyAsyncCalls集合里获取下一个call来执行</p>\n<h3 id=\"executed-RealCall-call\"><a href=\"#executed-RealCall-call\" class=\"headerlink\" title=\"executed(RealCall call)\"></a>executed(RealCall call)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">executed</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    runningSyncCalls.add(call);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到只是做了一个把 call 加入到 runningSyncCalls 里</p>\n<h3 id=\"同步的call\"><a href=\"#同步的call\" class=\"headerlink\" title=\"同步的call\"></a>同步的call</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Used by &#123;<span class=\"doctag\">@code</span> Call#execute&#125; to signal it is in-flight. */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">executed</span><span class=\"params\">(RealCall call)</span> </span>&#123;</span><br><span class=\"line\">    runningSyncCalls.add(call);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同步的call在加入到了runningSyncCalls队列之后, 几乎说明也没干; 在finished方法中有被remove掉. 把同步的call放到Dispatcher中走一遭应该只是单纯的为了把同步call统一管理而已. </p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl4edno7a000bg0jeta98k380","category_id":"cl4edno7c000eg0jeo0aazet1","_id":"cl4edno7i000pg0je99mub349"},{"post_id":"cl4edno7a000cg0jeq3mf9itx","category_id":"cl4edno7c000eg0jeo0aazet1","_id":"cl4edno7k000ug0jeo2s0zk2m"},{"post_id":"cl4edno770007g0jei3ujt3ey","category_id":"cl4edno790009g0jeh68d2h2s","_id":"cl4edno7l0010g0jedyb03xx9"},{"post_id":"cl4edno770007g0jei3ujt3ey","category_id":"cl4edno7i000og0jek3waw5pr","_id":"cl4edno7m0014g0je6l54h587"},{"post_id":"cl4edno7c000dg0je32vo7uev","category_id":"cl4edno7k000vg0jel1g75x9x","_id":"cl4edno7n0016g0jezu0d44iw"},{"post_id":"cl4edno7n0017g0jexfmss2rq","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7q001eg0jeuslryvgq"},{"post_id":"cl4edno7e000ig0jen4yl3fww","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7q001hg0jekn0xevam"},{"post_id":"cl4edno7h000ng0je4r4g6nh6","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7s001pg0jead52c61j"},{"post_id":"cl4edno7j000tg0jerthpae1o","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7u001vg0jeoyfr3pc1"},{"post_id":"cl4edno7k000xg0je3unq0zbe","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7v0020g0jeh9hldlyu"},{"post_id":"cl4edno7d000hg0jetewhzjas","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7w0024g0jeiw0kj7pf"},{"post_id":"cl4edno7d000hg0jetewhzjas","category_id":"cl4edno7v001zg0jeqx51qf9k","_id":"cl4edno7w0027g0jezbi99ii1"},{"post_id":"cl4edno7g000lg0jex9qy6yk2","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7w002bg0jei9vko8d0"},{"post_id":"cl4edno7g000lg0jex9qy6yk2","category_id":"cl4edno7v0022g0je9k9wn8pz","_id":"cl4edno7x002dg0jeyzi9si3f"},{"post_id":"cl4edno7i000rg0jetgjp9021","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7x002gg0jeopbmj02c"},{"post_id":"cl4edno7i000rg0jetgjp9021","category_id":"cl4edno7v0022g0je9k9wn8pz","_id":"cl4edno7x002ig0je8v3bw2pv"},{"post_id":"cl4edno7l000zg0jeulpykk34","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno7y002jg0je1q0nka3p"},{"post_id":"cl4edno7l000zg0jeulpykk34","category_id":"cl4edno7v0022g0je9k9wn8pz","_id":"cl4edno7y002lg0je2imzwdjk"},{"post_id":"cl4edno8a002ng0jea551m4nr","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno8d002ug0jemxwig7x6"},{"post_id":"cl4edno8b002qg0jee8xauc0y","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno8f002yg0jexcf73uyi"},{"post_id":"cl4edno8a002og0jet2oqxgzy","category_id":"cl4edno8c002rg0jelorvm980","_id":"cl4edno8h0034g0jezbsccggl"},{"post_id":"cl4edno8e002xg0jel5v1sb37","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno8i0038g0jerxqg5xqp"},{"post_id":"cl4edno8e002xg0jel5v1sb37","category_id":"cl4edno7v0022g0je9k9wn8pz","_id":"cl4edno8j003bg0je6o9rcpe7"},{"post_id":"cl4edno8g0033g0jeo572dtgy","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno8k003eg0jeb0t291i4"},{"post_id":"cl4edno8h0037g0jea9st6yj9","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno8l003hg0jero6diejq"},{"post_id":"cl4edno8h0037g0jea9st6yj9","category_id":"cl4edno7v0022g0je9k9wn8pz","_id":"cl4edno8l003kg0jemjw76mse"},{"post_id":"cl4edno8n003pg0je3skro1zq","category_id":"cl4edno8p003tg0je32otooxt","_id":"cl4edno8u0046g0je6gcbow83"},{"post_id":"cl4edno8r003xg0jex91yx54z","category_id":"cl4edno8t0042g0jejmf5kqsr","_id":"cl4edno8v004bg0jesdgoaxyr"},{"post_id":"cl4edno8s003zg0jeybeyaba9","category_id":"cl4edno8t0042g0jejmf5kqsr","_id":"cl4edno8v004fg0jei9zdimed"},{"post_id":"cl4edno91004pg0jecdbzr6ii","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno95004vg0je6x2sj817"},{"post_id":"cl4edno980051g0je9yaazbhf","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9a0058g0jeqt42esjk"},{"post_id":"cl4edno980051g0je9yaazbhf","category_id":"cl4edno7v0022g0je9k9wn8pz","_id":"cl4edno9a005ag0jeny13y25f"},{"post_id":"cl4edno92004qg0jetdf6kspx","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9a005cg0jexqdr8awc"},{"post_id":"cl4edno92004qg0jetdf6kspx","category_id":"cl4edno95004ug0jedoz9i3c3","_id":"cl4edno9b005eg0jekee6gdbt"},{"post_id":"cl4edno92004qg0jetdf6kspx","category_id":"cl4edno990052g0jeozjjwqcx","_id":"cl4edno9b005gg0jemj9sj232"},{"post_id":"cl4edno9m005kg0jesvvyerm6","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9o005pg0jedjwrzx66"},{"post_id":"cl4edno9n005ng0jee3gzfm10","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9q005ug0jebwydfc22"},{"post_id":"cl4edno9o005og0jegbacs4aw","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9s005xg0jenqmn4y2l"},{"post_id":"cl4edno9p005qg0jenz6w2wf1","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9t0061g0jeb2fdxgsq"},{"post_id":"cl4edno9q005tg0je808udvdr","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9u0064g0jenx0aftmq"},{"post_id":"cl4edno9s005wg0jer9zlw2qu","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9u0067g0je09mof6bg"},{"post_id":"cl4edno9s0060g0je5i5s7umw","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9v006ag0jegz53n9zl"},{"post_id":"cl4edno9t0063g0jedwnnwu2i","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9w006dg0jez6qpxfkp"},{"post_id":"cl4edno9u0065g0je2adafet9","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9x006hg0jennh35p9b"},{"post_id":"cl4edno9v006cg0jejjdog472","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9y006mg0jes5m40dme"},{"post_id":"cl4edno9w006fg0jeprl2o9du","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9z006og0jeyh9quwh5"},{"post_id":"cl4edno9x006ig0jeawynr8bm","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9z006rg0je8xfctlto"},{"post_id":"cl4edno9y006lg0jeb05uk0a3","category_id":"cl4edno7m0011g0jeqdxphz1j","_id":"cl4edno9z006tg0je570c2vsj"}],"PostTag":[{"post_id":"cl4edno6l0001g0jeqr5d50zq","tag_id":"cl4edno6q0003g0je31x8k1m9","_id":"cl4edno6t0005g0je14wh2tis"},{"post_id":"cl4edno770007g0jei3ujt3ey","tag_id":"cl4edno79000ag0je041hogoi","_id":"cl4edno7d000gg0jevw3lmdf1"},{"post_id":"cl4edno780008g0jem6e0zgpb","tag_id":"cl4edno7c000fg0jezif2oq6g","_id":"cl4edno7h000mg0jef0rtofti"},{"post_id":"cl4edno7c000dg0je32vo7uev","tag_id":"cl4edno7f000kg0jecor6v3fa","_id":"cl4edno7j000sg0jetwcwhx6f"},{"post_id":"cl4edno7d000hg0jetewhzjas","tag_id":"cl4edno7i000qg0jej96jf3fs","_id":"cl4edno7l000yg0jem1y0xlbk"},{"post_id":"cl4edno7e000ig0jen4yl3fww","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno7p001ag0jeqjv7bu32"},{"post_id":"cl4edno7e000ig0jen4yl3fww","tag_id":"cl4edno7m0013g0je1gz492w8","_id":"cl4edno7p001cg0jegpg2e272"},{"post_id":"cl4edno7n0017g0jexfmss2rq","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno7q001fg0jeymrh5lqx"},{"post_id":"cl4edno7g000lg0jex9qy6yk2","tag_id":"cl4edno7o0019g0jewx028s73","_id":"cl4edno7r001jg0jeao41kdd5"},{"post_id":"cl4edno7g000lg0jex9qy6yk2","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno7r001lg0je2wgwcqnq"},{"post_id":"cl4edno7h000ng0je4r4g6nh6","tag_id":"cl4edno7q001ig0jep0284hnc","_id":"cl4edno7s001ng0jepuc9r5iy"},{"post_id":"cl4edno7i000rg0jetgjp9021","tag_id":"cl4edno7o0019g0jewx028s73","_id":"cl4edno7t001tg0jevk0nz7r8"},{"post_id":"cl4edno7i000rg0jetgjp9021","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno7u001wg0je99o20xoz"},{"post_id":"cl4edno7j000tg0jerthpae1o","tag_id":"cl4edno7t001sg0jebhgtj389","_id":"cl4edno7u001yg0je8y0u3c2b"},{"post_id":"cl4edno7k000xg0je3unq0zbe","tag_id":"cl4edno7u001xg0jemly49onn","_id":"cl4edno7w0025g0jes39o5n8x"},{"post_id":"cl4edno7k000xg0je3unq0zbe","tag_id":"cl4edno7v0021g0jeew5jhh1t","_id":"cl4edno7w0028g0jez955ozf4"},{"post_id":"cl4edno7l000zg0jeulpykk34","tag_id":"cl4edno7v0023g0jesze3efp7","_id":"cl4edno7x002cg0jedpzeabjb"},{"post_id":"cl4edno7l000zg0jeulpykk34","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno7x002eg0je11sabsee"},{"post_id":"cl4edno7m0012g0jesu2ue3wq","tag_id":"cl4edno7w0029g0jefr8d7uaa","_id":"cl4edno7x002hg0je7ws8i564"},{"post_id":"cl4edno7n0015g0jem7yntiso","tag_id":"cl4edno7o0019g0jewx028s73","_id":"cl4edno7y002kg0jel6gs5uud"},{"post_id":"cl4edno7n0015g0jem7yntiso","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno7y002mg0je94hjnnt4"},{"post_id":"cl4edno8a002ng0jea551m4nr","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno8b002pg0jee971l2g3"},{"post_id":"cl4edno8b002qg0jee8xauc0y","tag_id":"cl4edno7m0013g0je1gz492w8","_id":"cl4edno8e002vg0jemwppdc9f"},{"post_id":"cl4edno8a002og0jet2oqxgzy","tag_id":"cl4edno8c002sg0jej71pnw0w","_id":"cl4edno8f0030g0jen0g2u6zm"},{"post_id":"cl4edno8e002xg0jel5v1sb37","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno8g0032g0jesfnrbqwl"},{"post_id":"cl4edno8f0031g0je24uas4aj","tag_id":"cl4edno7m0013g0je1gz492w8","_id":"cl4edno8h0036g0jey4ede455"},{"post_id":"cl4edno8f0031g0je24uas4aj","tag_id":"cl4edno7o0019g0jewx028s73","_id":"cl4edno8i0039g0je9ay1f4qm"},{"post_id":"cl4edno8d002tg0jed0fdphje","tag_id":"cl4edno8f002zg0je7z1984va","_id":"cl4edno8j003cg0jeyfmyjqh0"},{"post_id":"cl4edno8g0033g0jeo572dtgy","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno8k003fg0jevxeihrzh"},{"post_id":"cl4edno8h0037g0jea9st6yj9","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno8l003ig0jex3y3y1gf"},{"post_id":"cl4edno8e002wg0jewwkmzw3j","tag_id":"cl4edno8h0035g0je4jq1jnhi","_id":"cl4edno8l003mg0jecl3q0bzt"},{"post_id":"cl4edno8m003og0jeb72uwsxo","tag_id":"cl4edno8l003lg0jej73ivpts","_id":"cl4edno8o003rg0jecyb7iojc"},{"post_id":"cl4edno8n003pg0je3skro1zq","tag_id":"cl4edno8l003lg0jej73ivpts","_id":"cl4edno8q003ug0jegpfhz4pd"},{"post_id":"cl4edno8k003gg0jemvoxksm4","tag_id":"cl4edno8l003lg0jej73ivpts","_id":"cl4edno8s003yg0je81nh75co"},{"post_id":"cl4edno8k003gg0jemvoxksm4","tag_id":"cl4edno8o003qg0jeaqjhm103","_id":"cl4edno8s0040g0jee5rrytyq"},{"post_id":"cl4edno8q003vg0je5p2d78cn","tag_id":"cl4edno8c002sg0jej71pnw0w","_id":"cl4edno8t0044g0je3c4pb9gn"},{"post_id":"cl4edno8m003ng0jecy3eqy1v","tag_id":"cl4edno8q003wg0jei9oh2vhy","_id":"cl4edno8u0047g0jevc5zszba"},{"post_id":"cl4edno8u0045g0jegf8wuclf","tag_id":"cl4edno8c002sg0jej71pnw0w","_id":"cl4edno8v004ag0jezd51xazy"},{"post_id":"cl4edno8p003sg0je0gn86x1z","tag_id":"cl4edno7o0019g0jewx028s73","_id":"cl4edno8v004dg0jevp3taivu"},{"post_id":"cl4edno8p003sg0je0gn86x1z","tag_id":"cl4edno8s0041g0je1j01x31b","_id":"cl4edno8v004eg0jemjl8iydk"},{"post_id":"cl4edno8p003sg0je0gn86x1z","tag_id":"cl4edno8u0048g0jemnxuf3zn","_id":"cl4edno8w004hg0jevmo7oohp"},{"post_id":"cl4edno8r003xg0jex91yx54z","tag_id":"cl4edno8q003wg0jei9oh2vhy","_id":"cl4edno8w004ig0je5i3f0p92"},{"post_id":"cl4edno8r003xg0jex91yx54z","tag_id":"cl4edno8v004cg0je3jf13bx5","_id":"cl4edno8w004kg0jew3giwms1"},{"post_id":"cl4edno8s003zg0jeybeyaba9","tag_id":"cl4edno8w004gg0je8itpwbqc","_id":"cl4edno8w004lg0je64rsr5nz"},{"post_id":"cl4edno8s003zg0jeybeyaba9","tag_id":"cl4edno8q003wg0jei9oh2vhy","_id":"cl4edno8w004mg0jefpm2qt8n"},{"post_id":"cl4edno8t0043g0je2u8r9kn9","tag_id":"cl4edno8l003lg0jej73ivpts","_id":"cl4edno8w004ng0jeqmhql9z6"},{"post_id":"cl4edno8t0043g0je2u8r9kn9","tag_id":"cl4edno8w004jg0jefj912b4r","_id":"cl4edno8w004og0je5wpthd65"},{"post_id":"cl4edno94004tg0jehokryusz","tag_id":"cl4edno7t001sg0jebhgtj389","_id":"cl4edno97004yg0je71crzgum"},{"post_id":"cl4edno91004pg0jecdbzr6ii","tag_id":"cl4edno7u001xg0jemly49onn","_id":"cl4edno980050g0jeoes0hb6c"},{"post_id":"cl4edno91004pg0jecdbzr6ii","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4edno990054g0jegv1fmbbp"},{"post_id":"cl4edno92004qg0jetdf6kspx","tag_id":"cl4edno96004xg0jem8a65o4x","_id":"cl4edno990055g0je3cycif4d"},{"post_id":"cl4edno980051g0je9yaazbhf","tag_id":"cl4edno7k000wg0jem9tj7r32","_id":"cl4edno9a0057g0je7hf1ekpa"},{"post_id":"cl4edno980051g0je9yaazbhf","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4edno9a0059g0je0uhi2fnv"},{"post_id":"cl4edno93004sg0jeu7dyypbi","tag_id":"cl4edno990053g0jeyat61z8n","_id":"cl4edno9a005bg0je71lqfesi"},{"post_id":"cl4edno93004sg0jeu7dyypbi","tag_id":"cl4edno7o0019g0jewx028s73","_id":"cl4edno9b005dg0jepny18h1a"},{"post_id":"cl4edno95004wg0jehpfjr6yo","tag_id":"cl4edno990053g0jeyat61z8n","_id":"cl4edno9b005fg0jewakb9xed"},{"post_id":"cl4edno95004wg0jehpfjr6yo","tag_id":"cl4edno7o0019g0jewx028s73","_id":"cl4edno9b005hg0jee0z1i8kw"},{"post_id":"cl4edno9o005og0jegbacs4aw","tag_id":"cl4edno9n005mg0jespb5r36g","_id":"cl4edno9p005sg0jedt9lanjl"},{"post_id":"cl4edno9m005kg0jesvvyerm6","tag_id":"cl4edno9n005mg0jespb5r36g","_id":"cl4edno9r005vg0jevgfu7cdu"},{"post_id":"cl4edno9p005qg0jenz6w2wf1","tag_id":"cl4edno9n005mg0jespb5r36g","_id":"cl4edno9s005zg0jey1qani2r"},{"post_id":"cl4edno9n005ng0jee3gzfm10","tag_id":"cl4edno9n005mg0jespb5r36g","_id":"cl4edno9t0062g0jezo18kicl"},{"post_id":"cl4edno9q005tg0je808udvdr","tag_id":"cl4edno9s005yg0jexucyv1vu","_id":"cl4edno9v0068g0jesmodenr8"},{"post_id":"cl4edno9q005tg0je808udvdr","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4edno9v006bg0jehz55gexy"},{"post_id":"cl4edno9s005wg0jer9zlw2qu","tag_id":"cl4edno9u0066g0jea3gg7t53","_id":"cl4edno9x006gg0je1mwvtkix"},{"post_id":"cl4edno9s005wg0jer9zlw2qu","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4edno9x006jg0jedm5qhgde"},{"post_id":"cl4edno9v006cg0jejjdog472","tag_id":"cl4edno9u0066g0jea3gg7t53","_id":"cl4edno9y006ng0jegoho42d7"},{"post_id":"cl4edno9v006cg0jejjdog472","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4edno9z006pg0jek7uey56o"},{"post_id":"cl4edno9w006fg0jeprl2o9du","tag_id":"cl4edno9u0066g0jea3gg7t53","_id":"cl4edno9z006sg0je814wc3uw"},{"post_id":"cl4edno9w006fg0jeprl2o9du","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4edno9z006ug0jennyggavv"},{"post_id":"cl4edno9s0060g0je5i5s7umw","tag_id":"cl4edno9s005yg0jexucyv1vu","_id":"cl4ednoa0006wg0je3ze9c7z3"},{"post_id":"cl4edno9s0060g0je5i5s7umw","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4ednoa0006xg0jectg3kawt"},{"post_id":"cl4edno9x006ig0jeawynr8bm","tag_id":"cl4edno9u0066g0jea3gg7t53","_id":"cl4ednoa0006zg0jeemza4vcj"},{"post_id":"cl4edno9x006ig0jeawynr8bm","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4ednoa00070g0je7kszut88"},{"post_id":"cl4edno9t0063g0jedwnnwu2i","tag_id":"cl4edno9x006kg0jek880fhu7","_id":"cl4ednoa00071g0je9xtzwdqd"},{"post_id":"cl4edno9t0063g0jedwnnwu2i","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4ednoa00072g0jefv4nc15t"},{"post_id":"cl4edno9u0065g0je2adafet9","tag_id":"cl4edno9u0066g0jea3gg7t53","_id":"cl4ednoa00073g0je1z3yrokj"},{"post_id":"cl4edno9u0065g0je2adafet9","tag_id":"cl4edno9z006vg0jey1ya81c7","_id":"cl4ednoa00074g0jenxi2dugn"},{"post_id":"cl4edno9y006lg0jeb05uk0a3","tag_id":"cl4ednoa0006yg0je9kmtmj9m","_id":"cl4ednoa00075g0je2ah8k4uk"},{"post_id":"cl4edno9y006lg0jeb05uk0a3","tag_id":"cl4edno93004rg0jegg5fecoj","_id":"cl4ednoa00076g0jegs5t0yft"}],"Tag":[{"name":"AOSP","_id":"cl4edno6q0003g0je31x8k1m9"},{"name":"多线程","_id":"cl4edno79000ag0je041hogoi"},{"name":"jni","_id":"cl4edno7c000fg0jezif2oq6g"},{"name":"Java","_id":"cl4edno7f000kg0jecor6v3fa"},{"name":"AndroidStudio","_id":"cl4edno7i000qg0jej96jf3fs"},{"name":"View","_id":"cl4edno7k000wg0jem9tj7r32"},{"name":"RecyclerView","_id":"cl4edno7m0013g0je1gz492w8"},{"name":"Android","_id":"cl4edno7o0019g0jewx028s73"},{"name":"注解","_id":"cl4edno7q001ig0jep0284hnc"},{"name":"Activity","_id":"cl4edno7t001sg0jebhgtj389"},{"name":"Handler","_id":"cl4edno7u001xg0jemly49onn"},{"name":"内存泄露","_id":"cl4edno7v0021g0jeew5jhh1t"},{"name":"Animation","_id":"cl4edno7v0023g0jesze3efp7"},{"name":"Fragment","_id":"cl4edno7w0029g0jefr8d7uaa"},{"name":"Kotlin","_id":"cl4edno8c002sg0jej71pnw0w"},{"name":"ViewModel","_id":"cl4edno8f002zg0je7z1984va"},{"name":"nested2","_id":"cl4edno8h0035g0je4jq1jnhi"},{"name":"Flutter","_id":"cl4edno8l003lg0jej73ivpts"},{"name":"Redux","_id":"cl4edno8o003qg0jeaqjhm103"},{"name":"Linux","_id":"cl4edno8q003wg0jei9oh2vhy"},{"name":"Notification","_id":"cl4edno8s0041g0je1j01x31b"},{"name":"Uri","_id":"cl4edno8u0048g0jemnxuf3zn"},{"name":"Docker","_id":"cl4edno8v004cg0je3jf13bx5"},{"name":"mysql","_id":"cl4edno8w004gg0je8itpwbqc"},{"name":"RenderObject","_id":"cl4edno8w004jg0jefj912b4r"},{"name":"源码解析","_id":"cl4edno93004rg0jegg5fecoj"},{"name":"Service","_id":"cl4edno96004xg0jem8a65o4x"},{"name":"Framework","_id":"cl4edno990053g0jeyat61z8n"},{"name":"Gradle","_id":"cl4edno9n005mg0jespb5r36g"},{"name":"glide","_id":"cl4edno9s005yg0jexucyv1vu"},{"name":"okhttp3","_id":"cl4edno9u0066g0jea3gg7t53"},{"name":"Fresco","_id":"cl4edno9x006kg0jek880fhu7"},{"name":"源码分析","_id":"cl4edno9z006vg0jey1ya81c7"},{"name":"Okhttp3","_id":"cl4ednoa0006yg0je9kmtmj9m"}]}}