<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BrightStone</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-13T08:43:08.226Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BrightStone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义注解处理器并发布为gradle组件</title>
    <link href="http://yoursite.com/2022/03/13/Android/gradle/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E5%B9%B6%E5%8F%91%E5%B8%83%E4%B8%BAgradle%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/13/Android/gradle/自定义注解处理器并发布为gradle组件/</id>
    <published>2022-03-13T07:27:24.000Z</published>
    <updated>2022-03-13T08:43:08.226Z</updated>
    
    <content type="html"><![CDATA[<p>自定义一个基于注解的路由框架</p><h2 id="定义注解类"><a href="#定义注解类" class="headerlink" title="定义注解类"></a>定义注解类</h2><ol><li>新建一个模块 router_annotations </li><li>在 router_annotations 目录中创建 build.gradle </li></ol><a id="more"></a><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin"</span> <span class="comment">// 使用 kotlin</span></span><br><span class="line"></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 发布脚本，后面会写</span></span><br><span class="line">apply <span class="string">from :</span> rootProject.file(<span class="string">"maven-publish.gradle"</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>定义注解类</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置使用注解的对象是 类</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.CLASS)</span></span><br><span class="line"><span class="comment">// 设置注解只在编译期存在</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.BINARY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>(</span><br><span class="line">    <span class="keyword">val</span> url: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="定义注解处理器模块"><a href="#定义注解处理器模块" class="headerlink" title="定义注解处理器模块"></a>定义注解处理器模块</h2><ol><li>新建一个模块 router_compile</li><li>在 router_compile 目录中创建 build.gradle</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin"</span> <span class="comment">// 使用kotlin插件</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin-kapt"</span> <span class="comment">// 使用kotlin注解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置源码兼容性</span></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(<span class="string">":router_annotations"</span>)</span><br><span class="line">    implementation <span class="string">"com.google.auto.service:auto-service:1.0-rc6"</span></span><br><span class="line">    kapt <span class="string">"com.google.auto.service:auto-service:1.0-rc6"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 发布脚本。后面会写</span></span><br><span class="line">apply <span class="string">from :</span> rootProject.file(<span class="string">"maven-publish.gradle"</span>)</span><br></pre></td></tr></table></figure><p>在注解处理器模块，如果使用kotlin写注解处理器代码，需要引用 <code>kotlin-kapt</code> 这个插件<br><code>implementation &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 使用google的一个注解框架。<br>同时还要加上 <code>kapt &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 。 这是kotlin的写法，如果是java，需要换成<br><code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code></p><ol start="3"><li>编写注解处理器<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService(Processor::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestinationProcessor</span> : <span class="type">AbstractProcessor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">"DestinationProcessor"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">set</span>: <span class="type">MutableSet</span>&lt;<span class="type">out</span> <span class="type">TypeElement</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        roundEnvironment: <span class="type">RoundEnvironment</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (roundEnvironment.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"<span class="variable">$TAG</span> &gt;&gt;&gt;&gt; process start"</span>)</span><br><span class="line"></span><br><span class="line">        println(<span class="keyword">set</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> destinationClasses = roundEnvironment.getElementsAnnotatedWith(Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">        println(TAG + <span class="string">" "</span> + destinationClasses.size)</span><br><span class="line">        <span class="keyword">if</span> (destinationClasses.size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> destinationClasses) &#123;</span><br><span class="line">            <span class="keyword">val</span> typeElement = element <span class="keyword">as</span> TypeElement</span><br><span class="line">            <span class="keyword">val</span> destination = typeElement.getAnnotation(Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">                ?: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">val</span> url = destination.url</span><br><span class="line">            <span class="keyword">val</span> className = typeElement.qualifiedName</span><br><span class="line">            println(<span class="string">"<span class="variable">$TAG</span> <span class="variable">$url</span> <span class="variable">$className</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"<span class="variable">$TAG</span> &gt;&gt;&gt;&gt; process finish"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> mutableSetOf(</span><br><span class="line">            Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">canonicalName</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@AutoService(Processor::class)</code> 是固定写法</p><p><code>AbstractProcessor</code> 继承这个抽象类。<br>重写<code>getSupportedAnnotationTypes</code>方法，返回需要处理的注解。<br>重写<code>process</code>方法，处理注解信息。 返回值为true表示已处理这个注解，相同的注解不会再被其他注解处理器处理。<br><code>roundEnvironment.processingOver()</code>表示之前已经有处理过一轮，此时<code>roundEnvironment.elements.size==0</code> 不是很明白gradle为什么会执行多轮。。。</p><h2 id="在本地使用注解"><a href="#在本地使用注解" class="headerlink" title="在本地使用注解"></a>在本地使用注解</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation project(<span class="string">":router_annotations"</span>)</span><br><span class="line">kapt project(<span class="string">":router_compile"</span>)</span><br></pre></td></tr></table></figure><h2 id="将注解处理器打包成组件并发布"><a href="#将注解处理器打包成组件并发布" class="headerlink" title="将注解处理器打包成组件并发布"></a>将注解处理器打包成组件并发布</h2><ol><li><p>在最外层的 build.properties 中写通用参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POM_URL=..<span class="regexp">/repo  /</span>/ 发布的仓库地址，这里是本地</span><br><span class="line">GROUP_ID=com.example.test <span class="comment">// group</span></span><br><span class="line">VERSION_NAME=<span class="number">1.0</span><span class="number">.0</span> <span class="comment">// 版本</span></span><br></pre></td></tr></table></figure></li><li><p>在 router_annotation 和 router_compile 中写 group_id</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 router_annotation build.properties</span></span><br><span class="line">POM_ARTIFACT_ID=router-test-annotation</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 router_compile build.properties</span></span><br><span class="line">POM_ARTIFACT_ID=router-test-processor</span><br></pre></td></tr></table></figure></li><li><p>编写发布脚本 maven-publish.gradle</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span> <span class="comment">// 引入maven插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根目录的 gradle.properties 中获取通用参数 start</span></span><br><span class="line"><span class="keyword">def</span> rootProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">rootProperties.load(<span class="keyword">new</span> FileInputStream(project.rootProject.file(<span class="string">"gradle.properties"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> versionName = rootProperties.getProperty(<span class="string">"VERSION_NAME"</span>)</span><br><span class="line"><span class="keyword">def</span> pomUrl = rootProperties.getProperty(<span class="string">"POM_URL"</span>) <span class="comment">// ../repo</span></span><br><span class="line"><span class="keyword">def</span> groupId = rootProperties.getProperty(<span class="string">"GROUP_ID"</span>)</span><br><span class="line"><span class="comment">// 获取通用参数 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前项目的 gradle.properties 中获取参数</span></span><br><span class="line"><span class="keyword">def</span> projectProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">projectProperties.load(<span class="keyword">new</span> FileInputStream(project.file(<span class="string">"gradle.properties"</span>)))</span><br><span class="line"><span class="keyword">def</span> pomArtifactId = projectProperties.getProperty(<span class="string">"POM_ARTIFACT_ID"</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"maven-publish $versionName $pomUrl $groupId $pomArtifactId"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写maven的发布任务</span></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(<span class="string">url:</span> uri(pomUrl)) &#123;</span><br><span class="line">                pom.groupId = groupId</span><br><span class="line">                pom.artifactId = pomArtifactId</span><br><span class="line">                pom.version = versionName</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pom.whenConfigured &#123; pom -&gt;</span><br><span class="line">                pom.dependencies.forEach &#123; dep -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (dep.getVersion() == <span class="string">"unspecified"</span>) &#123;</span><br><span class="line">                        dep.setGroupId(groupId)</span><br><span class="line">                        dep.setVersion(versionName)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意有一个 <code>pom.whenConfigured { pom -&gt; ...</code> 的代码，这是因为 router_compile 应用到了 router_annotations 模块。如果不做处理，发布之后， router_comiple 模块是找不到 router_annotations 的正确位置和版本的。所以要强制制定</p><h2 id="执行发布任务"><a href="#执行发布任务" class="headerlink" title="执行发布任务"></a>执行发布任务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :router_compile:uploadArchives</span><br><span class="line">./gradlew :router_annotations:uploadArchives</span><br></pre></td></tr></table></figure><p>我们设置的 <code>POM_URL=../repo</code> 所以最终会在项目的repo目录里生成aar包。 </p><h2 id="使用发布后的组件"><a href="#使用发布后的组件" class="headerlink" title="使用发布后的组件"></a>使用发布后的组件</h2><ol><li>首先，moven本地仓库地址加入到工程里<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>buildscript.repositories 和 allprojects.repositories 都要加，这样才会应用到所有子工程</p><ol start="2"><li>在app模块里引用组件<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"com.example.test:router-test-annotation:1.0.0"</span></span><br><span class="line">kapt <span class="string">"com.example.test:router-test-processor:1.0.0"</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自定义一个基于注解的路由框架&lt;/p&gt;&lt;h2 id=&quot;定义注解类&quot;&gt;&lt;a href=&quot;#定义注解类&quot; class=&quot;headerlink&quot; title=&quot;定义注解类&quot;&gt;&lt;/a&gt;定义注解类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;新建一个模块 router_annotations &lt;/li&gt;
&lt;li&gt;在 router_annotations 目录中创建 build.gradle &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>MultiDex原理</title>
    <link href="http://yoursite.com/2021/12/25/Android/Framework/MultiDex%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2021/12/25/Android/Framework/MultiDex原理/</id>
    <published>2021-12-25T10:20:52.000Z</published>
    <updated>2021-12-25T11:04:06.178Z</updated>
    
    <content type="html"><![CDATA[<p>apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.<br>为了规避安卓项目编译65536最大方法数的限制，需要做分dex</p><a id="more"></a><h2 id="1-Dalvik-和-ART-虚拟机的区别"><a href="#1-Dalvik-和-ART-虚拟机的区别" class="headerlink" title="1. Dalvik 和 ART 虚拟机的区别"></a>1. Dalvik 和 ART 虚拟机的区别</h2><p>Android5.0以上系统使用 ART 虚拟机，5.0以下使用 Dalvik 虚拟机</p><p>Dalvik 编译策略是 JIT 技术。JIT意思是Just In Time Compiler，就是即时编译技术。<br>JIT是运行时编译，是动态编译，可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间可以加快Dalvik运行速度。每次运行都需要重新编译。</p><p>AOT是指”Ahead Of Time”，与”Just In Time”不同，从字面来看是说提前编译。<br>AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex预编译，一次性将所有dex代码转换为机器码，每次运行程序的时候不用重新编译。 </p><p>Android 7.0上，JIT 编译器被再次使用，采用AOT/JIT 混合编译的策略，特点是：</p><p>应用在安装的时候dex不会再被编译<br>App运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息。<br>手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译</p><h2 id="2-不同虚拟机在-MultiDex-的区别。"><a href="#2-不同虚拟机在-MultiDex-的区别。" class="headerlink" title="2. 不同虚拟机在 MultiDex 的区别。"></a>2. 不同虚拟机在 MultiDex 的区别。</h2><ul><li>Andorid 5.0 之后，ART天然支持从apk文件中加载多个.dex文件，在应用安装期间，它会执行一个预编译操作。将所有的dex编译成一个单一的.oat文件，在应用运行是去加载这个.oat文件，而不是一个一个的加载.dex文件。<br>所以我们只需要 在 gradle 开启 multiDexEnabled true 即可</li><li>Dalvik 使用的 JIT ，JIT每次运行都需要重新编译。 所以我们需要在应用启动时手动去一个一个加载 dex 文件</li></ul><h2 id="3-在-Dalvik-加载多dex"><a href="#3-在-Dalvik-加载多dex" class="headerlink" title="3. 在 Dalvik 加载多dex"></a>3. 在 Dalvik 加载多dex</h2><p>简单来说 hook PathClassLoader 。</p><ol><li>获取到所有的dex文件</li><li>通过反射拿到DexPathList的Element数组，把dex添加到 Element数组中</li></ol><p>通过这样的方式也可以实现热热修复，将修改后的新class打包成一个dex， 然后通过反射将 新dex插入到 PathClassLoader 中的 element数组最前面。从而实现对旧类的覆盖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.&lt;br&gt;为了规避安卓项目编译65536最大方法数的限制，需要做分dex&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>技术Owner的职责</title>
    <link href="http://yoursite.com/2021/11/27/%E6%8A%80%E6%9C%AFOwner%E7%9A%84%E8%81%8C%E8%B4%A3/"/>
    <id>http://yoursite.com/2021/11/27/技术Owner的职责/</id>
    <published>2021-11-27T07:58:24.000Z</published>
    <updated>2021-11-27T08:09:40.100Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参与需求评审，完成可行性调研，完善细节。<ul><li>要督促完成UI/UE评审，埋点评审</li></ul></li><li>技术评审，输出技术方案，拆分需求子任务，给出详细排期</li><li>开始开发，定期站会，同步风险<ul><li>发生变更，更改排期</li><li>需求提测前，推进case评审</li><li>自测</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;参与需求评审，完成可行性调研，完善细节。&lt;ul&gt;
&lt;li&gt;要督促完成UI/UE评审，埋点评审&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术评审，输出技术方案，拆分需求子任务，给出详细排期&lt;/li&gt;
&lt;li&gt;开始开发，定期站会，同步风险&lt;ul&gt;
&lt;li&gt;发生变更
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Binder源码笔记</title>
    <link href="http://yoursite.com/2021/11/03/Android/Framework/Binder%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/11/03/Android/Framework/Binder源码笔记/</id>
    <published>2021-11-03T13:42:37.000Z</published>
    <updated>2021-11-09T14:29:00.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Service-的启动-独立进程的-Service"><a href="#Service-的启动-独立进程的-Service" class="headerlink" title="Service 的启动 (独立进程的 Service )"></a>Service 的启动 (独立进程的 Service )</h1><a id="more"></a><h2 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a>ProcessState</h2><p>ProcessState 是一个系统 Service 进程的单例，一个进程只有一个 ProcessState 实例。 </p><p>内部会打开设备 “/dev/binder” ，调用 mmap 函数，完成自己和内核空间的内存映射。</p><p>ioctl 和 Binder 设备传递参数，设置了 binder 线程池的最大线程数</p><h2 id="Binder线程池"><a href="#Binder线程池" class="headerlink" title="Binder线程池"></a>Binder线程池</h2><p>调用 ProcessState::startThreadPool() 启动 Binder 线程池。 调用之后，实际上就已经 run 了一个 Binder 主线程, 并开始 while 死循环接收 Binder 消息。<br>之后会根据情况，选择在 Binder 线程池中创建新的线程，但是创建出来的就不是一个死循环的线程了</p><h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="BpBinder-和-BBinder"><a href="#BpBinder-和-BBinder" class="headerlink" title="BpBinder 和 BBinder"></a>BpBinder 和 BBinder</h2><p>IBinder 对象是负责binder通信的实例。 BpBinder 是客户端和服务端交互的代理类，BBinder 代表服务端</p><h2 id="BpBinder-transact"><a href="#BpBinder-transact" class="headerlink" title="BpBinder::transact"></a>BpBinder::transact</h2><p>发送数据的方法</p><h2 id="IPCThreadState-self-gt-transact-…"><a href="#IPCThreadState-self-gt-transact-…" class="headerlink" title="IPCThreadState::self()-&gt;transact(…)"></a>IPCThreadState::self()-&gt;transact(…)</h2><p>真正数据通信的方法。 一个线程只会有一个实例， 使用 pthread_setspecific 实现，类似于 java 的 ThreadLocal<br>IPCThreadState 有两个缓存 mIn 和 mOut 分别负责数据的接收和发射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> transact(..)</span><br><span class="line">    -&gt; writeTransactionData(..)</span><br><span class="line">        -&gt; 将 cmd 和 data 写入到 mOut 中</span><br><span class="line">    -&gt; waitForResponse(..)</span><br><span class="line">        -&gt; talkWithDriver(doReceive)</span><br><span class="line">            -&gt; 将 bwr(一个和Binder驱动的结构体) bwr.write_buffer 指向 mOut.data()</span><br><span class="line">            -&gt; 将 bwr.read_buffer 指向 mIn.data()</span><br><span class="line">            -&gt; do-while 循环，调用 ioctl 函数 和 Binder 驱动通信，直到结束</span><br></pre></td></tr></table></figure><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的"><a href="#1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的" class="headerlink" title="1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的"></a>1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的</h2><p>应用 Service 是发布到 AMS 上的，客户端从 AMS 上去查找 Service 的 Binder 对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Service-的启动-独立进程的-Service&quot;&gt;&lt;a href=&quot;#Service-的启动-独立进程的-Service&quot; class=&quot;headerlink&quot; title=&quot;Service 的启动 (独立进程的 Service )&quot;&gt;&lt;/a&gt;Service 的启动 (独立进程的 Service )&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>InputManagerService</title>
    <link href="http://yoursite.com/2021/10/18/Android/Framework/InputManagerService/"/>
    <id>http://yoursite.com/2021/10/18/Android/Framework/InputManagerService/</id>
    <published>2021-10-18T13:31:03.000Z</published>
    <updated>2021-10-18T14:01:44.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="native层概述"><a href="#native层概述" class="headerlink" title="native层概述"></a>native层概述</h2><h3 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h3><p>输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。</p><a id="more"></a><p>InputReader 持有 InputMapper 对应不同的输入设备的 事件加工器。 </p><p>事件加工后，InputReader 会 调用 InputDispatcher.notifyXXX 函数 唤醒 InputDispatcher 进行事件分发</p><h3 id="InputDispatcher"><a href="#InputDispatcher" class="headerlink" title="InputDispatcher"></a>InputDispatcher</h3><p>输入事件的分发者。 分发输入事件到目标窗口。 运行在 InputDispatcherThread 中， 这个线程平时是休眠状态，等待 InputReader 的唤醒</p><p>被唤醒后，调用 dispatchOnceInnerLocked 将输入事件分发到合适的窗口中</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;native层概述&quot;&gt;&lt;a href=&quot;#native层概述&quot; class=&quot;headerlink&quot; title=&quot;native层概述&quot;&gt;&lt;/a&gt;native层概述&lt;/h2&gt;&lt;h3 id=&quot;InputReader&quot;&gt;&lt;a href=&quot;#InputReader&quot; class=&quot;headerlink&quot; title=&quot;InputReader&quot;&gt;&lt;/a&gt;InputReader&lt;/h3&gt;&lt;p&gt;输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin-flow</title>
    <link href="http://yoursite.com/2021/10/04/Kotlin/kotlin-flow/"/>
    <id>http://yoursite.com/2021/10/04/Kotlin/kotlin-flow/</id>
    <published>2021-10-04T06:58:00.000Z</published>
    <updated>2021-10-05T11:55:11.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础的流"><a href="#基础的流" class="headerlink" title="基础的流"></a>基础的流</h1><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// 流构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们在这里做了一些有用的事情</span></span><br><span class="line">        emit(i) <span class="comment">// 发送下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">"I'm not blocked <span class="variable">$k</span>"</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集这个流</span></span><br><span class="line">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="flow-是-”冷流“"><a href="#flow-是-”冷流“" class="headerlink" title="flow 是 ”冷流“"></a>flow 是 ”冷流“</h2><ul><li>冷流的定义：  flow 构建器中的代码直到流被调用 collect 的时候才运行。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">flow</span><span class="params">(<span class="meta">@BuilderInference</span> block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.()</span></span> -&gt; <span class="built_in">Unit</span>): Flow&lt;T&gt; = SafeFlow(block)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeFlow</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> FlowCollector&lt;T&gt;.() -&gt; <span class="built_in">Unit</span>) : AbstractFlow&lt;T&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collectSafely</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        collector.block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlowCollector</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flow 的实现如上，只不过是传入了 代码块作为 FlowCollector 的拓展函数。<br>当 流开始收集 （调用collect），会执行这个 flow 的代码块。<br>在 collect 中传入的代码块， 实际上是一个 FlowCollector 匿名对象，当 flow 的代码块调用 emit 的时候，就直接调用了 collect 后的代码块。</p><p>用一个例子体现这一点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">1</span>) &#123;</span><br><span class="line">        log(<span class="string">"Emit start <span class="variable">$i</span>"</span>)</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">        log(<span class="string">"Emit end <span class="variable">$i</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .collect &#123; value -&gt;</span><br><span class="line">            log(<span class="string">"Collected start <span class="variable">$value</span>"</span>)</span><br><span class="line">            delay(<span class="number">300</span>)</span><br><span class="line">            log(<span class="string">"Collected end <span class="variable">$value</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] Emit start 1</span><br><span class="line">[main] Collected start 1</span><br><span class="line">[main] Collected end 1</span><br><span class="line">[main] Emit end 1</span><br></pre></td></tr></table></figure><h2 id="流的上下文保存"><a href="#流的上下文保存" class="headerlink" title="流的上下文保存"></a>流的上下文保存</h2><ul><li>上下文保存： <strong>flow { … } 构建器中的代码运行在相应流的收集器提供的上下文中</strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line">           </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    log(<span class="string">"Started simple flow"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt; log(<span class="string">"Collected <span class="variable">$value</span>"</span>) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#1] Started simple flow</span><br><span class="line">[main @coroutine#1] Collected 1</span><br><span class="line">[main @coroutine#1] Collected 2</span><br><span class="line">[main @coroutine#1] Collected 3</span><br></pre></td></tr></table></figure><p>由于 simple().collect 是在主线程调用的，那么 simple 的流主体也是在主线程调用的。<br><strong>如果在 调用<code>emit</code>时切换协程上下文，会直接抛出异常</strong></p><ul><li>flowOn: 正确的切换 flow 的上下文</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line">           </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们以消耗 CPU 的方式进行计算</span></span><br><span class="line">        log(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// 在流构建器中改变协程上下文的正确方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt;</span><br><span class="line">        log(<span class="string">"Collected <span class="variable">$value</span>"</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决-背压问题"><a href="#解决-背压问题" class="headerlink" title="解决 背压问题"></a>解决 背压问题</h2><p>名词解释：<strong>背压： 假设有一个快的数据生产者和一个慢的数据消费者，背压就是一种 “倒逼 “生产者而使自己不被数据淹没的机制</strong></p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>并发运行这个 流中发射元素的代码以及收集的代码， 而不是顺序运行它们； buffer() 会给切换 flow 的协程，保证 发送端 是不阻塞的 。 可以设置 buffer 容量和策略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .buffer() <span class="comment">// 缓冲发射项，无需等待</span></span><br><span class="line">            .collect &#123; value -&gt; </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(value) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conflate"><a href="#conflate" class="headerlink" title="conflate"></a>conflate</h3><p>一种特殊 buffer 策略 新数据会覆盖老数据</p><h3 id="collectLatest"><a href="#collectLatest" class="headerlink" title="collectLatest"></a>collectLatest</h3><p>它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .collectLatest &#123; value -&gt; <span class="comment">// 取消并重新发射最后一个值</span></span><br><span class="line">                println(<span class="string">"Collecting <span class="variable">$value</span>"</span>) </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(<span class="string">"Done <span class="variable">$value</span>"</span>) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collecting 1</span><br><span class="line">Collecting 2</span><br><span class="line">Collecting 3</span><br><span class="line">Done 3</span><br><span class="line">Collected in 741 ms</span><br></pre></td></tr></table></figure><h1 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h1><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">val</span> flow = MutableStateFlow(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> success = flow.tryEmit(i)</span><br><span class="line">            println(<span class="string">"tryEmit <span class="variable">$i</span> <span class="variable">$success</span>"</span>)</span><br><span class="line"><span class="comment">//            delay(200)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            produce()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch(Dispatchers.IO)&#123;</span><br><span class="line"></span><br><span class="line">            flow.onEach &#123;</span><br><span class="line">                println(<span class="string">"receive-1 <span class="variable">$it</span>"</span>)</span><br><span class="line">                delay(<span class="number">500</span>)</span><br><span class="line">            &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="StateFlow-是一个-“流”"><a href="#StateFlow-是一个-“流”" class="headerlink" title="StateFlow 是一个 “流”"></a>StateFlow 是一个 “流”</h2><p>不同于普通的 flow ， StateFlow 是一个热数据流。 不需要主动调动 collect{…} , 就能 emit 数据</p><h2 id="StateFlow-的-collect-是阻塞的，需要在单独的协程中运行"><a href="#StateFlow-的-collect-是阻塞的，需要在单独的协程中运行" class="headerlink" title="StateFlow 的 collect 是阻塞的，需要在单独的协程中运行"></a>StateFlow 的 collect 是阻塞的，需要在单独的协程中运行</h2><p>在demo中调用了 launchIn ，而不是直接 collect 。 看一下源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StateFlow </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _state = atomic(initialState)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> slot = allocateSlot()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (collector <span class="keyword">is</span> SubscribedFlowCollector) collector.onSubscription()</span><br><span class="line">            <span class="keyword">val</span> collectorJob = currentCoroutineContext()[Job]</span><br><span class="line">            <span class="keyword">var</span> oldState: Any? = <span class="literal">null</span> </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newState = _state.value</span><br><span class="line">                collectorJob?.ensureActive()</span><br><span class="line">                <span class="keyword">if</span> (oldState == <span class="literal">null</span> || oldState != newState) &#123;</span><br><span class="line">                    collector.emit(NULL.unbox(newState))</span><br><span class="line">                    oldState = newState</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!slot.takePending()) &#123; <span class="comment">// try fast-path without suspending first</span></span><br><span class="line">                    slot.awaitPending() <span class="comment">// only suspend for new values when needed</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            freeSlot(slot)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 collec 中，一个 while 死循环，开始不断读取 _state.value 的值<br>solt 可以看做是 collector 的一个封装。 这里调用了 slot.awaitPending() 来挂起当前协程，让出cpu时间. 看一下 StateFlowSlot 是如何挂起的 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">awaitPending</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = suspendCancellableCoroutine <span class="symbol">sc@</span> &#123; cont -&gt;</span><br><span class="line">    <span class="comment">// 如果 _state 是 None ，就设置为 cont </span></span><br><span class="line">    <span class="comment">// cont 的类型 CancellableContinuation ，只用调用 resume 或 fail 等，才会结束，否则挂起当前协程</span></span><br><span class="line">    <span class="keyword">if</span> (_state.compareAndSet(NONE, cont)) <span class="keyword">return</span><span class="symbol">@sc</span></span><br><span class="line">    cont.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 StateFlow 的 emit 被调用的时候， 会获取到 solt 中的 CancellableContinuation 对象，调用其 resume ，将协程进行唤醒</p><h1 id="ShareFlow"><a href="#ShareFlow" class="headerlink" title="ShareFlow"></a>ShareFlow</h1><h2 id="demo-2"><a href="#demo-2" class="headerlink" title="demo"></a>demo</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> flow = MutableSharedFlow&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">    replay = <span class="number">0</span>, </span><br><span class="line">    extraBufferCapacity = <span class="number">100</span>, </span><br><span class="line">    onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> success = flow.tryEmit(i)</span><br><span class="line">        println(<span class="string">"tryEmit <span class="variable">$i</span> <span class="variable">$success</span>"</span>)</span><br><span class="line"><span class="comment">//            delay(200)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    launch(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        produce()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch(Dispatchers.IO)&#123;</span><br><span class="line"></span><br><span class="line">        flow.onEach &#123;</span><br><span class="line">            println(<span class="string">"receive-1 <span class="variable">$it</span>"</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">        &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MutableShareFlow 的三个参数：</p><ul><li>通过 replay ，您可以针对新订阅者重新发送多个之前已发出的值</li><li>extraBufferCapacity: 除了 replay 值以外的缓冲区容量。 extraBufferCapacity + replay 是缓冲区buffer的容量</li><li>通过 onBufferOverflow，您可以指定相关政策来处理缓冲区中已存满要发送的数据项的情况。默认值为 BufferOverflow.SUSPEND，这会使调用方挂起。其他选项包括 DROP_LATEST 或 DROP_OLDEST</li></ul><p>ShareFlow 在收集侧 和 StateFlow 基本一致。 都是 while 死循环，然后将 solt 挂起。 这里不再赘述</p><!-- ## BufferOverflow.SUSPEND, tryEmit 和 Emit当  -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础的流&quot;&gt;&lt;a href=&quot;#基础的流&quot; class=&quot;headerlink&quot; title=&quot;基础的流&quot;&gt;&lt;/a&gt;基础的流&lt;/h1&gt;&lt;h2 id=&quot;demo&quot;&gt;&lt;a href=&quot;#demo&quot; class=&quot;headerlink&quot; title=&quot;demo&quot;&gt;&lt;/a&gt;demo&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; kotlinx.coroutines.*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; kotlinx.coroutines.flow.*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;simple&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: Flow&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt; = flow &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 流构建器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delay(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 假装我们在这里做了一些有用的事情&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        emit(i) &lt;span class=&quot;comment&quot;&gt;// 发送下一个值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = runBlocking&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Unit&lt;/span&gt;&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 启动并发的协程以验证主线程并未阻塞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    launch &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            println(&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m not blocked &lt;span class=&quot;variable&quot;&gt;$k&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            delay(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 收集这个流&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    simple().collect &amp;#123; value -&amp;gt; println(value) &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>nested2嵌套滚动机制</title>
    <link href="http://yoursite.com/2021/07/24/Android/nested2%E5%B5%8C%E5%A5%97%E6%BB%9A%E5%8A%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/07/24/Android/nested2嵌套滚动机制/</id>
    <published>2021-07-24T08:36:31.000Z</published>
    <updated>2021-10-03T01:57:41.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。</p><a id="more"></a><h2 id="NestedScrollingParent2"><a href="#NestedScrollingParent2" class="headerlink" title="NestedScrollingParent2"></a>NestedScrollingParent2</h2><p>NestedScrollingParent2 包含以下接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 即将开始嵌套滑动，此时嵌套滑动尚未开始，由子控件的 startNestedScroll 方法调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> child  嵌套滑动对应的父类的子类(因为嵌套滑动对于的父控件不一定是一级就能找到的，可能挑了两级父控件的父控件，child的辈分&gt;=target)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target 具体嵌套滑动的那个子类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> axes   嵌套滑动支持的滚动方向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type   嵌套滑动的类型，有两种ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true 表示此父类开始接受嵌套滑动，只有true时候，才会执行下面的 onNestedScrollAccepted 等操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当onStartNestedScroll返回为true时，也就是父控件接受嵌套滑动时，该方法才会调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> child</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> axes</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class="line"><span class="comment">    * 在嵌套滑动的子View未滑动之前</span></span><br><span class="line"><span class="comment">    * ，判断父view是否优先与子view处理(也就是父view可以先消耗，然后给子view消耗）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target   具体嵌套滑动的那个子类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dx       水平方向嵌套滑动的子View想要变化的距离</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dy       垂直方向嵌套滑动的子View想要变化的距离 dy&lt;0向下滑动 dy&gt;0 向上滑动</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> consumed 这个参数要我们在实现这个函数的时候指定，回头告诉子View当前父View消耗的距离</span></span><br><span class="line"><span class="comment">    *                 consumed[0] 水平消耗的距离，consumed[1] 垂直消耗的距离 好让子view做出相应的调整</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @NonNull <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">           </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class="line"><span class="comment">    * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target       具体嵌套滑动的那个子类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxConsumed   水平方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyConsumed   垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxUnconsumed 水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyUnconsumed 垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 停止滑动</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(@NonNull View target, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NestedScrollingChild2"><a href="#NestedScrollingChild2" class="headerlink" title="NestedScrollingChild2"></a>NestedScrollingChild2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingChild2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 开始滑动前调用，在惯性滑动和触摸滑动前都会进行调用，此方法一般在 onInterceptTouchEvent或者onTouch中，通知父类方法开始滑动</span></span><br><span class="line"><span class="comment">    * 会调用父类方法的 onStartNestedScroll onNestedScrollAccepted 两个方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> axes 滑动方向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type 开始滑动的类型 the type of input which cause this scroll event</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 有父视图并且开始滑动，则返回true 实际上就是看parent的 onStartNestedScroll 方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(@ScrollAxis <span class="keyword">int</span> axes, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 子控件停止滑动，例如手指抬起，惯性滑动结束</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type 停止滑动的类型 TYPE_TOUCH，TYPE_NON_TOUCH</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">(@NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断是否有父View 支持嵌套滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">(@NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在dispatchNestedPreScroll 之后进行调用</span></span><br><span class="line"><span class="comment">    * 当滑动的距离父控件消耗后，父控件将剩余的距离再次交个子控件，</span></span><br><span class="line"><span class="comment">    * 子控件再次消耗部分距离后，又继续将剩余的距离分发给父控件,由父控件判断是否消耗剩下的距离。</span></span><br><span class="line"><span class="comment">    * 如果四个消耗的距离都是0，则表示没有神可以消耗的了，会直接返回false，否则会调用父控件的</span></span><br><span class="line"><span class="comment">    * onNestedScroll 方法，父控件继续消耗剩余的距离</span></span><br><span class="line"><span class="comment">    * 会调用父控件的</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxConsumed     水平方向嵌套滑动的子控件滑动的距离(消耗的距离)    dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyConsumed     垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)    dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxUnconsumed   水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyUnconsumed   垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 如果返回true, 表示父控件又继续消耗了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, @Nullable <span class="keyword">int</span>[] offsetInWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 子控件在开始滑动前，通知父控件开始滑动，同时由父控件先消耗滑动时间</span></span><br><span class="line"><span class="comment">    * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离</span></span><br><span class="line"><span class="comment">    * 最终会调用父view的 onNestedPreScroll 方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dx             水平方向嵌套滑动的子控件想要变化的距离 dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dy             垂直方向嵌套滑动的子控件想要变化的距离 dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> consumed       父控件消耗的距离，父控件消耗完成之后，剩余的才会给子控件，子控件需要使用consumed来进行实际滑动距离的处理</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type           滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true    表示父控件进行了滑动消耗，需要处理 consumed 的值，false表示父控件不对滑动距离进行消耗，可以不考虑consumed数据的处理，此时consumed中两个数据都应该为0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @Nullable <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           @Nullable <span class="keyword">int</span>[] offsetInWindow, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nested2机制，滚动的传递"><a href="#nested2机制，滚动的传递" class="headerlink" title="nested2机制，滚动的传递"></a>nested2机制，滚动的传递</h2><p>一般情况下，事件是从child的触摸事件开始的，</p><ol><li><p>首先调用 <code>child.startNestedScroll()</code> 方法，此方法内部通过 <code>NestedScrollingChildHelper</code> 调用并返回 <code>parent.onStartNestedScroll()</code> 方法的结果，为 true，说明parent接受了嵌套滑动，同时会调用 <code>parent.onNestedScrollAccepted()</code> 方法，此时开始嵌套滑动；</p></li><li><p>在滑动事件中，child通过 <code>child.dispatchNestedPreScroll()</code> 方法分配滑动的距离，内部会先调用 <code>parent.onNestedPreScroll()</code> 方法，由parent先处理滑动距离。</p></li><li><p>parent消耗完成之后，再将剩余的距离传递给child，child拿到parent使用完成之后的距离之后，自己再处理剩余的距离。</p></li><li><p>如果此时子控件还有未处理的距离，则将剩余的距离再次通过 <code>child.dispatchNestedScroll()</code> 方法调用 <code>parent.onNestedScroll()</code> 方法，将剩余的距离交个parent来进行处理</p></li><li><p>滑动结束之后，调用 child.stopNestedScroll()通知parent滑动结束，至此，触摸滑动结束</p></li></ol><p>触摸滑动结束之后，child会继续进行惯性滑动，惯性滑动可以通过 Scroller 实现，具体滑动可以自己来处理，在fling过程中，和触摸滑动调用流程一样，需要注意 type 参数的区分，用来通知parent两种不同的滑动流程</p><h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><h3 id="预期目标"><a href="#预期目标" class="headerlink" title="预期目标"></a>预期目标</h3><p>自己实现一个嵌套滚动的 parent 和 child， 满足以下效果</p><ol><li>parent 包含 top 和 content 两部分，可滚动</li><li>当 top 未完全隐藏是，滚动 content ，是外层的 parent 滚动</li><li>当 top 完全隐藏，触摸滚动 content ，content 自己滚动</li><li>当触摸 content 滚动到顶部， top 未完全漏出， 则 parent 滚动，直至 top 完全露出</li></ol><h3 id="xml布局"><a href="#xml布局" class="headerlink" title="xml布局"></a>xml布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.test2.nest2_test.CustomNestedParent</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nested_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.core.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/view_top"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">androidx.core.widget.NestedScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">com.example.test2.nest2_test.CustomNestedChild</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/view_list"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"1500dp"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.example.test2.nest2_test.CustomNestedParent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里模仿 ScrollView 嵌套 ScrollView 的场景，即外部的 CustomNestedParent 嵌套 内部的 CustomNestedChild ，并解决他们的之间的滑动冲突<br>topVie2 外面包裹了一层 NestedScrollView，是为了让它支持 nested 机制</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedTestActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> nestedParent: CustomNestedParent</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> listView: LinearLayout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_nested_test)</span><br><span class="line"></span><br><span class="line">        nestedParent = findViewById(R.id.nested_parent)</span><br><span class="line">        <span class="keyword">val</span> topView: View = findViewById(R.id.view_top)</span><br><span class="line">        listView = findViewById(R.id.view_list)</span><br><span class="line"></span><br><span class="line">        nestedParent.<span class="keyword">init</span>(topView, listView)</span><br><span class="line"></span><br><span class="line">        addListItems()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">addListItems</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 填充 child， 这里模拟 child 是一个 recyclerview</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> textView = TextView(<span class="keyword">this</span>)</span><br><span class="line">            textView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, <span class="number">100</span>)</span><br><span class="line">            textView.text = <span class="string">"position <span class="variable">$i</span>"</span></span><br><span class="line">            listView.addView(textView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CustomNestedParent"><a href="#CustomNestedParent" class="headerlink" title="CustomNestedParent"></a>CustomNestedParent</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNestedParent</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context?,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingParent2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> TAG = <span class="string">"CustomNestedParent"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mNestedScrollingParentHelper = NestedScrollingParentHelper(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> topView: View</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> nestedChild: View</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> childrenHeight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinishInflate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onFinishInflate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(topView: <span class="type">View</span>, contentView: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.topView = topView</span><br><span class="line">        <span class="keyword">this</span>.nestedChild = contentView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 模仿 NestedScrollView</span></span><br><span class="line">        <span class="keyword">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">        <span class="keyword">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        childrenHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getChildAt(i)</span><br><span class="line">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class="line">            childrenHeight += child.measuredHeight</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(width, height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行其他操作</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartNestedScroll</span><span class="params">(child: <span class="type">View</span>, target: <span class="type">View</span>, axes: <span class="type">Int</span>, type: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onStartNestedScroll: "</span>)</span><br><span class="line">        <span class="keyword">return</span> axes == ViewCompat.SCROLL_AXIS_VERTICAL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当嵌套滑动被parent接收了，会回调这个方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedScrollAccepted</span><span class="params">(child: <span class="type">View</span>, target: <span class="type">View</span>, axes: <span class="type">Int</span>, type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onNestedScrollAccepted: "</span>)</span><br><span class="line">        mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes, type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class="line"><span class="comment">     * 不管手势滚动还是fling都会回调这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedPreScroll</span><span class="params">(target: <span class="type">View</span>, dx: <span class="type">Int</span>, dy: <span class="type">Int</span>, consumed: <span class="type">IntArray</span>, type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> threshold = nestedChild.top</span><br><span class="line">        <span class="keyword">var</span> parentScrollable = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> hideTop = dy &gt; <span class="number">0</span> &amp;&amp; scrollY &lt; threshold</span><br><span class="line">        <span class="keyword">val</span> showTop = dy &lt; <span class="number">0</span> &amp;&amp; !target.canScrollVertically(-<span class="number">1</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">"onNestedPreScroll-1: <span class="variable">$dy</span> <span class="variable">$type</span>"</span>)</span><br><span class="line">        <span class="keyword">if</span> (hideTop || showTop) &#123;</span><br><span class="line">          <span class="comment">// parent 提前消费的场景 </span></span><br><span class="line">          <span class="comment">// 1. 向上滚动，parent滚动的距离 &lt; topView的高度，需要隐藏topView </span></span><br><span class="line">          <span class="comment">// 2. 向下滚动，且 child 已经滚动到顶部，需要漏出 topView</span></span><br><span class="line">            parentScrollable = <span class="literal">true</span></span><br><span class="line">            consumed[<span class="number">1</span>] = dy</span><br><span class="line">            scrollBy(<span class="number">0</span>, dy)</span><br><span class="line">            Log.i(TAG, <span class="string">"onNestedPreScroll-2: hideTop=<span class="variable">$hideTop</span> showTop=<span class="variable">$showTop</span> dy=<span class="variable">$dy</span> scrollY=<span class="variable">$scrollY</span> threshold=<span class="variable">$threshold</span> type=<span class="variable">$type</span>"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 反之，应该让 child 滚动，parent不应该消费滚动距离</span></span><br><span class="line">            parentScrollable = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class="line"><span class="comment">     * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 孩子吃剩下的留给爸爸了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        target: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dxConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dxUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onNestedScroll: <span class="variable">$dyUnconsumed</span> <span class="variable">$type</span> <span class="variable">$scrollY</span>"</span>)</span><br><span class="line">        <span class="comment">// 剩余的parent全部消费</span></span><br><span class="line">        scrollBy(<span class="number">0</span>, dyUnconsumed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStopNestedScroll</span><span class="params">(target: <span class="type">View</span>, type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mNestedScrollingParentHelper.onStopNestedScroll(target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNestedScrollAxes</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mNestedScrollingParentHelper.nestedScrollAxes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollTo</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> resY = y</span><br><span class="line">        <span class="comment">// 限定 parnet 的上下边界，防止滚动出屏幕外</span></span><br><span class="line">        <span class="keyword">if</span> (resY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            resY = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> max = max(childrenHeight - height, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &gt; max) &#123;</span><br><span class="line">            resY = max</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"scrollTo: <span class="variable">$max</span> <span class="variable">$y</span> <span class="variable">$resY</span>"</span>)</span><br><span class="line">        <span class="keyword">super</span>.scrollTo(x, resY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CustomNestedChild"><a href="#CustomNestedChild" class="headerlink" title="CustomNestedChild"></a>CustomNestedChild</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNestedChild</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context?,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingChild2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> TAG = <span class="string">"CustomNestedChild"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mScrollingChildHelper = NestedScrollingChildHelper(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewConfiguration: ViewConfiguration = ViewConfiguration.<span class="keyword">get</span>(context)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mVelocityTracker: VelocityTracker? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mScroller: Scroller = Scroller(context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastX: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastY: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastFlingX: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastFlingY: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> offset = IntArray(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> consumed = IntArray(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fling = <span class="literal">false</span> <span class="comment">//判断当前是否是可以进行惯性滑动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> childrenHeight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        orientation = VERTICAL</span><br><span class="line">        <span class="comment">// 这里必须都设置为 true ，表明这个view是支持nested2机制的</span></span><br><span class="line">        isNestedScrollingEnabled = <span class="literal">true</span></span><br><span class="line">        mScrollingChildHelper.isNestedScrollingEnabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">        <span class="keyword">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        childrenHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getChildAt(i)</span><br><span class="line">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class="line">            childrenHeight += child.measuredHeight</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(width, height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startNestedScroll</span><span class="params">(axes: <span class="type">Int</span>, type: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.startNestedScroll(axes, type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">stopNestedScroll</span><span class="params">(type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mScrollingChildHelper.stopNestedScroll(type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNestedScrollingParent</span><span class="params">(type: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.hasNestedScrollingParent()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        dx: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dy: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        consumed: <span class="type">IntArray</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        offsetInWindow: <span class="type">IntArray</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchNestedScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        dxConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dxUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        offsetInWindow: <span class="type">IntArray</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedScroll(</span><br><span class="line">            dxConsumed,</span><br><span class="line">            dyConsumed,</span><br><span class="line">            dxUnconsumed,</span><br><span class="line">            dyUnconsumed,</span><br><span class="line">            offsetInWindow,</span><br><span class="line">            type</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">// 处理触摸事件是，关闭fling</span></span><br><span class="line">        cancelFling()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker == <span class="literal">null</span>) &#123;</span><br><span class="line">            mVelocityTracker = VelocityTracker.obtain()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> velocityTracker = mVelocityTracker!!</span><br><span class="line">        velocityTracker.addMovement(event)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                mLastX = event.x</span><br><span class="line">                mLastY = event.y</span><br><span class="line">                <span class="comment">// 表明开始处理嵌套滚动， TYPE_TOUCH 表明这是一个触摸场景</span></span><br><span class="line">                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> curX = event.x</span><br><span class="line">                <span class="keyword">val</span> curY = event.y</span><br><span class="line">                <span class="keyword">var</span> dy = (mLastY - curY).toInt()</span><br><span class="line">                <span class="keyword">var</span> dx = (mLastX - curX).toInt()</span><br><span class="line">                <span class="comment">// 先交给parent处理</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchNestedPreScroll(dx, dy, consumed, offset, TYPE_TOUCH)) &#123;</span><br><span class="line">                    dy -= consumed[<span class="number">1</span>]</span><br><span class="line">                    dx -= consumed[<span class="number">0</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// child自己消费</span></span><br><span class="line">                <span class="keyword">val</span> consumedY = childConsumeY(dy)</span><br><span class="line">                <span class="comment">// 将消费剩下的，传递给parent</span></span><br><span class="line">                dispatchNestedScroll(<span class="number">0</span>, consumedY, dx, dy - consumedY, <span class="literal">null</span>, TYPE_TOUCH)</span><br><span class="line">                mLastX = curX</span><br><span class="line">                mLastY = curY</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP,</span><br><span class="line">            MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">              <span class="comment">// 先结束 TYPE_TOUCH 场景的嵌套滚动</span></span><br><span class="line">                stopNestedScroll(TYPE_TOUCH)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否需要惯性滑动</span></span><br><span class="line">                velocityTracker.computeCurrentVelocity(</span><br><span class="line">                    <span class="number">1000</span>,</span><br><span class="line">                    viewConfiguration.scaledMaximumFlingVelocity.toFloat()</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">val</span> yvel = velocityTracker.yVelocity</span><br><span class="line">                fling(yvel.toInt())</span><br><span class="line">                velocityTracker.clear()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fling</span><span class="params">(velocityY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        cancelFling()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断速度是否足够大。如果够大才执行fling</span></span><br><span class="line">        <span class="keyword">var</span> dy: <span class="built_in">Int</span> = velocityY</span><br><span class="line">        <span class="keyword">if</span> (abs(velocityY) &lt; viewConfiguration.scaledMinimumFlingVelocity) &#123;</span><br><span class="line">            dy = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dy == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这步必须要有，表明开始 TYPE_NON_TOUCH 的嵌套滚动</span></span><br><span class="line">        <span class="comment">// 如果不设置，后续的嵌套滚动流程都都会找不到对应的parent</span></span><br><span class="line">        startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_NON_TOUCH)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> maxFlingVelocity: <span class="built_in">Int</span> = viewConfiguration.scaledMaximumFlingVelocity</span><br><span class="line">        dy = max(-maxFlingVelocity, min(dy, maxFlingVelocity))</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"fling: <span class="variable">$dy</span> "</span>)</span><br><span class="line">        fling = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 开始fling</span></span><br><span class="line">        mScroller.fling(</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            dy,</span><br><span class="line">            Integer.MIN_VALUE,</span><br><span class="line">            Integer.MAX_VALUE,</span><br><span class="line">            Integer.MIN_VALUE,</span><br><span class="line">            Integer.MAX_VALUE</span><br><span class="line">        )</span><br><span class="line">        postInvalidate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeScroll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset() &amp;&amp; fling) &#123;</span><br><span class="line">            <span class="keyword">val</span> y = mScroller.currY</span><br><span class="line">            <span class="keyword">var</span> dy = (mLastFlingY - y).toInt()</span><br><span class="line">            mLastFlingY = y.toFloat()</span><br><span class="line">            <span class="comment">// 和触摸场景一样，优先让parent处理</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchNestedPreScroll(<span class="number">0</span>, dy, consumed, <span class="literal">null</span>, TYPE_NON_TOUCH)) &#123;</span><br><span class="line">                dy -= consumed[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">"computeScroll: <span class="subst">$&#123;consumed[<span class="number">1</span>]&#125;</span> <span class="variable">$dy</span>"</span>)</span><br><span class="line">            <span class="comment">// child 自己处理</span></span><br><span class="line">            <span class="keyword">val</span> consumedY = childFling(dy)</span><br><span class="line">            <span class="comment">// 将剩下的在传递给 parent</span></span><br><span class="line">            dispatchNestedScroll(<span class="number">0</span>, consumedY, <span class="number">0</span>, dy - consumedY, <span class="literal">null</span>, TYPE_NON_TOUCH)</span><br><span class="line">            postInvalidate()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stopNestedScroll(TYPE_NON_TOUCH)</span><br><span class="line">            cancelFling()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">childConsumeY</span><span class="params">(dy: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> consumed = dy</span><br><span class="line">        <span class="keyword">if</span> (consumed &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果滑动到顶部，只处理部分，不然可能无法触达顶部边界</span></span><br><span class="line">            consumed = max(-scrollY, consumed)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果滑动到顶部，只处理部分，不然可能会无法触达底部边界</span></span><br><span class="line">            <span class="keyword">val</span> max = max(childrenHeight - height, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (dy + scrollY &gt; max) &#123;</span><br><span class="line">                consumed = max - scrollY</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"childConsumeY: <span class="variable">$dy</span> <span class="variable">$consumed</span> <span class="variable">$scrollY</span>"</span>)</span><br><span class="line">        scrollBy(<span class="number">0</span>, consumed)</span><br><span class="line">        <span class="keyword">return</span> consumed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">childFling</span><span class="params">(dy: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> childConsumeY(dy)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelFling</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fling = <span class="literal">false</span></span><br><span class="line">        mLastFlingY = <span class="number">0f</span></span><br><span class="line">        mLastFlingY = <span class="number">0f</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollTo</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> resY = y</span><br><span class="line">        <span class="keyword">if</span> (resY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            resY = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> max = max(childrenHeight - height, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &gt; max) &#123;</span><br><span class="line">            resY = max</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"scrollTo: <span class="variable">$max</span> <span class="variable">$y</span> <span class="variable">$resY</span>"</span>)</span><br><span class="line">        <span class="keyword">super</span>.scrollTo(x, resY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">canScrollVertically</span><span class="params">(direction: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction &lt; <span class="number">0</span> &amp;&amp; scrollY &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction &gt; <span class="number">0</span> &amp;&amp; scrollY &gt;= measuredHeight - height) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844903960432607246#heading-1" target="_blank" rel="noopener">https://juejin.cn/post/6844903960432607246#heading-1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h2&gt;&lt;p&gt;nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nested2" scheme="http://yoursite.com/tags/nested2/"/>
    
  </entry>
  
  <entry>
    <title>编译aosp</title>
    <link href="http://yoursite.com/2021/05/22/%E7%BC%96%E8%AF%91aosp/"/>
    <id>http://yoursite.com/2021/05/22/编译aosp/</id>
    <published>2021-05-22T09:12:59.000Z</published>
    <updated>2021-10-03T01:57:41.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘</li></ol><a id="more"></a><h1 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h1><ol><li>下载 Repo 工具，并确保它可执行：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure><p>使用清华源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git-repo-downloads/repo  &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure></p><ol start="2"><li>初始化 Repo</li></ol><p>-b 后面可以指定要同步代码的安卓系统版本代号<br>版本代号可以在下面的链接中查找<br><a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">https://source.android.com/setup/start/build-numbers</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1</span><br></pre></td></tr></table></figure><p>使用清华源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r40</span><br></pre></td></tr></table></figure></p><ol start="3"><li>同步 Repo</li></ol><p>需要几个小时的时间同步代码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>执行下面的命令，<br>lunch 选择编译模式（ 这里我选择的是  aosp_x86_64-eng）<br>m （m 命令系统会根据cpu性能自动选取需要使用的线程，你也可以根据cpu多少使用 make -jN, N表示cpu个数x2）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">lunch  aosp_x86_64-eng</span><br><span class="line">m</span><br></pre></td></tr></table></figure><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><ul><li>找不到对应的MacOSX.sdk<br>Could not find a supported mac sdk: [“10.10” “10.11” “10.12” “10.13”]</li></ul><p>我的系统版本是10.15，你需要到 <a href="https://github.com/phracker/MacOSX-SDKs/releases" target="_blank" rel="noopener">https://github.com/phracker/MacOSX-SDKs/releases</a> 下载需要的版本</p><p>我这里下载的是MacOSX10.12.sdk，解压复制到如下目录：<br>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</p><ul><li>不知名报错、</li></ul><p>找到文件：源文件根目录/system/sepolicy/tests/Android.bp，删除掉第14行的一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// libsepolwrap gets loaded from the system python, which does not have the</span><br><span class="line">// ASAN runtime. So turn off sanitization for ourself, and  use static</span><br><span class="line">// libraries, since the shared libraries will use ASAN.</span><br><span class="line">static_libs: [</span><br><span class="line">    &quot;libbase&quot;,</span><br><span class="line">    &quot;libsepol&quot;,</span><br><span class="line">],</span><br><span class="line">stl: &quot;libc++_static&quot;, // 删除掉这一行</span><br><span class="line">sanitize: &#123;</span><br><span class="line">    never: true,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="使用-Android-Studio-阅读源码"><a href="#使用-Android-Studio-阅读源码" class="headerlink" title="使用 Android Studio 阅读源码"></a>使用 Android Studio 阅读源码</h1><ol><li>生成 Android Studio 工程配置文件</li></ol><p>生成 android.iml 和 android.ipr 文件。</p><p>其中 iml 文件 表示 information of modules, 用来描述 AOSP 的模块信息。<br>ipr 文件 表示 IDEA project configuration ，用来描述 IDEA 的工程配置信息，双击此文件时系统将直接使用 Andorid Studio 打开此项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 设置 AOSP 编译所需的环境变量</span><br><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="meta">#</span> 使用 idegen.sh 脚本生成 IDEA 工程文件</span><br><span class="line">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="AOSP" scheme="http://yoursite.com/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>屏幕刷新机制</title>
    <link href="http://yoursite.com/2021/03/18/Android/Framework/%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/03/18/Android/Framework/屏幕刷新机制/</id>
    <published>2021-03-17T16:05:08.000Z</published>
    <updated>2021-10-03T01:57:41.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h1><p>view.requestLayout 最终会调用 ViewRootImpl.requestLayout</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();  <span class="comment">// 检查线程是否是 ViewRootImpl 实例化的线程</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mTraversalScheduled 标记位，避免短时间多次调用requestLayout重复刷新</span></span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 添加一个同步屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// 通过 Choreographer 添加一个 Vsync 回调</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 measure layout draw 三步走</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</code> 这个操作会在 LooperQueue 中添加一个同步屏障，阻断同步 message（普通 message ）的执行。<br>（异步 message 能正常执行）<br>这里主要是为了保证在 Vync 到来时，这个 message 能够快速响应，保证在 Vync 到来的最初时刻就开始绘制，从而保证 UI 的绘制和 Vync 的周期是协调的。</p><p><code>mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</code> 添加一个 Vsync 回调。在 Vsync 信号到来时执行 mTraversalRunnable 。</p><h1 id="Choreographer"><a href="#Choreographer" class="headerlink" title="Choreographer"></a>Choreographer</h1><p>Choreographer 是用来监听 Vsync 信号的一个类。 在刷新UI时主要有两步。</p><h2 id="添加一个-vsync-信号的回调"><a href="#添加一个-vsync-信号的回调" class="headerlink" title="添加一个 vsync 信号的回调"></a>添加一个 vsync 信号的回调</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">// 这里 mCallbackQueues 是多个事件的队列</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 延时做刷新，最终也会走 scheduleFrameLocked</span></span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="comment">// 判断是不是在 ViewRootImpl 实例化时的线程</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是，用一个 Handler 切换线程</span></span><br><span class="line">                <span class="comment">// 发送一个异步消息，并且放置在队列最前方</span></span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 native 方法请求一个 vsync 回调</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理-vsync-回调"><a href="#处理-vsync-回调" class="headerlink" title="处理 vsync 回调"></a>处理 vsync 回调</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Choreographer 的构造方法里实例化 DisplayEventReceiver</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">        mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">                ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">        mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">            mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHavePendingVsync;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mTimestampNanos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFrame;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, vsyncSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">            timestampNanos = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        <span class="comment">// 发送一个异步消息，注意，这里没有放置到消息队列最前端</span></span><br><span class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">// 当前时间 - vsync回调到来时间 = 主线程message耗时</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="comment">// 当超过了屏幕一帧刷新时间 16ms</span></span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                <span class="comment">// 当跳过的帧超过一定程度</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理屏幕刷新的回调，这里会调用 ViewRootImpl.TraversalRunnable</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;requestLayout&quot;&gt;&lt;a href=&quot;#requestLayout&quot; class=&quot;headerlink&quot; title=&quot;requestLayout&quot;&gt;&lt;/a&gt;requestLayout&lt;/h1&gt;&lt;p&gt;view.requestLayout 最终会调用 ViewRootImpl.requestLayout&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://yoursite.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>应用进程是如何启动的</title>
    <link href="http://yoursite.com/2021/03/07/Android/Framework/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E7%9A%84/"/>
    <id>http://yoursite.com/2021/03/07/Android/Framework/应用进程是如何启动的/</id>
    <published>2021-03-06T16:23:23.000Z</published>
    <updated>2021-10-03T01:57:41.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zygote的启动"><a href="#zygote的启动" class="headerlink" title="zygote的启动"></a>zygote的启动</h1><h2 id="zygote-的功能"><a href="#zygote-的功能" class="headerlink" title="zygote 的功能"></a>zygote 的功能</h2><p>zygote 进程的主要功能有两个：</p><a id="more"></a><ol><li>在系统启动时启动 SystemServer 进程</li><li>启动 应用进程</li></ol><h2 id="zygote-进程的启动过程"><a href="#zygote-进程的启动过程" class="headerlink" title="zygote 进程的启动过程"></a>zygote 进程的启动过程</h2><h3 id="zygote进程的创建。"><a href="#zygote进程的创建。" class="headerlink" title="zygote进程的创建。"></a>zygote进程的创建。</h3><p>在 Android 系统开机之后，会创建 init 进程，这是 Linux 系统启动后创建的第一个进程。 init 进程有一个配置文件 init.rc 。 将需要启动的服务写入到 init.rc 中， init 进程在启动后就会创建这些进程， 比如 zygote ， ServiceManager 等。</p><h3 id="zygote-进程的-native-部分。"><a href="#zygote-进程的-native-部分。" class="headerlink" title="zygote 进程的 native 部分。"></a>zygote 进程的 native 部分。</h3><p>zygote 的c层代码入口在 /rameworks/base/cmds/app_process/app_main.cpp 中，最终主要的工作内容在 /frameworks/base/core/jni/AndroidRuntime.cpp 。主要内容如下。不详细分析了</p><ul><li>启动虚拟机。</li><li>注册 JNI 函数</li><li>调用 Java 类 Zygote.main 方法，进入 Java 循环 。</li></ul><h3 id="zygote-进程的-Java-部分"><a href="#zygote-进程的-Java-部分" class="headerlink" title="zygote 进程的 Java 部分"></a>zygote 进程的 Java 部分</h3><p>zygote 的 java 入口在 /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /android_aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">        ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> Runnable caller;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            RuntimeInit.enableDdms();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">            String socketName = <span class="string">"zygote"</span>;</span><br><span class="line">            String abiList = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                    startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                    enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                    abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 socket</span></span><br><span class="line">            zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In some configurations, we avoid preloading resources and classes eagerly.</span></span><br><span class="line">            <span class="comment">// In such cases, we will preload things prior to our first fork.</span></span><br><span class="line">            <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">                <span class="comment">// 预加载类和资源</span></span><br><span class="line">                preload(bootTimingsTraceLog);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Zygote.resetNicePriority();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ... </span><br><span class="line">            <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">                <span class="comment">// fork SystemServer 进程</span></span><br><span class="line">                Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">                <span class="comment">// child (system_server) process.</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果 r != null ，说明是子进程 SystemServer ，r.run 应该是进入 SystemServer 的事件循环，然后直接return</span></span><br><span class="line">                    r.run();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// zygote 事件循环，不让zygote退出</span></span><br><span class="line">            caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">        <span class="comment">// command.</span></span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            caller.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>注册 Socket 服务， zygote 进程通过 socket 和 AMS 通信</li><li>预加载类和资源。这样在 fork SystemServer 和 应用进程时，能够直接拷贝给子进程使用</li><li>fork 出 SystemServer 进程， SystemServer 进程随后又会启动 Binder ，并启动这种系统 Service ，比如 AMS ，WMS 等。</li><li>进入 loop 循环，等待接收 AMS 的 Socket 消息。 收到消息后会调用 runOnce 方法，fork 出应用进程，并执行应用进程的 ActivityThread.main() </li></ul><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p><strong>注意：zygote fork 进程时一定是单线程的</strong><br><strong>zygote 新 fork 出来的进程不需要再创建java虚拟机，因为 fork 出来的子进程是会继承拷贝父进程的资源的， fork 出来的进程会拥有 zygote 进程的虚拟机的拷贝</strong><br><strong>为什么要设计一个 zygote 来 fork 应用进程，而不是 SystemServer : 因为systemServer中运行了很多系统服务，不能被继承。应用程序启动时，除了必要的资源外，最好是干净的，所以需要单独用一个zygote来fork。</strong></p><h3 id="zygote-的事件循环"><a href="#zygote-的事件循环" class="headerlink" title="zygote 的事件循环"></a>zygote 的事件循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/com/android/internal/os/ZygoteServer.java</span></span><br><span class="line">    <span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">        ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">        fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">        peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">                pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">                pollFds[i].fd = fds.get(i);</span><br><span class="line">                pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span></span><br><span class="line">                Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 这里没看懂。。。</span></span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    fds.add(newPeer.getFileDesciptor());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 处理接收到的消息</span></span><br><span class="line">                        ZygoteConnection connection = peers.get(i);</span><br><span class="line">                        <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java</span></span><br><span class="line">    <span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, ...);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 子进程</span></span><br><span class="line">                zygoteServer.setForkChild();</span><br><span class="line"></span><br><span class="line">                zygoteServer.closeServerSocket();</span><br><span class="line">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">                serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class="line">                        parsedArgs.startChildZygote);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 父进程</span></span><br><span class="line">                IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">                childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">                handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs, FileDescriptor[] descriptors,</span></span></span><br><span class="line"><span class="function"><span class="params">            FileDescriptor pipeFd, <span class="keyword">boolean</span> isZygote)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        closeSocket();</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">                <span class="comment">// 应用进程启动流程进入这个分支</span></span><br><span class="line">                <span class="comment">// 从 socket 传来参数中取出 class ，并执行 main 方法</span></span><br><span class="line">                <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没看懂这个分支是做什么的。。</span></span><br><span class="line">                <span class="comment">// 看注释的意思是提供了「跳过启动binder，直接创建进程」的方式</span></span><br><span class="line">                <span class="keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                        parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="应用进程的启动"><a href="#应用进程的启动" class="headerlink" title="应用进程的启动"></a>应用进程的启动</h1><p>我们以 Activity 的启动为入口，来探讨应用进程的启动过程</p><h2 id="AMS-发起创建进程"><a href="#AMS-发起创建进程" class="headerlink" title="AMS 发起创建进程"></a>AMS 发起创建进程</h2><h3 id="由-Activity-的启动寻找应用进程创建的入口"><a href="#由-Activity-的启动寻找应用进程创建的入口" class="headerlink" title="由 Activity 的启动寻找应用进程创建的入口"></a>由 Activity 的启动寻找应用进程创建的入口</h3><p>首先来看 Activity 的启动。安卓四大组件都是由AMS来管理的。 应用进程会调用 AMS 的binder 对象，实现在 ActivityManagerService.startActivity 里。</p><p>最终顺着调用栈，会走到 ActivityStackSupervisor.startSpecificActivityLocked(…)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 进程已启动，真正开始启动 activity 了，哎，调用链太长了</span></span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进程没启动，开始启动进程了</span></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的逻辑里，会先判断要启动的 activity 所在应用的进程是否启动，如果已经成功启动，则开始启动 activity ；否则，启动引用进程。<br>注意这里应用是否启动的判断条件： <code>if (app != null &amp;&amp; app.thread != null)</code><br> ProcessRecord 是应用进程在 AMS 的信息记录，除了判断 app 不为空，还对 app.thread 。这个 app.thread 是一个 IApplicationThread binder 对象，这个对象很重要。</p><h3 id="AMS-发送-Socket-给-zygote"><a href="#AMS-发送-Socket-给-zygote" class="headerlink" title="AMS 发送 Socket 给 zygote"></a>AMS 发送 Socket 给 zygote</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(String hostingType, String hostingNameStr, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mConstants.FLAG_PROCESS_START_ASYNC) &#123;</span><br><span class="line">        <span class="comment">// 异步启动进程，忽略吧</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ProcessStartResult startResult = startProcess(hostingType, entryPoint, app,</span><br><span class="line">                    uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    invokeWith, startTime);</span><br><span class="line">            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                    startSeq, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app.pid &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMS.startProcess 会调用 Process.start(…) 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /frameworks/base/core/java/android/os/Process.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /frameworks/base/core/java/android/os/ZygoteProcess.java</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Process.<span class="function">ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                    runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                    abi, instructionSet, appDataDir, invokeWith, <span class="keyword">false</span> <span class="comment">/* startChildZygote */</span>,</span><br><span class="line">                    zygoteArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                      <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ... <span class="comment">// 组装 socket 的参数</span></span><br><span class="line">        <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">            <span class="comment">// openZygoteSocketIfNeeded 会获取一个 ZygoteState ，有必要的话，会创建 socket 连接。 ZygoteState 包含了 socket 输入输出流。</span></span><br><span class="line">            <span class="comment">// zygote fork 进程成功会返回应用进程的 pid</span></span><br><span class="line">            <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>AMS 会发送 socket 消息给 zygote ，zygote 会 fork 应用进程，并执行应用进程的 ActivityThread.main 方法</p><h1 id="应用进程在启动之后都干了啥？"><a href="#应用进程在启动之后都干了啥？" class="headerlink" title="应用进程在启动之后都干了啥？"></a>应用进程在启动之后都干了啥？</h1><h2 id="thread-attach-…"><a href="#thread-attach-…" class="headerlink" title="thread.attach(…)"></a>thread.attach(…)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">            <span class="comment">// 走这个分支</span></span><br><span class="line">            RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">            <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>应用整个进程的入口在 ActivityThread.main() 方法中，这个方法里没啥操作： 1. 准备 Looper 2. 实例化 ActivityThread ，并 attach 3. 开启 Looper 循环</p><p>显然， main 方法里做的事情支撑不了一个 app 的启动。 重点看 thread.attach , 它 使用 binder 调用了 AMS.attachApplication ，然后又调用了 AMS.attachApplicationLocked(…)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码。。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        ProcessRecord app;</span><br><span class="line">        <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                app = mPidsSelfLocked.get(pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread.bindApplication(...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理一些因为应用进程还没有启动而暂存的组件</span></span><br><span class="line">        mStackSupervisor.attachApplicationLocked(app);</span><br><span class="line">        ...</span><br><span class="line">        mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        ...</span><br><span class="line">        sendPendingBroadcastsLocked(app);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="thread-bindApplication-…"><a href="#thread-bindApplication-…" class="headerlink" title="thread.bindApplication(…)"></a>thread.bindApplication(…)</h2><p>AMS 在 attch 进程之后又通过 binder 调用了应用进程的 bindApplication </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span></span><br><span class="line"><span class="function"><span class="params">        String buildSerial, <span class="keyword">boolean</span> autofillCompatibilityEnabled)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">    ... <span class="comment">// 补充 AppBindData 的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送一个 消息到 H handler </span></span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用进程，发送了一个 H.BIND_APPLICATION 给 handler ，实现了线程的切换。 注意 <strong>通过 binder对象调用，是运行在 binder 线程里的</strong>，所以这个 bindApplication 也是运行在 binder 线程里的，需要切换回主线程。 </p><h2 id="handleBindApplication"><a href="#handleBindApplication" class="headerlink" title="handleBindApplication"></a>handleBindApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data.info 是一个描述应用安装包信息的类。 <code>data.info.makeApplication</code> 一个applicaiton 类，并调用生命周期的 onCreate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></span><br><span class="line"><span class="function"><span class="params">            Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 application 和 context 对象，并绑定</span></span><br><span class="line">    ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">    app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，应用的启动就完成了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;zygote的启动&quot;&gt;&lt;a href=&quot;#zygote的启动&quot; class=&quot;headerlink&quot; title=&quot;zygote的启动&quot;&gt;&lt;/a&gt;zygote的启动&lt;/h1&gt;&lt;h2 id=&quot;zygote-的功能&quot;&gt;&lt;a href=&quot;#zygote-的功能&quot; class=&quot;headerlink&quot; title=&quot;zygote 的功能&quot;&gt;&lt;/a&gt;zygote 的功能&lt;/h2&gt;&lt;p&gt;zygote 进程的主要功能有两个：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://yoursite.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>自定义LayoutManager</title>
    <link href="http://yoursite.com/2021/02/26/Android/%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager/"/>
    <id>http://yoursite.com/2021/02/26/Android/自定义LayoutManager/</id>
    <published>2021-02-26T09:06:00.000Z</published>
    <updated>2021-10-03T01:57:41.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LayoutManager-的常用方法"><a href="#LayoutManager-的常用方法" class="headerlink" title="LayoutManager 的常用方法"></a>LayoutManager 的常用方法</h1><h3 id="generateDefaultLayoutParams"><a href="#generateDefaultLayoutParams" class="headerlink" title="generateDefaultLayoutParams"></a>generateDefaultLayoutParams</h3><a id="more"></a><p>生成默认RecyclerView的LayoutParams, 没啥意义，就返回 wrap_content</p><h3 id="isAutoMeasureEnabled-和-onMeasure"><a href="#isAutoMeasureEnabled-和-onMeasure" class="headerlink" title="isAutoMeasureEnabled 和 onMeasure"></a>isAutoMeasureEnabled 和 onMeasure</h3><p>isAutoMeasureEnabled()是自测量模式。 如果要支持 wrap_content ，那必须重写这两个方法中的一个。 大部分情况下，isAutoMeasureEnabled 返回 true 即可。重写onMeasure()的情况也极少，除非像我那个PickerLayoutManger一样。</p><h3 id="canScrollHorizontally-和-canScrollVertically"><a href="#canScrollHorizontally-和-canScrollVertically" class="headerlink" title="canScrollHorizontally 和 canScrollVertically"></a>canScrollHorizontally 和 canScrollVertically</h3><p>无需多言</p><h3 id="onLayoutChildren"><a href="#onLayoutChildren" class="headerlink" title="onLayoutChildren"></a>onLayoutChildren</h3><p>当 RecyclerView 的 layout 过程中会调用这个方法，<strong>包括第一次 layout 和 其他原因的重新 layout</strong>，比如说键盘的升降。</p><h3 id="scrollHorizontallyBy-和-scrollVerticallyBy"><a href="#scrollHorizontallyBy-和-scrollVerticallyBy" class="headerlink" title="scrollHorizontallyBy 和 scrollVerticallyBy"></a>scrollHorizontallyBy 和 scrollVerticallyBy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun scrollHorizontallyBy(</span><br><span class="line"></span><br><span class="line">    dx: Int,</span><br><span class="line">    recycler: RecyclerView.Recycler,</span><br><span class="line">    state: RecyclerView.State</span><br><span class="line">): Int &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecyclerView 滚动的时候回回调这个方法，但是它只是告诉你用户滑动的距离，需要你自己去实现滑动的效果。同时需要去判断滑动的边界。<br>但是返回值与 RecyclerView 的 overScorll 的动画有关，返回0会有边界的波纹动画。</p><h3 id="getPosition-View"><a href="#getPosition-View" class="headerlink" title="getPosition(View)"></a>getPosition(View)</h3><p>返回 child view 在 adapter 中的位置</p><h3 id="getDecoratedXxxx"><a href="#getDecoratedXxxx" class="headerlink" title="getDecoratedXxxx"></a>getDecoratedXxxx</h3><p>在 LayoutManager 中与布局有关的api都需要替换成带 Decorated 的api，不然无法实现对 itemDecorated 的兼容</p><h3 id="detachAndScrapAttachedViews"><a href="#detachAndScrapAttachedViews" class="headerlink" title="detachAndScrapAttachedViews()"></a>detachAndScrapAttachedViews()</h3><p>从 RecyclerView 暂时移除 child 并送入临时缓存。 之前一直很奇怪，暂时移除是个什么场景。 后来想明白了，在每次布局 child 之前，都需要吧调用一次这个方法，吧所有的 child 移除到临时缓存里。否则，在布局的时候 addView(child) ，如果 child 已经 add 到了 RecyclerView 里，会造成一些麻烦。</p><h3 id="removeAndRecycleView"><a href="#removeAndRecycleView" class="headerlink" title="removeAndRecycleView"></a>removeAndRecycleView</h3><p>移除 child 并将对应的 ViewHolder 移动到 cachePool ，从 cachePool 中取出的 ViewHolder 需要重新调用 Adapter.onBindViewHolder 方法</p><h1 id="自定义-LayoutManager-的一般套路"><a href="#自定义-LayoutManager-的一般套路" class="headerlink" title="自定义 LayoutManager 的一般套路"></a>自定义 LayoutManager 的一般套路</h1><p>scrollHorizontallyBy 和 onLayoutChildren 可以服用同一个布局逻辑。</p><ol><li>确定锚点 view 的 position</li><li>确定布局的左右(上下)边界</li><li>开始 addView()-&gt;measureView()-&gt;layoutView() </li><li>回收布局边界之外的 child</li></ol><h1 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomLinearLayoutManager</span> : <span class="type">RecyclerView.LayoutManager</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">generateDefaultLayoutParams</span><span class="params">()</span></span>: RecyclerView.LayoutParams &#123;</span><br><span class="line">        <span class="keyword">return</span> RecyclerView.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class="line">            ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isAutoMeasureEnabled</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">canScrollHorizontally</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">canScrollVertically</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLayoutChildren</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state.itemCount == <span class="number">0</span>) &#123;</span><br><span class="line">            removeAndRecycleAllViews(recycler)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> left = paddingStart</span><br><span class="line">        <span class="keyword">var</span> curPos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (childCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是兼容键盘升起然后重新 rebuild 的情况。</span></span><br><span class="line">            <span class="comment">// 如果不做兼容，RecyclerView 会移动到列表最顶部</span></span><br><span class="line">            left = getDecoratedLeft(getChildAt(<span class="number">0</span>)!!)</span><br><span class="line">            curPos = getPosition(getChildAt(<span class="number">0</span>)!!)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        detachAndScrapAttachedViews(recycler)</span><br><span class="line"></span><br><span class="line">        fill(recycler, state, curPos, left, paddingStart + getAvailableSpace(), <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollHorizontallyBy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        dx: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        state: <span class="type">RecyclerView</span>.<span class="type">State</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> resDx = calculateOffset(recycler, state, dx)</span><br><span class="line">        <span class="keyword">if</span> (resDx == <span class="number">0</span> || itemCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resDx</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> d = abs(resDx)</span><br><span class="line">        <span class="keyword">if</span> (resDx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> anchorView = getChildAt(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">val</span> anchorPos = getPosition(anchorView!!)</span><br><span class="line">            <span class="keyword">val</span> anchorLeft = getDecoratedLeft(anchorView)</span><br><span class="line"></span><br><span class="line">            detachAndScrapAttachedViews(recycler)</span><br><span class="line"></span><br><span class="line">            fill(recycler, state, anchorPos, anchorLeft - d, getAvailableSpace() + paddingStart, <span class="literal">true</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> anchorView = getChildAt(childCount - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> anchorPos = getPosition(anchorView!!)</span><br><span class="line">            <span class="keyword">val</span> anchorRight = getDecoratedRight(anchorView)</span><br><span class="line"></span><br><span class="line">            detachAndScrapAttachedViews(recycler)</span><br><span class="line"></span><br><span class="line">            fill(recycler, state, anchorPos, paddingLeft, anchorRight + d, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recycler(recycler, state, resDx)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resDx</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateOffset</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>, dx: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (childCount == <span class="number">0</span> || dx == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> fillPos = RecyclerView.NO_POSITION</span><br><span class="line">        <span class="keyword">val</span> d = abs(dx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> firstView = getChildAt(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">val</span> firstPos = getPosition(firstView!!)</span><br><span class="line">            <span class="keyword">val</span> firstLeft = getDecoratedLeft(firstView)</span><br><span class="line"></span><br><span class="line">            fillPos = firstPos - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fillPos &lt; <span class="number">0</span> &amp;&amp; firstLeft + d &gt; paddingStart) &#123;</span><br><span class="line">                <span class="keyword">return</span> firstLeft - paddingStart</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (firstLeft + d &lt; paddingStart) &#123;</span><br><span class="line">                <span class="keyword">return</span> dx</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> lastView = getChildAt(childCount - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">val</span> lastPos = getPosition(lastView!!)</span><br><span class="line">            <span class="keyword">val</span> lastRight = getDecoratedRight(lastView)</span><br><span class="line"></span><br><span class="line">            fillPos = lastPos + <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> endEdge = getAvailableSpace() + paddingStart</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fillPos &gt;= itemCount &amp;&amp; lastRight - d &lt; endEdge) &#123;</span><br><span class="line">                <span class="keyword">return</span> lastRight - endEdge</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lastRight - d &gt; endEdge) &#123;</span><br><span class="line">                <span class="keyword">return</span> dx</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dx</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fill</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     anchorIndex: <span class="type">Int</span>, anchorLeft: <span class="type">Int</span>, anchorRight: <span class="type">Int</span>, isLTR: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> availableSpace = anchorRight - anchorLeft</span><br><span class="line">        <span class="keyword">var</span> fillPos = anchorIndex</span><br><span class="line">        <span class="keyword">var</span> left = anchorLeft</span><br><span class="line">        <span class="keyword">var</span> right = anchorRight</span><br><span class="line">        <span class="keyword">val</span> top = paddingTop</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (availableSpace &gt; <span class="number">0</span> &amp;&amp; fillPos &gt;= <span class="number">0</span> &amp;&amp; fillPos &lt; state.itemCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> view = recycler.getViewForPosition(fillPos)</span><br><span class="line">            <span class="keyword">if</span> (isLTR) &#123;</span><br><span class="line">                addView(view)</span><br><span class="line">                measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                right = left + getDecoratedMeasuredWidth(view)</span><br><span class="line">                <span class="keyword">val</span> bottom = top + getDecoratedMeasuredHeight(view)</span><br><span class="line">                layoutDecoratedWithMargins(view, left, top, right, bottom)</span><br><span class="line">                fillPos++</span><br><span class="line">                left = right</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addView(view, <span class="number">0</span>)</span><br><span class="line">                measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                left = right - getDecoratedMeasuredWidth(view)</span><br><span class="line">                <span class="keyword">val</span> bottom = top + getDecoratedMeasuredHeight(view)</span><br><span class="line">                layoutDecoratedWithMargins(view, left, top, right, bottom)</span><br><span class="line">                fillPos--</span><br><span class="line">                right = left</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            availableSpace -= getDecoratedMeasuredWidth(view)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recycler</span><span class="params">(recycler: <span class="type">RecyclerView</span>.<span class="type">Recycler</span>, state: <span class="type">RecyclerView</span>.<span class="type">State</span>, dx: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//要回收View的集合，暂存</span></span><br><span class="line">        <span class="keyword">val</span> recycleViews = hashSetOf&lt;View&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dx&gt;0就是手指从右滑向左，所以要回收前面的children</span></span><br><span class="line">        <span class="keyword">if</span> (dx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">                <span class="keyword">val</span> child = getChildAt(i)!!</span><br><span class="line">                <span class="keyword">val</span> right = getDecoratedRight(child)</span><br><span class="line">                <span class="comment">//itemView的right&lt;0就是要超出屏幕要回收View</span></span><br><span class="line">                <span class="keyword">if</span> (right &gt; paddingStart) <span class="keyword">break</span></span><br><span class="line">                recycleViews.add(child)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//dx&lt;0就是手指从左滑向右，所以要回收后面的children</span></span><br><span class="line">        <span class="keyword">if</span> (dx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> childCount - <span class="number">1</span> downTo <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> child = getChildAt(i)!!</span><br><span class="line">                <span class="keyword">val</span> left = getDecoratedLeft(child)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//itemView的left&gt;recyclerView.width就是要超出屏幕要回收View</span></span><br><span class="line">                <span class="keyword">if</span> (left &lt; getAvailableSpace() + paddingStart) <span class="keyword">break</span></span><br><span class="line">                recycleViews.add(child)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//真正把View移除掉</span></span><br><span class="line">        <span class="keyword">for</span> (view <span class="keyword">in</span> recycleViews) &#123;</span><br><span class="line">            removeAndRecycleView(view, recycler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAvailableSpace</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width - paddingStart - paddingEnd</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LayoutManager-的常用方法&quot;&gt;&lt;a href=&quot;#LayoutManager-的常用方法&quot; class=&quot;headerlink&quot; title=&quot;LayoutManager 的常用方法&quot;&gt;&lt;/a&gt;LayoutManager 的常用方法&lt;/h1&gt;&lt;h3 id=&quot;generateDefaultLayoutParams&quot;&gt;&lt;a href=&quot;#generateDefaultLayoutParams&quot; class=&quot;headerlink&quot; title=&quot;generateDefaultLayoutParams&quot;&gt;&lt;/a&gt;generateDefaultLayoutParams&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="RecyclerView" scheme="http://yoursite.com/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>redux源码</title>
    <link href="http://yoursite.com/2021/01/24/Flutter/redux%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2021/01/24/Flutter/redux源码/</id>
    <published>2021-01-24T13:40:51.000Z</published>
    <updated>2021-10-03T01:57:41.031Z</updated>
    
    <content type="html"><![CDATA[<p>Redux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux</p><a id="more"></a><h1 id="被观察者-Store-State"><a href="#被观察者-Store-State" class="headerlink" title="被观察者 Store/State"></a>被观察者 Store/State</h1><p>被观察者 明显是 Store 和 State 。 State 是状态的 model类 。 Store 是 State 的持有者。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span>&lt;<span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">  Reducer&lt;State&gt; reducer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;State&gt; _changeController;</span><br><span class="line">  State _state;</span><br><span class="line">  <span class="built_in">List</span>&lt;NextDispatcher&gt; _dispatchers;</span><br><span class="line"></span><br><span class="line">  Store(</span><br><span class="line">    <span class="keyword">this</span>.reducer, &#123;</span><br><span class="line">    State initialState,</span><br><span class="line">    <span class="built_in">List</span>&lt;Middleware&lt;State&gt;&gt; middleware = <span class="keyword">const</span> [],</span><br><span class="line">    <span class="built_in">bool</span> syncStream = <span class="keyword">false</span>,</span><br><span class="line">    <span class="built_in">bool</span> distinct = <span class="keyword">false</span>,</span><br><span class="line">  &#125;) : _changeController = StreamController.broadcast(<span class="keyword">sync</span>: syncStream) &#123;</span><br><span class="line">    _state = initialState;</span><br><span class="line">    _dispatchers = _createDispatchers(</span><br><span class="line">      middleware,</span><br><span class="line">      _createReduceAndNotify(distinct),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  NextDispatcher _createReduceAndNotify(<span class="built_in">bool</span> distinct) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">dynamic</span> action) &#123;</span><br><span class="line">      <span class="keyword">final</span> state = reducer(_state, action);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (distinct &amp;&amp; state == _state) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      _state = state;</span><br><span class="line">      _changeController.add(state);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">dynamic</span> dispatch(<span class="keyword">dynamic</span> action) &#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatchers[<span class="number">0</span>](action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Stream&lt;State&gt; <span class="keyword">get</span> onChange =&gt; _changeController.stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个 Store 创建时，会实例化一个 _changeController ，并将 middleware 和 reducer 打包合并成 _dispatchers 集合。<br>注意看 _createReduceAndNotify 方法， 当每一个 action 发送到 Store 时，会交给 reducer 处理，并将新的 state 给 add 到 _changeController 里。这样就完成了状态的更新。。</p><p>是不是很简单。。。</p><h1 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h1><p>Redux 里观察者是 StoreConnector 。<br>但是得先提一下 StoreProvider ， StoreProvider 是初始化和存储 Store 的 Widget 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoreProvider</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Store&lt;S&gt; _store;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Create a [StoreProvider] by passing in the required [store] and [child]</span></span><br><span class="line">  <span class="comment">/// parameters.</span></span><br><span class="line">  <span class="keyword">const</span> StoreProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> Store&lt;S&gt; store,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(store != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">assert</span>(child != <span class="keyword">null</span>),</span><br><span class="line">        _store = store,</span><br><span class="line">        <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Store&lt;S&gt; of&lt;S&gt;(BuildContext context, &#123;<span class="built_in">bool</span> listen = <span class="keyword">true</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;StoreProvider&lt;S&gt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> provider = (listen</span><br><span class="line">        ? context.inheritFromWidgetOfExactType(type)</span><br><span class="line">        : context</span><br><span class="line">            .ancestorInheritedElementForWidgetOfExactType(type)</span><br><span class="line">            ?.widget) <span class="keyword">as</span> StoreProvider&lt;S&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (provider == <span class="keyword">null</span>) <span class="keyword">throw</span> StoreProviderError(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> provider._store;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Workaround to capture generics</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(StoreProvider&lt;S&gt; oldWidget) =&gt;</span><br><span class="line">      _store != oldWidget._store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StoreProvider 也很简单，就是一个典型的 InheritedWidget 。</p><p>现在来看 StoreConnector ，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoreConnector</span>&lt;<span class="title">S</span>, <span class="title">ViewModel</span>&gt; <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StoreConnector(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.converter,</span><br><span class="line">    <span class="keyword">this</span>.distinct = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">this</span>.onInit,</span><br><span class="line">    <span class="keyword">this</span>.onDispose,</span><br><span class="line">    <span class="keyword">this</span>.rebuildOnChange = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.ignoreChange,</span><br><span class="line">    <span class="keyword">this</span>.onWillChange,</span><br><span class="line">    <span class="keyword">this</span>.onDidChange,</span><br><span class="line">    <span class="keyword">this</span>.onInitialBuild,</span><br><span class="line">  &#125;)  : <span class="keyword">assert</span>(builder != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">assert</span>(converter != <span class="keyword">null</span>),</span><br><span class="line">        <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> _StoreStreamListener&lt;S, ViewModel&gt;(</span><br><span class="line">      store: StoreProvider.of&lt;S&gt;(context),</span><br><span class="line">      builder: builder,</span><br><span class="line">      converter: converter,</span><br><span class="line">      distinct: distinct,</span><br><span class="line">      onInit: onInit,</span><br><span class="line">      onDispose: onDispose,</span><br><span class="line">      rebuildOnChange: rebuildOnChange,</span><br><span class="line">      ignoreChange: ignoreChange,</span><br><span class="line">      onWillChange: onWillChange,</span><br><span class="line">      onDidChange: onDidChange,</span><br><span class="line">      onInitialBuild: onInitialBuild,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来，StoreConnector 只是一个壳，实际的工作者是 _StoreStreamListener 。 StoreConnect 唯一做的工作就是调用 <code>StoreProvider.of&lt;S&gt;(context)</code> 给 _StoreStreamListener 的 store 赋值。</p><p>_StoreStreamListener 是一个 StatefulWidget</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_StoreStreamListenerState</span>&lt;<span class="title">S</span>, <span class="title">ViewModel</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">_StoreStreamListener</span>&lt;<span class="title">S</span>, <span class="title">ViewModel</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    latestValue = widget.converter(widget.store);</span><br><span class="line">    _createStream();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> widget.rebuildOnChange</span><br><span class="line">        ? StreamBuilder&lt;ViewModel&gt;(</span><br><span class="line">            stream: stream,</span><br><span class="line">            builder: (context, snapshot) =&gt; widget.builder(</span><br><span class="line">              context,</span><br><span class="line">              latestValue,</span><br><span class="line">            ),</span><br><span class="line">          )</span><br><span class="line">        : widget.builder(context, latestValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _createStream() &#123;</span><br><span class="line">    stream = widget.store.onChange</span><br><span class="line">        .where(_ignoreChange)</span><br><span class="line">        .map(_mapConverter)</span><br><span class="line">        .where(_whereDistinct)</span><br><span class="line">        .transform(StreamTransformer.fromHandlers(handleData: _handleChange));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ViewModel _mapConverter(S state) &#123;</span><br><span class="line">    <span class="keyword">return</span> widget.converter(widget.store);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _whereDistinct(ViewModel vm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (widget.distinct) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm != latestValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleChange(ViewModel vm, EventSink&lt;ViewModel&gt; sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">    latestValue = vm;</span><br><span class="line">    ...</span><br><span class="line">    sink.add(vm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 build 方法中 widget.rebuildOnChange 默认为 true 。<br>StreamBuilder 将 stream 转化为 widget 。<br>stream 就是对 widget.store.onChange (Store 里的 _changeController) 的监听。</p><p>需要说明的是， StoreConnector 只是在 Flutter Framework 基础上添加的额外的监听机制。<br>之前自己一直有个误区： 当 StoreConnector 的外部 Widget 执行 rebuild 之后， StoreConnector 可以控制 child 不 rebuild ，只要 vm 没有发生改变。<br>这显然不正确。有空可以看看 StreamBuilder 的源码。</p><h1 id="Action-事件的执行"><a href="#Action-事件的执行" class="headerlink" title="Action 事件的执行"></a>Action 事件的执行</h1><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">dynamic</span> dispatch(<span class="keyword">dynamic</span> action) &#123;</span><br><span class="line">    <span class="keyword">return</span> _dispatchers[<span class="number">0</span>](action);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。很简单， Store.dispath 从 _dispatchers 的第一个位置开始分发事件。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redux是一个Flutter状态管理工具。实现并不复杂，其核心是一个简单的观察者模式。我们从 观察者 和 被观察者 两个角度来分析 Redux&lt;/p&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>源码探究Activity的生命周期</title>
    <link href="http://yoursite.com/2021/01/02/Android/Framework/%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2021/01/02/Android/Framework/源码探究Activity的生命周期/</id>
    <published>2021-01-02T07:00:33.000Z</published>
    <updated>2021-10-03T01:57:41.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity"></a>startActivity</h2><p>startActivity有很多重载方法，最终都会调用<code>startActivityForResult</code></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If this start is requesting a result, we can avoid making</span></span><br><span class="line">            <span class="comment">// the activity visible until the result is received.  Setting</span></span><br><span class="line">            <span class="comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class="line">            <span class="comment">// activity hidden during this time, to avoid flickering.</span></span><br><span class="line">            <span class="comment">// This can only be done when a result is requested because</span></span><br><span class="line">            <span class="comment">// that guarantees we will get information back when the</span></span><br><span class="line">            <span class="comment">// activity is finished, no matter what happens to it.</span></span><br><span class="line">            mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">        <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mParent 代表的是 ActivityGroup，是 Activity 很早的版本里才有的东西，在 api13 中已经被废弃。<code>mParent == null</code> 一定为 true</p><p>然后的调用过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activit.startActivity(...)</span><br><span class="line"> -&gt; Instrumentation.execStartActivity(...)</span><br><span class="line">  -&gt; ActivityManagerService.startActivity(...)</span><br><span class="line">   -&gt; ...startActivityAsUser(...)</span><br></pre></td></tr></table></figure></p><h2 id="startActivityAsUser"><a href="#startActivityAsUser" class="headerlink" title="startActivityAsUser"></a>startActivityAsUser</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line"></span><br><span class="line">    userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStartController.obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setMayWait(userId)</span><br><span class="line">            .execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mActivityStartController.obtainStarter</code> 会创建一个 ActivityStarter </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityStarter <span class="title">setMayWait</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    mRequest.mayWait = <span class="keyword">true</span>;</span><br><span class="line">    mRequest.userId = userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRequest.mayWait) &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                    mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execute()</code> 中 <code>mRequest.mayWait</code> 为 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, WaitResult outResult,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration globalConfig, SafeActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> userId, TaskRecord inTask, String reason,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startActivityUnchecked</code> 是一个很重要的方法，这个方法里会根据启动标志位和Activity启动模式来决定如何启动一个Activity以及是否要调用deliverNewIntent方法通知Activity有一个Intent试图重新启动它。<br>因为这里只讨论住 activity 启动的主流程，所以先不看这个。</p><p><code>startActivityUnchecked</code> 之后的调用过程如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; ActivityStarter.startActivityUnchecked(...)</span><br><span class="line"> -&gt; ActivityStackSupervisor.resumeFocusedStackTopActivityLocked(...)</span><br><span class="line">  -&gt; ActivityStack.resumeTopActivityUncheckedLocked(...)</span><br><span class="line">   -&gt; ...resumeTopActivityInnerLocked(...)</span><br></pre></td></tr></table></figure><p>在 <code>resumeTopActivityInnerLocked</code> 中会先对 resume 状态的 activity 执行 pause。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, next, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 开始进行真正最终真正的activity启动</span></span><br><span class="line">    mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        next.completeResumeLocked();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="activity-的-pause-过程"><a href="#activity-的-pause-过程" class="headerlink" title="activity 的 pause 过程"></a>activity 的 pause 过程</h2><p><code>startPausingLocked</code> 之后会执行 startPausingLocked</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startPausingLocked</span><span class="params">(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord resuming, <span class="keyword">boolean</span> pauseImmediately)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (prev.app != <span class="keyword">null</span> &amp;&amp; prev.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev),</span><br><span class="line">                    prev.shortComponentName, <span class="string">"userLeaving="</span> + userLeaving);</span><br><span class="line">            mService.updateUsageStats(prev, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// Android 9.0在这里引入了ClientLifecycleManager和</span></span><br><span class="line">            <span class="comment">// ClientTransactionHandler来辅助管理Activity生命周期，</span></span><br><span class="line">            <span class="comment">// 他会发送EXECUTE_TRANSACTION消息到ActivityThread.H里面继续处理。</span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,</span><br><span class="line">                    PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                            prev.configChangeFlags, pauseImmediately));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(@NonNull IApplicationThread client, @NonNull IBinder activityToken,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull ActivityLifecycleItem stateRequest)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ClientTransaction clientTransaction = transactionWithState(client, activityToken,</span><br><span class="line">            stateRequest);</span><br><span class="line">    scheduleTransaction(clientTransaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ClientTransaction <span class="title">transactionWithState</span><span class="params">(@NonNull IApplicationThread client,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull IBinder activityToken, @NonNull ActivityLifecycleItem stateRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(client, activityToken);</span><br><span class="line">    clientTransaction.setLifecycleStateRequest(stateRequest);</span><br><span class="line">    <span class="keyword">return</span> clientTransaction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android 9.0在这里引入了<code>ClientLifecycleManager</code>和 <code>ClientTransactionHandler</code>来辅助管理Activity生命周期，</p><p><code>startPausingLocked</code>生成了一个 <code>PauseActivityItem</code> 然后，<code>ClientLifecycleManager</code> 会将参数打包为一个 <code>ClientTransaction</code> 并设置一个改变生命周期的request。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientTransaction</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>schedule()</code> 将工作转给了 mClient ，mClient 是 transactionWithState 中传入的，是一个 IApplicationThread， IApplicationThread 是 ActivityThread 的内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// IAppliction</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityThread</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityThread</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (async) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mH.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="H-extends-Handler"><a href="#H-extends-Handler" class="headerlink" title="H extends Handler"></a>H extends Handler</h3><p>在上面可以看出，最终，向 mH 发送了一个 message</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">            <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">            mTransactionExecutor.execute(transaction);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>msg.what 是 <code>ActivityThread.H.EXECUTE_TRANSACTION</code> 。将activity生命周期的变换任务交给了 TransactionExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    log(<span class="string">"Start resolving transaction for client: "</span> + mTransactionHandler + <span class="string">", token: "</span> + token);</span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">    log(<span class="string">"End resolving transaction"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Cycle to the state right before the final requested state.</span></span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the final transition with proper parameters.</span></span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TransactionExecutor 中从 ClientTransaction 获取 ActivityLifecycleItem ， 并执行 execute 和 postExecute 。 由于我们传入的是 PauseActivityItem ， 所以真正执行的代码还是在 PauseActivityItem 里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,</span><br><span class="line">            <span class="string">"PAUSE_ACTIVITY_ITEM"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDontReport) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): Use interface callback instead of AMS.</span></span><br><span class="line">        ActivityManager.getService().activityPaused(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PauseActivityItem.execute 中调用的是 ClientTransactionHandler.</span></span><br><span class="line"><span class="comment">// handlePauseActivity ，但是， ActivityThread 继承了 ClientTransactionHandler。 其实调用的还是 ActivityThread 。。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished, <span class="keyword">boolean</span> userLeaving,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userLeaving) &#123;</span><br><span class="line">                performUserLeavingActivity(r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">            performPauseActivity(r, finished, reason, pendingActions);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">                QueuedWork.waitToFinish();</span><br><span class="line">            &#125;</span><br><span class="line">            mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        &#125; ...</span><br><span class="line">        r.setState(ON_PAUSE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instrumentation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnPause</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        activity.performPause();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="创建-App-进程"><a href="#创建-App-进程" class="headerlink" title="创建 App 进程"></a>创建 App 进程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityStackSupervisor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">                r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">                <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>startSpecificActivityLocked 中会判断要跳转的 activity 所在的进程是否已经存在，如果存在，则调用 realStartActivityLocked ，如果没有存在，则调用 mService.startProcessLocked 创建进程。 </p><p>先看看应用进程不存在的情况。之后的调用栈如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; ActivityManagerService.startProcessLocked</span><br><span class="line"> -&gt; ...startProcessLocked</span><br><span class="line">  -&gt; ...startProcess</span><br><span class="line">   -&gt; Process.start</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Process.start</span><br><span class="line"> -&gt; zygoteProcess.start</span><br><span class="line">  -&gt; ...startViaZygote</span><br><span class="line">   -&gt; ...zygoteSendArgsAndGetResult</span><br><span class="line">    -&gt; ...openZygoteSocketIfNeeded</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    Preconditions.checkState(Thread.holdsLock(mLock), <span class="string">"ZygoteProcess lock not held"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to primary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">        maybeSetApiBlacklistExemptions(primaryZygoteState, <span class="keyword">false</span>);</span><br><span class="line">        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The primary zygote didn't match. Try the secondary.</span></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState == <span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            secondaryZygoteState = ZygoteState.connect(mSecondarySocket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to secondary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">        maybeSetApiBlacklistExemptions(secondaryZygoteState, <span class="keyword">false</span>);</span><br><span class="line">        maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>。。。这里没太看懂，但是网上的文章说 “其最终调用了Zygote并通过socket通信的方式让Zygote进程fork出一个新的进程，并根据传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法对其进行初始化。“</p><p>。。。不知道他是怎么看出来的。。记个 TODO 吧</p><h2 id="启动-activity"><a href="#启动-activity" class="headerlink" title="启动 activity"></a>启动 activity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityStackSupervisor</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// Create activity launch transaction.</span></span><br><span class="line">                <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">                        r.appToken);</span><br><span class="line">                clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">                        System.identityHashCode(r), r.info,</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">                        <span class="comment">// and override configs.</span></span><br><span class="line">                        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                        r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                        profilerInfo));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set desired final state.</span></span><br><span class="line">                <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">                <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                    lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">                &#125;</span><br><span class="line">                clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Schedule transaction.</span></span><br><span class="line">                mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里核心是创建了一个 ClientTransaction ，先添加了一个 LaunchActivityItem 作为 callback ， ClientTransaction 在调度是会先执行 callback 。然后设置 LifecycleStateRequest ，这里传入的 andResume == true ，所以设置的是 ResumeActivityItem 。</p><p>因为在之前 ClientTransaction 的调度流程已经分析过了，我们直接先来看 LaunchActivityItem.execute</p><h3 id="activity-的-onCreate"><a href="#activity-的-onCreate" class="headerlink" title="activity 的 onCreate"></a>activity 的 onCreate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaunchActivityItem</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">                mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">                mProfilerInfo, client);</span><br><span class="line">        client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化ComponentName</span></span><br><span class="line">        ComponentName component = r.intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">            component = r.intent.resolveActivity(</span><br><span class="line">                mInitialApplication.getPackageManager());</span><br><span class="line">            r.intent.setComponent(component);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                    r.activityInfo.targetActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化ContextImpl和Activity</span></span><br><span class="line">        ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">        Activity activity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 activity</span></span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化Application</span></span><br><span class="line">            Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">                <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    config.updateFrom(r.overrideConfig);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加window</span></span><br><span class="line">                Window window = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                    window = r.mPendingRemoveWindow;</span><br><span class="line">                    r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                    r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Application、Activity和ContextImpl互相关联</span></span><br><span class="line">                appContext.setOuterContext(activity);</span><br><span class="line">                activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    activity.mIntent = customIntent;</span><br><span class="line">                &#125;</span><br><span class="line">                r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">                checkAndBlockForNetworkAccess();</span><br><span class="line">                activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 设置Activity的Theme</span></span><br><span class="line">                <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">                <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                    activity.setTheme(theme);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                        <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                        <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                r.activity = activity;</span><br><span class="line">            &#125;</span><br><span class="line">            r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instrumentation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className,</span></span></span><br><span class="line"><span class="function"><span class="params">            Intent intent)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">        String pkg = intent != <span class="keyword">null</span> &amp;&amp; intent.getComponent() != <span class="keyword">null</span></span><br><span class="line">                ? intent.getComponent().getPackageName() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// instantiateActivity 利用传入的 ClassLoader ，利用</span></span><br><span class="line">        <span class="keyword">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 performLaunchActivity 中创建了 activity ，并将 context 和 application 与之绑定，执行 <code>activity.attach</code> 。 并添加 window ，设置主题</p><p>接下来，performLaunchActivity 里通过调用 mInstrumentation.callActivityOnCreate ，开始进行 onCreate 的流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instrumentation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">        prePerformCreate(activity);</span><br><span class="line">        activity.performCreate(icicle);</span><br><span class="line">        postPerformCreate(activity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="activity-的-onResume"><a href="#activity-的-onResume" class="headerlink" title="activity 的 onResume"></a>activity 的 onResume</h3><p>前面我们走完了 activity 的 onCreate 过程，执行代码是在 LaunchActivityItem 中，然后 onResume 显然是在 ResumeActivityItem 里， 那 onOnStart 呢？？</p><p>再回到 ClientTransaction 的调度流程中来， 在 TransactionExecutor 里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionExecutor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line"></span><br><span class="line">        executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">        executeLifecycleState(transaction);</span><br><span class="line">        mPendingActions.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">        <span class="keyword">if</span> (lifecycleItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No lifecycle request, return early.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Ignore requests for non-existent client records for now.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cycle to the state right before the final requested state.</span></span><br><span class="line">        cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Execute the final transition with proper parameters.</span></span><br><span class="line">        lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleToPath</span><span class="params">(ActivityClientRecord r, <span class="keyword">int</span> finish,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> start = r.getLifecycleState();</span><br><span class="line">        <span class="keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">        performLifecycleSequence(r, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Transition the client through previously initialized state sequence. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLifecycleSequence</span><span class="params">(ActivityClientRecord r, IntArray path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = path.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, state; i &lt; size; i++) &#123;</span><br><span class="line">            state = path.get(i);</span><br><span class="line">            <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">case</span> ON_START:</span><br><span class="line">                    mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 TransactionExecutor 中先执行 callback ，然后 lifecycleItem.execute 。中间有一个 cycleToPath 方法。 cycleToPath 内部逻辑很明显，执行 start 和 finish 中间状态的逻辑。 对于 ResumeActivityItem 来说就会执行 onStart 的逻辑。。。 我佛了。</p><p>activity 之后的 start 过程和 create 过程基本一致。现在再来看看 onResume</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResumeActivityItem</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">        client.handleResumeActivity(token, <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward, <span class="string">"RESUME_ACTIVITY"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityThread</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">            String reason)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">                ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    impl.notifyChildRebuilt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    a.onWindowAttributesChanged(l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">            r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">            String reason)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r.activity.onStateNotSaved();</span><br><span class="line">            r.activity.mFragments.noteStateNotSaved();</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            <span class="keyword">if</span> (r.pendingIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                deliverNewIntents(r, r.pendingIntents);</span><br><span class="line">                r.pendingIntents = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r.pendingResults != <span class="keyword">null</span>) &#123;</span><br><span class="line">                deliverResults(r, r.pendingResults, reason);</span><br><span class="line">                r.pendingResults = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line"></span><br><span class="line">            r.state = <span class="keyword">null</span>;</span><br><span class="line">            r.persistentState = <span class="keyword">null</span>;</span><br><span class="line">            r.setState(ON_RESUME);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to resume activity "</span></span><br><span class="line">                        + r.intent.getComponent().toShortString() + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>handleResumeActivity 中操作了很多 window 相关的东西。 到这里 activity 的启动就完成了</p><h2 id="activity-的-stop"><a href="#activity-的-stop" class="headerlink" title="activity 的 stop"></a>activity 的 stop</h2><p>之前分析了 onPause 的流程， 但是没有看到 onStop ， 所以 onStop 是如何执行的呢。 在 activity 的生命周期中， activity a 启动 activity b ， b.onStop 应该在 a.onResume 之后执行。</p><p>玄机竟然在 handleResumeActivity 里。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityThread</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">            String reason)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityManagerService</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">            <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ActivityRecord r =</span><br><span class="line">                        mStackSupervisor.activityIdleInternalLocked(token, <span class="keyword">false</span> <span class="comment">/* fromTimeout */</span>,</span><br><span class="line">                                <span class="keyword">false</span> <span class="comment">/* processPausingActivities */</span>, config);</span><br><span class="line">                <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((mProfileProc == r.app) &amp;&amp; mProfilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        clearProfilerLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityStackSupervisor.java</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r, <span class="keyword">true</span> <span class="comment">/* remove */</span>, processPausingActivities);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NS; i++) &#123;</span><br><span class="line">            r = stops.get(i);</span><br><span class="line">            <span class="keyword">final</span> ActivityStack stack = r.getStack();</span><br><span class="line">            <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, <span class="keyword">false</span>,</span><br><span class="line">                            <span class="string">"activityIdleInternalLocked"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.stopActivityLocked(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityStack</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopActivityLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,</span><br><span class="line">                StopActivityItem.obtain(r.visible, r.configChangeFlags));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>经过一番调用，最终还是一样，向 ClientLifecycleManager 发送了一个 StopActivityItem 。</p><p>到此，activity 的启动流程就结束了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/89fd44083c1c" target="_blank" rel="noopener">（Android 9.0）Activity启动流程源码分析</a><br><a href="https://www.kancloud.cn/digest/androidframeworks/127782" target="_blank" rel="noopener">Activity启动过程全解析</a><br><a href="https://www.jianshu.com/p/15a0df736e52" target="_blank" rel="noopener">炼狱难度！腾讯Android高级岗：为什么 Activity.finish() 之后 10s 才 onDestroy ？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;startActivity&quot;&gt;&lt;a href=&quot;#startActivity&quot; class=&quot;headerlink&quot; title=&quot;startActivity&quot;&gt;&lt;/a&gt;startActivity&lt;/h2&gt;&lt;p&gt;startActivity有很多重载方法，最终都会调用&lt;code&gt;startActivityForResult&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Fragment可见性总结</title>
    <link href="http://yoursite.com/2020/10/04/Android/Fragment%E5%8F%AF%E8%A7%81%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/10/04/Android/Fragment可见性总结/</id>
    <published>2020-10-04T10:28:37.000Z</published>
    <updated>2021-10-03T01:57:41.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="onResume-onPause"><a href="#onResume-onPause" class="headerlink" title="onResume()/onPause()"></a>onResume()/onPause()</h2><p><strong>不要用这两个方法为可见性依据做操作。</strong> 触发onResume()/onPause()的场景有很多</p><a id="more"></a><ul><li><strong>Activity执行onResume()/onPause()</strong>，其所有的 Fragment 都会的 onResume()/onPause() 方法，即使Fragment是状态是隐藏的</li><li><strong>在当前Activity中添加一个Fragment时</strong>，被添加的Fragment都会调用onResume，这包括通过add和replace的方式添加；在Fragment销毁的情况下都会触发onPause，如果是add到回退栈的情况，back键就会触发onPause，如果是replace的情况，则被替换掉的Fragment会触发onPause。</li><li><strong>ViewPager 预加载：</strong> 被预加载的Fragment也会执行 onResume()/onPause() </li></ul><h2 id="isVisible"><a href="#isVisible" class="headerlink" title="isVisible()"></a>isVisible()</h2><p>注释说是可以用来判断其可见性，<strong>但是如果你是在Fragment的onResume/onPause方法中调用这两个方法判断是不准确的，</strong>onResume的方法中isVisible()有可能为false, 而onPause的方法中isVisible()也有可能为true。</p><h2 id="onHiddenChanged"><a href="#onHiddenChanged" class="headerlink" title="onHiddenChanged()"></a>onHiddenChanged()</h2><p>就是对Fragment进行show和hide的时候会回调onHiddenChanged方法。除此之外的操作，如add/replace/remove都不会触发这个方法。</p><h2 id="setUserVisibleHint-getUserVisibleHint"><a href="#setUserVisibleHint-getUserVisibleHint" class="headerlink" title="setUserVisibleHint()/getUserVisibleHint()"></a>setUserVisibleHint()/getUserVisibleHint()</h2><p>getUserVisibleHint() 默认返回true， 只有和 ViewPager 配合使用有效，ViewPager 选中的 fragment 调用 getUserVisibleHint() 会返回true。 <strong>在ViewPager2无效</strong></p><h2 id="判断fragment是否可见的保险操作？？-maybe"><a href="#判断fragment是否可见的保险操作？？-maybe" class="headerlink" title="判断fragment是否可见的保险操作？？ maybe"></a>判断fragment是否可见的保险操作？？ maybe</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> parentVisible = parentFragment == <span class="keyword">null</span> ? <span class="keyword">true</span> : parentFragment.isVisible()=</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> visible = isVisible() &amp;&amp; parentVisible &amp;&amp; getUserVisibleHint()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;onResume-onPause&quot;&gt;&lt;a href=&quot;#onResume-onPause&quot; class=&quot;headerlink&quot; title=&quot;onResume()/onPause()&quot;&gt;&lt;/a&gt;onResume()/onPause()&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;不要用这两个方法为可见性依据做操作。&lt;/strong&gt; 触发onResume()/onPause()的场景有很多&lt;/p&gt;
    
    </summary>
    
    
      <category term="Fragment" scheme="http://yoursite.com/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>RenderObject 原理</title>
    <link href="http://yoursite.com/2020/09/22/Flutter/RenderObject-%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/09/22/Flutter/RenderObject-原理/</id>
    <published>2020-09-22T08:28:21.000Z</published>
    <updated>2021-10-03T01:57:41.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ParentData-和各种-Mixin"><a href="#ParentData-和各种-Mixin" class="headerlink" title="ParentData 和各种 Mixin"></a>ParentData 和各种 Mixin</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">BoxParentData --|&gt; ParentData</span><br><span class="line">ContainerParentDataMixin --|&gt; ParentData</span><br><span class="line">ContainerBoxParentData --|&gt; BoxParentData</span><br><span class="line">ContainerBoxParentData --|&gt; ContainerParentDataMixin</span><br><span class="line"></span><br><span class="line">RenderObject *-- ParentData</span><br><span class="line">RenderObjectWithChildMixin --|&gt; RenderObject</span><br><span class="line">ContainerRenderObjectMixin --|&gt; RenderObject</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ContainerParentDataMixin&#123;</span><br><span class="line">+ previousSlibling</span><br><span class="line">+ nextSibling</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ContainerRenderObjectMixin &#123;</span><br><span class="line">+ firstChild *-- ContainerParentDataMixin</span><br><span class="line">+ lastChild</span><br><span class="line">+ childCount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BoxParentData&#123;</span><br><span class="line">+ offset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RenderObject&#123;</span><br><span class="line">+ parentData</span><br><span class="line">&#125;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>ParentData<br>在 Flutter 的布局系统中，该类负责存储父节点所需要的子节点的布局信息<ul><li>BoxParentData<br>– offset<br>包含有一个 offset 属性，该属性用于存储 child 的布局信息，也就是 child 应该被摆在哪个位置。与 Android 不同，Flutter并不是以父View为坐标基础进行绘制的，所以需要带上 offset 参数，得到一个累加的偏移值。至于偏移的参考点在哪里，可以看下面的绘制阶段的原理解析。</li><li>ContainerParentDataMixin<br>– previousSibling<br>– nextSibling<br>该类使用频率很高，基本上所有父节点的 ParentData 都混入了该类，该类需要与ContainerRenderObjectMixin 共同使用，主要解决了对 child 的管理，previousSibling nextSibling 都是child RenderObject, 从而组成把父节点的所有 child 组成了一个双链表</li><li>ContainerBoxParentData<br>空类，继承了 BoxParentData 并且混入了 ContainerParentDataMixin， 使其拥有二者的能力</li></ul></li><li>RenderObject<br>Flutter 中真正实现布局和绘制的类<ul><li>RenderObjectWithChildMixin<br>实现对只有一个child的管理</li><li>ContainerRenderObjectMixin<br>– firstChild<br>– lastChild<br>– childCount<br>实现对多child的管理，firstChild、lastChild、childCount，用来获取首末 child，child的个数，配合使用 ContainerParentDataMixin 中的 previousSibling、nextSibling就可以对 child 进行遍历了。<br>child 的insert、remove、move等操作都在这个Mixin中实现</li></ul></li></ul><p>除了以上的类，Flutter 还提供了 RenderBoxContainerDefaultsMixin，该类提供了一些 RenderBox 默认的行为方法，如上面绘制 child 的流程调用该类中的 defaultPaint(PaintingContext context, Offset offset) 就可以了，可以简化一些模板代码。</p><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>在 RenderBox 中，控件大小的值为 _size 成员，它只包含宽高两个属性值，我们可以通过该成员的 set 和 get 方法访问或修改它的值。在测量时( layout 方法中)，parent 会传给当前 RenderBox 一个大小的限制，为 BoxConstraints 类型，最后测量得到的 size 必须满足这个限制，在 Flutter 的 debug 模式下对 size 是否满足 constraints 做了 assert 检查，如果检查未通过就会布局失败。所以测量上我们要做的是下面两点：</p><ul><li>如果没有 child，那么根据自身的属性计算出满足 constraints 的 size.</li><li>如果有 child，那么综合自身的属性和 child 的测量结果计算出满足 constraints 的 size.</li></ul><p>测量和布局都在layout方法中完成</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  RenderObject relayoutBoundary;</span><br><span class="line">  <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">    relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    relayoutBoundary = parent._relayoutBoundary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _constraints = constraints;</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">    visitChildren((RenderObject child) &#123;</span><br><span class="line">      child._cleanRelayoutBoundary();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line">  <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      performResize();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _debugReportException(<span class="string">'performResize'</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    performLayout();</span><br><span class="line">    markNeedsSemanticsUpdate();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    _debugReportException(<span class="string">'performLayout'</span>, e, stack);</span><br><span class="line">  &#125;</span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parentUsesSize<br>  layout 方法中由父节点传入，表示父节点的 size 依赖当前节点的 size </li><li>constraints<br>  layout 方法中从父节点传入，当前节点会从更新到自己的变量中保存</li><li>relayoutBoundary<br>  relayoutBoundary 是framework层自动设置的，如果满足<br>  <code>(!parentUsesSize || sizedByParent || constraints.isTight || parent is! RenderObject)</code> 则该节点是一个 relayoutBoundary, 否则会从父节点寻找。</li><li>sizedByParent &amp; performResize()<br>  <strong>这两个必须成对配置，performResize() 方法如果被重写，sizedByParent 也必须重写为true，并且你不应该在 perfromLayout() 方法中对 size 重新赋值。</strong><br>  sizedByParent 意为该控件的大小是否能仅通过 parent 赋予它的 constraints 就可以被确定下来了，即该控件的大小与它自身的属性和与它的 child 都无关，比如如果一个控件永远充满 parent 的大小，那么 sizedByParent 就应该返回 true。<br>  <strong>这个操作不是必须的</strong><br>  官方文档中说这是一个优化项，如果完全不care这个，sizedByParent = false，那始终是正确的。 我的理解是，把 size 的计算单独抽出，避免每次 relayout 时对 size 重新计算。<br>  performResize() 这个方法名字可能会造成误会，认为测量必须放在这里，其实大多是情况下，测量和布局都在 performLayout() 中</li><li>performLayout()<br>  上面已经说得差不多了</li></ul><p>如果是在标脏后，在一帧绘制的回调中刷新布局，不会调用layout方法，而是调用_layoutWithoutSize </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _layoutWithoutResize() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    performLayout();</span><br><span class="line">    markNeedsSemanticsUpdate();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    _debugReportException(<span class="string">'performLayout'</span>, e, stack);</span><br><span class="line">  &#125;</span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="paint"><a href="#paint" class="headerlink" title="paint"></a>paint</h2><p>父节点绘制子节点的入口</p><p><strong>paintContext.paintChild()</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</span><br><span class="line">    stopRecordingIfNeeded();</span><br><span class="line">    _compositeChild(child, offset);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="comment">// Create a layer for our child, and paint the child into it.</span></span><br><span class="line">  <span class="keyword">if</span> (child._needsPaint) &#123;</span><br><span class="line">    <span class="comment">// 这个方法会创建layer，然后再调用 child._paintWithContext 方法</span></span><br><span class="line">    repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> OffsetLayer childOffsetLayer = child._layer;</span><br><span class="line">  childOffsetLayer.offset = offset;</span><br><span class="line">  appendLayer(child._layer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">  RenderObject child, &#123;</span><br><span class="line">  <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">  PaintingContext childContext,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  OffsetLayer childLayer = child._layer;</span><br><span class="line">  <span class="keyword">if</span> (childLayer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    child._layer = childLayer = OffsetLayer();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    childLayer.removeAllChildren();</span><br><span class="line">  &#125;</span><br><span class="line">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class="line">  child._paintWithContext(childContext, Offset.zero);</span><br><span class="line">  childContext.stopRecordingIfNeeded();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> appendLayer(Layer layer) &#123;</span><br><span class="line">  layer.remove();</span><br><span class="line">  _containerLayer.append(layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 paintChild 方法中，若 child 是一个 repaintBoundary ，会为 child 创建一个 layer ，然后再调用 child._paintWithContext(this, offset) ；如果 isRepaintBoundary 为false，则直接调用 child._paintWithContext(this, offset)。。<br>所以这个layer又是怎样？？？ </p><p>在drawFrame()中，paint 标脏节点刷新时会直接执行 PaintContext.repaintCompositeChild() </p><p><strong>_paintWithContext(..) &amp; paint()</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsLayout)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  RenderObject debugLastActivePaint;</span><br><span class="line">  _needsPaint = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    paint(context, offset);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    _debugReportException(<span class="string">'paint'</span>, e, stack);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br></pre></td></tr></table></figure><p>RenderObject 中的 paint 是一个空方法，交给子类来实现。 以 RenderFlex 为例： </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_hasOverflow) &#123;</span><br><span class="line">    defaultPaint(context, offset);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> defaultPaint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  ChildType child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> ParentDataType childParentData = child.parentData;</span><br><span class="line">    context.paintChild(child, childParentData.offset + offset);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Flex没有要绘制的内容，所以调用 RenderBoxContainerDefaultsMixin 提供的默认实现。在 defaultPaint 中遍历child，绘制child时将 childParentData.offset累加到offset中。所以，这个 offset 的基准到底是个啥？？？？</p><h2 id="PaintingContext-和-Layer"><a href="#PaintingContext-和-Layer" class="headerlink" title="PaintingContext 和 Layer"></a>PaintingContext 和 Layer</h2><h3 id="drawFrame"><a href="#drawFrame" class="headerlink" title="drawFrame()"></a>drawFrame()</h3><p>PaintContext 可以类比于 BuildContext，Layer 和 Element 最终会组成一个 Layer树，最终渲染是在C++的engine层完成的。在flutter的framework层构成了一颗Layer树，传送到engine进行绘制。</p><p>回过头来看，在 drawFrame() 中对需要paint的节点是如何处理的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  <span class="comment">// BD ADD:</span></span><br><span class="line">  Boost.resetIdleCallbacks();</span><br><span class="line">  <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">  pipelineOwner.flushLayout();</span><br><span class="line">  pipelineOwner.flushCompositingBits();</span><br><span class="line">  pipelineOwner.flushPaint();</span><br><span class="line">  renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">  pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先直接来看 pipelineOwner.flushPaint(); 和里面调用到的 PaintContext._repaintCompositedChild </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">    _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line">    <span class="comment">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class="line">    <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsPaint &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node._layer.attached) &#123;</span><br><span class="line">          PaintingContext.repaintCompositedChild(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          node._skippedPaintingOnLayer();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PaintingContext._repaintCompositedChild(…)</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">  RenderObject child, &#123;</span><br><span class="line">  <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">  PaintingContext childContext,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="comment">// 关注这个 assert，证明了最终需要 paint 的都是 RepaintBoundary 节点</span></span><br><span class="line">  <span class="keyword">assert</span>(child.isRepaintBoundary);</span><br><span class="line">  OffsetLayer childLayer = child._layer;</span><br><span class="line">  <span class="keyword">if</span> (childLayer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 为 repaint boundaries 创建layer</span></span><br><span class="line">    child._layer = childLayer = OffsetLayer();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    childLayer.removeAllChildren();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为 RepaintBoundary 创建 PaintContext</span></span><br><span class="line">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class="line">  <span class="comment">// 初始化了Offset，说明offset的值是以layer为参考依据的</span></span><br><span class="line">  child._paintWithContext(childContext, Offset.zero);</span><br><span class="line"></span><br><span class="line">  childContext.stopRecordingIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次回顾 PaintingContext._repaintCompositedChild 方法，我们发现，它为 RepaintBoundary ，创建了PaintingContext 和 layer。 说明 RepaintBoundary 、PaintingContext 、layer 是一一对应的， <strong>即 layer 是绘制的基本单位，只有 RepaintBoundary 极其子 RenderObject 共享一个layer， 每次绘制会创建都会为 layer 创建一个 PaintingContext</strong>。而 paint 过程中的offset的参考点，就是layer的左上角的坐标原点。</p><p><strong>renderView.compositeFrame();</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> compositeFrame() &#123;</span><br><span class="line">  Timeline.startSync(<span class="string">'Compositing'</span>, arguments: timelineWhitelistArguments);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> ui.SceneBuilder builder = ui.SceneBuilder();</span><br><span class="line">    <span class="keyword">final</span> ui.Scene scene = layer.buildScene(builder);</span><br><span class="line">    <span class="keyword">if</span> (automaticSystemUiAdjustment)</span><br><span class="line">      _updateSystemChrome();</span><br><span class="line">    _window.render(scene);</span><br><span class="line">    scene.dispose();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Timeline.finishSync();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>renderView 是页面的根RenderObject，renderView.layer 是页面的根layer。 调用 <code>layer.buildScene(builder);</code> 生成了一个scene， 调用_window.render(scene) 发送给engine层进行渲染</p><h3 id="Layer的标脏和局部刷新"><a href="#Layer的标脏和局部刷新" class="headerlink" title="Layer的标脏和局部刷新"></a>Layer的标脏和局部刷新</h3><p><strong>layer.buildScene</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">ui.Scene buildScene(ui.SceneBuilder builder) &#123;</span><br><span class="line">  <span class="built_in">List</span>&lt;PictureLayer&gt; temporaryLayers;</span><br><span class="line">  updateSubtreeNeedsAddToScene();</span><br><span class="line">  addToScene(builder);</span><br><span class="line">  _needsAddToScene = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">final</span> ui.Scene scene = builder.build();</span><br><span class="line">  <span class="keyword">return</span> scene;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> updateSubtreeNeedsAddToScene() &#123;</span><br><span class="line">  <span class="keyword">super</span>.updateSubtreeNeedsAddToScene();</span><br><span class="line">  Layer child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    child.updateSubtreeNeedsAddToScene();</span><br><span class="line">    _needsAddToScene = _needsAddToScene || child._needsAddToScene;</span><br><span class="line">    <span class="comment">// child.nextSibling 是下一个子layer， 这里显然是一个树的 层序遍历</span></span><br><span class="line">    child = child.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是 ContainerLayer 的实现， 没有子Layer的叶子 Layer 实现各不相同</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</span><br><span class="line">  addChildrenToScene(builder, layerOffset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> addChildrenToScene(ui.SceneBuilder builder, [ Offset childOffset = Offset.zero ]) &#123;</span><br><span class="line">  Layer child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (childOffset == Offset.zero) &#123;</span><br><span class="line">      child._addToSceneWithRetainedRendering(builder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child.addToScene(builder, childOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    child = child.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>renderView 的 layer 是一个 OffsetLayer ，继承自 ContainerLayer 。<br>Layer.buildScene(…) 这个方法在framework调用的地方很少，可以认为只有 renderView 的 layer 会调用 buildScene 方法创建创建一个 scene ， 即 scene 包含了页面的完整 layer 树。</p><p>首先会调用 updateSubtreeNeedsAddToScene ， 需要update的原因是， 如果子layer标脏， 那显然父layer 也需要标脏</p><p><strong>_addToSceneWithRetainedRendering</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsAddToScene() &#123;</span><br><span class="line">  <span class="comment">// Already marked. Short-circuit.</span></span><br><span class="line">  <span class="keyword">if</span> (_needsAddToScene) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _needsAddToScene = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _addToSceneWithRetainedRendering(ui.SceneBuilder builder) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_needsAddToScene &amp;&amp; _engineLayer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    builder.addRetained(_engineLayer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  addToScene(builder);</span><br><span class="line">  _needsAddToScene = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>markNeedAddToScene() 对 layer 节点进行标脏。在layer属性发生改变时会进行标脏；当子layer添加到父layer时也会进行标脏。</p><p>这个方法是唯一用到使用到 _needsAddToScene 标脏flag值的地方。 如果 _needsAddToScene 为false ，调用 builder.addRetained(_engineLayer); 这个 _engineLayer</p><p>_eingineLayer 是 layer.addToScene(…) 返回的engine生成的图层（ContainerLayer例外，没有engineLayer）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是 OpacityLayer 的addToScene方法，生成了一个 engineLayer ，</span></span><br><span class="line"><span class="comment"> * 然后调用addChildrenToScene(builder);</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) &#123;</span><br><span class="line">  <span class="built_in">bool</span> enabled = firstChild != <span class="keyword">null</span>;  <span class="comment">// don't add this layer if there's no child</span></span><br><span class="line">  <span class="keyword">if</span> (enabled)</span><br><span class="line">    engineLayer = builder.pushOpacity(alpha, offset: offset + layerOffset, oldLayer: _engineLayer);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    engineLayer = <span class="keyword">null</span>;</span><br><span class="line">  addChildrenToScene(builder);</span><br><span class="line">  <span class="keyword">if</span> (enabled)</span><br><span class="line">    builder.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SceneBuilder.addRetained()</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> addRetained(EngineLayer retainedLayer) &#123;</span><br><span class="line">  <span class="keyword">final</span> _EngineLayerWrapper wrapper = retainedLayer;</span><br><span class="line">  _addRetained(wrapper._nativeLayer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _addRetained(EngineLayer retainedLayer) native <span class="string">'SceneBuilder_addRetained'</span>;</span><br></pre></td></tr></table></figure><p>addRetained 直接调用了engine层的代码，对layer进行复用。。。</p><h3 id="直接使用-layer-进行UI绘制"><a href="#直接使用-layer-进行UI绘制" class="headerlink" title="直接使用 layer 进行UI绘制"></a>直接使用 layer 进行UI绘制</h3><p>flutter最终是绘制在layer上的，那样的话，实际上，可以脱离 Widget、Element、RenderObject ，直接操作 layer 进行UI的绘制</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/rendering.dart'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">    <span class="keyword">final</span> OffsetLayer rootLayer = <span class="keyword">new</span> OffsetLayer();</span><br><span class="line">    <span class="keyword">final</span> PictureLayer pictureLayer = <span class="keyword">new</span> PictureLayer(Rect.zero);</span><br><span class="line">    rootLayer.append(pictureLayer);</span><br><span class="line"></span><br><span class="line">    PictureRecorder recorder = PictureRecorder();</span><br><span class="line">    Canvas canvas = Canvas(recorder);</span><br><span class="line"></span><br><span class="line">    Paint paint = Paint();</span><br><span class="line">    paint.color = Colors.primaries[Random().nextInt(Colors.primaries.length)];</span><br><span class="line"></span><br><span class="line">    canvas.drawRect(Rect.fromLTWH(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>), paint);</span><br><span class="line">    pictureLayer.picture = recorder.endRecording();</span><br><span class="line">    </span><br><span class="line">    SceneBuilder sceneBuilder = SceneBuilder();</span><br><span class="line">    rootLayer.addToScene(sceneBuilder);</span><br><span class="line"></span><br><span class="line">    Scene scene = sceneBuilder.build();</span><br><span class="line">    <span class="built_in">window</span>.onDrawFrame = ()&#123;</span><br><span class="line">      <span class="built_in">window</span>.render(scene);</span><br><span class="line">      <span class="comment">// window.scheduleFrame();</span></span><br><span class="line">      <span class="comment">// 在onDrawFrame回调最后加上scheduleFrame，可以使UI不断刷新，进行动画操作</span></span><br><span class="line">      <span class="comment">// 不是很懂那vsync的作用是什么。。。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>在 main.dart 中添加 <code>debugRepaintRainbowEnabled = true;</code> ，或者通过 devtools 可以观察到App的layer树</p><p><a href="https://xieguanglei.github.io/blog/post/flutter-code-chapter-02.html" target="_blank" rel="noopener">Flutter Framework 源码解析（ 2 ）—— 图层详解</a></p><p><a href="https://juejin.im/post/6844904133728665614#heading-10" target="_blank" rel="noopener">从源码看flutter（四）：Layer篇</a></p><p><a href="https://guoshuyu.cn/home/wx/Flutter-21.html" target="_blank" rel="noopener">Flutter画面渲染全面解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ParentData-和各种-Mixin&quot;&gt;&lt;a href=&quot;#ParentData-和各种-Mixin&quot; class=&quot;headerlink&quot; title=&quot;ParentData 和各种 Mixin&quot;&gt;&lt;/a&gt;ParentData 和各种 Mixin&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@startuml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BoxParentData --|&amp;gt; ParentData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ContainerParentDataMixin --|&amp;gt; ParentData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ContainerBoxParentData --|&amp;gt; BoxParentData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ContainerBoxParentData --|&amp;gt; ContainerParentDataMixin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RenderObject *-- ParentData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RenderObjectWithChildMixin --|&amp;gt; RenderObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ContainerRenderObjectMixin --|&amp;gt; RenderObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class ContainerParentDataMixin&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ previousSlibling&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ nextSibling&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class ContainerRenderObjectMixin &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ firstChild *-- ContainerParentDataMixin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ lastChild&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ childCount&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class BoxParentData&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ offset&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class RenderObject&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ parentData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@enduml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
      <category term="RenderObject" scheme="http://yoursite.com/tags/RenderObject/"/>
    
  </entry>
  
  <entry>
    <title>flutter ui源码 初步</title>
    <link href="http://yoursite.com/2020/08/14/Flutter/flutter-ui%E6%BA%90%E7%A0%81-%E5%88%9D%E6%AD%A5/"/>
    <id>http://yoursite.com/2020/08/14/Flutter/flutter-ui源码-初步/</id>
    <published>2020-08-14T12:30:42.000Z</published>
    <updated>2021-10-03T01:57:41.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Widget-Element-RanderObject-三者之间的关系"><a href="#Widget-Element-RanderObject-三者之间的关系" class="headerlink" title="Widget, Element, RanderObject 三者之间的关系"></a>Widget, Element, RanderObject 三者之间的关系</h2><a id="more"></a><p>Widget纯作为一个配置文件存在，可以理解为一个数据结构。Element作为配置文件的实例化对象，具有生命周期的概念，承载构建上下文数据，且持有RenderObject,系统通过遍历Element来构建RenderObject数据，具体Layout，Paint交给RenderObject来完成。Element更像是一个中间层，隔开了Widget与RenderObject,同时也在正常开发过程中将开发者与RenderObject隔开，开发者大部分情况下只需要关注Widget即可。</p><h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>Widget类和Element类一一对应。Element是通过Widget生成的<br>Widget是Element的配置数据，保存UI相关参数。Widget十分轻量，可以频繁的销毁和重建。</p><p><strong>Widget.createElement()</strong></p><p>创建Element对象</p><p><strong>Widget.canUpdate(..)</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要用于在Widget树重新build时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的Element对象的配置；<br>通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType和key 同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存UI状态信息.</p><p><strong>createState()</strong></p><p>用于创建和StatefulWidget相关的状态，它在StatefulWidget的生命周期中可能会被多次调用。例如，当一个StatefulWidget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例。createState()会在Element实例化的时候调用，<strong>所以，本质上就是一个StatefulElement对应一个State实例。</strong></p><p><strong>widget和context</strong></p><ul><li><p>widget, 它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但<strong>State实例只会在第一次插入到树中时被创建</strong>，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。 </p></li><li><p>context, StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。Elements继承自BuildContext</p></li></ul><p><strong>State如何被Widget复用</strong><br>只有在Element实例化时会创建新的State。当Widget重新build，Element的updateChild会调用canUpdate(…)方法，若返回true，将child element的widget更新；若返回false，则会重新create新的element。</p><h2 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h2><p>最终的UI树其实是由一个个独立的Element节点构成。组件最终的Layout、渲染都是通过RenderObject来完成的，从创建到渲染的大体流程是：根据Widget生成Element，然后创建相应的RenderObject并关联到Element.renderObject属性上，最后再通过RenderObject来完成布局排列和绘制。</p><p>下面从Element的 <strong>挂载、更新、卸载</strong>过程来描述Element</p><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p><strong>根Element的mount</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- main() </span><br><span class="line">    - runApp(..)</span><br><span class="line">    - WidgetsFlutterBinding.attachRootWidget(app)</span><br><span class="line">        - RenderObjectToWidgetAdapter&lt;RenderBox&gt;.attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">            - createElement()</span><br><span class="line">            - BuildOwner.buildScope(element, () &#123;</span><br><span class="line">                element.mount(null, null);</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure><p>以上是根Element的mount过程，其中rederViewElement是根Elemet</p><p>** Element的mount过程</p><p>首先来看一下常用的StatelessElement，StatefulElement的继承关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element -&gt; ComponentElement -&gt; StatelessElement</span><br><span class="line">                            -&gt; StatefulElement</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- mount()</span><br><span class="line">    - Element.updateInheritance()</span><br><span class="line">    - ComponentElement.firstBuild()</span><br><span class="line">        - Element.rebuild()</span><br><span class="line">        - ComponentElement.performRebuild()</span><br><span class="line">            - built = build()</span><br><span class="line">                -Widget.build()</span><br><span class="line">            - Element.updateChild(child, built, _)</span><br></pre></td></tr></table></figure><p>Element.updateChild方法非常重要</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">Element</span> updateChild(<span class="built_in">Element</span> child, Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">        deactivateChild(child);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child.widget == newWidget) &#123;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">        child.update(newWidget);</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">      &#125;</span><br><span class="line">      deactivateChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inflateWidget(newWidget, newSlot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码，总结各种case</p><ul><li>child != null &amp;&amp; newWidget == null :<br>  newWidget为空，说明 Widget.build返回了null， child element对应的widget已经不在widget树上，所以也要移除该element</li><li>child == null &amp;&amp; newWidget != null :<br>  第一次挂载child Element，解析build出的widget，调用 inflateWidget(newWidget, newSlot)</li><li>child != null &amp;&amp; newWidget != null :<br>  更新Element，StatefulWidget 调用setState时会进入这个分支。 会调用 child.canUpdate这个方法，判断是否需要更新Element。如果canUpdate返回false，移除这个element然后重新创建</li><li>child == null &amp;&amp; newWidget == null :<br>  do nothing</li></ul><p>在mount过程会进入第二个分支，调用 inflateWidget(newWidget, newSlot)</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">    newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line">    <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StatefulWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatefulElement createElement() =&gt; StatefulElement(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  State createState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  StatefulElement(StatefulWidget widget)</span><br><span class="line">      : _state = widget.createState(),</span><br><span class="line">        <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">    _state._element = <span class="keyword">this</span>;</span><br><span class="line">    _state._widget = widget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build() =&gt; state.build(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatefulWidget，State，StatefulElement的调用关系：<br>Widget.createElement() -&gt; Element.build() -&gt; State.build()</p><h3 id="更新Element"><a href="#更新Element" class="headerlink" title="更新Element"></a>更新Element</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget.setState</span><br><span class="line">    - <span class="built_in">Element</span>.markNeedsBuild()</span><br><span class="line">        - <span class="built_in">Element</span>._dirty = <span class="keyword">true</span></span><br><span class="line">        - BuildOwner.scheduleBuildFor(<span class="keyword">this</span>)</span><br><span class="line">            - BuildOwner._dirtyElements.add(element)</span><br></pre></td></tr></table></figure><p>当调用statState之后，会将element标脏，并加入到_dirtyElements列表中</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- WidgetsBinding.drawFrame()</span><br><span class="line">    - BuildOwner.buildScope(renderViewElement)</span><br><span class="line">        - BuildOwner._dirtyElements[index].rebuild()</span><br></pre></td></tr></table></figure><p>每次UI刷新时，会回调WidgetBinding的drawFrame(), BuildOwner会将_dirtyElements列表rebuild。<br>可以翻上去查看挂载阶段rebuild之后的调用链，是完全一样的</p><h3 id="卸载Element"><a href="#卸载Element" class="headerlink" title="卸载Element"></a>卸载Element</h3><p>在Element的updateChild方法中，在 <code>child != null &amp;&amp; newWidget == null</code> 时，会调用deactivateChild()</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> deactivateChild(<span class="built_in">Element</span> child) &#123;</span><br><span class="line">  child._parent = <span class="keyword">null</span>;</span><br><span class="line">  child.detachRenderObject();</span><br><span class="line">  owner._inactiveElements.add(child); <span class="comment">// this eventually calls child.deactivate()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>deactivateChild()方法中，会将child element加入到 BuildOwner的_inactiveElements集合中。</p><p>还是WidgetBind.drawFrame()方法，会调用 buildOwner.finalizeTree(); 对不再使用的Element进行unmount</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> finalizeTree() &#123;</span><br><span class="line">    Timeline.startSync(<span class="string">'Finalize tree'</span>, arguments: timelineWhitelistArguments);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lockState(() &#123;</span><br><span class="line">        _inactiveElements._unmountAll(); <span class="comment">// this unregisters the GlobalKeys</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _unmountAll() &#123;</span><br><span class="line">    _locked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; elements = _elements.toList()..sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">    _elements.clear();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      elements.reversed.forEach(_unmount);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _locked = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _unmount(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    element.visitChildren((<span class="built_in">Element</span> child) &#123;</span><br><span class="line">      _unmount(child);</span><br><span class="line">    &#125;);</span><br><span class="line">    element.unmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h2><h3 id="RenderObjectElement"><a href="#RenderObjectElement" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h3><p>RenderObjectElement使用RenderObjectWidget作为配置文件。在RenderTree中有一个与之对应的RenderObject，用来执行具体的测量，绘制等操作。<strong>不是所有的Element都有对应的RenderObject</strong></p><p>RenderObjectElement有三个常用的子类：</p><ul><li>LeafRenderObjectElement：Leaf render objects, with no children</li><li>SingleChildRenderObjectElement：A single child</li><li>MultiChildRenderObjectElement：A linked list of children.</li></ul><p>RenderObjectElement的mount、update、unmount逻辑与ComponentElement大致相同，只不过加上了RenderObject的相关逻辑。</p><p><strong>mmount、update、unmount</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> attachRenderObject(<span class="keyword">dynamic</span> newSlot) &#123;</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">  _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</span><br><span class="line">  <span class="keyword">final</span> ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">  <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">    _updateParentData(parentDataElement.widget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(covariant RenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RenderObject的更新"><a href="#RenderObject的更新" class="headerlink" title="RenderObject的更新"></a>RenderObject的更新</h3><p>我们从render树的insert过程类分析RenderObject的更新<br>从RenderObjectElement.insertChildRenderObject开始</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> insertChildRenderObject(RenderObject child, <span class="built_in">Element</span> slot) &#123;</span><br><span class="line">  <span class="keyword">final</span> ContainerRenderObjectMixin&lt;RenderObject, ContainerParentDataMixin&lt;RenderObject&gt;&gt; renderObject = <span class="keyword">this</span>.renderObject;</span><br><span class="line">  renderObject.insert(child, after: slot?.renderObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了ContainerRenderObjectMixin的insert方法，</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> insert(ChildType child, &#123; ChildType after &#125;) &#123;</span><br><span class="line">  adoptChild(child);</span><br><span class="line">  _insertIntoChildList(child, after: after);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> adoptChild(RenderObject child) &#123;</span><br><span class="line">  setupParentData(child);</span><br><span class="line">  markNeedsLayout();</span><br><span class="line">  markNeedsCompositingBitsUpdate();</span><br><span class="line">  markNeedsSemanticsUpdate();</span><br><span class="line">  <span class="keyword">super</span>.adoptChild(child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">    markParentNeedsLayout();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> markParentNeedsLayout() &#123;</span><br><span class="line">  _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">  <span class="keyword">if</span> (!_doingThisLayoutWithCallback) &#123;</span><br><span class="line">    parent.markNeedsLayout();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span>(parent._debugDoingThisLayout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和element的build流程不同，RenderObject的标脏会向上标脏。<br>找到 _relayoutBoundary 节点，触发<code>owner._nodesNeedingLayout.add( this )</code>与<code>owner.requestVisualUpdate()</code> 其中owner._nodesNeedingLayout.add( this )将当前RenderObject注册进PipelineOwner的待刷新列表中，然后触发“VisualUpdate”。这里的owner是PipelineOwner</p><p>PiplelineOwner.requestVisualUpdate会请求engine进行一次刷新。。<br>(todo 不是标脏吗？ 难道不是等待vsync信号对标脏的node进行重绘？？？)<br>来看一下PiplelineOwner.requestVisualUpdate</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> requestVisualUpdate() &#123;</span><br><span class="line">  <span class="keyword">if</span> (onNeedVisualUpdate != <span class="keyword">null</span>)</span><br><span class="line">    onNeedVisualUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onNeedVisualUpdate是在PiplelineOwner实例化的时候赋值的，在RendererBinding的initInstances里</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">  <span class="keyword">super</span>.initInstances();</span><br><span class="line">  _instance = <span class="keyword">this</span>;</span><br><span class="line">  _pipelineOwner = PipelineOwner(</span><br><span class="line">    onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">    onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">    onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">window</span></span><br><span class="line">    ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">    ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">    ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">    ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">    ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">  initRenderView();</span><br><span class="line">  _handleSemanticsEnabledChanged();</span><br><span class="line">  <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">  addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">  initMouseTracker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _handlePersistentFrameCallback(<span class="built_in">Duration</span> timeStamp) &#123;</span><br><span class="line">  drawFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ensureVisualUpdate 会调用window.scheduleFrame()请求native层绘制新帧。。。没太搞懂为什么要主动请求绘制</p><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p><strong>RendererBinding.drawFrame</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  ...</span><br><span class="line">  pipelineOwner.flushLayout();</span><br><span class="line">  pipelineOwner.flushCompositingBits();</span><br><span class="line">  pipelineOwner.flushPaint();</span><br><span class="line">  renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">  pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pipelineOwner.flushLayout()</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">      _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">      <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">          node._layoutWithoutResize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>*RendererObject._layoutWithoutResize</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _layoutWithoutResize() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    performLayout();</span><br><span class="line">    markNeedsSemanticsUpdate();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    _debugReportException(<span class="string">'performLayout'</span>, e, stack);</span><br><span class="line">  &#125;</span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用performLayout()进行layout，并标记需要paint</p><h3 id="paint"><a href="#paint" class="headerlink" title="paint"></a>paint</h3><p>之前说到过，layout过程中会对paint进行标脏</p><p><strong>markNeedsPaint()</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsPaint)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    parent.markNeedsPaint();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If we're the root of the render tree (probably a RenderView),</span></span><br><span class="line">    <span class="comment">// then we have to paint ourselves, since nobody else can paint</span></span><br><span class="line">    <span class="comment">// us. We don't add ourselves to _nodesNeedingPaint in this</span></span><br><span class="line">    <span class="comment">// case, because the root is always told to paint regardless.</span></span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和layout的标脏过程类似，一直向上标脏，直到 isRepaintBoundary 为true。<strong>注意，这里只有 RepaintBoundary 才加入到了 PiplineOwner 的_nodesNeedingPaint中，即最终是以 RepaintBoundary 单位进行刷新的</strong><br>需要说明的是，我们可以 RepaintBoundary 是一个widget，我们可以手动添加，来终止paint的向上标脏过程，来达到局部重绘，提升性能。 LayoutBoundary 则是只是一个标记位，framework层帮我们判断的，我们不需要手动处理。</p><p><strong>pipelineOwner.flushLayout()</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">    _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line">    <span class="comment">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class="line">    <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsPaint &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node._layer.attached) &#123;</span><br><span class="line">          PaintingContext.repaintCompositedChild(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          node._skippedPaintingOnLayer();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与layout不同的是这里的 sort 规则是相反的，最深的节点先重绘。并且，多了判断 <code>node._layer.attached</code>, 如果为true，重绘，并且重绘逻辑交给了PaintContext；如果为false，则执行 <code>node._skippedPaintingOnLayer();</code></p><p><strong>node._skippedPaintingOnLayer()</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _skippedPaintingOnLayer() &#123;</span><br><span class="line">  AbstractNode ancestor = parent;</span><br><span class="line">  <span class="keyword">while</span> (ancestor <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObject node = ancestor;</span><br><span class="line">    <span class="keyword">if</span> (node.isRepaintBoundary) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._layer == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// looks like the subtree here has never been painted. let it handle itself.</span></span><br><span class="line">      <span class="keyword">if</span> (node._layer.attached)</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// it's the one that detached us, so it's the one that will decide to repaint us.</span></span><br><span class="line">      node._needsPaint = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ancestor = node.parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的理解是，该节点的 layer 被 detached 了，需要对该节点及其父节点行重新标脏，保证该节点的 layer 被重新 attach 之后能够重绘。 </p><p><strong>PaintingContext.repaintCompositedChild(node);</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> repaintCompositedChild(RenderObject child, &#123; <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  _repaintCompositedChild(</span><br><span class="line">    child,</span><br><span class="line">    debugAlsoPaintedParent: debugAlsoPaintedParent,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">  RenderObject child, &#123;</span><br><span class="line">  <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">  PaintingContext childContext,</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  OffsetLayer childLayer = child._layer;</span><br><span class="line">  <span class="keyword">if</span> (childLayer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    child._layer = childLayer = OffsetLayer();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    childLayer.removeAllChildren();</span><br><span class="line">  &#125;</span><br><span class="line">  childContext ??= PaintingContext(child._layer, child.paintBounds);</span><br><span class="line">  child._paintWithContext(childContext, Offset.zero);</span><br><span class="line"></span><br><span class="line">  childContext.stopRecordingIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是 PaintContext 和 layer。。。先跳过这两个，最终重绘的逻辑在 <code>child._paintWithContext(childContext, Offset.zero);</code>中</p><p><strong>child._paintWithContext(childContext, Offset.zero);</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="comment">// 一堆注释解释了为啥在paint的时候 _needsLayout 还可能为true 。。。</span></span><br><span class="line">  <span class="comment">// 英文注释没咋看懂</span></span><br><span class="line">  <span class="keyword">if</span> (_needsLayout)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  RenderObject debugLastActivePaint;</span><br><span class="line">  _needsPaint = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 最终的重绘交给具体的 RenderObject 子类</span></span><br><span class="line">    paint(context, offset);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    _debugReportException(<span class="string">'paint'</span>, e, stack);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Widget-Element-RanderObject-三者之间的关系&quot;&gt;&lt;a href=&quot;#Widget-Element-RanderObject-三者之间的关系&quot; class=&quot;headerlink&quot; title=&quot;Widget, Element, RanderObject 三者之间的关系&quot;&gt;&lt;/a&gt;Widget, Element, RanderObject 三者之间的关系&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Flutter" scheme="http://yoursite.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Java获取泛型类型</title>
    <link href="http://yoursite.com/2020/07/23/Java/Java%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/07/23/Java/Java获取泛型类型/</id>
    <published>2020-07-23T12:05:38.000Z</published>
    <updated>2021-10-03T01:57:41.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取泛型class的通用方法"><a href="#获取泛型class的通用方法" class="headerlink" title="获取泛型class的通用方法"></a>获取泛型class的通用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><a id="more"></a><p>因为有泛型擦除, 并不是所有情况下都能获取到泛型实际类型. 只有在泛型类型明确时, 才能在运行时获取到泛型类型</p><h2 id="无法获取到泛型类型"><a href="#无法获取到泛型类型" class="headerlink" title="无法获取到泛型类型"></a>无法获取到泛型类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SuperClass&lt;String&gt; object = SuperClass&lt;String&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">SubClass&lt;T&gt; extends SuperClass&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SubClass&lt;String&gt; object = SubClass&lt;Strng&gt;()</span><br></pre></td></tr></table></figure><h2 id="可以获取到泛型类型"><a href="#可以获取到泛型类型" class="headerlink" title="可以获取到泛型类型"></a>可以获取到泛型类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 子类继承父类时, 明确了泛型类型</span></span><br><span class="line">SubClass extends SuperClass&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 匿名内部类, 子类继承父类的特殊情况</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SuperClass&lt;String&gt; object = <span class="keyword">new</span> SuperClass&lt;String&gt;()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;获取泛型class的通用方法&quot;&gt;&lt;a href=&quot;#获取泛型class的通用方法&quot; class=&quot;headerlink&quot; title=&quot;获取泛型class的通用方法&quot;&gt;&lt;/a&gt;获取泛型class的通用方法&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Type type = ((ParameterizedType)obj.getClass().getGenericSuperclass()).getActualTypeArguments()[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>kotlin协程</title>
    <link href="http://yoursite.com/2020/07/15/Android/kotlin%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/07/15/Android/kotlin协程/</id>
    <published>2020-07-15T03:30:02.000Z</published>
    <updated>2021-10-03T01:57:41.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><p>首先看一个例子，先后调用两个挂起函数</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = doSomethingUsefulOne()</span><br><span class="line">        <span class="keyword">val</span> two = doSomethingUsefulTwo()</span><br><span class="line">        println(<span class="string">"The answer is <span class="subst">$&#123;one + two&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed in <span class="variable">$time</span> ms"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里做了些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里也做了一些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The answer is 42</span></span><br><span class="line"><span class="comment">Completed in 2017 ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>可以发现，两个挂起函数是同步执行的，有先后顺序</p><p>使用async</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line">        <span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br><span class="line">        println(<span class="string">"The answer is <span class="subst">$&#123;one.await() + two.await()&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"Completed in <span class="variable">$time</span> ms"</span>)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里做了些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// 假设我们在这里也做了些有用的事</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">The answer is 42</span></span><br><span class="line"><span class="comment">Completed in 1024 ms</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>在结果耗时上，两个挂起方法达到了异步的效果。这得益于<code>async</code>关键字<br>在概念上，<code>async</code> 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。</p><h2 id="调度器与线程"><a href="#调度器与线程" class="headerlink" title="调度器与线程"></a>调度器与线程</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    launch &#123; <span class="comment">// 运行在父协程的上下文中，即 runBlocking 主协程</span></span><br><span class="line">        println(<span class="string">"main runBlocking      : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Unconfined) &#123; <span class="comment">// 不受限的——将工作在主线程中</span></span><br><span class="line">        println(<span class="string">"Unconfined            : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(Dispatchers.Default) &#123; <span class="comment">// 将会获取默认调度器</span></span><br><span class="line">        println(<span class="string">"Default               : I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(newSingleThreadContext(<span class="string">"MyOwnThread"</span>)) &#123; <span class="comment">// 将使它获得一个新的线程</span></span><br><span class="line">        println(<span class="string">"newSingleThreadContext: I'm working in thread <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出 注意先后顺序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unconfined            : I'm working in thread main <span class="doctag">@coroutine</span>#3</span></span><br><span class="line"><span class="comment">Default               : I'm working in thread DefaultDispatcher-worker-1 <span class="doctag">@coroutine</span>#4</span></span><br><span class="line"><span class="comment">main runBlocking      : I'm working in thread main <span class="doctag">@coroutine</span>#2</span></span><br><span class="line"><span class="comment">newSingleThreadContext: I'm working in thread MyOwnThread <span class="doctag">@coroutine</span>#5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li><code>launch { …… }</code> :<ul><li>当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。</li></ul></li><li><code>launch(Dispatchers.Default) { …… }</code> :<ul><li>当协程在 GlobalScope 中启动时，使用的是由<code>Dispatchers.Default</code>代表的默认调度器。 默认调度器使用共享的后台线程池。 所以<code>launch(Dispatchers.Default) { …… }</code>与<code>GlobalScope.launch { …… }</code>使用相同的调度器。<br><code>Dispatchers.Default</code>适合CPU密集型的任务，比如解析JSON文件，排序一个较大的list</li></ul></li><li><code>launch(Dispatchers.IO) { …… }</code> :<ul><li>针对磁盘和网络IO进行了优化，适合IO密集型的任务，比如：读写文件，操作数据库以及网络请求 </li></ul></li><li><code>launch(newSingleThreadContext(&quot;...&quot;)) { ... }</code> :<ul><li><code>newSingleThreadContext</code> 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 <code>close</code> 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。???</li></ul></li><li><code>launch(Dispatchers.Unconfined) { ... }</code> :<ul><li>完全没搞懂这玩意儿..</li></ul></li></ul><h2 id="在Android中使用协程作用域"><a href="#在Android中使用协程作用域" class="headerlink" title="在Android中使用协程作用域"></a>在Android中使用协程作用域</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mainScope = MainScope()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">destroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mainScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 在示例中启动了 10 个协程，且每个都工作了不同的时长</span></span><br><span class="line">        repeat(<span class="number">10</span>) &#123; i -&gt;</span><br><span class="line">            mainScope.launch &#123;</span><br><span class="line">                delay((i + <span class="number">1</span>) * <span class="number">200L</span>) <span class="comment">// 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间</span></span><br><span class="line">                println(<span class="string">"Coroutine <span class="variable">$i</span> is done"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// Activity 类结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> activity = Activity()</span><br><span class="line">    activity.doSomething() <span class="comment">// 运行测试函数</span></span><br><span class="line">    println(<span class="string">"Launched coroutines"</span>)</span><br><span class="line">    delay(<span class="number">500L</span>) <span class="comment">// 延迟半秒钟</span></span><br><span class="line">    println(<span class="string">"Destroying activity!"</span>)</span><br><span class="line">    activity.destroy() <span class="comment">// 取消所有的协程</span></span><br><span class="line">    delay(<span class="number">1000</span>) <span class="comment">// 为了在视觉上确认它们没有工作    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activity 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 <code>Dispatchers.Main</code> 作为默认调度器的 UI 应用程序 创建作用域.</p><p>在上面的程序中, 当Actiivty被destroy()时, 会 cancel() 协程作用域, 从而终止所有的协程</p><h2 id="异步流"><a href="#异步流" class="headerlink" title="异步流"></a>异步流</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// 流构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们在这里做了一些有用的事情</span></span><br><span class="line">        emit(i) <span class="comment">// 发送下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">"I'm not blocked <span class="variable">$k</span>"</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集这个流</span></span><br><span class="line">    foo().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">I'm not blocked 1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">I'm not blocked 2</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">I'm not blocked 3</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>上方的程序: </p><ul><li>名为 flow 的 Flow 类型构建器函数。</li><li>flow { … } 构建块中的代码可以挂起。</li><li>函数 foo() 不再标有 suspend 修饰符。</li><li>流使用 emit 函数 发射 值。</li><li>流使用 collect 函数 收集 值。</li></ul><p>kotlin支持对flow进行各种操作, 比如: flat, reduce, zip等等, 类似RxJava的各种运算</p><h2 id="suspendCancellableCoroutine"><a href="#suspendCancellableCoroutine" class="headerlink" title="suspendCancellableCoroutine"></a>suspendCancellableCoroutine</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">loadPageSuspend</span><span class="params">(productCategoryType: <span class="type">Int</span>, page: <span class="type">Int</span>)</span></span>: ProductListLoadResultBean =</span><br><span class="line">            suspendCancellableCoroutine &#123; cnt -&gt;</span><br><span class="line">                ProductManagementAPI.requestProductList(</span><br><span class="line">                        category = productCategoryType,</span><br><span class="line">                        page = page,</span><br><span class="line">                        keyword = getKeyword(),</span><br><span class="line">                        orderBy = getOrderType(),</span><br><span class="line">                        desc =  isOrderDesc(),</span><br><span class="line">                        listener = <span class="keyword">object</span> : INetRequestListener&lt;ProductListLoadResultBean&gt; &#123;</span><br><span class="line">                            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSuccess</span><span class="params">(result: <span class="type">DataHull</span>&lt;<span class="type">ProductListLoadResultBean</span>&gt;?)</span></span> &#123;</span><br><span class="line">                                result?.let &#123;</span><br><span class="line">                                    cnt.resumeWith(Result.success(it.<span class="keyword">data</span>))</span><br><span class="line"></span><br><span class="line">                                &#125; ?: kotlin.run &#123;</span><br><span class="line">                                    cnt.resumeWithException(Exception())</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(error: <span class="type">DataHull</span>&lt;<span class="type">ProductListLoadResultBean</span>&gt;?, isNetError: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">                                cnt.resumeWithException(Exception(error?.stateBean?.message))</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Async&quot;&gt;&lt;a href=&quot;#Async&quot; class=&quot;headerlink&quot; title=&quot;Async&quot;&gt;&lt;/a&gt;Async&lt;/h2&gt;&lt;p&gt;首先看一个例子，先后调用两个挂起函数&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android自定义注解</title>
    <link href="http://yoursite.com/2020/06/27/Android/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/06/27/Android/Android自定义注解/</id>
    <published>2020-06-27T03:06:02.000Z</published>
    <updated>2021-10-03T01:57:41.022Z</updated>
    
    <content type="html"><![CDATA[<p>因为要自定义一个页面导航工具，需要使用自定义注解</p><a id="more"></a><h2 id="1-创建Java-Library"><a href="#1-创建Java-Library" class="headerlink" title="1. 创建Java Library"></a>1. 创建Java Library</h2><p>创建两个新的module，<strong>创建时module一定要选择Java Library</strong></p><p>两个module分别是:</p><ul><li>libnavannotation 注解</li><li>libnavcompile 注解处理器</li></ul><h2 id="2-定义注解"><a href="#2-定义注解" class="headerlink" title="2. 定义注解"></a>2. 定义注解</h2><p>定义两个注解ActivityDestination, FragmentDestination</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.CLASS)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.BINARY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityDestination</span></span>(</span><br><span class="line">    <span class="keyword">val</span> pageUrl: String,</span><br><span class="line">    <span class="keyword">val</span> needLogin: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">val</span> asStarter: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.CLASS)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.BINARY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentDestination</span></span>(</span><br><span class="line">    <span class="keyword">val</span> pageUrl: String,</span><br><span class="line">    <span class="keyword">val</span> needLogin: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">val</span> asStarter: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="3-定义注解处理器（关键）"><a href="#3-定义注解处理器（关键）" class="headerlink" title="3. 定义注解处理器（关键）"></a>3. 定义注解处理器（关键）</h2><h3 id="3-1-配置build-gradle"><a href="#3-1-配置build-gradle" class="headerlink" title="3.1 配置build.gradle"></a>3.1 配置build.gradle</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'java-library'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-kapt'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"</span></span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'com.alibaba:fastjson:1.2.59'</span></span><br><span class="line"></span><br><span class="line">    implementation project(<span class="string">':libnavannotation'</span>)</span><br><span class="line">    implementation <span class="string">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class="line"><span class="comment">//    annotationProcessor 'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class="line">    kapt <span class="string">'com.google.auto.service:auto-service:1.0-rc6'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="string">"8"</span></span><br><span class="line">targetCompatibility = <span class="string">"8"</span></span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li>如果注解处理器是使用kotlin编写的，那么，一定要添加<code>kotlin-kapt</code>插件</li><li>implementation 导入annotation注解模块</li><li>导入auto-service注解处理器依赖，如果是纯Java代码，可以使用<code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>， <strong>如果是kotlin代码，必须使用<code>kapt &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code>。</strong> 我这里还implementation了auto-service</li></ul><h3 id="3-2-编写注解处理器"><a href="#3-2-编写注解处理器" class="headerlink" title="3.2 编写注解处理器"></a>3.2 编写注解处理器</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@AutoService(Processor::class)</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(</span></span><br><span class="line"><span class="meta">    <span class="meta-string">"com.example.libnavannotation.ActivityDestination"</span>,</span></span><br><span class="line"><span class="meta">    <span class="meta-string">"com.example.libnavannotation.FragmentDestination"</span></span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NavProcessor</span> : <span class="type">AbstractProcessor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(processingEnv: <span class="type">ProcessingEnvironment</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(processingEnv)</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(annotations: <span class="type">Set</span>&lt;<span class="type">TypeElement</span>&gt;, roundEnv: <span class="type">RoundEnvironment</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意注解处理器类上面的几个注解</strong></p><h3 id="3-3-创建processor-configuration-file"><a href="#3-3-创建processor-configuration-file" class="headerlink" title="3.3 创建processor configuration file"></a>3.3 创建processor configuration file</h3><p>这里取决于gradle的版本，<strong>高版本必须创建processor配置文件，否则不会执行注解处理器的代码</strong></p><ul><li>需要在注解处理器所在module的 main 底下新建一个package，名称为 resources</li><li>在 <code>resources</code> 底下新建文件 <code>META-INF/services/javax.annotation.processing.Processor</code></li><li>在 <code>javax.annotation.processing.Processor</code> 下写入 注解处理器的全名称  eg: <code>com.example.libnavcompiler.NavProcessor</code></li></ul><h2 id="4-使用注解"><a href="#4-使用注解" class="headerlink" title="4. 使用注解"></a>4. 使用注解</h2><p>在Android工程module中配置build.gradle</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-kapt'</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line">    implementation <span class="string">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    implementation project(<span class="string">":libnavannotation"</span>)</span><br><span class="line"><span class="comment">//    annotationProcessor project(":libnavcompiler")</span></span><br><span class="line">    kapt project(<span class="string">":libnavcompiler"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入 注解module、注解处理器module<br>kotlin相关的注意事项和 注解处理器module 中的一样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FragmentDestination(pageUrl = <span class="meta-string">"main/tabs/home"</span>, asStarter = true)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在build中点击<code>make project</code>，即可执行直接处理器中的代码。如果遇到不成功，可以<code>rebuild</code>再试一次</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5cb7ebeee51d456e8833394b#heading-0" target="_blank" rel="noopener">教你如何完全解析Kotlin中的注解</a></p><p><a href="https://juejin.im/post/5e58dca26fb9a07cb24aa1d6#heading-4" target="_blank" rel="noopener">Android 开发之 自定义注解处理器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为要自定义一个页面导航工具，需要使用自定义注解&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="注解" scheme="http://yoursite.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>gradle相关基础</title>
    <link href="http://yoursite.com/2020/06/18/Android/gradle/gradle%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/06/18/Android/gradle/gradle相关基础/</id>
    <published>2020-06-18T11:54:57.000Z</published>
    <updated>2022-03-13T07:33:58.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gradle中的对象"><a href="#Gradle中的对象" class="headerlink" title="Gradle中的对象"></a>Gradle中的对象</h2><p>Gradle主要有三种对象<br>这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：</p><a id="more"></a><ul><li>Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。</li><li>Project对象：Gradle对每一个build.gradle会实例化成一个Project类，并且能够通过project变量使其隐式可用。</li><li>Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。</li></ul><p>构建的生命周期，首先根据settings.gradle文件构建出一个Seetings对象，然后根据Seetings中的配置，创建Project对象，去找各个project下的build.gradle文件，根据文件内容来对project对象进行配置。</p><h2 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">':app'</span>, <span class="string">':progect_1'</span>, <span class="string">':progect_2'</span></span><br></pre></td></tr></table></figure><p>用于指示 Gradle 在构建应用时应将哪些模块包括在内</p><h2 id="gradle-properties"><a href="#gradle-properties" class="headerlink" title="gradle.properties"></a>gradle.properties</h2><p>里面可以定义一些常量供build.gradle使用，如版本号等.<br>然后，我们就可以在build文件中进行引用了。引用方式，直接通过变量名就可以。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COMPILE_SDK_VERSION = <span class="number">23</span></span><br><span class="line">BUILD_TOOLS_VERSION = <span class="number">23.0</span><span class="number">.1</span></span><br><span class="line">VERSION_CODE = <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h2><p>build文件有两种，一个是针对当前的Module，一个是针对项目中所有的module<br>在顶层的build文件中，我们可以来添加一些子module所共有的一些配置</p><p>下面是一些常用的build.gradle的配置说明<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 应用插件，module中的build.gradle很多配置都是插件提供的支持</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line"><span class="comment">// 仓库， </span></span><br><span class="line">buildscript&#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">''</span> <span class="comment">// 声明插件名称和版本号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部依赖，添加的依赖会在这些配置的仓库中去寻找</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// "group:name:version"</span></span><br><span class="line">    implementation <span class="string">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有子工程的仓库地址</span></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>为什么<code>buildscript</code>和<code>allpojectes</code>都有<code>repositories</code></strong></p><ul><li>buildScript块的repositories主要是为了Gradle脚本自身的执行，获取脚本依赖插件。</li><li>allprojects块的repositories用于多项目构建，为所有项目提供共同所需依赖包。比如用到的Glide/OkHttp等</li><li>子项目可以配置自己的repositories以获取自己独需的依赖包。</li></ul><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以定义依赖于其它任务、动作序列和执行条件。</p><ul><li>depandsOn: 依赖于其它任务</li><li>doFirst, doLast(&lt;&lt;): Task是一个动作列表，doFirst表示在动作列表最前面添加一个动作，doLast在动作列表最后面添加一个动作</li></ul><p>apply的插件自带和很多Task，在Gradle页面的 <code>&lt;项目名&gt;/Tasks/build</code> 目录里面可以看到。<br>我们也可以自己编写任务，自己的Task在Gradle页面的 <code>&lt;项目名&gt;/Tasks/other/</code> 目录里可以查找到</p><h2 id="Gradle的工作流程"><a href="#Gradle的工作流程" class="headerlink" title="Gradle的工作流程"></a>Gradle的工作流程</h2><p><img src="/images/gradle的构建过程.jpg" alt="gradle的工作流程"></p><ul><li>Initialization: 初始化，在多模块的项目中，就是执行settings.gradle</li><li>Configuration: Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。  Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。</li><li>Execution: 执行Task。 只有doFirst和doLast中的内容属于执行阶段</li></ul><p>简言之，Gradle有一个初始化流程，这个时候settings.gradle会执行。<br>在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！</p><p>在每一步的步骤中间可以添加hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task a &#123;</span><br><span class="line">    println <span class="string">'this is a'</span></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println <span class="string">'this is a do first'</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">"this is a do last"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task testBoth &#123;</span><br><span class="line">    <span class="comment">// 配置阶段</span></span><br><span class="line">    <span class="comment">// 依赖 a task 先执行</span></span><br><span class="line">    dependsOn(<span class="string">"a"</span>)</span><br><span class="line">    println <span class="string">'this is b'</span></span><br><span class="line">    doFirst &#123;</span><br><span class="line">        <span class="comment">// 执行阶段</span></span><br><span class="line">        println <span class="string">'this is b first'</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        <span class="comment">// 执行阶段</span></span><br><span class="line">        println <span class="string">'this is b last'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; Configure project :</span></span><br><span class="line"><span class="comment">this is a</span></span><br><span class="line"><span class="comment">this is b</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; Task :a</span></span><br><span class="line"><span class="comment">this is a do first</span></span><br><span class="line"><span class="comment">this is a do last</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&gt; Task :testBoth</span></span><br><span class="line"><span class="comment">this is b first</span></span><br><span class="line"><span class="comment">this is b last</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="解决依赖版本冲突"><a href="#解决依赖版本冲突" class="headerlink" title="解决依赖版本冲突"></a>解决依赖版本冲突</h2><p>大部分情况下，不需要我们去解决版本冲突。当出现版本冲突时，Gradle会帮我们自动依赖最高版本的包。</p><p>以下是我们自己解决版本冲突的一般步骤</p><h3 id="查看依赖报告"><a href="#查看依赖报告" class="headerlink" title="查看依赖报告"></a>查看依赖报告</h3><p>运行Gradle， <code>&lt;项目名称&gt;/app/Tasks/dependencies/</code> 查看依赖报告，输出如下</p><p><code>xxxx -&gt; xxxx</code> 表示依赖包自动提升到了最高版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- androidx.lifecycle:lifecycle-extensions:2.1.0</span><br><span class="line">|    +--- androidx.lifecycle:lifecycle-runtime:2.1.0</span><br><span class="line">|    |    +--- androidx.lifecycle:lifecycle-common:2.1.0 -&gt; 2.3.0-alpha01</span><br><span class="line">|    |    |    \--- androidx.annotation:annotation:1.1.0</span><br><span class="line">|    |    +--- androidx.arch.core:core-common:2.1.0</span><br><span class="line">|    |    |    \--- androidx.annotation:annotation:1.1.0</span><br><span class="line">|    |    \--- androidx.annotation:annotation:1.1.0</span><br><span class="line">|    +--- androidx.arch.core:core-common:2.1.0 (*)</span><br><span class="line">|    +--- androidx.arch.core:core-runtime:2.1.0</span><br></pre></td></tr></table></figure><h3 id="排除传递性冲突"><a href="#排除传递性冲突" class="headerlink" title="排除传递性冲突"></a>排除传递性冲突</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile (<span class="string">'cn.qqtheme.framework:WheelPicker:1.5.1'</span>)&#123;</span><br><span class="line">    exclude <span class="string">group:</span><span class="string">'com.android.support'</span>, <span class="string">module:</span><span class="string">"appcompat"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制一个版本"><a href="#强制一个版本" class="headerlink" title="强制一个版本"></a>强制一个版本</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configurations.all&#123;</span><br><span class="line">    resolutionStrategy&#123;</span><br><span class="line">        force <span class="string">'androidx.appcompat:appcompat:1.1.0'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Gradle中的对象&quot;&gt;&lt;a href=&quot;#Gradle中的对象&quot; class=&quot;headerlink&quot; title=&quot;Gradle中的对象&quot;&gt;&lt;/a&gt;Gradle中的对象&lt;/h2&gt;&lt;p&gt;Gradle主要有三种对象&lt;br&gt;这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对象：&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
</feed>
