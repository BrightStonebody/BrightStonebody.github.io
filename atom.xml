<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BrightStone</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-08-19T09:22:30.366Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BrightStone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DecorView, Window, ViewRootImpl的关系</title>
    <link href="http://yoursite.com/2022/08/19/Android/Framework/DecorView-Window-ViewRootImpl%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2022/08/19/Android/Framework/DecorView-Window-ViewRootImpl的关系/</id>
    <published>2022-08-19T02:22:30.000Z</published>
    <updated>2022-08-19T09:22:30.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Window的创建"><a href="#Window的创建" class="headerlink" title="Window的创建"></a>Window的创建</h2><p>一个 activity 对应的是 PhoneWindow 。 创建的时机是在 attach </p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 PhoneWindow 的同时，会设置 WindowManager , WindowManager 是一个系统服务。 在app进程的代理类是 WindowManagerImpl， 但是 WindowManagerImpl 把实现委托给了 WindowManagerGlobal 。 </p><h2 id="DecorView-的创建"><a href="#DecorView-的创建" class="headerlink" title="DecorView 的创建"></a>DecorView 的创建</h2><p>DecorView的创建在 <code>activity.setContentView(int)</code> , 最终实现在 <code>PhoneWindow.setContentView(int)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// mContentParent 是 android.R.id.content 的 view</span></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>); <span class="comment">// 实例化 DecorView </span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor); <span class="comment">// 返回 content 的view</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewRootImpl-的创建"><a href="#ViewRootImpl-的创建" class="headerlink" title="ViewRootImpl 的创建"></a>ViewRootImpl 的创建</h2><p>ViewRootImpl 的创建在 <code>ActivityThread#handleResumeActivity</code> 里。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 activity#onResume</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> forwardBit = isForward</span><br><span class="line">            ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the window hasn't yet been added to the window manager,</span></span><br><span class="line">    <span class="comment">// and this guy didn't finish itself or start another activity,</span></span><br><span class="line">    <span class="comment">// then go ahead and add the window.</span></span><br><span class="line">    <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</span><br><span class="line">    <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            willBeVisible = ActivityTaskManager.getService().willActivityBeVisible(</span><br><span class="line">                    a.getActivityToken());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        ... <span class="comment">// 非主流程？ </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The window is now visible if it has been added, we are not</span></span><br><span class="line">    <span class="comment">// simply finishing, and we are not starting another activity.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        ViewRootImpl impl = r.window.getDecorView().getViewRootImpl();</span><br><span class="line">        WindowManager.LayoutParams l = impl != <span class="keyword">null</span></span><br><span class="line">                ? impl.mWindowAttributes : r.window.getAttributes();</span><br><span class="line">        ...</span><br><span class="line">        r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">        mNumVisibleActivities++;</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>activity#makeVisible()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用了 WindowManagerGlobal#addView(…)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root; <span class="comment">// 实例化 ViewRootImpl</span></span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储所有的 decorView 和 ViewRootImpl 。暂时不明白存储来做什么的</span></span><br><span class="line">        mViews.add(view); </span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定 DecorView 和 ViewRootImpl</span></span><br><span class="line">            root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 异常了，移除</span></span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h3><p>核心类是 ViewRootImpl 。 它负责和系统 WMS 交互</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">ThreadedRenderer</span>.<span class="title">DrawCallbacks</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ViewRootHandler mHandler = <span class="keyword">new</span> ViewRootHandler();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        <span class="comment">// WMS端Session的代理对象</span></span><br><span class="line">        mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">        mDisplay = display;</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 继承于IWindow.Stub的W对象</span></span><br><span class="line">        mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);</span><br><span class="line">        mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>, context);</span><br><span class="line">        <span class="comment">// 绘制相关的对象</span></span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mView = view;</span><br><span class="line">                mAttachInfo.mRootView = view;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开启绘制流程三步走</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">// 由之前的解析可知Session.addToDisplay会调用到WMS.addWindow方法</span></span><br><span class="line">            <span class="comment">// 通过session与WMS建立通信，完成window的添加</span></span><br><span class="line">            es = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                    getHostVisibility(), mDisplay.getDisplayId(), mWinFrame,</span><br><span class="line">                    mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                    mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Window-的移除"><a href="#Window-的移除" class="headerlink" title="Window 的移除"></a>Window 的移除</h2><p>在 ActivityThread 的 handleDestroyActivity 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 activity#onDestroy</span></span><br><span class="line">    ActivityClientRecord r = performDestroyActivity(token, finishing,</span><br><span class="line">            configChanges, getNonConfigInstance, reason);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WindowManager wm = r.activity.getWindowManager();</span><br><span class="line">        View v = r.activity.mDecor;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromServer) &#123;</span><br><span class="line">                mNumVisibleActivities--;</span><br><span class="line">            &#125;</span><br><span class="line">            IBinder wtoken = v.getWindowToken();</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mWindowAdded) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                    ... <span class="comment">// window还未显示出来，pending remove</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wm.removeViewImmediate(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityTaskManager.getService().activityDestroyed(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wm.removeViewImmediate(v);</code> 是下一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowManagerGlobal#removeView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">        View curView = mRoots.get(index).getView();</span><br><span class="line">        removeViewLocked(index, immediate);</span><br><span class="line">        <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    ViewRootImpl root = mRoots.get(index);</span><br><span class="line">    View view = root.getView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通知 InputManagerService</span></span><br><span class="line">        root.getImeFocusController().onWindowDismissed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> deferred = root.die(immediate);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.assignParent(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">            mDyingViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步是 ViewRootImpl.die(boolean)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">        doDie();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果不是 immediate 加入到消息循环中</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoved) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRemoved = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAdded) &#123;</span><br><span class="line">            dispatchDetachedFromWindow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 销毁 Surface</span></span><br><span class="line">                destroySurface();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAdded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    destroySurface();</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// binder调用移除window</span></span><br><span class="line">        mWindowSession.remove(mWindow);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Window的创建&quot;&gt;&lt;a href=&quot;#Window的创建&quot; class=&quot;headerlink&quot; title=&quot;Window的创建&quot;&gt;&lt;/a&gt;Window的创建&lt;/h2&gt;&lt;p&gt;一个 activity 对应的是 PhoneWindow 。 创建的时机是在 attach &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程的原理</title>
    <link href="http://yoursite.com/2022/07/17/Kotlin/%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2022/07/17/Kotlin/协程的原理/</id>
    <published>2022-07-17T05:30:18.000Z</published>
    <updated>2022-07-17T13:30:10.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="suspend-到底做了什么"><a href="#suspend-到底做了什么" class="headerlink" title="suspend 到底做了什么"></a>suspend 到底做了什么</h2><p>一个简单的协程调用<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">task</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">100</span>) <span class="comment">// 延时来模拟耗时任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">runTask</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">val</span> time = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> result = task()</span><br><span class="line">    println(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"getTask case <span class="subst">$&#123;time - System.currentTimeMillis()&#125;</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>这里runTask表示一个在协程环境调用一个耗时suspend方法并获取结果。<br>看一下 runTask() 方法反编译之后的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">runTask</span><span class="params">(@NotNull Continuation var1)</span> </span>&#123;</span><br><span class="line">    Object $continuation;</span><br><span class="line">    label20: &#123; <span class="comment">// 这边label可以理解为goto语句</span></span><br><span class="line">        <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> &lt;undefinedtype&gt;) &#123;</span><br><span class="line">            $continuation = (&lt;undefinedtype&gt;)var1;</span><br><span class="line">            <span class="keyword">if</span> ((((&lt;undefinedtype&gt;)$continuation).label &amp; Integer.MIN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ((&lt;undefinedtype&gt;)$continuation).label -= Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">break</span> label20;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $continuation = <span class="keyword">new</span> ContinuationImpl(var1) &#123;</span><br><span class="line">            <span class="comment">// $FF: synthetic field</span></span><br><span class="line">            Object result;</span><br><span class="line">            <span class="keyword">int</span> label;</span><br><span class="line">            <span class="keyword">long</span> J$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">invokeSuspend</span><span class="params">(@NotNull Object $result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.result = $result;</span><br><span class="line">                <span class="keyword">this</span>.label |= Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">return</span> ContinueTest.<span class="keyword">this</span>.runTask(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object $result = ((&lt;undefinedtype&gt;)$continuation).result;</span><br><span class="line">    Object var8 = IntrinsicsKt.getCOROUTINE_SUSPENDED();</span><br><span class="line">    Object var10000;</span><br><span class="line">    <span class="keyword">long</span> time;</span><br><span class="line">    <span class="keyword">switch</span>(((&lt;undefinedtype&gt;)$continuation).label) &#123; <span class="comment">// 状态机的状态值</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        ResultKt.throwOnFailure($result);</span><br><span class="line">        time = System.currentTimeMillis();</span><br><span class="line">        ((&lt;undefinedtype&gt;)$continuation).J$<span class="number">0</span> = time;</span><br><span class="line">        ((&lt;undefinedtype&gt;)$continuation).label = <span class="number">1</span>;</span><br><span class="line">        var10000 = <span class="keyword">this</span>.task((Continuation)$continuation);</span><br><span class="line">        <span class="keyword">if</span> (var10000 == var8) &#123;</span><br><span class="line">            <span class="comment">// 进入挂起状态，结束</span></span><br><span class="line">            <span class="keyword">return</span> var8;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        time = ((&lt;undefinedtype&gt;)$continuation).J$<span class="number">0</span>;</span><br><span class="line">        ResultKt.throwOnFailure($result);</span><br><span class="line">        var10000 = $result;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"call to 'resume' before 'invoke' with coroutine"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String result = (String)var10000;</span><br><span class="line">    <span class="keyword">boolean</span> var5 = <span class="keyword">false</span>;</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"getTask cost "</span> + (time - System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个关注点：</p><ul><li>suspend 增加了一个 <code>@NotNull Continuation var1</code> 参数， Continuation 意思是 <code>继续 再开始</code> , 可以理解为一个状态机实现的callback</li><li><code>switch(((&lt;undefinedtype&gt;)$continuation).label)</code><br>switch语句里的 continuation.label 即是状态机的状态值。<br>case 0 是执行suspend之前的代码，case 1 代表执行suspend之后的代码。 对应调用了几次suspend挂起方法，就会生成对应的case<br>在<code>case 0</code>有一个判断<br> <code>if (var10000 == var8</code><br> 可以转化为<br> <code>if (var10000 == COROUTINE_SUSPENDED)</code><br>这个判断被调用的task()是不是挂起的，因为里面做了delay，所以肯定为true, 直接return，告诉调用自己的上层自己也是挂起状态。</li></ul><p>现在，runTask() 和 task() 都是挂起的，该如何从挂起状态恢复呢？ </p><h3 id="挂起的恢复"><a href="#挂起的恢复" class="headerlink" title="挂起的恢复"></a>挂起的恢复</h3><p>在上面反编译的代码里面，有一个很明显的<code>label20:</code> 标记，这里我理解就是一个goto语句，里面首先有一个if判断，这个不知道是什么，不管它。。。然后后面有一个new实例化<code>$continuation = new ContinuationImpl(var1)</code> var1是suspend方法的Continuation入参，ContinuationImpl 继承自 BaseContinuationImpl , 我们来分析一下这个 BaseContinuationImpl 的源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: kotlin.coroutines.CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">kotlin</span>.<span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span>: kotlin.<span class="built_in">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseContinuationImpl</span></span>(</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> param = result</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            with(current) &#123; <span class="comment">// this -&gt;</span></span><br><span class="line">            <span class="comment">// ... 这个with语句，里面的变量有些是current的成员变量，注意区分...</span></span><br><span class="line">            <span class="comment">// ... kotlin //的垃圾语法糖啊</span></span><br><span class="line">                <span class="keyword">val</span> completion = completion!!</span><br><span class="line">                <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">val</span> outcome = invokeSuspend(param) <span class="comment">// current.invokeCurrent(param)</span></span><br><span class="line">                        <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                        Result.success(outcome)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                        Result.failure(exception)</span><br><span class="line">                    &#125;</span><br><span class="line">                releaseIntercepted()</span><br><span class="line">                <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123;</span><br><span class="line">                    current = completion</span><br><span class="line">                    param = outcome</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    completion.resumeWith(outcome)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseContinuationImpl 实现了 Continuation 接口，resumeWith 在 耗时挂起执行完了之后会被调用。<br>在前面反编译的代码中创建了匿名内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$continuation = <span class="keyword">new</span> ContinuationImpl(var1) &#123;</span><br><span class="line">      Object result;</span><br><span class="line">      <span class="keyword">int</span> label;</span><br><span class="line">      <span class="keyword">long</span> J$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Nullable</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">invokeSuspend</span><span class="params">(@NotNull Object $result)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.result = $result;</span><br><span class="line">          <span class="keyword">this</span>.label |= Integer.MIN_VALUE;</span><br><span class="line">          <span class="keyword">return</span> ContinueTest.<span class="keyword">this</span>.runTask(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>continuation 的初始 label 值是0，在switch语句里，执行完suspend之前的代码后，label会设为1， 当调用完suspend方法后， BaseContinuationImpl#resumeWith 会调用 invokeSuspend 方法递归调用suspend方法 runTask() 。 如果 suspend 方法还是 挂起的，那么直接return。否则递归不断向上resume</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;suspend-到底做了什么&quot;&gt;&lt;a href=&quot;#suspend-到底做了什么&quot; class=&quot;headerlink&quot; title=&quot;suspend 到底做了什么&quot;&gt;&lt;/a&gt;suspend 到底做了什么&lt;/h2&gt;&lt;p&gt;一个简单的协程调用&lt;br&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    delay(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 延时来模拟耗时任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;runTask&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: String &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; time = System.currentTimeMillis()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; result = task()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println(result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;getTask case &lt;span class=&quot;subst&quot;&gt;$&amp;#123;time - System.currentTimeMillis()&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mmkv原理</title>
    <link href="http://yoursite.com/2022/07/10/Android/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/mmkv%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2022/07/10/Android/源码解析/mmkv原理/</id>
    <published>2022-07-10T09:03:32.000Z</published>
    <updated>2022-07-10T11:36:49.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SharedPreferences的痛点"><a href="#SharedPreferences的痛点" class="headerlink" title="SharedPreferences的痛点"></a>SharedPreferences的痛点</h2><h3 id="只能全量读取和写入"><a href="#只能全量读取和写入" class="headerlink" title="只能全量读取和写入"></a>只能全量读取和写入</h3><a id="more"></a><p>sp保存数据的文件形式是xml。每次读取都去读xml文件，解析后加入内存缓存里。每次写入都更改内存缓存的值，然后全量写入到文件里</p><h3 id="有anr的风险"><a href="#有anr的风险" class="headerlink" title="有anr的风险"></a>有anr的风险</h3><ul><li><p>在第一次载入时会产生anr<br>有一个加锁配合while循环，如果第一次使用xml文件还没有加载完成，就会pending。xml文件的全量读取本身就不快，如果xml文件过大，在首次使用时就可能会anr，在app启动过程中问题会比较明显。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key, <span class="keyword">boolean</span> defValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        Boolean v = (Boolean)mMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mLoaded) &#123;</span><br><span class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mThrowable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(mThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>commit写入导致anr<br>没啥说的，同步写入文件</p></li><li><p>apply写入导致anr<br>apply会异步写入，先写入到内存缓存，然后在子线程更新xml文件。<br>但是sp会将更新文件的问题加入到QueuedWork中。android的系统会在Activity的onStop,onPause等生命周期中，调用QueuedWork.waitToFinish，等待落盘的任务队列执行完成，如果任务队列中的任务很多，或者待写入的数据量很大时(sp文件是全量读写的)，在一些io性能差的中低端机型上就会很容易出现anr.</p></li></ul><p>具体可以参考这个文章：<a href="https://juejin.cn/post/6844904033820377096" target="_blank" rel="noopener">https://juejin.cn/post/6844904033820377096</a><br><a href="https://www.jianshu.com/p/9ae0f6842689" target="_blank" rel="noopener">https://www.jianshu.com/p/9ae0f6842689</a></p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。</p><ul><li>普通io文件操作的过程<br>Linux系统内存分为 内核空间 和 用户空间 。文件操作属于 内核空间。应用需要通过系统调用才能完成文件读取。<br>普通io操作需要先将文件拷贝到页缓存里(内核空间)，然后再从页缓存拷贝到用户空间。这需要两次拷贝。</li><li>mmap文件读写<br>mmap创建了 用户空间 到 内核空间 的映射，返回对应的指针；<br>读取文件时，文件还是一样拷贝到页缓存里(内核空间)。 因为创建了内存映射，用户空间能直接获取到文件数据。<br>写文件时，直接写入到指针地址对应的内核空间，Linux系统机制会保证内核空间到文件磁盘的写入，这样即使进程crash，也不会导致数据丢失</li></ul><h2 id="数据存储优化"><a href="#数据存储优化" class="headerlink" title="数据存储优化"></a>数据存储优化</h2><ul><li>数据组织<br>数据序列化方面我们选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。</li><li>写入优化<br>考虑到主要使用场景是频繁地进行写入更新，我们需要有增量更新的能力。我们考虑将增量 kv 对象序列化后，append 到内存末尾。<br>这样同一个 key 会有新旧若干份数据，最新的数据在最后。写入速度会很快<br>读取只需要从后往前读，读到第一个key匹配即使最新的有效数据。</li><li>空间增长<br>使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。我们需要在性能和空间上做个折中。<br>以内存 pagesize(内存页大小) 为单位申请空间，在空间用尽之前都是 append 模式；当 append 到文件末尾时，进行文件重整(去除重复key)、key 排重，尝试序列化保存排重结果；在程序启动第一次打开 mmkv 时，也会进行文件重整。<br>排重后空间还是不够用的话，将文件扩大一倍，直到空间足够。</li></ul><h2 id="多进程读写支持"><a href="#多进程读写支持" class="headerlink" title="多进程读写支持"></a>多进程读写支持</h2><p>在mmap的时候，只会返回映射内存的指针。在append和重整时可以加文件锁，保证自己的写文件成功。但是一个进程并不知道自己文件的数据是否被其他进程修改过。</p><ul><li>写指针的同步<br>因为mmkv的写入是直接append在数据末尾，mmap导致数据的大小和文件的大小并不一直，所以需要一个指针指向有效数据的末尾，称之为写指针。<br>mmkv 在每个进程内部缓存自己的写指针，然后在写入键值的同时，还要把最新的写指针位置也写到 mmap 内存中；这样每个进程只需要对比一下缓存的指针与 mmap 内存的写指针，如果不一样，就说明其他进程进行了写操作。<br>事实上 MMKV 原本就在文件头部保存了有效内存的大小，这个数值刚好就是写指针的内存偏移量，可以重用这个数值来校对写指针。</li><li>内存重整的感知<br>使用一个单调递增的序列号，每次发生内存重整，就将序列号递增。将这个序列号也放到 mmap 内存中，每个进程内部也缓存一份，只需要对比序列号是否一致，就能够知道其他进程是否触发了内存重整。</li><li>内存增长的感知<br>事实上 MMKV 在内存增长之前，会先尝试通过内存重整来腾出空间，重整后还不够空间才申请新的内存。所以内存增长可以跟内存重整一样处理。至于新的内存大小，可以通过查询文件大小来获得，无需在 mmap 内存另外存放。</li></ul><p>可以参考文档 <a href="https://cloud.tencent.com/developer/article/1354199" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1354199</a></p><h2 id="mmkv的不足"><a href="#mmkv的不足" class="headerlink" title="mmkv的不足"></a>mmkv的不足</h2><p>主要是mmap的缺点，需要提前确定好文件的大小，即 映射内存的大小。但是，映射内存的大小并不是有效数据的大小。 映射内存只是提供了一个快捷操作文件的场地。 会造成存储空间的浪费，并且映射内存的大小必须是页缓存(pagesize)的整数倍</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SharedPreferences的痛点&quot;&gt;&lt;a href=&quot;#SharedPreferences的痛点&quot; class=&quot;headerlink&quot; title=&quot;SharedPreferences的痛点&quot;&gt;&lt;/a&gt;SharedPreferences的痛点&lt;/h2&gt;&lt;h3 id=&quot;只能全量读取和写入&quot;&gt;&lt;a href=&quot;#只能全量读取和写入&quot; class=&quot;headerlink&quot; title=&quot;只能全量读取和写入&quot;&gt;&lt;/a&gt;只能全量读取和写入&lt;/h3&gt;
    
    </summary>
    
    
      <category term="源码解析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="glide" scheme="http://yoursite.com/tags/glide/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit源码解析</title>
    <link href="http://yoursite.com/2022/06/12/Android/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Retrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2022/06/12/Android/源码解析/Retrofit源码解析/</id>
    <published>2022-06-12T10:21:16.000Z</published>
    <updated>2022-07-05T05:30:08.364Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetrofitService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"query"</span>)</span><br><span class="line">    <span class="function">Observable&lt;PostInfo&gt; <span class="title">getPostInfoRx</span><span class="params">(@Query(<span class="string">"type"</span>)</span> String type, @<span class="title">Query</span><span class="params">(<span class="string">"postid"</span>)</span> String postid)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"http://www.kuaidi100.com/"</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class="comment">// 支持RxJava</span></span><br><span class="line">        .build();</span><br><span class="line">        </span><br><span class="line">RetrofitService service = retrofit.create(XxxInterface.class);</span><br><span class="line">Call&lt;PostInfo&gt; call = service.getPostInfo(<span class="string">"yuantong"</span>, <span class="string">"11111111111"</span>);</span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;PostInfo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;PostInfo&gt; call, Response&lt;PostInfo&gt; response)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"http返回："</span>, response.body().toString() + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;PostInfo&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面是 Retrofit 的主要用法，主要重要的东西有 ConverterFactory , CallAdapterFactory , retrofit.create(XxxInterface.class) 三个东西</p><h2 id="Retrofit-Builder"><a href="#Retrofit-Builder" class="headerlink" title="Retrofit.Builder()"></a>Retrofit.Builder()</h2><p>builder就是一个常见的建造者模式，没什么好说的。 有一个点需要注意一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">   <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">     callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">   <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 默认callback回调是执行在主线程的</span></span><br><span class="line">     callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">   callAdapterFactories.addAll(platform.defaultCallAdapterFactories(callbackExecutor));</span><br><span class="line"></span><br><span class="line">   List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">       <span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size() + platform.defaultConverterFactoriesSize());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">   <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">   converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">   converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">   converterFactories.addAll(platform.defaultConverterFactories());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">       unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == ResponseBody.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> Utils.isAnnotationPresent(annotations, Streaming.class)</span><br><span class="line">            ? StreamingResponseBodyConverter.INSTANCE</span><br><span class="line">            : BufferingResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == Void.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先插入了一个 BuiltInConverters 内置的转换器。 当返回类型是 ResponseBody 的时候就会使用 BuiltInConverters ，返回 ResponseBody 就和 okhttp 的返回一致了。</p><h2 id="retrofit-create-XxxInterface-class"><a href="#retrofit-create-XxxInterface-class" class="headerlink" title="retrofit.create(XxxInterface.class)"></a>retrofit.create(XxxInterface.class)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">return</span> loadServiceMethod(method).invoke(args != <span class="keyword">null</span> ? args : emptyArgs);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了动态代理，create方法返回的接口对象是一个动态代理的实例</p><h2 id="loadServiceMethod"><a href="#loadServiceMethod" class="headerlink" title="loadServiceMethod"></a>loadServiceMethod</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod&lt;?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">  ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      result = ServiceMethod.parseAnnotations(<span class="keyword">this</span>, method);</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存 + 解析Method</p><h2 id="ServiceMethod-parseAnnotations"><a href="#ServiceMethod-parseAnnotations" class="headerlink" title="ServiceMethod.parseAnnotations"></a>ServiceMethod.parseAnnotations</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceMethod</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">    RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, method);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">T <span class="title">invoke</span><span class="params">(Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在抽象父类里先调用了 <code>RequestFactory.parseAnnotations(retrofit, method);</code> 去解析方法参数的注解。<br><code>HttpServiceMethod.parseAnnotations(retrofit, method, requestFactory);</code> 里解析了返回类型，并匹配 CallAdapter 和 Converter<br>。。。抽象父类的静态方法区调用了子类的静态方法。。。有些迷惑</p><h2 id="HttpServiceMethod-parseAnnotations"><a href="#HttpServiceMethod-parseAnnotations" class="headerlink" title="HttpServiceMethod.parseAnnotations"></a>HttpServiceMethod.parseAnnotations</h2><p>RequestFactory.parseAnnotations 都是一些注解的处理，不说了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;ResponseT, ReturnT&gt; <span class="function">HttpServiceMethod&lt;ResponseT, ReturnT&gt; <span class="title">parseAnnotations</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Retrofit retrofit, Method method, RequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isKotlinSuspendFunction = requestFactory.isKotlinSuspendFunction;</span><br><span class="line">    <span class="keyword">boolean</span> continuationWantsResponse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> continuationBodyNullable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    Type adapterType;</span><br><span class="line">    <span class="keyword">if</span> (isKotlinSuspendFunction) &#123;</span><br><span class="line">    <span class="comment">// 是协程suspend方法调用</span></span><br><span class="line">    <span class="comment">// kotli的suspend方法转成java之后会在方法参数上生成一个Continuation类型的参数</span></span><br><span class="line">      Type[] parameterTypes = method.getGenericParameterTypes(); <span class="comment">// 获取方法的所有参数类型</span></span><br><span class="line">      Type responseType = Utils.getParameterLowerBound(<span class="number">0</span>,</span><br><span class="line">          (ParameterizedType) parameterTypes[parameterTypes.length - <span class="number">1</span>]); <span class="comment">// 获取最后一个 Continuation 类型参数的泛型</span></span><br><span class="line">      <span class="keyword">if</span> (getRawType(responseType) == Response.class &amp;&amp; responseType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="comment">// Unwrap the actual body type from Response&lt;T&gt;.</span></span><br><span class="line">        <span class="comment">// 获取 Response&lt;T&gt; 中泛型T的类型</span></span><br><span class="line">        responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) responseType);</span><br><span class="line">        continuationWantsResponse = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里把suspend方法的返回类型的 AdapterType 当做 Call&lt;T&gt; 来处理了</span></span><br><span class="line">      adapterType = <span class="keyword">new</span> Utils.ParameterizedTypeImpl(<span class="keyword">null</span>, Call.class, responseType);</span><br><span class="line">      annotations = SkipCallbackExecutorImpl.ensurePresent(annotations);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是非suspend方法，那直接取返回类型就可以了</span></span><br><span class="line">      adapterType = method.getGenericReturnType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找合适的 CallAdapterFactory 生产 CallAdapter</span></span><br><span class="line">    CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =</span><br><span class="line">        createCallAdapter(retrofit, method, adapterType, annotations);</span><br><span class="line">    Type responseType = callAdapter.responseType();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找合适的 ConverterFactory 生产 Converter</span></span><br><span class="line">    Converter&lt;ResponseBody, ResponseT&gt; responseConverter =</span><br><span class="line">        createResponseConverter(retrofit, method, responseType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CallFactory 实质上就是 OkHttpClient</span></span><br><span class="line">    okhttp3.Call.Factory callFactory = retrofit.callFactory; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是返回 HttpServiceMethod 的子类，这三个子类其实就是 CallAdapted wrap 了一层。 SuspendForResponse 和 SuspendForBody 调用了协程的 await 方法去等待协程的完成（其实就是加了个Continuation的回调）</span></span><br><span class="line">    <span class="keyword">if</span> (!isKotlinSuspendFunction) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CallAdapted&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (continuationWantsResponse) &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">      <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForResponse&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//noinspection unchecked Kotlin compiler guarantees ReturnT to be Object.</span></span><br><span class="line">      <span class="keyword">return</span> (HttpServiceMethod&lt;ResponseT, ReturnT&gt;) <span class="keyword">new</span> SuspendForBody&lt;&gt;(requestFactory,</span><br><span class="line">          callFactory, responseConverter, (CallAdapter&lt;ResponseT, Call&lt;ResponseT&gt;&gt;) callAdapter,</span><br><span class="line">          continuationBodyNullable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="ServiceMethod-invode"><a href="#ServiceMethod-invode" class="headerlink" title="ServiceMethod.invode"></a>ServiceMethod.invode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">HttpServiceMethod</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">invoke</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    Call&lt;ResponseT&gt; call = <span class="keyword">new</span> OkHttpCall&lt;&gt;(requestFactory, args, callFactory, responseConverter);</span><br><span class="line">    <span class="keyword">return</span> adapt(call, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> <span class="function">ReturnT <span class="title">adapt</span><span class="params">(Call&lt;ResponseT&gt; call, Object[] args)</span></span>;</span><br></pre></td></tr></table></figure><p>OkHttpCall 实现了 Retrofit 的 call 到 OkHttpCall 的转换<br>adapt 最终会调用 CallAdapter 的 adapt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">   okhttp3.Call call;</span><br><span class="line">   Throwable failure;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">     executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     call = rawCall;</span><br><span class="line">     failure = creationFailure;</span><br><span class="line">     <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 懒加载 rawCall</span></span><br><span class="line">         <span class="comment">// 传入真实请求参数，构建真正发起请求的 okhttp 的 Call 对象</span></span><br><span class="line">         call = rawCall = createRawCall();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">     <span class="meta">@Override</span> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">       Response&lt;T&gt; response;</span><br><span class="line">       <span class="comment">// 调用 Converter 解析返回类型</span></span><br><span class="line">       response = parseResponse(rawResponse);</span><br><span class="line">       callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">       callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看一下默认的 DefaultCallAdapterFactory 是怎么实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">DefaultCallAdapterFactory</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(</span><br><span class="line">      Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取 Call&lt;T&gt; 的具体类型</span></span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有 SkipCallbackExecutor 这个注解，一般是没有的</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor = Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)</span><br><span class="line">        ? <span class="keyword">null</span></span><br><span class="line">        : callbackExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor == <span class="keyword">null</span></span><br><span class="line">            ? call</span><br><span class="line">            : <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(executor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">  <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delegate.execute();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>enqueue 里的返回 onResponse 和 onFailure 都是在 callbackExecutor<br>callbackExecutor 也是在 retrofit 构建时传入的， 默认是 <code>Android.MainThreadExecutor</code> 也就是说默认 enqueue 的 callback 默认是执行在主线程的</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RetrofitService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GET&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;query&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Observable&amp;lt;PostInfo&amp;gt; &lt;span class=&quot;title&quot;&gt;getPostInfoRx&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(@Query(&lt;span class=&quot;string&quot;&gt;&quot;type&quot;&lt;/span&gt;)&lt;/span&gt; String type, @&lt;span class=&quot;title&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;postid&quot;&lt;/span&gt;)&lt;/span&gt; String postid)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Retrofit retrofit = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Retrofit.Builder()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .baseUrl(&lt;span class=&quot;string&quot;&gt;&quot;http://www.kuaidi100.com/&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .addConverterFactory(GsonConverterFactory.create())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) &lt;span class=&quot;comment&quot;&gt;// 支持RxJava&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RetrofitService service = retrofit.create(XxxInterface.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Call&amp;lt;PostInfo&amp;gt; call = service.getPostInfo(&lt;span class=&quot;string&quot;&gt;&quot;yuantong&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;11111111111&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;call.enqueue(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Callback&amp;lt;PostInfo&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onResponse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Call&amp;lt;PostInfo&amp;gt; call, Response&amp;lt;PostInfo&amp;gt; response)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Log.i(&lt;span class=&quot;string&quot;&gt;&quot;http返回：&quot;&lt;/span&gt;, response.body().toString() + &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onFailure&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Call&amp;lt;PostInfo&amp;gt; call, Throwable t)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RequestLayout和Invalidate</title>
    <link href="http://yoursite.com/2022/05/02/Android/Framework/RequestLayout%E5%92%8CInvalidate/"/>
    <id>http://yoursite.com/2022/05/02/Android/Framework/RequestLayout和Invalidate/</id>
    <published>2022-05-02T08:48:49.000Z</published>
    <updated>2022-08-17T08:34:43.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RequestLayout"><a href="#RequestLayout" class="headerlink" title="RequestLayout"></a>RequestLayout</h1><h2 id="标记自身"><a href="#标记自身" class="headerlink" title="标记自身"></a>标记自身</h2><p>给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。<br>并将RequestLayout向上传递。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从源码注释可以看出，如果当前View在请求布局的时候，View树正在进行布局流程的话，</span></span><br><span class="line"><span class="comment">//该请求会延迟到布局流程完成后或者绘制流程完成且下一次布局发现的时候再执行。</span></span><br><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果处于 Layout 则将该请求加入 ViewRootImpl 中的任务队列中</span></span><br><span class="line">        ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">        <span class="keyword">if</span> (viewRoot != <span class="keyword">null</span> &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!viewRoot.requestLayoutDuringLayout(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为当前view设置标记位 PFLAG_FORCE_LAYOUT</span></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        <span class="comment">//向父容器请求布局</span></span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 requestLayout() 的view会给自己添加标记位 <code>PFLAG_FORCE_LAYOUT</code> , <code>PFLAG_INVALIDATED</code><br>并一直parent向上递归，这个view所有的祖先都会设置上标记位</p><h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><p>会顺着view树，一路向上标记，最终到达 ViewRootImpl<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals(); <span class="comment">// 开启measure、layout、draw三步走</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> scheduleTraversals() 开启绘制三步走流程。 在measure、layout、draw过程中都会判断标志位，只有需要的时候才执行</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">            widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">            <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> measure时判断了 PFLAG_FORCE_LAYOUT ，或者 measureSpec 发生了改变。 并不是所有的view都会重新measure 。在一个view调用 requestLayout 时，这个view和它的所有祖先一定会重新measure，其他view按需要判断是否重新measure。</p><p>在 <code>mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</code> 中也给layout过程做了标记</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">                setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">    <span class="comment">//判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        <span class="comment">//onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后清除PFLAG_FORCE_LAYOUT标记位</span></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remember our drawn bit</span></span><br><span class="line">            <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">            <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">            <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">            <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">            <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            ...</span><br><span class="line">            mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line">            mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">                sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> changed;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> layout时判断了PFLAG_LAYOUT_REQUIRED标记，需要时才做。<br> changed 获取有一个 <code>setFrame(...)</code> 方法，里面会判断view的layout是否改变，如果改变了，会调用 <code>invalidate()</code> 进行重新draw</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 调用 View.requestLayout 方法后会依次调用 performMeasure, performLayout 和 performDraw 方法，调用者 View 及其父 View 会重新从上往下进行 measure, layout 流程，如果view顶点没有改变，不会执行 draw 流程</p><h1 id="Invalidate"><a href="#Invalidate" class="headerlink" title="Invalidate"></a>Invalidate</h1><h2 id="标记自身-1"><a href="#标记自身-1" class="headerlink" title="标记自身"></a>标记自身</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">            || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">            || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">            || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置PFLAG_DIRTY标记位</span></span><br><span class="line">        mPrivateFlags |= PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate the damage rectangle to the parent view.</span></span><br><span class="line">        <span class="comment">//把需要重绘的区域传递给父容器</span></span><br><span class="line">        <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">        <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">            <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">            damage.set(l, t, r, b);</span><br><span class="line">            <span class="comment">//调用父容器的方法，向上传递事件</span></span><br><span class="line">            p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewGroup处理并向上传递"><a href="#ViewGroup处理并向上传递" class="headerlink" title="ViewGroup处理并向上传递"></a>ViewGroup处理并向上传递</h2> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Don't call or override this method. It is used for the implementation of</span></span><br><span class="line"><span class="comment"> * the view hierarchy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 parent 等于自身</span></span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (child.mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">            mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// 循环向上遍历祖先view</span></span><br><span class="line">            View view = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                view = (View) parent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((view.mViewFlags &amp; FADING_EDGE_MASK) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        view.getSolidColor() == <span class="number">0</span>) &#123;</span><br><span class="line">                    opaqueFlag = PFLAG_DIRTY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123;</span><br><span class="line">                    <span class="comment">//对当前View的标记位进行设置</span></span><br><span class="line">                    view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用ViewGrup的invalidateChildInParent，如果已经达到最顶层view,则调用ViewRootImpl的invalidateChildInParent。</span></span><br><span class="line">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span>[] location, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN ||</span><br><span class="line">            (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) !=</span><br><span class="line">                    FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响</span></span><br><span class="line">            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,</span><br><span class="line">                    location[CHILD_TOP_INDEX] - mScrollY);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//求并集，结果是把子视图的dirty区域转化为父容器的dirty区域</span></span><br><span class="line">                dirty.union(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = mLeft;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = mTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!dirty.intersect(<span class="number">0</span>, <span class="number">0</span>, mRight - left, mBottom - top)) &#123;</span><br><span class="line">                    dirty.setEmpty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录当前视图的mLeft和mTop值，在下一次循环中会把当前值再向父容器的坐标转化</span></span><br><span class="line">            location[CHILD_LEFT_INDEX] = left;</span><br><span class="line">            location[CHILD_TOP_INDEX] = top;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mLayerType != LAYER_TYPE_NONE) &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回当前视图的父容器</span></span><br><span class="line">            <span class="keyword">return</span> mParent;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ViewRootImpl-1"><a href="#ViewRootImpl-1" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewParent <span class="title">invalidateChildInParent</span><span class="params">(<span class="keyword">int</span>[] location, Rect dirty)</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    ...</span><br><span class="line">    invalidateRectOnScreen(dirty);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidateRectOnScreen</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用硬件加速渲染</span></span><br><span class="line">    <span class="comment">// 2. 使用软件加速渲染</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if drawing was successful, false if an error occurred</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw with software renderer.</span></span><br><span class="line">        <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">            canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">            <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">            <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                    || bottom != dirty.bottom) &#123;</span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Do this in native</span></span><br><span class="line">            canvas.setDensity(mDensity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 伪代码</span></span><br><span class="line">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里只有软件绘制的代码。<br>网上有人说invalidate只会重绘脏区域，但是这里只看到用dirty做了一个 <code>canvas = mSurface.lockCanvas(dirty);</code> 。还不是很懂局部重绘是怎么做到的。。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RequestLayout&quot;&gt;&lt;a href=&quot;#RequestLayout&quot; class=&quot;headerlink&quot; title=&quot;RequestLayout&quot;&gt;&lt;/a&gt;RequestLayout&lt;/h1&gt;&lt;h2 id=&quot;标记自身&quot;&gt;&lt;a href=&quot;#标记自身&quot; class=&quot;headerlink&quot; title=&quot;标记自身&quot;&gt;&lt;/a&gt;标记自身&lt;/h2&gt;&lt;p&gt;给当前View添加上 PFLAG_FORCE_LAYOUT 和 PFLAG_INVALIDATED 标记。&lt;br&gt;并将RequestLayout向上传递。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>协程上下文和异常传播</title>
    <link href="http://yoursite.com/2022/04/11/Kotlin/%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD/"/>
    <id>http://yoursite.com/2022/04/11/Kotlin/协程上下文和异常传播/</id>
    <published>2022-04-11T15:50:53.000Z</published>
    <updated>2022-04-11T16:56:12.838Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7068901166456766472#heading-6" target="_blank" rel="noopener">https://juejin.cn/post/7068901166456766472#heading-6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7068901166456766472#heading-6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.cn/post/7068901166456766472#
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>jvm虚拟机</title>
    <link href="http://yoursite.com/2022/04/07/Java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://yoursite.com/2022/04/07/Java/jvm虚拟机/</id>
    <published>2022-04-07T15:10:00.000Z</published>
    <updated>2022-04-07T16:57:54.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM架构"><a href="#JVM架构" class="headerlink" title="JVM架构"></a>JVM架构</h2><p>jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈</p><a id="more"></a><ol><li><p>方法区<br>方法区被所有线程共享。存放 类信息、类的字段信息和方法信息、常量、static类变量</p></li><li><p>Java栈<br>Java栈线程之间不共享。<br>Java栈是由很多的栈帧(stack frame)或者说帧(frame)组成的，一个栈帧包含一个Java方法调用状态。用来存放方法的局部变量、被调用时传进来的参数、返回值 以及运算的中间结果等等。</p></li><li><p>Native栈<br>用来存放Native方法的调用状态</p></li><li><p>堆<br>用于存放对象。 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。</p></li><li><p>程序计数器（PC寄存器）<br>每一个线程有一个程序计数器。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。</p></li><li><p>类加载子系统<br>读取class文件，加载Java类到内存。</p></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器负责动态加载Java类到Java虚拟机的内存空间中。</p><ul><li>双亲委托机制<br>“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类 路径中查找并装载目标类。这一点是从安全角度考虑的</li></ul><h2 id="GC垃圾回收机制"><a href="#GC垃圾回收机制" class="headerlink" title="GC垃圾回收机制"></a>GC垃圾回收机制</h2><h3 id="如何判断对象是否可以被回收"><a href="#如何判断对象是否可以被回收" class="headerlink" title="如何判断对象是否可以被回收"></a>如何判断对象是否可以被回收</h3><ul><li>引用计数法</li><li>根搜索算法：<ul><li>从GC root出发查找引用链，无法触及到的对象可以被回收。 </li><li>GC-root包括：虚拟机栈中引用的对象、类静态属性引用的对象、常量引用的对象</li></ul></li></ul><h3 id="强引用、弱引用、软引用、虚引用"><a href="#强引用、弱引用、软引用、虚引用" class="headerlink" title="强引用、弱引用、软引用、虚引用"></a>强引用、弱引用、软引用、虚引用</h3><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>jvm将对象分为三个区域， 新生代（Young Generation） 、 老年代（Old Generation） 和 持久代（Permanent Generation）。</p><ul><li>持久代：<ul><li>存放java类的类信息，存放静态文件，如final常量，static常量，常量池等。几乎不回收</li></ul></li><li>新生代：<ul><li>新生代使用拷贝算法：新生代中存在一个Eden区和两个Survivor区，其中一个Survivor始终为空。 eden区gc时，存活的对象会复制到其中一个survivor区。 Survivor区gc时，会拷贝到另一个空闲的Survivor区。 当对象多次gc存活一定次数之后，会移动到老年代</li><li>jvm中 eden区和Survivor区的大小为8：1</li></ul></li><li>老年代：<ul><li>使用标记整理算法。标记需要清除对象，将存活的对象往内存的一端移动，再将需要清除要回收的对象。这样的算法可以避免内存碎片的产生</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM架构&quot;&gt;&lt;a href=&quot;#JVM架构&quot; class=&quot;headerlink&quot; title=&quot;JVM架构&quot;&gt;&lt;/a&gt;JVM架构&lt;/h2&gt;&lt;p&gt;jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="http://yoursite.com/2022/04/04/Java/ConcurrentHashMap/"/>
    <id>http://yoursite.com/2022/04/04/Java/ConcurrentHashMap/</id>
    <published>2022-04-04T08:36:53.000Z</published>
    <updated>2022-04-05T09:43:51.079Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 </p><a id="more"></a><h2 id="1-8-之前"><a href="#1-8-之前" class="headerlink" title="1.8 之前"></a>1.8 之前</h2><p>将 table 数组划分为多个 segment ，对每一个 segment 单独加锁，不同的 segment 可以跨线程运算，提高并发效率。 </p><p>每一个segment有一个单独的table数组，类似1.7版本的 hashmap，table数组遇到哈希冲突后，同hash值的元素使用的数据结构是链表。</p><p>读是不需要加锁的，因为 segment 的 table 数组加了 volatile 修饰，HashEntry 的val和next字段也用 volatile 修饰。 一个线程改变了值，另一个线程能马上发现。</p><p>put的时候需要加锁，当put时，所在的segment还没有创建，会懒加载创建segment。实例化segment之后，会通过cas插入到segment数组中，保证线程安全。</p><p>下面是 1.8之前 ConcurrentHashMap 的 Segment 的 put 流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取锁，获取成功，node为null，代码向下执行</span></span><br><span class="line">    <span class="comment">//如果有其他线程占据锁对象，那么去做别的事情，而不是一直等待，提升效率</span></span><br><span class="line">    <span class="comment">// tryLock 通过cas获取锁</span></span><br><span class="line">    <span class="comment">//scanAndLockForPut 稍后分析</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//取hash的低位，计算HashEntry[]的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//获取索引位的元素对象</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="comment">//获取的元素对象不为空</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">//如果是重复元素，覆盖原值</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果不是重复元素，获取链表的下一个元素，继续循环遍历链表</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//如果获取到的元素为空</span></span><br><span class="line">                <span class="comment">//当前添加的键值对的HashEntry对象已经创建</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first); <span class="comment">//头插法关联即可</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//创建当前添加的键值对的HashEntry对象</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">//添加的元素数量递增</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//判断是否需要扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    <span class="comment">//需要扩容</span></span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//不需要扩容</span></span><br><span class="line">                    <span class="comment">//将当前添加的元素对象，存入数组角标位，完成头插法添加元素</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 四：Segment的scanAndLockForPut方法</span></span><br><span class="line"><span class="comment"> * 该方法在线程没有获取到锁的情况下，去完成HashEntry对象的创建，提升效率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取头部元素</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>；</span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        <span class="comment">//获取锁失败</span></span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//没有下一个节点，并且也不是重复元素，创建HashEntry对象，不再遍历</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                <span class="comment">//重复元素，不创建HashEntry对象，不再遍历</span></span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//继续遍历下一个节点</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            <span class="comment">//如果尝试获取锁的次数过多，直接加锁</span></span><br><span class="line">            <span class="comment">//MAX_SCAN_RETRIES会根据可用cpu核数来确定</span></span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            <span class="comment">//如果期间有别的线程获取锁，重新遍历</span></span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8-之后"><a href="#1-8-之后" class="headerlink" title="1.8 之后"></a>1.8 之后</h2><p>1.8之后ConcurrentHashMap改变了加锁策略，改为对哈希数组的每一个hash位置加锁；同时，将哈希冲突的链表替换为了和 HashMap 一样的红黑树。</p><h3 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h3><ul><li>为0，默认状态，代表数组未初始化， 且数组的初始容量为16</li><li>为-1，表示数组正在进行初始化</li><li>为正数，其记录的是数组的扩容阈值</li><li>小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操</li></ul><h3 id="put时如何保证线程安全"><a href="#put时如何保证线程安全" class="headerlink" title="put时如何保证线程安全"></a>put时如何保证线程安全</h3><ul><li>在put时对table哈希数组的每一个hash位置，如果为该位置为null，cas判断，然后在改位置添加元素；如果该位置不为null，则对该hash位置进行Synchronize加锁，将新元素加载链表or红黑树上。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果有空值或者空键，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//基于key计算hash值，并进行一定的扰动</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="comment">//记录某个桶上元素的个数，如果超过8个，会转成红黑树</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//如果数组还未初始化，先对数组进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">    <span class="comment">//如果hash计算得到的桶位置没有元素，利用cas将元素添加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//cas+自旋（和外侧的for构成自旋循环），保证元素添加安全</span></span><br><span class="line">            <span class="comment">//如果cas检测没过，下一次while循环就相当于在table的这个hash位置添加新元素</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果hash计算得到的桶位置元素的hash值为MOVED，证明正在扩容，那么协助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//hash计算的桶位置元素不为空，且当前没有处于扩容操作，进行元素添加</span></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对当前桶进行加锁，保证线程安全，执行元素添加操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 重复判断，方式加锁之前已经有其他线程做了修改</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">//普通链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//树节点，将元素添加到红黑树中</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//链表长度大于/等于8，将链表转成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">//如果是重复键，直接将旧值返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加的是新元素，维护集合长度，并判断是否要进行扩容操作</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化hash数组"><a href="#初始化hash数组" class="headerlink" title="初始化hash数组"></a>初始化hash数组</h3><ul><li>在初始化哈希数组的时候，会cas+自旋保证线程安全</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化底层数组 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//cas+自旋，保证线程安全，对数组进行初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果sizeCtl的值（-1）小于0，说明此时正在初始化， 让出cpu</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//cas修改sizeCtl的值为-1，修改成功，进行数组初始化，失败，继续自旋</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果另一个线程已经初始化了数组，则不会走到这里。 会直接break</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//sizeCtl为0，取默认长度16，否则去sizeCtl的值</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">//基于初始长度，构建数组对象</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//计算扩容阈值，并赋值给sc</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将扩容阈值，赋值给sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>ConcurrentHashMap 的扩容在transfer方法中；<br>需要注意的是，ConcurrentHashMap 有一个多线程协助扩容的机制。</p><ul><li>当一个线程在扩容的时候，在移动hash数组的元素到新数组的时候，会确定自己的开始位置 和 一个stride容量，hash数组stride内的元素自己负责扩容拷贝；然后确定一个 transferIndex 作为下次拷贝的起点。 同时在原数组的hash位置放置一个 ForwardingNode 。 </li><li>当有新的线程想要在这个hash位置插入元素时，发现这里有一个 ForwardingNode ，会协助一起扩容，帮助将原数组的元素迁移到新数组。 以 transferIndex 作为起点，stride容量内的元素自己负责协助拷贝</li><li>对于线程安全，在扩容拷贝的时候，会对hash数组要拷贝的位置进行 synchronized 加锁。在计算 transferIndex 的会使用 cas+自旋 机制保证线程安全。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//如果是多cpu，那么每个线程划分任务，最小任务量是16个桶位的迁移</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="comment">//如果是扩容线程，此时新数组为null</span></span><br><span class="line">    <span class="comment">//如果是帮助扩容的线程，此时nextTab不为null</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            <span class="comment">//两倍扩容创建新数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">//记录线程开始迁移的桶位，从后往前迁移，指向最右边</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录新数组的末尾</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//已经迁移的桶位，会用这个节点占位（这个节点的hash值为-1--MOVED）</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="comment">// advance：代表是否可以继续推进下一个槽位，只有当前槽位数据被迁移完成之后才可以设置为 true</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">//i记录当前正在迁移桶位的索引值</span></span><br><span class="line">            <span class="comment">//bound记录下一次任务迁移的开始桶位</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//--i &gt;= bound 成立表示当前线程分配的迁移任务还没有完成</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//没有元素需要迁移 -- 后续会去将扩容线程数减1，并判断扩容是否完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算下一次任务迁移的开始桶位，并将这个值赋值给transferIndex</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有更多的需要迁移的桶位，就进入该if</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">//扩容结束后，保存新数组，并重新计算扩容阈值，赋值给sizeCtl</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//扩容任务线程数减1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//判断当前所有扩容任务线程是否都执行完成</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//所有扩容线程都执行完，标识结束</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前迁移的桶位没有元素，直接在该位置添加一个fwd节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">//当前节点已经被迁移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前节点需要迁移，加锁迁移，保证多线程安全</span></span><br><span class="line">            <span class="comment">//此处迁移逻辑和jdk7的ConcurrentHashMap相同，不再赘述</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    ... <span class="comment">// 省略代码，和 HashMap 的扩容拷贝基本一致</span></span><br><span class="line">                    advance = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap" target="_blank" rel="noopener">https://mvbbb.cn/concurrenthashmap-deepunderstanding/#jdk8-%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84-concurrenthashmap</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ConcurrentHashMap 可以实现线程安全。在1.8之前和之后实现线程安全的方法不同。 &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://yoursite.com/2022/04/04/Java/HashMap/"/>
    <id>http://yoursite.com/2022/04/04/Java/HashMap/</id>
    <published>2022-04-04T06:23:14.000Z</published>
    <updated>2022-04-04T08:39:37.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本数据结构"><a href="#1-基本数据结构" class="headerlink" title="1. 基本数据结构"></a>1. 基本数据结构</h2><p>Node&lt;K, V&gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。<br>如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小<br>如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树</p><a id="more"></a><h2 id="2-加入的元素如何确定在数组中的-index"><a href="#2-加入的元素如何确定在数组中的-index" class="headerlink" title="2. 加入的元素如何确定在数组中的 index"></a>2. 加入的元素如何确定在数组中的 index</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把新加入的元素均匀分布到数组中，我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的. 但是jdk通过h &amp; (table.length -1)来得到该对象的保存位，这样运算会加快。</p><h2 id="3-如何扩容"><a href="#3-如何扩容" class="headerlink" title="3. 如何扩容"></a>3. 如何扩容</h2><p>将数组的容量扩大为原来的两倍，原数组长度为oldCap，下标j的元素会被分散到 数组j 和 j+oldCap 的位置。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">table = newTab;</span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 数组下表位置如果是 红黑树，逻辑和下面的链表差不多</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">            <span class="comment">// 数组下表位置如果是 链表</span></span><br><span class="line">                Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                Node&lt;K,V&gt; next;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    next = e.next;</span><br><span class="line">                    <span class="comment">// 因为 oldCap 始终为2的倍数。 (e.hash &amp; oldCap) 只会有0或1两个值，由此决定是位置 j 还是 j+oldCap</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                            loHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            loTail.next = e;</span><br><span class="line">                        loTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                            hiHead = e;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            hiTail.next = e;</span><br><span class="line">                        hiTail = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j] = loHead;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                    newTab[j + oldCap] = hiHead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-扩容的时机"><a href="#4-扩容的时机" class="headerlink" title="4. 扩容的时机"></a>4. 扩容的时机</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure><p>当size大于一个阈值的时候，就会开始扩容。 <code>threshold = length * loadFactor</code> 是数组长度*负载因子。 负载因子默认是0.75 ，注意这个length是table数组的长度而不是HashMap的整体size（为了保证获取元素的时间复杂度接近1）。</p><p>loadFactor 是时间复杂度和空间复杂度的权衡。 如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><h2 id="5-HashMap是线程不安全的。HashTable是线程安全的。"><a href="#5-HashMap是线程不安全的。HashTable是线程安全的。" class="headerlink" title="5. HashMap是线程不安全的。HashTable是线程安全的。"></a>5. HashMap是线程不安全的。HashTable是线程安全的。</h2><p>HashTable的线程安全很粗暴，将所有的map操作加一个synchronized修饰。</p><p>参考：<br><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-基本数据结构&quot;&gt;&lt;a href=&quot;#1-基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. 基本数据结构&quot;&gt;&lt;/a&gt;1. 基本数据结构&lt;/h2&gt;&lt;p&gt;Node&amp;lt;K, V&amp;gt; 的一个table数组，容量始终为2的幂，Node代表一个entry。在put一个元素时，懒加载分配数组空间。&lt;br&gt;如果实例化HashMap的时候传入一个 initialCapacity ，table的大小会给一个最接近的2的幂的大小&lt;br&gt;如果遇到hash冲突，会变为一个链表或红黑树，数组中的node作为链表or红黑树的头节点，新加入的节点插入到链表中。 在java1.8，如果新加入的链表长度超过8，会转化为红黑树&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>transform和asm初探</title>
    <link href="http://yoursite.com/2022/03/21/Android/gradle/transform%E5%92%8Casm%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2022/03/21/Android/gradle/transform和asm初探/</id>
    <published>2022-03-21T13:54:26.000Z</published>
    <updated>2022-05-04T08:50:41.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义RouterTransform"><a href="#自定义RouterTransform" class="headerlink" title="自定义RouterTransform"></a>自定义RouterTransform</h2><p>Transform 是AGP官方提供的接口，在 class-&gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类</p><a id="more"></a><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>因为是安卓官方提供的能力，需要在 buildSrc 的 build.gradle 中 添加 google() 仓库和安卓构建工具的依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">    implementation <span class="string">"com.android.tools.build:gradle:3.5.3"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-RouterTranform"><a href="#编写-RouterTranform" class="headerlink" title="编写 RouterTranform"></a>编写 RouterTranform</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"RouterMappingTransform"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要插桩的输入类型， 这里是类文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要插桩的范围, 这里是整个工程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否支持增量</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实现</span><br><span class="line">     * @param transformInvocation</span><br><span class="line">     * @throws TransformException</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation)</span><br><span class="line">        throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        super.transform(transformInvocation)</span><br><span class="line"></span><br><span class="line">        println("transform start")</span><br><span class="line"></span><br><span class="line">        def collector = new RouterMappingCollector()</span><br><span class="line"></span><br><span class="line">        // 遍历所有的输入</span><br><span class="line">        transformInvocation.inputs.each &#123;</span><br><span class="line">            // 把 文件夹 类型的输入，拷贝到目标目录</span><br><span class="line">            it.directoryInputs.each &#123; directoryInput -&gt;</span><br><span class="line">                def destDir = transformInvocation.outputProvider</span><br><span class="line">                    .getContentLocation(</span><br><span class="line">                        directoryInput.name,</span><br><span class="line">                        directoryInput.contentTypes,</span><br><span class="line">                        directoryInput.scopes,</span><br><span class="line">                        Format.DIRECTORY)</span><br><span class="line"></span><br><span class="line">                collector.collect(directoryInput.file)</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.file, destDir)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 把 JAR 类型的输入，拷贝到目标目录</span><br><span class="line">            it.jarInputs.each &#123; jarInput -&gt;</span><br><span class="line">                def dest = transformInvocation.outputProvider</span><br><span class="line">                    .getContentLocation(</span><br><span class="line">                        jarInput.name,</span><br><span class="line">                        jarInput.contentTypes,</span><br><span class="line">                        jarInput.scopes, Format.JAR)</span><br><span class="line">                collector.collectFromJarFile(jarInput.file)</span><br><span class="line">                println("transform jar input path $&#123;jarInput.file.absolutePath&#125;")</span><br><span class="line">                println("transform jar output path $&#123;dest.absolutePath&#125;")</span><br><span class="line">                FileUtils.copyFile(jarInput.file, dest)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        File mappingJarFile = transformInvocation.outputProvider.</span><br><span class="line">            getContentLocation(</span><br><span class="line">                "router_mapping",</span><br><span class="line">                getOutputTypes(),</span><br><span class="line">                getScopes(),</span><br><span class="line">                Format.JAR)</span><br><span class="line"></span><br><span class="line">        println("$&#123;getName()&#125;  mappingJarFile = $mappingJarFile")</span><br><span class="line"></span><br><span class="line">        if (mappingJarFile.getParentFile().exists()) &#123;</span><br><span class="line">            mappingJarFile.getParentFile().mkdirs()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mappingJarFile.exists()) &#123;</span><br><span class="line">            mappingJarFile.delete()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将生成的字节码，写入本地文件</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(mappingJarFile)</span><br><span class="line">        JarOutputStream jarOutputStream = new JarOutputStream(fos)</span><br><span class="line">        // CLASS_NAME = "com/imooc/router/mapping/generated/RouterMapping"</span><br><span class="line">        ZipEntry zipEntry =</span><br><span class="line">            new ZipEntry(RouterMappingByteCodeBuilder.CLASS_NAME + ".class")</span><br><span class="line">        jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">        println("transform collect class $&#123;collector.mappingClassName&#125;")</span><br><span class="line">        jarOutputStream.write(</span><br><span class="line">            // 写入字节码</span><br><span class="line">            RouterMappingByteCodeBuilder.get(collector.mappingClassName)</span><br><span class="line">        )</span><br><span class="line">        jarOutputStream.closeEntry()</span><br><span class="line">        jarOutputStream.close()</span><br><span class="line">        fos.close()</span><br><span class="line"></span><br><span class="line">        println("transform end")</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>transformInvocation.inputs.each {</code><br>表示遍历所有输入</li><li><code>it.directoryInputs.each { directoryInput -&gt;</code><br>表示遍历所有目录文件输入，directoryInput 是class文件的目录</li><li><code>it.jarInputs.each { jarInput -&gt;</code><br>遍历所有jar包输入， jarInput 是jar包</li><li><code>transformInvocation.outputProvider.getContentLocation(</code><br>获取具体的输入</li><li><code>collector.collect(directoryInput.file)</code><br>这里是一个自定义逻辑，表示从 class文件 或 jar包 中找到生成的 RouterMapping 路由映射类。 </li><li><p><code>FileUtils.copyFile(jarInput.file, dest)</code><br>拷贝文件到目标目录， 最终transform执行之后会在 /…项目目录/app/build/intermediates/transforms 中生成一个RouterMappingTransform目录。 需要吧class文件和jar包都拷贝过去。有意思是，我原本以为我们工程自己的代码应该都是 class文件，都在 <code>it.directoryInputs.each { directoryInput -&gt;</code> 这个输入里。 但是后来发现，只有 app工程是 class 文件，子工程打包成了 jar 包，和其他第三方库放在了一起</p></li><li><p>后面的代码都是动态生成了一个集合了所有子工程路由注册的路由类，使用asm写入了字节码</p></li></ul><p><strong>即使我们没有对文件做任何处理，我们仍然需要把输入文件拷贝到目标目录下，否则下一个Task就没有TansformInput，如果我们没有将input目录复制到output指定目录，会导致最后的打包的apk缺少class</strong></p><h2 id="注册transform"><a href="#注册transform" class="headerlink" title="注册transform"></a>注册transform</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterPlugin2</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (project.plugins.hasPlugin(AppPlugin)) &#123;</span><br><span class="line">            <span class="comment">// hasPlugin(AppPlugin) 表示这是 app 主工程</span></span><br><span class="line">            <span class="comment">// 注册进我们的 RouterTransform</span></span><br><span class="line">            <span class="keyword">def</span> extension = project.extensions.getByType(AppExtension)</span><br><span class="line">            extension.registerTransform(<span class="keyword">new</span> RouterTransform())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插件也是需要注册的。。。在resource目录的方式注册。 不写了，网上搜一下吧。</p><h2 id="使用我们的-Router"><a href="#使用我们的-Router" class="headerlink" title="使用我们的 Router"></a>使用我们的 Router</h2><p>使用反射实例化我们的类即可<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// GENERATED_MAPPING = "com.imooc.router.mapping.generated.RouterMapping"</span></span><br><span class="line">    <span class="comment">// 注意上面原来文件"/"的分割要变成"."</span></span><br><span class="line">    <span class="keyword">val</span> clazz = Class.forName(GENERATED_MAPPING)</span><br><span class="line">    <span class="keyword">val</span> method = clazz.getMethod(<span class="string">"get"</span>)</span><br><span class="line">    <span class="keyword">val</span> allMapping = method.invoke(<span class="literal">null</span>) <span class="keyword">as</span> Map&lt;String, String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allMapping?.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"init: get all mapping:"</span>)</span><br><span class="line">        allMapping.onEach &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">"    <span class="subst">$&#123;it.key&#125;</span> -&gt; <span class="subst">$&#123;it.value&#125;</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mapping.putAll(allMapping)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"init: error while init router : <span class="variable">$e</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自定义RouterTransform&quot;&gt;&lt;a href=&quot;#自定义RouterTransform&quot; class=&quot;headerlink&quot; title=&quot;自定义RouterTransform&quot;&gt;&lt;/a&gt;自定义RouterTransform&lt;/h2&gt;&lt;p&gt;Transform 是AGP官方提供的接口，在 class-&amp;gt;dex 的阶段提供一个时机，可以让我们对字节码文件做修改，或者动态添加一个新的类&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>自定义gradle插件</title>
    <link href="http://yoursite.com/2022/03/19/Android/gradle/%E8%87%AA%E5%AE%9A%E4%B9%89gradle%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/19/Android/gradle/自定义gradle插件/</id>
    <published>2022-03-19T09:52:18.000Z</published>
    <updated>2022-05-04T08:53:22.297Z</updated>
    
    <content type="html"><![CDATA[<p>这里只记录本地插件的写法</p><h2 id="创建-buildSrc-目录"><a href="#创建-buildSrc-目录" class="headerlink" title="创建 buildSrc 目录"></a>创建 buildSrc 目录</h2><a id="more"></a><ol><li>在创建的 buildScr 目录中创建 build.gradle 文件</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"groovy"</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation gradleApi()</span><br><span class="line">    implementation localGroovy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置源码兼容性</span></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br></pre></td></tr></table></figure><p>上面是固定写法，这里只使用了 groovy 插件，所以我们的插件代码只支持用 groovy 编写</p><ol start="2"><li><p>在 buildSrc 目录中，创建对应的 groovy 目录<br>文件路径是<br>src/main/groovy/…(包名)/</p></li><li><p>创建 自定义的插件 RouterPlugin2</p></li></ol><p>创建文件名 RouterPlugin2.Plugin<br>创建插件类，并实现 Plugin 接口</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterPlugin2</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建 res 文件暴露自己的 groovy<br>创建文件路径：<br>src/main/resources/META-INF.gradle-plugins/RouterPlugin.properties</li></ol><p>内容如下<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-<span class="class"><span class="keyword">class</span>=<span class="title">com</span>.<span class="title">example</span>.<span class="title">test</span>.<span class="title">RouterPlugin2</span></span></span><br></pre></td></tr></table></figure></p><p>创建的文件名 META-INF.gradle-plugins 是固定目录名，xxxx.properties 中的xxxx就是对外暴露的插件的名字。 properties文件的内容表示插件的实现类</p><h2 id="外部使用插件"><a href="#外部使用插件" class="headerlink" title="外部使用插件"></a>外部使用插件</h2><ol><li>导入插件</li></ol><p>在业务的module的 build.gradle 文件中</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"RouterPlugin2"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>向插件写入参数</li></ol><p>在 buildSrc module 中创建一个 groovy 类，代表参数的model类</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterExtension2</span> &#123;</span></span><br><span class="line">    String wiki;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>插件类读取参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> extension = project.extensions.create(<span class="string">"router"</span>, RouterExtension2)</span><br><span class="line"><span class="keyword">def</span> path = extension.wiki</span><br></pre></td></tr></table></figure></li><li><p>在业务调用方传入参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">router &#123;</span><br><span class="line">    wiki <span class="string">"$&#123;getRootDir().absolutePath&#125;/router_wiki.md"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="RouterPlugin2-的详细实现"><a href="#RouterPlugin2-的详细实现" class="headerlink" title="RouterPlugin2 的详细实现"></a>RouterPlugin2 的详细实现</h2><p>插件中要实现三个功能</p><ol><li>在使用路由注解处理器的module，都向注解处理器插入一个参数，代表路由文件生成的路径。 </li><li>在项目clean时清除掉注解中间文件</li><li>将所有module生成的注解中间文件，汇总生成一个路由wiki文档</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Plugin</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.Project</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterPlugin2</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"RouterPlugin2"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"$TAG apply kotlin"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> routerFileDir = <span class="keyword">new</span> File(project.getRootDir(), <span class="string">"router_mapping"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * kapt &#123;</span></span><br><span class="line"><span class="comment">         *      rguments &#123;</span></span><br><span class="line"><span class="comment">         *          arg("router_mapping", rootProject.rootProjectDir.absolutePath）</span></span><br><span class="line"><span class="comment">         *      &#125;</span></span><br><span class="line"><span class="comment">         *  &#125;</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="comment">// 1. 自动帮助用户传递路径参数到注解处理器中 start</span></span><br><span class="line">        <span class="comment">// 以下代码可以替代以上的 build.gradle 配置</span></span><br><span class="line">        <span class="keyword">if</span> (project.extensions.findByName(<span class="string">"kapt"</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">            project.extensions.findByName(<span class="string">"kapt"</span>).arguments &#123;</span><br><span class="line">                arg(<span class="string">"router_file_dir"</span>, routerFileDir)</span><br><span class="line">                arg(<span class="string">"project_name"</span>, project.name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 自动帮助用户传递路径参数到注解处理器中 end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 在clean时自动清理旧的构建产物</span></span><br><span class="line">        project.clean.doFirst &#123;</span><br><span class="line">            <span class="keyword">def</span> routerMappingFile = routerFileDir</span><br><span class="line">            <span class="keyword">if</span> (routerMappingFile.exists()) &#123;</span><br><span class="line">                routerMappingFile.deleteDir()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 集合各个子project路由信息，生成路由文档</span></span><br><span class="line">        <span class="keyword">def</span> extension = project.extensions.create(<span class="string">"router"</span>, RouterExtension2)</span><br><span class="line">        project.afterEvaluate &#123;</span><br><span class="line">            <span class="comment">// 在工程完成配置阶段之后才能获取到 外部配置的参数</span></span><br><span class="line">            <span class="keyword">def</span> wikiPath = extension.wiki</span><br><span class="line">            project.tasks.findAll &#123; task -&gt;</span><br><span class="line">                <span class="comment">// 找到编译的task，compileDebugJavaWithJavac</span></span><br><span class="line">                task.name.startsWith(<span class="string">"compile"</span>) &amp;&amp; task.name.endsWith(<span class="string">"JavaWithJavac"</span>)</span><br><span class="line">            &#125;.each &#123;task -&gt;</span><br><span class="line">                task.doLast &#123;</span><br><span class="line">                    <span class="keyword">def</span> wikiFile = <span class="keyword">new</span> File(wikiPath)</span><br><span class="line">                    <span class="keyword">if</span> (!wikiFile.exists()) &#123;</span><br><span class="line">                        wikiFile.createNewFile()</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">def</span> jsonFiles = routerFileDir</span><br><span class="line">                    jsonFiles.eachFile &#123;file -&gt;</span><br><span class="line">                        <span class="keyword">def</span> content = file.readBytes()</span><br><span class="line">                        wikiFile.append(<span class="keyword">new</span> String(content))</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// write jsonFile content into wikiPath</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里只记录本地插件的写法&lt;/p&gt;&lt;h2 id=&quot;创建-buildSrc-目录&quot;&gt;&lt;a href=&quot;#创建-buildSrc-目录&quot; class=&quot;headerlink&quot; title=&quot;创建 buildSrc 目录&quot;&gt;&lt;/a&gt;创建 buildSrc 目录&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>自定义注解处理器并发布为gradle组件</title>
    <link href="http://yoursite.com/2022/03/13/Android/gradle/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%E5%B9%B6%E5%8F%91%E5%B8%83%E4%B8%BAgradle%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/13/Android/gradle/自定义注解处理器并发布为gradle组件/</id>
    <published>2022-03-13T07:27:24.000Z</published>
    <updated>2022-03-13T09:10:55.158Z</updated>
    
    <content type="html"><![CDATA[<p>自定义一个基于注解的路由框架</p><h2 id="定义注解类"><a href="#定义注解类" class="headerlink" title="定义注解类"></a>定义注解类</h2><ol><li>新建一个模块 router_annotations </li><li>在 router_annotations 目录中创建 build.gradle </li></ol><a id="more"></a><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin"</span> <span class="comment">// 使用 kotlin</span></span><br><span class="line"></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 发布脚本，后面会写</span></span><br><span class="line">apply <span class="string">from :</span> rootProject.file(<span class="string">"maven-publish.gradle"</span>)</span><br></pre></td></tr></table></figure><ol start="3"><li>定义注解类</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置使用注解的对象是 类</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.CLASS)</span></span><br><span class="line"><span class="comment">// 设置注解只在编译期存在</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.BINARY)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>(</span><br><span class="line">    <span class="keyword">val</span> url: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="定义注解处理器模块"><a href="#定义注解处理器模块" class="headerlink" title="定义注解处理器模块"></a>定义注解处理器模块</h2><ol><li>新建一个模块 router_compile</li><li>在 router_compile 目录中创建 build.gradle</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin"</span> <span class="comment">// 使用kotlin插件</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">"kotlin-kapt"</span> <span class="comment">// 使用kotlin注解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置源码兼容性</span></span><br><span class="line">targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation project(<span class="string">":router_annotations"</span>)</span><br><span class="line">    implementation <span class="string">"com.google.auto.service:auto-service:1.0-rc6"</span></span><br><span class="line">    kapt <span class="string">"com.google.auto.service:auto-service:1.0-rc6"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用 发布脚本。后面会写</span></span><br><span class="line">apply <span class="string">from :</span> rootProject.file(<span class="string">"maven-publish.gradle"</span>)</span><br></pre></td></tr></table></figure><p>在注解处理器模块，如果使用kotlin写注解处理器代码，需要引用 <code>kotlin-kapt</code> 这个插件<br><code>implementation &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 使用google的一个注解框架。<br>同时还要加上 <code>kapt &quot;com.google.auto.service:auto-service:1.0-rc6&quot;</code> 。 这是kotlin的写法，如果是java，需要换成<br><code>annotationProcessor &#39;com.google.auto.service:auto-service:1.0-rc6&#39;</code></p><ol start="3"><li>编写注解处理器<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoService(Processor::class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestinationProcessor</span> : <span class="type">AbstractProcessor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">"DestinationProcessor"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">set</span>: <span class="type">MutableSet</span>&lt;<span class="type">out</span> <span class="type">TypeElement</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">        roundEnvironment: <span class="type">RoundEnvironment</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (roundEnvironment.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"<span class="variable">$TAG</span> &gt;&gt;&gt;&gt; process start"</span>)</span><br><span class="line"></span><br><span class="line">        println(<span class="keyword">set</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> destinationClasses = roundEnvironment.getElementsAnnotatedWith(Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">        println(TAG + <span class="string">" "</span> + destinationClasses.size)</span><br><span class="line">        <span class="keyword">if</span> (destinationClasses.size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (element <span class="keyword">in</span> destinationClasses) &#123;</span><br><span class="line">            <span class="keyword">val</span> typeElement = element <span class="keyword">as</span> TypeElement</span><br><span class="line">            <span class="keyword">val</span> destination = typeElement.getAnnotation(Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">                ?: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">val</span> url = destination.url</span><br><span class="line">            <span class="keyword">val</span> className = typeElement.qualifiedName</span><br><span class="line">            println(<span class="string">"<span class="variable">$TAG</span> <span class="variable">$url</span> <span class="variable">$className</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"<span class="variable">$TAG</span> &gt;&gt;&gt;&gt; process finish"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> mutableSetOf(</span><br><span class="line">            Destination::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">canonicalName</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@AutoService(Processor::class)</code> 是固定写法</p><p><code>AbstractProcessor</code> 继承这个抽象类。<br>重写<code>getSupportedAnnotationTypes</code>方法，返回需要处理的注解。<br>重写<code>process</code>方法，处理注解信息。 返回值为true表示已处理这个注解，相同的注解不会再被其他注解处理器处理。<br><code>roundEnvironment.processingOver()</code>表示之前已经有处理过一轮，此时<code>roundEnvironment.elements.size==0</code> 不是很明白gradle为什么会执行多轮。。。</p><h2 id="在本地使用注解"><a href="#在本地使用注解" class="headerlink" title="在本地使用注解"></a>在本地使用注解</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation project(<span class="string">":router_annotations"</span>)</span><br><span class="line">kapt project(<span class="string">":router_compile"</span>)</span><br></pre></td></tr></table></figure><h2 id="将注解处理器打包成组件并发布"><a href="#将注解处理器打包成组件并发布" class="headerlink" title="将注解处理器打包成组件并发布"></a>将注解处理器打包成组件并发布</h2><ol><li><p>在最外层的 build.properties 中写通用参数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POM_URL=..<span class="regexp">/repo  /</span>/ 发布的仓库地址，这里是本地</span><br><span class="line">GROUP_ID=com.example.test <span class="comment">// group</span></span><br><span class="line">VERSION_NAME=<span class="number">1.0</span><span class="number">.0</span> <span class="comment">// 版本</span></span><br></pre></td></tr></table></figure></li><li><p>在 router_annotation 和 router_compile 中写 group_id</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 router_annotation build.properties</span></span><br><span class="line">POM_ARTIFACT_ID=router-test-annotation</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 router_compile build.properties</span></span><br><span class="line">POM_ARTIFACT_ID=router-test-processor</span><br></pre></td></tr></table></figure></li><li><p>编写发布脚本 maven-publish.gradle</p></li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span> <span class="comment">// 引入maven插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从根目录的 gradle.properties 中获取通用参数 start</span></span><br><span class="line"><span class="keyword">def</span> rootProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">rootProperties.load(<span class="keyword">new</span> FileInputStream(project.rootProject.file(<span class="string">"gradle.properties"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> versionName = rootProperties.getProperty(<span class="string">"VERSION_NAME"</span>)</span><br><span class="line"><span class="keyword">def</span> pomUrl = rootProperties.getProperty(<span class="string">"POM_URL"</span>) <span class="comment">// ../repo</span></span><br><span class="line"><span class="keyword">def</span> groupId = rootProperties.getProperty(<span class="string">"GROUP_ID"</span>)</span><br><span class="line"><span class="comment">// 获取通用参数 end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前项目的 gradle.properties 中获取参数</span></span><br><span class="line"><span class="keyword">def</span> projectProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">projectProperties.load(<span class="keyword">new</span> FileInputStream(project.file(<span class="string">"gradle.properties"</span>)))</span><br><span class="line"><span class="keyword">def</span> pomArtifactId = projectProperties.getProperty(<span class="string">"POM_ARTIFACT_ID"</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"maven-publish $versionName $pomUrl $groupId $pomArtifactId"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写maven的发布任务</span></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(<span class="string">url:</span> uri(pomUrl)) &#123;</span><br><span class="line">                pom.groupId = groupId</span><br><span class="line">                pom.artifactId = pomArtifactId</span><br><span class="line">                pom.version = versionName</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pom.whenConfigured &#123; pom -&gt;</span><br><span class="line">                pom.dependencies.forEach &#123; dep -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (dep.getVersion() == <span class="string">"unspecified"</span>) &#123;</span><br><span class="line">                        dep.setGroupId(groupId)</span><br><span class="line">                        dep.setVersion(versionName)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意有一个 <code>pom.whenConfigured { pom -&gt; ...</code> 的代码，这是因为 router_compile 应用到了 router_annotations 模块。如果不做处理，发布之后， router_comiple 模块是找不到 router_annotations 的正确位置和版本的。所以要强制制定</p><h2 id="执行发布任务"><a href="#执行发布任务" class="headerlink" title="执行发布任务"></a>执行发布任务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./gradlew :router_compile:uploadArchives</span><br><span class="line">./gradlew :router_annotations:uploadArchives</span><br></pre></td></tr></table></figure><p>我们设置的 <code>POM_URL=../repo</code> 所以最终会在项目的repo目录里生成aar包。 </p><h2 id="使用发布后的组件"><a href="#使用发布后的组件" class="headerlink" title="使用发布后的组件"></a>使用发布后的组件</h2><ol><li>首先，moven本地仓库地址加入到工程里<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123; url uri(<span class="string">'/Users/bytedance/code/test/repo'</span>) &#125;</span><br><span class="line">        google()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>buildscript.repositories 和 allprojects.repositories 都要加，这样才会应用到所有子工程</p><ol start="2"><li><p>在app模块里引用组件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"com.example.test:router-test-annotation:1.0.0"</span></span><br><span class="line">kapt <span class="string">"com.example.test:router-test-processor:1.0.0"</span></span><br></pre></td></tr></table></figure></li><li><p>gradle版本的区别</p></li></ol><p>在 gradle 7.+ 版本有很多东西不兼容，上述实现只有在 gradle 6.+ 的版本有效。 gradle 的版本升级和项目创建还是要谨慎一些。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自定义一个基于注解的路由框架&lt;/p&gt;&lt;h2 id=&quot;定义注解类&quot;&gt;&lt;a href=&quot;#定义注解类&quot; class=&quot;headerlink&quot; title=&quot;定义注解类&quot;&gt;&lt;/a&gt;定义注解类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;新建一个模块 router_annotations &lt;/li&gt;
&lt;li&gt;在 router_annotations 目录中创建 build.gradle &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>MultiDex原理</title>
    <link href="http://yoursite.com/2021/12/25/Android/Framework/MultiDex%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2021/12/25/Android/Framework/MultiDex原理/</id>
    <published>2021-12-25T10:20:52.000Z</published>
    <updated>2021-12-25T11:04:06.178Z</updated>
    
    <content type="html"><![CDATA[<p>apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.<br>为了规避安卓项目编译65536最大方法数的限制，需要做分dex</p><a id="more"></a><h2 id="1-Dalvik-和-ART-虚拟机的区别"><a href="#1-Dalvik-和-ART-虚拟机的区别" class="headerlink" title="1. Dalvik 和 ART 虚拟机的区别"></a>1. Dalvik 和 ART 虚拟机的区别</h2><p>Android5.0以上系统使用 ART 虚拟机，5.0以下使用 Dalvik 虚拟机</p><p>Dalvik 编译策略是 JIT 技术。JIT意思是Just In Time Compiler，就是即时编译技术。<br>JIT是运行时编译，是动态编译，可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间可以加快Dalvik运行速度。每次运行都需要重新编译。</p><p>AOT是指”Ahead Of Time”，与”Just In Time”不同，从字面来看是说提前编译。<br>AOT 是静态编译，应用在安装的时候会启动 dex2oat 过程把 dex预编译，一次性将所有dex代码转换为机器码，每次运行程序的时候不用重新编译。 </p><p>Android 7.0上，JIT 编译器被再次使用，采用AOT/JIT 混合编译的策略，特点是：</p><p>应用在安装的时候dex不会再被编译<br>App运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息。<br>手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译</p><h2 id="2-不同虚拟机在-MultiDex-的区别。"><a href="#2-不同虚拟机在-MultiDex-的区别。" class="headerlink" title="2. 不同虚拟机在 MultiDex 的区别。"></a>2. 不同虚拟机在 MultiDex 的区别。</h2><ul><li>Andorid 5.0 之后，ART天然支持从apk文件中加载多个.dex文件，在应用安装期间，它会执行一个预编译操作。将所有的dex编译成一个单一的.oat文件，在应用运行是去加载这个.oat文件，而不是一个一个的加载.dex文件。<br>所以我们只需要 在 gradle 开启 multiDexEnabled true 即可</li><li>Dalvik 使用的 JIT ，JIT每次运行都需要重新编译。 所以我们需要在应用启动时手动去一个一个加载 dex 文件</li></ul><h2 id="3-在-Dalvik-加载多dex"><a href="#3-在-Dalvik-加载多dex" class="headerlink" title="3. 在 Dalvik 加载多dex"></a>3. 在 Dalvik 加载多dex</h2><p>简单来说 hook PathClassLoader 。</p><ol><li>获取到所有的dex文件</li><li>通过反射拿到DexPathList的Element数组，把dex添加到 Element数组中</li></ol><p>通过这样的方式也可以实现热热修复，将修改后的新class打包成一个dex， 然后通过反射将 新dex插入到 PathClassLoader 中的 element数组最前面。从而实现对旧类的覆盖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;apk中的一个dex文件的方法索引是一个ushort类型，最大值为655535. 所以一个dex文件的最大方法数是65535.&lt;br&gt;为了规避安卓项目编译65536最大方法数的限制，需要做分dex&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>技术Owner的职责</title>
    <link href="http://yoursite.com/2021/11/27/%E6%8A%80%E6%9C%AFOwner%E7%9A%84%E8%81%8C%E8%B4%A3/"/>
    <id>http://yoursite.com/2021/11/27/技术Owner的职责/</id>
    <published>2021-11-27T07:58:24.000Z</published>
    <updated>2021-11-27T08:09:40.100Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参与需求评审，完成可行性调研，完善细节。<ul><li>要督促完成UI/UE评审，埋点评审</li></ul></li><li>技术评审，输出技术方案，拆分需求子任务，给出详细排期</li><li>开始开发，定期站会，同步风险<ul><li>发生变更，更改排期</li><li>需求提测前，推进case评审</li><li>自测</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;参与需求评审，完成可行性调研，完善细节。&lt;ul&gt;
&lt;li&gt;要督促完成UI/UE评审，埋点评审&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术评审，输出技术方案，拆分需求子任务，给出详细排期&lt;/li&gt;
&lt;li&gt;开始开发，定期站会，同步风险&lt;ul&gt;
&lt;li&gt;发生变更
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Binder源码笔记</title>
    <link href="http://yoursite.com/2021/11/03/Android/Framework/Binder%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/11/03/Android/Framework/Binder源码笔记/</id>
    <published>2021-11-03T13:42:37.000Z</published>
    <updated>2021-11-09T14:29:00.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Service-的启动-独立进程的-Service"><a href="#Service-的启动-独立进程的-Service" class="headerlink" title="Service 的启动 (独立进程的 Service )"></a>Service 的启动 (独立进程的 Service )</h1><a id="more"></a><h2 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a>ProcessState</h2><p>ProcessState 是一个系统 Service 进程的单例，一个进程只有一个 ProcessState 实例。 </p><p>内部会打开设备 “/dev/binder” ，调用 mmap 函数，完成自己和内核空间的内存映射。</p><p>ioctl 和 Binder 设备传递参数，设置了 binder 线程池的最大线程数</p><h2 id="Binder线程池"><a href="#Binder线程池" class="headerlink" title="Binder线程池"></a>Binder线程池</h2><p>调用 ProcessState::startThreadPool() 启动 Binder 线程池。 调用之后，实际上就已经 run 了一个 Binder 主线程, 并开始 while 死循环接收 Binder 消息。<br>之后会根据情况，选择在 Binder 线程池中创建新的线程，但是创建出来的就不是一个死循环的线程了</p><h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="BpBinder-和-BBinder"><a href="#BpBinder-和-BBinder" class="headerlink" title="BpBinder 和 BBinder"></a>BpBinder 和 BBinder</h2><p>IBinder 对象是负责binder通信的实例。 BpBinder 是客户端和服务端交互的代理类，BBinder 代表服务端</p><h2 id="BpBinder-transact"><a href="#BpBinder-transact" class="headerlink" title="BpBinder::transact"></a>BpBinder::transact</h2><p>发送数据的方法</p><h2 id="IPCThreadState-self-gt-transact-…"><a href="#IPCThreadState-self-gt-transact-…" class="headerlink" title="IPCThreadState::self()-&gt;transact(…)"></a>IPCThreadState::self()-&gt;transact(…)</h2><p>真正数据通信的方法。 一个线程只会有一个实例， 使用 pthread_setspecific 实现，类似于 java 的 ThreadLocal<br>IPCThreadState 有两个缓存 mIn 和 mOut 分别负责数据的接收和发射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">-&gt;</span> transact(..)</span><br><span class="line">    -&gt; writeTransactionData(..)</span><br><span class="line">        -&gt; 将 cmd 和 data 写入到 mOut 中</span><br><span class="line">    -&gt; waitForResponse(..)</span><br><span class="line">        -&gt; talkWithDriver(doReceive)</span><br><span class="line">            -&gt; 将 bwr(一个和Binder驱动的结构体) bwr.write_buffer 指向 mOut.data()</span><br><span class="line">            -&gt; 将 bwr.read_buffer 指向 mIn.data()</span><br><span class="line">            -&gt; do-while 循环，调用 ioctl 函数 和 Binder 驱动通信，直到结束</span><br></pre></td></tr></table></figure><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的"><a href="#1-只有系统Service-才能记录到-ServiceManager-中，那么-应用的-Service-是如何查找到的" class="headerlink" title="1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的"></a>1. 只有系统Service 才能记录到 ServiceManager 中，那么 应用的 Service 是如何查找到的</h2><p>应用 Service 是发布到 AMS 上的，客户端从 AMS 上去查找 Service 的 Binder 对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Service-的启动-独立进程的-Service&quot;&gt;&lt;a href=&quot;#Service-的启动-独立进程的-Service&quot; class=&quot;headerlink&quot; title=&quot;Service 的启动 (独立进程的 Service )&quot;&gt;&lt;/a&gt;Service 的启动 (独立进程的 Service )&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>InputManagerService</title>
    <link href="http://yoursite.com/2021/10/18/Android/Framework/InputManagerService/"/>
    <id>http://yoursite.com/2021/10/18/Android/Framework/InputManagerService/</id>
    <published>2021-10-18T13:31:03.000Z</published>
    <updated>2021-10-18T14:01:44.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="native层概述"><a href="#native层概述" class="headerlink" title="native层概述"></a>native层概述</h2><h3 id="InputReader"><a href="#InputReader" class="headerlink" title="InputReader"></a>InputReader</h3><p>输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。</p><a id="more"></a><p>InputReader 持有 InputMapper 对应不同的输入设备的 事件加工器。 </p><p>事件加工后，InputReader 会 调用 InputDispatcher.notifyXXX 函数 唤醒 InputDispatcher 进行事件分发</p><h3 id="InputDispatcher"><a href="#InputDispatcher" class="headerlink" title="InputDispatcher"></a>InputDispatcher</h3><p>输入事件的分发者。 分发输入事件到目标窗口。 运行在 InputDispatcherThread 中， 这个线程平时是休眠状态，等待 InputReader 的唤醒</p><p>被唤醒后，调用 dispatchOnceInnerLocked 将输入事件分发到合适的窗口中</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;native层概述&quot;&gt;&lt;a href=&quot;#native层概述&quot; class=&quot;headerlink&quot; title=&quot;native层概述&quot;&gt;&lt;/a&gt;native层概述&lt;/h2&gt;&lt;h3 id=&quot;InputReader&quot;&gt;&lt;a href=&quot;#InputReader&quot; class=&quot;headerlink&quot; title=&quot;InputReader&quot;&gt;&lt;/a&gt;InputReader&lt;/h3&gt;&lt;p&gt;输入事件的读取者。 运行在单独的 InputReaderThread 线程中，死循环，通过 EventHub.getEvents 来获取输入事件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kotlin-flow</title>
    <link href="http://yoursite.com/2021/10/04/Kotlin/kotlin-flow/"/>
    <id>http://yoursite.com/2021/10/04/Kotlin/kotlin-flow/</id>
    <published>2021-10-04T06:58:00.000Z</published>
    <updated>2022-04-11T06:46:20.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础的流"><a href="#基础的流" class="headerlink" title="基础的流"></a>基础的流</h1><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123; <span class="comment">// 流构建器</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们在这里做了一些有用的事情</span></span><br><span class="line">        emit(i) <span class="comment">// 发送下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 启动并发的协程以验证主线程并未阻塞</span></span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">for</span> (k <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">"I'm not blocked <span class="variable">$k</span>"</span>)</span><br><span class="line">            delay(<span class="number">100</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集这个流</span></span><br><span class="line">    simple().collect &#123; value -&gt; println(value) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="flow-是-”冷流“"><a href="#flow-是-”冷流“" class="headerlink" title="flow 是 ”冷流“"></a>flow 是 ”冷流“</h2><ul><li>冷流的定义：  flow 构建器中的代码直到流被调用 collect 的时候才运行。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">flow</span><span class="params">(<span class="meta">@BuilderInference</span> block: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.()</span></span> -&gt; <span class="built_in">Unit</span>): Flow&lt;T&gt; = SafeFlow(block)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeFlow</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> block: <span class="keyword">suspend</span> FlowCollector&lt;T&gt;.() -&gt; <span class="built_in">Unit</span>) : AbstractFlow&lt;T&gt;() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collectSafely</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        collector.block()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlowCollector</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flow 的实现如上，只不过是传入了 代码块作为 FlowCollector 的拓展函数。<br>当 流开始收集 （调用collect），会执行这个 flow 的代码块。<br>在 collect 中传入的代码块， 实际上是一个 FlowCollector 匿名对象，当 flow 的代码块调用 emit 的时候，就直接调用了 collect 后的代码块。</p><p>用一个例子体现这一点：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">1</span>) &#123;</span><br><span class="line">        log(<span class="string">"Emit start <span class="variable">$i</span>"</span>)</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">        log(<span class="string">"Emit end <span class="variable">$i</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple()</span><br><span class="line">        .collect &#123; value -&gt;</span><br><span class="line">            log(<span class="string">"Collected start <span class="variable">$value</span>"</span>)</span><br><span class="line">            delay(<span class="number">300</span>)</span><br><span class="line">            log(<span class="string">"Collected end <span class="variable">$value</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main] Emit start 1</span><br><span class="line">[main] Collected start 1</span><br><span class="line">[main] Collected end 1</span><br><span class="line">[main] Emit end 1</span><br></pre></td></tr></table></figure><h2 id="流的上下文保存"><a href="#流的上下文保存" class="headerlink" title="流的上下文保存"></a>流的上下文保存</h2><ul><li>上下文保存： <strong>flow { … } 构建器中的代码运行在相应流的收集器提供的上下文中</strong></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line">           </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    log(<span class="string">"Started simple flow"</span>)</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt; log(<span class="string">"Collected <span class="variable">$value</span>"</span>) &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main @coroutine#1] Started simple flow</span><br><span class="line">[main @coroutine#1] Collected 1</span><br><span class="line">[main @coroutine#1] Collected 2</span><br><span class="line">[main @coroutine#1] Collected 3</span><br></pre></td></tr></table></figure><p>由于 simple().collect 是在主线程调用的，那么 simple 的流主体也是在主线程调用的。<br><strong>如果在 调用<code>emit</code>时切换协程上下文，会直接抛出异常</strong></p><ul><li>flowOn: 正确的切换 flow 的上下文</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">log</span><span class="params">(msg: <span class="type">String</span>)</span></span> = println(<span class="string">"[<span class="subst">$&#123;Thread.currentThread().name&#125;</span>] <span class="variable">$msg</span>"</span>)</span><br><span class="line">           </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>) <span class="comment">// 假装我们以消耗 CPU 的方式进行计算</span></span><br><span class="line">        log(<span class="string">"Emitting <span class="variable">$i</span>"</span>)</span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.flowOn(Dispatchers.Default) <span class="comment">// 在流构建器中改变协程上下文的正确方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    simple().collect &#123; value -&gt;</span><br><span class="line">        log(<span class="string">"Collected <span class="variable">$value</span>"</span>) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决-背压问题"><a href="#解决-背压问题" class="headerlink" title="解决 背压问题"></a>解决 背压问题</h2><p>名词解释：<strong>背压： 假设有一个快的数据生产者和一个慢的数据消费者，背压就是一种 “倒逼 “生产者而使自己不被数据淹没的机制</strong></p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>并发运行这个 流中发射元素的代码以及收集的代码， 而不是顺序运行它们； buffer() 会给切换 flow 的协程，保证 发送端 是不阻塞的 。 可以设置 buffer 容量和策略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .buffer() <span class="comment">// 缓冲发射项，无需等待</span></span><br><span class="line">            .collect &#123; value -&gt; </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(value) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="conflate"><a href="#conflate" class="headerlink" title="conflate"></a>conflate</h3><p>一种特殊 buffer 策略 新数据会覆盖老数据</p><h3 id="collectLatest"><a href="#collectLatest" class="headerlink" title="collectLatest"></a>collectLatest</h3><p>它并不会直接用新数据覆盖老数据，而是每一个都会被处理，只不过如果前一个还没被处理完后一个就来了的话，处理前一个数据的逻辑就会被取消。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">simple</span><span class="params">()</span></span>: Flow&lt;<span class="built_in">Int</span>&gt; = flow &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">3</span>) &#123;</span><br><span class="line">        delay(<span class="number">100</span>) <span class="comment">// 假装我们异步等待了 100 毫秒</span></span><br><span class="line">        emit(i) <span class="comment">// 发射下一个值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        simple()</span><br><span class="line">            .collectLatest &#123; value -&gt; <span class="comment">// 取消并重新发射最后一个值</span></span><br><span class="line">                println(<span class="string">"Collecting <span class="variable">$value</span>"</span>) </span><br><span class="line">                delay(<span class="number">300</span>) <span class="comment">// 假装我们花费 300 毫秒来处理它</span></span><br><span class="line">                println(<span class="string">"Done <span class="variable">$value</span>"</span>) </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    println(<span class="string">"Collected in <span class="variable">$time</span> ms"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collecting 1</span><br><span class="line">Collecting 2</span><br><span class="line">Collecting 3</span><br><span class="line">Done 3</span><br><span class="line">Collected in 741 ms</span><br></pre></td></tr></table></figure><h1 id="StateFlow"><a href="#StateFlow" class="headerlink" title="StateFlow"></a>StateFlow</h1><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">val</span> flow = MutableStateFlow(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> success = flow.tryEmit(i)</span><br><span class="line">            println(<span class="string">"tryEmit <span class="variable">$i</span> <span class="variable">$success</span>"</span>)</span><br><span class="line"><span class="comment">//            delay(200)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">        launch(Dispatchers.IO) &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            produce()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        launch(Dispatchers.IO)&#123;</span><br><span class="line"></span><br><span class="line">            flow.onEach &#123;</span><br><span class="line">                println(<span class="string">"receive-1 <span class="variable">$it</span>"</span>)</span><br><span class="line">                delay(<span class="number">500</span>)</span><br><span class="line">            &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="StateFlow-是一个-“流”"><a href="#StateFlow-是一个-“流”" class="headerlink" title="StateFlow 是一个 “流”"></a>StateFlow 是一个 “流”</h2><p>不同于普通的 flow ， StateFlow 是一个热数据流。 不需要主动调动 collect{…} , 就能 emit 数据</p><h2 id="StateFlow-的-collect-是阻塞的，需要在单独的协程中运行"><a href="#StateFlow-的-collect-是阻塞的，需要在单独的协程中运行" class="headerlink" title="StateFlow 的 collect 是阻塞的，需要在单独的协程中运行"></a>StateFlow 的 collect 是阻塞的，需要在单独的协程中运行</h2><p>在demo中调用了 launchIn ，而不是直接 collect 。 看一下源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StateFlow </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _state = atomic(initialState)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">collect</span><span class="params">(collector: <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> slot = allocateSlot()</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (collector <span class="keyword">is</span> SubscribedFlowCollector) collector.onSubscription()</span><br><span class="line">            <span class="keyword">val</span> collectorJob = currentCoroutineContext()[Job]</span><br><span class="line">            <span class="keyword">var</span> oldState: Any? = <span class="literal">null</span> </span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">val</span> newState = _state.value</span><br><span class="line">                collectorJob?.ensureActive()</span><br><span class="line">                <span class="keyword">if</span> (oldState == <span class="literal">null</span> || oldState != newState) &#123;</span><br><span class="line">                    collector.emit(NULL.unbox(newState))</span><br><span class="line">                    oldState = newState</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!slot.takePending()) &#123; <span class="comment">// try fast-path without suspending first</span></span><br><span class="line">                    slot.awaitPending() <span class="comment">// only suspend for new values when needed</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            freeSlot(slot)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 collec 中，一个 while 死循环，开始不断读取 _state.value 的值<br>solt 可以看做是 collector 的一个封装。 这里调用了 slot.awaitPending() 来挂起当前协程，让出cpu时间. 看一下 StateFlowSlot 是如何挂起的 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">awaitPending</span><span class="params">()</span></span>: <span class="built_in">Unit</span> = suspendCancellableCoroutine <span class="symbol">sc@</span> &#123; cont -&gt;</span><br><span class="line">    <span class="comment">// 如果 _state 是 None ，就设置为 cont </span></span><br><span class="line">    <span class="comment">// cont 的类型 CancellableContinuation ，只用调用 resume 或 fail 等，才会结束，否则挂起当前协程</span></span><br><span class="line">    <span class="keyword">if</span> (_state.compareAndSet(NONE, cont)) <span class="keyword">return</span><span class="symbol">@sc</span></span><br><span class="line">    cont.resume(<span class="built_in">Unit</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 StateFlow 的 emit 被调用的时候， 会获取到 solt 中的 CancellableContinuation 对象，调用其 resume ，将协程进行唤醒</p><h1 id="ShareFlow"><a href="#ShareFlow" class="headerlink" title="ShareFlow"></a>ShareFlow</h1><h2 id="demo-2"><a href="#demo-2" class="headerlink" title="demo"></a>demo</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> flow = MutableSharedFlow&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">    replay = <span class="number">0</span>, </span><br><span class="line">    extraBufferCapacity = <span class="number">100</span>, </span><br><span class="line">    onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">produce</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> success = flow.tryEmit(i)</span><br><span class="line">        println(<span class="string">"tryEmit <span class="variable">$i</span> <span class="variable">$success</span>"</span>)</span><br><span class="line"><span class="comment">//            delay(200)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmStatic</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Unit</span> = runBlocking &#123;</span><br><span class="line">    launch(Dispatchers.IO) &#123;</span><br><span class="line">        delay(<span class="number">1000</span>)</span><br><span class="line">        produce()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    launch(Dispatchers.IO)&#123;</span><br><span class="line"></span><br><span class="line">        flow.onEach &#123;</span><br><span class="line">            println(<span class="string">"receive-1 <span class="variable">$it</span>"</span>)</span><br><span class="line">            delay(<span class="number">500</span>)</span><br><span class="line">        &#125;.launchIn(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MutableShareFlow 的三个参数：</p><ul><li>通过 replay ，您可以针对新订阅者重新发送多个之前已发出的值</li><li>extraBufferCapacity: 除了 replay 值以外的缓冲区容量。 extraBufferCapacity + replay 是缓冲区buffer的容量</li><li>通过 onBufferOverflow，您可以指定相关政策来处理缓冲区中已存满要发送的数据项的情况。默认值为 BufferOverflow.SUSPEND，这会使调用方挂起。其他选项包括 DROP_LATEST 或 DROP_OLDEST</li></ul><p>ShareFlow 在收集侧 和 StateFlow 基本一致。 都是 while 死循环，然后将 solt 挂起。 这里不再赘述</p><!-- ## BufferOverflow.SUSPEND, tryEmit 和 Emit当  -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础的流&quot;&gt;&lt;a href=&quot;#基础的流&quot; class=&quot;headerlink&quot; title=&quot;基础的流&quot;&gt;&lt;/a&gt;基础的流&lt;/h1&gt;&lt;h2 id=&quot;demo&quot;&gt;&lt;a href=&quot;#demo&quot; class=&quot;headerlink&quot; title=&quot;demo&quot;&gt;&lt;/a&gt;demo&lt;/h2&gt;&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; kotlinx.coroutines.*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; kotlinx.coroutines.flow.*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;simple&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;: Flow&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&amp;gt; = flow &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 流构建器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        delay(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 假装我们在这里做了一些有用的事情&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        emit(i) &lt;span class=&quot;comment&quot;&gt;// 发送下一个值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; = runBlocking&amp;lt;&lt;span class=&quot;built_in&quot;&gt;Unit&lt;/span&gt;&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 启动并发的协程以验证主线程并未阻塞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    launch &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (k &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            println(&lt;span class=&quot;string&quot;&gt;&quot;I&#39;m not blocked &lt;span class=&quot;variable&quot;&gt;$k&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            delay(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 收集这个流&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    simple().collect &amp;#123; value -&amp;gt; println(value) &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>nested2嵌套滚动机制</title>
    <link href="http://yoursite.com/2021/07/24/Android/nested2%E5%B5%8C%E5%A5%97%E6%BB%9A%E5%8A%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/07/24/Android/nested2嵌套滚动机制/</id>
    <published>2021-07-24T08:36:31.000Z</published>
    <updated>2021-10-03T01:57:41.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。</p><a id="more"></a><h2 id="NestedScrollingParent2"><a href="#NestedScrollingParent2" class="headerlink" title="NestedScrollingParent2"></a>NestedScrollingParent2</h2><p>NestedScrollingParent2 包含以下接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 即将开始嵌套滑动，此时嵌套滑动尚未开始，由子控件的 startNestedScroll 方法调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> child  嵌套滑动对应的父类的子类(因为嵌套滑动对于的父控件不一定是一级就能找到的，可能挑了两级父控件的父控件，child的辈分&gt;=target)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target 具体嵌套滑动的那个子类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> axes   嵌套滑动支持的滚动方向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type   嵌套滑动的类型，有两种ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true 表示此父类开始接受嵌套滑动，只有true时候，才会执行下面的 onNestedScrollAccepted 等操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当onStartNestedScroll返回为true时，也就是父控件接受嵌套滑动时，该方法才会调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> child</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> axes</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(@NonNull View child, @NonNull View target, @ScrollAxis <span class="keyword">int</span> axes,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class="line"><span class="comment">    * 在嵌套滑动的子View未滑动之前</span></span><br><span class="line"><span class="comment">    * ，判断父view是否优先与子view处理(也就是父view可以先消耗，然后给子view消耗）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target   具体嵌套滑动的那个子类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dx       水平方向嵌套滑动的子View想要变化的距离</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dy       垂直方向嵌套滑动的子View想要变化的距离 dy&lt;0向下滑动 dy&gt;0 向上滑动</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> consumed 这个参数要我们在实现这个函数的时候指定，回头告诉子View当前父View消耗的距离</span></span><br><span class="line"><span class="comment">    *                 consumed[0] 水平消耗的距离，consumed[1] 垂直消耗的距离 好让子view做出相应的调整</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @NonNull <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">           </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class="line"><span class="comment">    * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target       具体嵌套滑动的那个子类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxConsumed   水平方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyConsumed   垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxUnconsumed 水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyUnconsumed 垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(@NonNull View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 停止滑动</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type     滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(@NonNull View target, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NestedScrollingChild2"><a href="#NestedScrollingChild2" class="headerlink" title="NestedScrollingChild2"></a>NestedScrollingChild2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingChild2</span> <span class="keyword">extends</span> <span class="title">NestedScrollingChild</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 开始滑动前调用，在惯性滑动和触摸滑动前都会进行调用，此方法一般在 onInterceptTouchEvent或者onTouch中，通知父类方法开始滑动</span></span><br><span class="line"><span class="comment">    * 会调用父类方法的 onStartNestedScroll onNestedScrollAccepted 两个方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> axes 滑动方向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type 开始滑动的类型 the type of input which cause this scroll event</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 有父视图并且开始滑动，则返回true 实际上就是看parent的 onStartNestedScroll 方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(@ScrollAxis <span class="keyword">int</span> axes, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 子控件停止滑动，例如手指抬起，惯性滑动结束</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type 停止滑动的类型 TYPE_TOUCH，TYPE_NON_TOUCH</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">stopNestedScroll</span><span class="params">(@NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断是否有父View 支持嵌套滑动</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">hasNestedScrollingParent</span><span class="params">(@NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在dispatchNestedPreScroll 之后进行调用</span></span><br><span class="line"><span class="comment">    * 当滑动的距离父控件消耗后，父控件将剩余的距离再次交个子控件，</span></span><br><span class="line"><span class="comment">    * 子控件再次消耗部分距离后，又继续将剩余的距离分发给父控件,由父控件判断是否消耗剩下的距离。</span></span><br><span class="line"><span class="comment">    * 如果四个消耗的距离都是0，则表示没有神可以消耗的了，会直接返回false，否则会调用父控件的</span></span><br><span class="line"><span class="comment">    * onNestedScroll 方法，父控件继续消耗剩余的距离</span></span><br><span class="line"><span class="comment">    * 会调用父控件的</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxConsumed     水平方向嵌套滑动的子控件滑动的距离(消耗的距离)    dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyConsumed     垂直方向嵌套滑动的子控件滑动的距离(消耗的距离)    dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dxUnconsumed   水平方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dyUnconsumed   垂直方向嵌套滑动的子控件未滑动的距离(未消耗的距离)dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 如果返回true, 表示父控件又继续消耗了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, @Nullable <span class="keyword">int</span>[] offsetInWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 子控件在开始滑动前，通知父控件开始滑动，同时由父控件先消耗滑动时间</span></span><br><span class="line"><span class="comment">    * 在子View的onInterceptTouchEvent或者onTouch中，调用该方法通知父View滑动的距离</span></span><br><span class="line"><span class="comment">    * 最终会调用父view的 onNestedPreScroll 方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dx             水平方向嵌套滑动的子控件想要变化的距离 dx&lt;0 向右滑动 dx&gt;0 向左滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> dy             垂直方向嵌套滑动的子控件想要变化的距离 dy&lt;0 向下滑动 dy&gt;0 向上滑动 （保持和 RecycleView 一致）</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> consumed       父控件消耗的距离，父控件消耗完成之后，剩余的才会给子控件，子控件需要使用consumed来进行实际滑动距离的处理</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> offsetInWindow 子控件在当前window的偏移量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> type           滑动类型，ViewCompat.TYPE_NON_TOUCH fling效果,ViewCompat.TYPE_TOUCH 手势滑动</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true    表示父控件进行了滑动消耗，需要处理 consumed 的值，false表示父控件不对滑动距离进行消耗，可以不考虑consumed数据的处理，此时consumed中两个数据都应该为0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, @Nullable <span class="keyword">int</span>[] consumed,</span></span></span><br><span class="line"><span class="function"><span class="params">           @Nullable <span class="keyword">int</span>[] offsetInWindow, @NestedScrollType <span class="keyword">int</span> type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nested2机制，滚动的传递"><a href="#nested2机制，滚动的传递" class="headerlink" title="nested2机制，滚动的传递"></a>nested2机制，滚动的传递</h2><p>一般情况下，事件是从child的触摸事件开始的，</p><ol><li><p>首先调用 <code>child.startNestedScroll()</code> 方法，此方法内部通过 <code>NestedScrollingChildHelper</code> 调用并返回 <code>parent.onStartNestedScroll()</code> 方法的结果，为 true，说明parent接受了嵌套滑动，同时会调用 <code>parent.onNestedScrollAccepted()</code> 方法，此时开始嵌套滑动；</p></li><li><p>在滑动事件中，child通过 <code>child.dispatchNestedPreScroll()</code> 方法分配滑动的距离，内部会先调用 <code>parent.onNestedPreScroll()</code> 方法，由parent先处理滑动距离。</p></li><li><p>parent消耗完成之后，再将剩余的距离传递给child，child拿到parent使用完成之后的距离之后，自己再处理剩余的距离。</p></li><li><p>如果此时子控件还有未处理的距离，则将剩余的距离再次通过 <code>child.dispatchNestedScroll()</code> 方法调用 <code>parent.onNestedScroll()</code> 方法，将剩余的距离交个parent来进行处理</p></li><li><p>滑动结束之后，调用 child.stopNestedScroll()通知parent滑动结束，至此，触摸滑动结束</p></li></ol><p>触摸滑动结束之后，child会继续进行惯性滑动，惯性滑动可以通过 Scroller 实现，具体滑动可以自己来处理，在fling过程中，和触摸滑动调用流程一样，需要注意 type 参数的区分，用来通知parent两种不同的滑动流程</p><h2 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h2><h3 id="预期目标"><a href="#预期目标" class="headerlink" title="预期目标"></a>预期目标</h3><p>自己实现一个嵌套滚动的 parent 和 child， 满足以下效果</p><ol><li>parent 包含 top 和 content 两部分，可滚动</li><li>当 top 未完全隐藏是，滚动 content ，是外层的 parent 滚动</li><li>当 top 完全隐藏，触摸滚动 content ，content 自己滚动</li><li>当触摸 content 滚动到顶部， top 未完全漏出， 则 parent 滚动，直至 top 完全露出</li></ol><h3 id="xml布局"><a href="#xml布局" class="headerlink" title="xml布局"></a>xml布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.test2.nest2_test.CustomNestedParent</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/nested_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.core.widget.NestedScrollView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">"@+id/view_top"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:background</span>=<span class="string">"@color/colorAccent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">androidx.core.widget.NestedScrollView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">com.example.test2.nest2_test.CustomNestedChild</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/view_list"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"1500dp"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.example.test2.nest2_test.CustomNestedParent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里模仿 ScrollView 嵌套 ScrollView 的场景，即外部的 CustomNestedParent 嵌套 内部的 CustomNestedChild ，并解决他们的之间的滑动冲突<br>topVie2 外面包裹了一层 NestedScrollView，是为了让它支持 nested 机制</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedTestActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> nestedParent: CustomNestedParent</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> listView: LinearLayout</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_nested_test)</span><br><span class="line"></span><br><span class="line">        nestedParent = findViewById(R.id.nested_parent)</span><br><span class="line">        <span class="keyword">val</span> topView: View = findViewById(R.id.view_top)</span><br><span class="line">        listView = findViewById(R.id.view_list)</span><br><span class="line"></span><br><span class="line">        nestedParent.<span class="keyword">init</span>(topView, listView)</span><br><span class="line"></span><br><span class="line">        addListItems()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">addListItems</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 填充 child， 这里模拟 child 是一个 recyclerview</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> textView = TextView(<span class="keyword">this</span>)</span><br><span class="line">            textView.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, <span class="number">100</span>)</span><br><span class="line">            textView.text = <span class="string">"position <span class="variable">$i</span>"</span></span><br><span class="line">            listView.addView(textView)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CustomNestedParent"><a href="#CustomNestedParent" class="headerlink" title="CustomNestedParent"></a>CustomNestedParent</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNestedParent</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context?,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingParent2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> TAG = <span class="string">"CustomNestedParent"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mNestedScrollingParentHelper = NestedScrollingParentHelper(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> topView: View</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> nestedChild: View</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> childrenHeight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFinishInflate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onFinishInflate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(topView: <span class="type">View</span>, contentView: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.topView = topView</span><br><span class="line">        <span class="keyword">this</span>.nestedChild = contentView</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 模仿 NestedScrollView</span></span><br><span class="line">        <span class="keyword">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">        <span class="keyword">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        childrenHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getChildAt(i)</span><br><span class="line">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class="line">            childrenHeight += child.measuredHeight</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(width, height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @return true 表示此父类开始接受嵌套滑动，只有true时候，才会执行其他操作</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartNestedScroll</span><span class="params">(child: <span class="type">View</span>, target: <span class="type">View</span>, axes: <span class="type">Int</span>, type: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onStartNestedScroll: "</span>)</span><br><span class="line">        <span class="keyword">return</span> axes == ViewCompat.SCROLL_AXIS_VERTICAL</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当嵌套滑动被parent接收了，会回调这个方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedScrollAccepted</span><span class="params">(child: <span class="type">View</span>, target: <span class="type">View</span>, axes: <span class="type">Int</span>, type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onNestedScrollAccepted: "</span>)</span><br><span class="line">        mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes, type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在子控件开始滑动之前，会先调用父控件的此方法，由父控件先消耗一部分滑动距离，并且将消耗的距离存在consumed中，传递给子控件</span></span><br><span class="line"><span class="comment">     * 不管手势滚动还是fling都会回调这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedPreScroll</span><span class="params">(target: <span class="type">View</span>, dx: <span class="type">Int</span>, dy: <span class="type">Int</span>, consumed: <span class="type">IntArray</span>, type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> threshold = nestedChild.top</span><br><span class="line">        <span class="keyword">var</span> parentScrollable = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> hideTop = dy &gt; <span class="number">0</span> &amp;&amp; scrollY &lt; threshold</span><br><span class="line">        <span class="keyword">val</span> showTop = dy &lt; <span class="number">0</span> &amp;&amp; !target.canScrollVertically(-<span class="number">1</span>)</span><br><span class="line">        Log.i(TAG, <span class="string">"onNestedPreScroll-1: <span class="variable">$dy</span> <span class="variable">$type</span>"</span>)</span><br><span class="line">        <span class="keyword">if</span> (hideTop || showTop) &#123;</span><br><span class="line">          <span class="comment">// parent 提前消费的场景 </span></span><br><span class="line">          <span class="comment">// 1. 向上滚动，parent滚动的距离 &lt; topView的高度，需要隐藏topView </span></span><br><span class="line">          <span class="comment">// 2. 向下滚动，且 child 已经滚动到顶部，需要漏出 topView</span></span><br><span class="line">            parentScrollable = <span class="literal">true</span></span><br><span class="line">            consumed[<span class="number">1</span>] = dy</span><br><span class="line">            scrollBy(<span class="number">0</span>, dy)</span><br><span class="line">            Log.i(TAG, <span class="string">"onNestedPreScroll-2: hideTop=<span class="variable">$hideTop</span> showTop=<span class="variable">$showTop</span> dy=<span class="variable">$dy</span> scrollY=<span class="variable">$scrollY</span> threshold=<span class="variable">$threshold</span> type=<span class="variable">$type</span>"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 反之，应该让 child 滚动，parent不应该消费滚动距离</span></span><br><span class="line">            parentScrollable = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 onNestedPreScroll 中，父控件消耗一部分距离之后，剩余的再次给子控件，</span></span><br><span class="line"><span class="comment">     * 子控件消耗之后，如果还有剩余，则把剩余的再次还给父控件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 孩子吃剩下的留给爸爸了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNestedScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        target: <span class="type">View</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dxConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dxUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"onNestedScroll: <span class="variable">$dyUnconsumed</span> <span class="variable">$type</span> <span class="variable">$scrollY</span>"</span>)</span><br><span class="line">        <span class="comment">// 剩余的parent全部消费</span></span><br><span class="line">        scrollBy(<span class="number">0</span>, dyUnconsumed)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStopNestedScroll</span><span class="params">(target: <span class="type">View</span>, type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mNestedScrollingParentHelper.onStopNestedScroll(target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNestedScrollAxes</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mNestedScrollingParentHelper.nestedScrollAxes</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollTo</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> resY = y</span><br><span class="line">        <span class="comment">// 限定 parnet 的上下边界，防止滚动出屏幕外</span></span><br><span class="line">        <span class="keyword">if</span> (resY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            resY = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> max = max(childrenHeight - height, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &gt; max) &#123;</span><br><span class="line">            resY = max</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"scrollTo: <span class="variable">$max</span> <span class="variable">$y</span> <span class="variable">$resY</span>"</span>)</span><br><span class="line">        <span class="keyword">super</span>.scrollTo(x, resY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CustomNestedChild"><a href="#CustomNestedChild" class="headerlink" title="CustomNestedChild"></a>CustomNestedChild</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNestedChild</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context?,</span><br><span class="line">    attrs: AttributeSet? = <span class="literal">null</span>,</span><br><span class="line">    defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : LinearLayout(context, attrs, defStyleAttr), NestedScrollingChild2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> TAG = <span class="string">"CustomNestedChild"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mScrollingChildHelper = NestedScrollingChildHelper(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewConfiguration: ViewConfiguration = ViewConfiguration.<span class="keyword">get</span>(context)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mVelocityTracker: VelocityTracker? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mScroller: Scroller = Scroller(context)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastX: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastY: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastFlingX: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mLastFlingY: <span class="built_in">Float</span> = <span class="number">0f</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> offset = IntArray(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> consumed = IntArray(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fling = <span class="literal">false</span> <span class="comment">//判断当前是否是可以进行惯性滑动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> childrenHeight = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        orientation = VERTICAL</span><br><span class="line">        <span class="comment">// 这里必须都设置为 true ，表明这个view是支持nested2机制的</span></span><br><span class="line">        isNestedScrollingEnabled = <span class="literal">true</span></span><br><span class="line">        mScrollingChildHelper.isNestedScrollingEnabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMeasure</span><span class="params">(widthMeasureSpec: <span class="type">Int</span>, heightMeasureSpec: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> height = MeasureSpec.getSize(heightMeasureSpec)</span><br><span class="line">        <span class="keyword">var</span> width = MeasureSpec.getSize(widthMeasureSpec)</span><br><span class="line">        childrenHeight = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until childCount) &#123;</span><br><span class="line">            <span class="keyword">val</span> child = getChildAt(i)</span><br><span class="line">            measureChild(child, widthMeasureSpec, MeasureSpec.UNSPECIFIED)</span><br><span class="line">            childrenHeight += child.measuredHeight</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(width, height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">startNestedScroll</span><span class="params">(axes: <span class="type">Int</span>, type: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.startNestedScroll(axes, type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">stopNestedScroll</span><span class="params">(type: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        mScrollingChildHelper.stopNestedScroll(type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasNestedScrollingParent</span><span class="params">(type: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.hasNestedScrollingParent()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        dx: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dy: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        consumed: <span class="type">IntArray</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        offsetInWindow: <span class="type">IntArray</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow, type)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchNestedScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        dxConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyConsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dxUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dyUnconsumed: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        offsetInWindow: <span class="type">IntArray</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        type: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper.dispatchNestedScroll(</span><br><span class="line">            dxConsumed,</span><br><span class="line">            dyConsumed,</span><br><span class="line">            dxUnconsumed,</span><br><span class="line">            dyUnconsumed,</span><br><span class="line">            offsetInWindow,</span><br><span class="line">            type</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">// 处理触摸事件是，关闭fling</span></span><br><span class="line">        cancelFling()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker == <span class="literal">null</span>) &#123;</span><br><span class="line">            mVelocityTracker = VelocityTracker.obtain()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> velocityTracker = mVelocityTracker!!</span><br><span class="line">        velocityTracker.addMovement(event)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">when</span> (event.action) &#123;</span><br><span class="line">            MotionEvent.ACTION_DOWN -&gt; &#123;</span><br><span class="line">                mLastX = event.x</span><br><span class="line">                mLastY = event.y</span><br><span class="line">                <span class="comment">// 表明开始处理嵌套滚动， TYPE_TOUCH 表明这是一个触摸场景</span></span><br><span class="line">                startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH)</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_MOVE -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> curX = event.x</span><br><span class="line">                <span class="keyword">val</span> curY = event.y</span><br><span class="line">                <span class="keyword">var</span> dy = (mLastY - curY).toInt()</span><br><span class="line">                <span class="keyword">var</span> dx = (mLastX - curX).toInt()</span><br><span class="line">                <span class="comment">// 先交给parent处理</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchNestedPreScroll(dx, dy, consumed, offset, TYPE_TOUCH)) &#123;</span><br><span class="line">                    dy -= consumed[<span class="number">1</span>]</span><br><span class="line">                    dx -= consumed[<span class="number">0</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// child自己消费</span></span><br><span class="line">                <span class="keyword">val</span> consumedY = childConsumeY(dy)</span><br><span class="line">                <span class="comment">// 将消费剩下的，传递给parent</span></span><br><span class="line">                dispatchNestedScroll(<span class="number">0</span>, consumedY, dx, dy - consumedY, <span class="literal">null</span>, TYPE_TOUCH)</span><br><span class="line">                mLastX = curX</span><br><span class="line">                mLastY = curY</span><br><span class="line">            &#125;</span><br><span class="line">            MotionEvent.ACTION_UP,</span><br><span class="line">            MotionEvent.ACTION_CANCEL -&gt; &#123;</span><br><span class="line">              <span class="comment">// 先结束 TYPE_TOUCH 场景的嵌套滚动</span></span><br><span class="line">                stopNestedScroll(TYPE_TOUCH)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否需要惯性滑动</span></span><br><span class="line">                velocityTracker.computeCurrentVelocity(</span><br><span class="line">                    <span class="number">1000</span>,</span><br><span class="line">                    viewConfiguration.scaledMaximumFlingVelocity.toFloat()</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">val</span> yvel = velocityTracker.yVelocity</span><br><span class="line">                fling(yvel.toInt())</span><br><span class="line">                velocityTracker.clear()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fling</span><span class="params">(velocityY: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        cancelFling()</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断速度是否足够大。如果够大才执行fling</span></span><br><span class="line">        <span class="keyword">var</span> dy: <span class="built_in">Int</span> = velocityY</span><br><span class="line">        <span class="keyword">if</span> (abs(velocityY) &lt; viewConfiguration.scaledMinimumFlingVelocity) &#123;</span><br><span class="line">            dy = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dy == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这步必须要有，表明开始 TYPE_NON_TOUCH 的嵌套滚动</span></span><br><span class="line">        <span class="comment">// 如果不设置，后续的嵌套滚动流程都都会找不到对应的parent</span></span><br><span class="line">        startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_NON_TOUCH)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> maxFlingVelocity: <span class="built_in">Int</span> = viewConfiguration.scaledMaximumFlingVelocity</span><br><span class="line">        dy = max(-maxFlingVelocity, min(dy, maxFlingVelocity))</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"fling: <span class="variable">$dy</span> "</span>)</span><br><span class="line">        fling = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 开始fling</span></span><br><span class="line">        mScroller.fling(</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            dy,</span><br><span class="line">            Integer.MIN_VALUE,</span><br><span class="line">            Integer.MAX_VALUE,</span><br><span class="line">            Integer.MIN_VALUE,</span><br><span class="line">            Integer.MAX_VALUE</span><br><span class="line">        )</span><br><span class="line">        postInvalidate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">computeScroll</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset() &amp;&amp; fling) &#123;</span><br><span class="line">            <span class="keyword">val</span> y = mScroller.currY</span><br><span class="line">            <span class="keyword">var</span> dy = (mLastFlingY - y).toInt()</span><br><span class="line">            mLastFlingY = y.toFloat()</span><br><span class="line">            <span class="comment">// 和触摸场景一样，优先让parent处理</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchNestedPreScroll(<span class="number">0</span>, dy, consumed, <span class="literal">null</span>, TYPE_NON_TOUCH)) &#123;</span><br><span class="line">                dy -= consumed[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">"computeScroll: <span class="subst">$&#123;consumed[<span class="number">1</span>]&#125;</span> <span class="variable">$dy</span>"</span>)</span><br><span class="line">            <span class="comment">// child 自己处理</span></span><br><span class="line">            <span class="keyword">val</span> consumedY = childFling(dy)</span><br><span class="line">            <span class="comment">// 将剩下的在传递给 parent</span></span><br><span class="line">            dispatchNestedScroll(<span class="number">0</span>, consumedY, <span class="number">0</span>, dy - consumedY, <span class="literal">null</span>, TYPE_NON_TOUCH)</span><br><span class="line">            postInvalidate()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stopNestedScroll(TYPE_NON_TOUCH)</span><br><span class="line">            cancelFling()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">childConsumeY</span><span class="params">(dy: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> consumed = dy</span><br><span class="line">        <span class="keyword">if</span> (consumed &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果滑动到顶部，只处理部分，不然可能无法触达顶部边界</span></span><br><span class="line">            consumed = max(-scrollY, consumed)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果滑动到顶部，只处理部分，不然可能会无法触达底部边界</span></span><br><span class="line">            <span class="keyword">val</span> max = max(childrenHeight - height, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (dy + scrollY &gt; max) &#123;</span><br><span class="line">                consumed = max - scrollY</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"childConsumeY: <span class="variable">$dy</span> <span class="variable">$consumed</span> <span class="variable">$scrollY</span>"</span>)</span><br><span class="line">        scrollBy(<span class="number">0</span>, consumed)</span><br><span class="line">        <span class="keyword">return</span> consumed</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">childFling</span><span class="params">(dy: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> childConsumeY(dy)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelFling</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fling = <span class="literal">false</span></span><br><span class="line">        mLastFlingY = <span class="number">0f</span></span><br><span class="line">        mLastFlingY = <span class="number">0f</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scrollTo</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> resY = y</span><br><span class="line">        <span class="keyword">if</span> (resY &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            resY = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> max = max(childrenHeight - height, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (y &gt; max) &#123;</span><br><span class="line">            resY = max</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"scrollTo: <span class="variable">$max</span> <span class="variable">$y</span> <span class="variable">$resY</span>"</span>)</span><br><span class="line">        <span class="keyword">super</span>.scrollTo(x, resY)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">canScrollVertically</span><span class="params">(direction: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (direction &lt; <span class="number">0</span> &amp;&amp; scrollY &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction &gt; <span class="number">0</span> &amp;&amp; scrollY &gt;= measuredHeight - height) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844903960432607246#heading-1" target="_blank" rel="noopener">https://juejin.cn/post/6844903960432607246#heading-1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开头&quot;&gt;&lt;a href=&quot;#开头&quot; class=&quot;headerlink&quot; title=&quot;开头&quot;&gt;&lt;/a&gt;开头&lt;/h2&gt;&lt;p&gt;nested2是安卓用于处理嵌套滚动的方案。 主要有两个重要的接口， NestedScrollingParent2 和 NestedScrollingChild2 ，分别代表桥套滚动的外层和内层。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nested2" scheme="http://yoursite.com/tags/nested2/"/>
    
  </entry>
  
  <entry>
    <title>编译aosp</title>
    <link href="http://yoursite.com/2021/05/22/%E7%BC%96%E8%AF%91aosp/"/>
    <id>http://yoursite.com/2021/05/22/编译aosp/</id>
    <published>2021-05-22T09:12:59.000Z</published>
    <updated>2021-10-03T01:57:41.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘</li></ol><a id="more"></a><h1 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h1><ol><li>下载 Repo 工具，并确保它可执行：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure><p>使用清华源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git-repo-downloads/repo  &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure></p><ol start="2"><li>初始化 Repo</li></ol><p>-b 后面可以指定要同步代码的安卓系统版本代号<br>版本代号可以在下面的链接中查找<br><a href="https://source.android.com/setup/start/build-numbers" target="_blank" rel="noopener">https://source.android.com/setup/start/build-numbers</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://android.googlesource.com/platform/manifest -b android-4.0.1_r1</span><br></pre></td></tr></table></figure><p>使用清华源<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-9.0.0_r40</span><br></pre></td></tr></table></figure></p><ol start="3"><li>同步 Repo</li></ol><p>需要几个小时的时间同步代码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync</span><br></pre></td></tr></table></figure></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>执行下面的命令，<br>lunch 选择编译模式（ 这里我选择的是  aosp_x86_64-eng）<br>m （m 命令系统会根据cpu性能自动选取需要使用的线程，你也可以根据cpu多少使用 make -jN, N表示cpu个数x2）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">lunch  aosp_x86_64-eng</span><br><span class="line">m</span><br></pre></td></tr></table></figure><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><ul><li>找不到对应的MacOSX.sdk<br>Could not find a supported mac sdk: [“10.10” “10.11” “10.12” “10.13”]</li></ul><p>我的系统版本是10.15，你需要到 <a href="https://github.com/phracker/MacOSX-SDKs/releases" target="_blank" rel="noopener">https://github.com/phracker/MacOSX-SDKs/releases</a> 下载需要的版本</p><p>我这里下载的是MacOSX10.12.sdk，解压复制到如下目录：<br>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</p><ul><li>不知名报错、</li></ul><p>找到文件：源文件根目录/system/sepolicy/tests/Android.bp，删除掉第14行的一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// libsepolwrap gets loaded from the system python, which does not have the</span><br><span class="line">// ASAN runtime. So turn off sanitization for ourself, and  use static</span><br><span class="line">// libraries, since the shared libraries will use ASAN.</span><br><span class="line">static_libs: [</span><br><span class="line">    &quot;libbase&quot;,</span><br><span class="line">    &quot;libsepol&quot;,</span><br><span class="line">],</span><br><span class="line">stl: &quot;libc++_static&quot;, // 删除掉这一行</span><br><span class="line">sanitize: &#123;</span><br><span class="line">    never: true,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="使用-Android-Studio-阅读源码"><a href="#使用-Android-Studio-阅读源码" class="headerlink" title="使用 Android Studio 阅读源码"></a>使用 Android Studio 阅读源码</h1><ol><li>生成 Android Studio 工程配置文件</li></ol><p>生成 android.iml 和 android.ipr 文件。</p><p>其中 iml 文件 表示 information of modules, 用来描述 AOSP 的模块信息。<br>ipr 文件 表示 IDEA project configuration ，用来描述 IDEA 的工程配置信息，双击此文件时系统将直接使用 Andorid Studio 打开此项目。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 设置 AOSP 编译所需的环境变量</span><br><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="meta">#</span> 使用 idegen.sh 脚本生成 IDEA 工程文件</span><br><span class="line">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在macOS上，默认文件系统是不区分大小写的，需要先建立一个区分大小写的磁盘&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="AOSP" scheme="http://yoursite.com/tags/AOSP/"/>
    
  </entry>
  
  <entry>
    <title>屏幕刷新机制</title>
    <link href="http://yoursite.com/2021/03/18/Android/Framework/%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2021/03/18/Android/Framework/屏幕刷新机制/</id>
    <published>2021-03-17T16:05:08.000Z</published>
    <updated>2021-10-03T01:57:41.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="requestLayout"><a href="#requestLayout" class="headerlink" title="requestLayout"></a>requestLayout</h1><p>view.requestLayout 最终会调用 ViewRootImpl.requestLayout</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();  <span class="comment">// 检查线程是否是 ViewRootImpl 实例化的线程</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mTraversalScheduled 标记位，避免短时间多次调用requestLayout重复刷新</span></span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 添加一个同步屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">// 通过 Choreographer 添加一个 Vsync 回调</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 measure layout draw 三步走</span></span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</code> 这个操作会在 LooperQueue 中添加一个同步屏障，阻断同步 message（普通 message ）的执行。<br>（异步 message 能正常执行）<br>这里主要是为了保证在 Vync 到来时，这个 message 能够快速响应，保证在 Vync 到来的最初时刻就开始绘制，从而保证 UI 的绘制和 Vync 的周期是协调的。</p><p><code>mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</code> 添加一个 Vsync 回调。在 Vsync 信号到来时执行 mTraversalRunnable 。</p><h1 id="Choreographer"><a href="#Choreographer" class="headerlink" title="Choreographer"></a>Choreographer</h1><p>Choreographer 是用来监听 Vsync 信号的一个类。 在刷新UI时主要有两步。</p><h2 id="添加一个-vsync-信号的回调"><a href="#添加一个-vsync-信号的回调" class="headerlink" title="添加一个 vsync 信号的回调"></a>添加一个 vsync 信号的回调</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">// 这里 mCallbackQueues 是多个事件的队列</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 延时做刷新，最终也会走 scheduleFrameLocked</span></span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="comment">// 判断是不是在 ViewRootImpl 实例化时的线程</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是，用一个 Handler 切换线程</span></span><br><span class="line">                <span class="comment">// 发送一个异步消息，并且放置在队列最前方</span></span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 native 方法请求一个 vsync 回调</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理-vsync-回调"><a href="#处理-vsync-回调" class="headerlink" title="处理 vsync 回调"></a>处理 vsync 回调</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Choreographer 的构造方法里实例化 DisplayEventReceiver</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">        mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">                ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">        mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">        mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">            mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHavePendingVsync;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mTimestampNanos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFrame;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, vsyncSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">            timestampNanos = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        <span class="comment">// 发送一个异步消息，注意，这里没有放置到消息队列最前端</span></span><br><span class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doFrame(mTimestampNanos, mFrame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// no work to do</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">// 当前时间 - vsync回调到来时间 = 主线程message耗时</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="comment">// 当超过了屏幕一帧刷新时间 16ms</span></span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                <span class="comment">// 当跳过的帧超过一定程度</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理屏幕刷新的回调，这里会调用 ViewRootImpl.TraversalRunnable</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;requestLayout&quot;&gt;&lt;a href=&quot;#requestLayout&quot; class=&quot;headerlink&quot; title=&quot;requestLayout&quot;&gt;&lt;/a&gt;requestLayout&lt;/h1&gt;&lt;p&gt;view.requestLayout 最终会调用 ViewRootImpl.requestLayout&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://yoursite.com/tags/Framework/"/>
    
  </entry>
  
</feed>
