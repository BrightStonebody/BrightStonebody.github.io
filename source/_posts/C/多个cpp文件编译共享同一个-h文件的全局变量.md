---
title: 多个cpp文件编译共享同一个.h文件的全局变量
date: 2019-04-13 13:12:22
categories: 
- C/C++
tags:
---

# 多个cpp文件编译共享同一个.h文件的全局变量

在多个cpp文件一起编译时，有事会出现.h文件中全局变量的重复定义，导致编译失败。下面是解决的方案:

## 一个cpp文件多次#include一个.h文件
> 使用#ifndef

```c++
//在.h头文件中
#ifndef <标示> //自定义的一个标示, 习惯性用.h文件名大写
#define <标示>
//...头文件内容
#endif
```
原理大概是在一个在头文件include的时候define一个标示，当再次include时检测标示是否已经定义过。是，则不再执行该头文件的内容

**这种方法只能解决一个cpp源文件中的重复include问题**

## 多个cpp文件多次#include一个.h文件
### 使用static关键字
```c++
//.h头文件
static int i;
static void func();
```
* #### static修饰变量
变量static标记之后，多个cpp文件include不会出现问题。
**但是使用static之后，会在每个cpp作用域中创建拷贝，这实际上并没有达到 共享的目的**
下面是网上的一些解释:
> 定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问。既然这种定义方式出现在头文件中，那么可以很自然地推测：包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。
> 
> 假如将上面两行代码的static去掉，编译的时候就会出现变量重定义的错误，这进一步证实了上面的推测，因为没有static的话变量的作用域是全局的，定义了两个以上的同名变量就会出现该错误。

* #### static修饰函数
函数标记为static表示只能在.h文件和定义该函数的cpp文件中被调用。其他文件中不可见。
*似乎是这样的。。。我的理解。网上说static和inline经常配合使用*

### 使用extern关键字
extern表明该变量在别的地方已经定义过了，在这里要使用那个变量

```c++
//cpp文件
extern int i;
```
经过实验，extern的不仅仅.h文件里定义，定义在其他cpp文件中的全局变量也是可以访问到的。

定义在.h文件的情况下，**在使用extern时，不能include定义它的.h文件。**否则还是会出现重定义的问题。
