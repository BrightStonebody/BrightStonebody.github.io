---
title: 网络相关知识点
date: 2022-08-27 17:56:47
tags:
---

## OSI五层网络模型

1. 物理层
   利用传输介质为数据提供物理连接，传输比特流。 wifi 、光纤 等
2. 数据链路层
   在两个相邻结点之间传送数据，传输数据帧
3. 网络层
   提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径。 IP协议
4. 传输层
   向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输，负责向两个主机中进程之间的通信提供服务。 TCP ， UDP
5. 应用层
    为用户提供的服务。 http，https 协议

## TCP
[面试准备 TCP 知识，看这一篇就够了](https://segmentfault.com/a/1190000022144695)

### TCP 三次握手
```
client ---- SYN=1,seq=j ----------> server
client <--- SYN=1,seq=k,ack=j+1 --- server
client ---- ack=k+1 --------> server
```

为什么需要三次，而不是两次？
如果试了两次握手，client端第一次发送到服务端，服务端即会认为建立连接。但是网络是会延迟或丢包的，如果第一次发生了客户端的握手发生了延迟，客户端会超时重传，这样就有可能服务端收到多个建立连接的消息，导致连接建立多次。

### TCP 四次挥手

```
client ---- FIN=1,seq=x ----> server
client <--- ack=x+1     ----- server
client <--------------------- server // 服务端传输剩余内容
client <--- FIN=1,seq=z ----> server
client ---- ack=z+1     ----> server
```

1. 客户端发送关闭连接的报文， FIN 标志位为1
2. 服务端收到FIN后，发送确认报文
3. 服务端继续发送剩余的报文，客户端继续接收剩余报文
4. 服务端报文发送完毕，向客户端发送FIN报文
5. 客户端向服务端发送确认报文，客户端等待一段时间后进入closed状态。 服务端收到确认报文即进入closed状态

**为什么挥手要四次不是三次？**
因为客户端发起关闭连接报文时，服务端可能还有剩余的数据没有发送完毕。 要等待服务端将剩余的数据发送完毕。

**客户端收到FIN后为什么要等待一段时间在进入closed状态？**
因为客户端发送的确认报文有可能丢失，这样，服务端会重复发送FIN报文； 如果客户端收到FIN立即关闭，就无法处理服务端重复发送的FIN报文。

### 和UDP相比，为什么TCP是可靠的

TCP有超时重传机制。 当TCP报文发出，会启动计数器，等待接收端返回确认报文。如果长时间没有收到确认报文，会将报文重新发送

## http

### http版本迭代

**http1.1**
1. Connnection: Keep-Alive
复用tcp连接。 允许HTTP设备在事务处理结束之后将TCP连接保持在打开的状态，以便未来的HTTP请求重用现在的连接

2. 支持只请求数据的一部分 range
RANGE:bytes=XXXX 表示要求服务器从文件 XXXX 字节处开始传送，断点续传

**http2.0**

多路复用。
多个请求**并行**的复用一个连接。 
和 keep-alive 的区别： http1.1 的复用是串行的，如果有一个请求耗时较长会阻塞。http2.0 是并行复用，不会阻塞

## https

```
client ---- 请求https连接  ----> server
client <--- 公钥          ----> server
client ---- 生成秘钥，并用公钥加密
client ---- 公钥加密后的秘钥 ---> server
       使用私钥解密，得到秘钥 ---- server
client <--- client 和 server使用秘钥通信 ---> server // 对称加密 
```