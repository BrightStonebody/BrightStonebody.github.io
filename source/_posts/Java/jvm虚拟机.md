---
title: jvm虚拟机
date: 2022-04-07 23:10:00
tags:
---

## JVM架构

jvm有几个区域：方法区、堆、Java栈、程序计数器、本地方法栈

1. 方法区
方法区被所有线程共享。存放 类信息、类的字段信息和方法信息、常量、static类变量

2. Java栈
Java栈线程之间不共享。
Java栈是由很多的栈帧(stack frame)或者说帧(frame)组成的，一个栈帧包含一个Java方法调用状态。用来存放方法的局部变量、被调用时传进来的参数、返回值 以及运算的中间结果等等。

3. Native栈
用来存放Native方法的调用状态

4. 堆
用于存放对象。 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。

5. 程序计数器（PC寄存器）
每一个线程有一个程序计数器。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。

6. 类加载子系统
读取class文件，加载Java类到内存。


## 类加载器
类加载器负责动态加载Java类到Java虚拟机的内存空间中。

* 双亲委托机制
“双亲委托机制”是指先委托父装载器寻找目标类，只有在找不到的情况下才从自己的类 路径中查找并装载目标类。这一点是从安全角度考虑的

## GC垃圾回收机制

### 如何判断对象是否可以被回收
* 引用计数法
* 根搜索算法：
  * 从GC root出发查找引用链，无法触及到的对象可以被回收。 
  * GC-root包括：虚拟机栈中引用的对象、类静态属性引用的对象、常量引用的对象

### 强引用、弱引用、软引用、虚引用

### GC算法
jvm将对象分为三个区域， 新生代（Young Generation） 、 老年代（Old Generation） 和 持久代（Permanent Generation）。
* 持久代：
  * 存放java类的类信息，存放静态文件，如final常量，static常量，常量池等。几乎不回收
* 新生代：
  * 新生代使用拷贝算法：新生代中存在一个Eden区和两个Survivor区，其中一个Survivor始终为空。 eden区gc时，存活的对象会复制到其中一个survivor区。 Survivor区gc时，会拷贝到另一个空闲的Survivor区。 当对象多次gc存活一定次数之后，会移动到老年代
  * jvm中 eden区和Survivor区的大小为8：1
* 老年代：
  * 使用标记整理算法。标记需要清除对象，将存活的对象往内存的一端移动，再将需要清除要回收的对象。这样的算法可以避免内存碎片的产生
